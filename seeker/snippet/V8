#date: 2025-09-26T17:11:05Z
#url: https://api.github.com/gists/c6379495441d24126f3a52bec2105b61
#owner: https://api.github.com/users/deliasbaker

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
TickMaster V5 - VERS√ÉO INVESTIGATIVA PARA R_75
Sistema Completo para Binary Options - Volatility 75 (R_75)
LOGS INVESTIGATIVOS ADICIONADOS:
- An√°lise detalhada das respostas da Deriv para R_75
- Logs espec√≠ficos para propostas rejeitadas
- Monitoramento do formato de barreiras
- Debug completo do fluxo de trading
- Teste de diferentes formatos de barreira
"""

import json
import os
import tkinter as tk
from tkinter import ttk, messagebox
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
from matplotlib.figure import Figure
import numpy as np
import websocket
import threading
import time
import queue
import logging
from collections import deque
from datetime import datetime

# Configura√ß√£o de logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('tickmaster_r75_investigative.log'),
        logging.StreamHandler()
    ]
)

def debug_log(message, data=None):
    """Sistema de debug limpo e eficiente"""
    timestamp = datetime.now().strftime("%H:%M:%S.%f")[:-3]
    print(f"üî• [{timestamp}] {message}", flush=True)
    if data:
        print(f" üìä {data}", flush=True)

class AdvancedConfigWindow:
    """JANELA DE CONFIGURA√á√ïES AVAN√áADAS"""
    def __init__(self, parent, current_config, callback):
        self.parent = parent
        self.callback = callback
        self.current_config = current_config
        self.config_vars = {}
        
        # Criar janela modal
        self.window = tk.Toplevel(parent)
        self.window.title("‚öôÔ∏è Configura√ß√µes Avan√ßadas")
        self.window.geometry("500x500")
        self.window.configure(bg='#2a2a2a')
        self.window.resizable(False, False)
        
        # Tornar modal
        self.window.transient(parent)
        self.window.grab_set()
        
        # Centralizar na tela
        self.center_window()
        
        # Criar interface
        self.create_interface()
        
        # Focar na janela
        self.window.focus_set()

    def center_window(self):
        """Centralizar janela na tela"""
        self.window.update_idletasks()
        x = (self.window.winfo_screenwidth() // 2) - (500 // 2)
        y = (self.window.winfo_screenheight() // 2) - (500 // 2)
        self.window.geometry(f"500x500+{x}+{y}")

    def create_interface(self):
        """Criar interface da janela de configura√ß√µes"""
        # T√≠tulo
        title_frame = tk.Frame(self.window, bg='#2a2a2a')
        title_frame.pack(fill='x', padx=20, pady=20)
        
        title_label = tk.Label(title_frame,
                              text="‚öôÔ∏è CONFIGURA√á√ïES AVAN√áADAS",
                              bg='#2a2a2a', fg='#00ff41',
                              font=('Arial', 16, 'bold'))
        title_label.pack()
        
        subtitle_label = tk.Label(title_frame,
                                 text="Ajuste os par√¢metros de estrat√©gia",
                                 bg='#2a2a2a', fg='#ffffff',
                                 font=('Arial', 10))
        subtitle_label.pack(pady=(5, 0))

        # Container principal
        main_frame = tk.Frame(self.window, bg='#2a2a2a')
        main_frame.pack(fill='both', expand=True, padx=20)

        # === RSI SETTINGS ===
        rsi_frame = tk.LabelFrame(main_frame,
                                 text="üìä Configura√ß√µes RSI",
                                 bg='#3a3a3a', fg='#00ff41',
                                 font=('Arial', 12, 'bold'),
                                 pady=10)
        rsi_frame.pack(fill='x', pady=(0, 15))

        # RSI Period
        self.create_config_row(rsi_frame, "Per√≠odo RSI:", "RSI_PERIOD",
                              self.current_config['RSI_PERIOD'],
                              "Quantidade de per√≠odos para calcular RSI (recomendado: 14)")

        # RSI Zones
        self.create_config_row(rsi_frame, "Zona PUT (Venda):", "RSI_PUT_ZONE",
                              self.current_config['RSI_PUT_ZONE'],
                              "RSI acima deste valor gera sinal PUT (recomendado: 80 para R_75)")
        
        self.create_config_row(rsi_frame, "Zona CALL (Compra):", "RSI_CALL_ZONE",
                              self.current_config['RSI_CALL_ZONE'],
                              "RSI abaixo deste valor gera sinal CALL (recomendado: 20 para R_75)")

        # === STRATEGY SETTINGS ===
        strategy_frame = tk.LabelFrame(main_frame,
                                     text="üéØ Configura√ß√µes de Estrat√©gia",
                                     bg='#3a3a3a', fg='#00ff41',
                                     font=('Arial', 12, 'bold'),
                                     pady=10)
        strategy_frame.pack(fill='x', pady=(0, 15))

        # Pressure Ticks
        self.create_config_row(strategy_frame, "Press√£o (Ticks):", "PRESSURE_TICKS",
                              self.current_config['PRESSURE_TICKS'],
                              "Quantos ticks consecutivos confirmam o sinal (recomendado: 3)")

        # Cooldown
        self.create_config_row(strategy_frame, "Cooldown (Segundos):", "COOLDOWN_SECONDS",
                              self.current_config['COOLDOWN_SECONDS'],
                              "Tempo de espera entre trades (recomendado: 8 para R_75)")

        # === BOT√ïES ===
        buttons_frame = tk.Frame(self.window, bg='#2a2a2a')
        buttons_frame.pack(fill='x', padx=20, pady=20)

        # Bot√£o Cancelar
        cancel_btn = tk.Button(buttons_frame,
                              text="‚ùå CANCELAR",
                              command=self.cancel,
                              bg='#666666', fg='white',
                              font=('Arial', 11, 'bold'),
                              width=12, height=2)
        cancel_btn.pack(side='left', padx=(0, 10))

        # Bot√£o Restaurar Padr√µes
        reset_btn = tk.Button(buttons_frame,
                             text="üîÑ PADR√ïES",
                             command=self.restore_defaults,
                             bg='#ff8800', fg='white',
                             font=('Arial', 11, 'bold'),
                             width=12, height=2)
        reset_btn.pack(side='left', padx=5)

        # BOT√ÉO APLICAR
        apply_btn = tk.Button(buttons_frame,
                             text="‚úÖ APLICAR",
                             command=self.apply_settings,
                             bg='#00aa00', fg='white',
                             font=('Arial', 11, 'bold'),
                             width=12, height=2)
        apply_btn.pack(side='right')

    def create_config_row(self, parent, label_text, var_name, current_value, tooltip):
        """Criar linha de configura√ß√£o"""
        row_frame = tk.Frame(parent, bg='#3a3a3a')
        row_frame.pack(fill='x', padx=10, pady=5)

        # Label
        label = tk.Label(row_frame,
                        text=label_text,
                        bg='#3a3a3a', fg='white',
                        font=('Arial', 10, 'bold'),
                        width=20, anchor='w')
        label.pack(side='left')

        # Entry
        var = tk.StringVar(value=str(current_value))
        entry = tk.Entry(row_frame,
                        textvariable=var,
                        font=('Arial', 10),
                        width=10,
                        justify='center')
        entry.pack(side='left', padx=10)

        # Valor atual
        current_label = tk.Label(row_frame,
                                text=f"(Atual: {current_value})",
                                bg='#3a3a3a', fg='#888888',
                                font=('Arial', 9))
        current_label.pack(side='left', padx=10)

        # Tooltip
        tooltip_label = tk.Label(row_frame,
                               text="‚ÑπÔ∏è",
                               bg='#3a3a3a', fg='#00aaff',
                               font=('Arial', 10),
                               cursor='question_arrow')
        tooltip_label.pack(side='right', padx=5)

        # Bind tooltip
        self.create_tooltip(tooltip_label, tooltip)

        # Armazenar vari√°vel
        self.config_vars[var_name] = var

    def create_tooltip(self, widget, text):
        """Criar tooltip para widget"""
        def show_tooltip(event):
            tooltip = tk.Toplevel()
            tooltip.wm_overrideredirect(True)
            tooltip.wm_geometry(f"+{event.x_root+10}+{event.y_root+10}")
            tooltip.configure(bg='#ffffe0')
            
            label = tk.Label(tooltip,
                           text=text,
                           bg='#ffffe0', fg='black',
                           font=('Arial', 9),
                           wraplength=300,
                           justify='left')
            label.pack()
            
            # Auto-destruir ap√≥s 3 segundos
            tooltip.after(3000, tooltip.destroy)
        
        widget.bind("<Button-1>", show_tooltip)

    def restore_defaults(self):
        """Restaurar valores padr√£o para R_75"""
        defaults = {
            'RSI_PERIOD': 14,
            'RSI_PUT_ZONE': 80.0,  # Mais sens√≠vel para R_75
            'RSI_CALL_ZONE': 20.0,  # Mais sens√≠vel para R_75
            'PRESSURE_TICKS': 3,
            'COOLDOWN_SECONDS': 8  # Maior para R_75
        }
        
        for var_name, default_value in defaults.items():
            if var_name in self.config_vars:
                self.config_vars[var_name].set(str(default_value))
        
        messagebox.showinfo("Padr√µes Restaurados",
                           "Valores padr√£o para R_75 restaurados!\nClique em APLICAR para confirmar.")

    def apply_settings(self):
        """APLICAR CONFIGURA√á√ïES"""
        try:
            # Validar e coletar valores
            new_config = {}
            
            # RSI Period
            rsi_period = int(self.config_vars['RSI_PERIOD'].get())
            if rsi_period < 2 or rsi_period > 50:
                raise ValueError("Per√≠odo RSI deve estar entre 2 e 50")
            new_config['RSI_PERIOD'] = rsi_period

            # RSI Zones
            rsi_put = float(self.config_vars['RSI_PUT_ZONE'].get())
            if rsi_put < 50 or rsi_put > 100:
                raise ValueError("Zona PUT deve estar entre 50 e 100")
            new_config['RSI_PUT_ZONE'] = rsi_put

            rsi_call = float(self.config_vars['RSI_CALL_ZONE'].get())
            if rsi_call < 0 or rsi_call > 50:
                raise ValueError("Zona CALL deve estar entre 0 e 50")
            new_config['RSI_CALL_ZONE'] = rsi_call

            if rsi_call >= rsi_put:
                raise ValueError("Zona CALL deve ser menor que Zona PUT")

            # Pressure Ticks
            pressure = int(self.config_vars['PRESSURE_TICKS'].get())
            if pressure < 1 or pressure > 10:
                raise ValueError("Press√£o deve estar entre 1 e 10 ticks")
            new_config['PRESSURE_TICKS'] = pressure

            # Cooldown
            cooldown = int(self.config_vars['COOLDOWN_SECONDS'].get())
            if cooldown < 0 or cooldown > 60:
                raise ValueError("Cooldown deve estar entre 0 e 60 segundos")
            new_config['COOLDOWN_SECONDS'] = cooldown

            # Confirmar aplica√ß√£o
            result = messagebox.askyesno(
                "Confirmar Configura√ß√µes",
                f"üîß APLICAR NOVAS CONFIGURA√á√ïES?\n\n"
                f"üìä RSI Per√≠odo: {rsi_period}\n"
                f"üî¥ Zona PUT: {rsi_put}\n"
                f"üü¢ Zona CALL: {rsi_call}\n"
                f"üéØ Press√£o: {pressure} ticks\n"
                f"‚è±Ô∏è Cooldown: {cooldown} segundos\n\n"
                f"‚ö†Ô∏è Isso ir√° alterar a estrat√©gia de trading!"
            )

            if result:
                # Executar callback para aplicar configura√ß√µes
                self.callback(new_config)
                
                # Mostrar sucesso
                messagebox.showinfo("Sucesso!",
                                   "‚úÖ Configura√ß√µes aplicadas com sucesso!\n"
                                   "As novas configura√ß√µes j√° est√£o ativas.")
                
                # Fechar janela
                self.close()

        except ValueError as e:
            messagebox.showerror("Erro de Valida√ß√£o", f"‚ùå {str(e)}")
        except Exception as e:
            messagebox.showerror("Erro", f"‚ùå Erro ao aplicar configura√ß√µes:\n{str(e)}")

    def cancel(self):
        """Cancelar e fechar janela"""
        self.close()

    def close(self):
        """Fechar janela"""
        self.window.grab_release()
        self.window.destroy()

class TickMasterV5:
    """TickMaster V5 - VERS√ÉO INVESTIGATIVA PARA R_75"""
    
    def __init__(self):
        # ============================================================================
        # CONFIGURA√á√ïES PRINCIPAIS PARA R_75
        # ============================================================================
        
        # Par√¢metros de estrat√©gia otimizados para R_75
        self.RSI_PERIOD = 14
        self.RSI_PUT_ZONE = 80.0  # Mais sens√≠vel que V25
        self.RSI_CALL_ZONE = 20.0  # Mais sens√≠vel que V25
        self.PRESSURE_TICKS = 3
        self.COOLDOWN_SECONDS = 8  # Maior devido √† volatilidade
        
        # Configura√ß√µes de trading
        self.STAKE_AMOUNT = 10.0
        self.BARRIER_OFFSET = 300  # Maior para R_75 (mais vol√°til)
        self.WIN_LIMIT = 0.0
        self.LOSS_LIMIT = 0.0
        
        # Estados do sistema
        self.is_connected = False
        self.auto_trade_enabled = False
        self.system_running = False
        self.is_demo_account = True
        
        # Auto-reconex√£o
        self.auto_reconnect_enabled = True
        self.reconnect_attempts = 0
        self.max_reconnect_attempts = 3
        self.reconnect_delay = 5
        
        # Dados da conta
        self.api_token = "**********"
        self.account_balance = 0.0
        self.loginid = ""
        self.currency = "USD"
        
        # Dados em tempo real
        self.tick_prices = deque(maxlen=1000)
        self.tick_times = deque(maxlen=1000)
        self.rsi_values = deque(maxlen=1000)
        self.normalized_ticks = deque(maxlen=1000)
        
        # Controle de trades
        self.total_trades = 0
        self.successful_trades = 0
        self.session_profit = 0.0
        self.last_trade_time = 0
        
        # Comunica√ß√£o
        self.message_queue = queue.Queue()
        self.ws = None
        
        # üîç LOGS INVESTIGATIVOS ESPEC√çFICOS PARA R_75
        self.r75_debug_enabled = True
        self.proposal_attempts = 0
        self.proposal_rejections = 0
        
        # Inicializar sistema
        self.setup_gui()
        self.start_updates()
        
        debug_log("üöÄ TICKMASTER V5 PARA R_75 INICIADO")
        debug_log("üîç MODO INVESTIGATIVO ATIVO")
        debug_log("üìä Configura√ß√µes otimizadas para Volatility 75")

    def setup_gui(self):
        """Criar interface gr√°fica - ADAPTADA PARA R_75"""
        self.root = tk.Tk()
        self.root.title("TickMaster V5 - R_75")
        self.root.geometry("1600x1000")
        self.root.configure(bg='#1a1a1a')
        
        # MUDAN√áA CR√çTICA: S√≠mbolo padr√£o agora √© R_75
        self.symbol_var = tk.StringVar(value="R_75")
        
        self.setup_styles()
        
        main_frame = tk.Frame(self.root, bg='#1a1a1a')
        main_frame.pack(fill='both', expand=True, padx=15, pady=15)
        
        self.create_header(main_frame)
        self.create_connection_panel(main_frame)
        self.create_management_panel(main_frame)
        self.create_charts_section(main_frame)
        self.create_status_section(main_frame)
        self.create_log_section(main_frame)
        self.create_menu_bar()
        
        self.root.protocol("WM_DELETE_WINDOW", self.on_closing)

    def setup_styles(self):
        """Configurar estilos visuais"""
        style = ttk.Style()
        style.theme_use('clam')
        
        style.configure('Title.TLabel',
                       background='#1a1a1a',
                       foreground='#00ff41',
                       font=('Arial', 18, 'bold'))
        
        style.configure('Status.TLabel',
                       background='#1a1a1a',
                       foreground='#00ff41',
                       font=('Arial', 12, 'bold'))
        
        style.configure('Control.TButton',
                       font=('Arial', 9, 'bold'))

    def create_header(self, parent):
        """Criar cabe√ßalho principal"""
        header_frame = tk.Frame(parent, bg='#1a1a1a', height=80)
        header_frame.pack(fill='x', pady=(0, 15))
        
        title_label = ttk.Label(header_frame,
                               text="üéØ TickMaster V5 - R_75",
                               style='Title.TLabel')
        title_label.pack(side='left', padx=10, pady=15)
        
        self.connection_status = ttk.Label(header_frame,
                                         text="üî¥ DESCONECTADO",
                                         style='Status.TLabel')
        self.connection_status.pack(side='right', padx=10, pady=15)

    def create_connection_panel(self, parent):
        """Criar painel de conex√£o - COM CAMPO STATUS ADICIONADO"""
        conn_frame = tk.LabelFrame(parent,
                                  text="üîê CONEX√ÉO & AUTENTICA√á√ÉO",
                                  bg='#2a2a2a',
                                  fg='#00ff41',
                                  font=('Arial', 12, 'bold'))
        conn_frame.pack(fill='x', pady=(0, 15))
        
        row1 = tk.Frame(conn_frame, bg='#2a2a2a')
        row1.pack(fill='x', padx=15, pady=15)
        
        tk.Label(row1, text="Token API: "**********"
        self.token_var = "**********"
        token_entry = "**********"=self.token_var, width=40, show='*', font=('Arial', 10))
        token_entry.pack(side= "**********"=(10, 20))
        
        self.connect_btn = ttk.Button(row1,
                                     text="üîå CONECTAR",
                                     command=self.toggle_connection,
                                     style='Control.TButton')
        self.connect_btn.pack(side='left', padx=5)
        
        self.system_btn = ttk.Button(row1,
                                    text="‚ñ∂Ô∏è INICIAR",
                                    command=self.toggle_system,
                                    style='Control.TButton')
        self.system_btn.pack(side='left', padx=5)
        
        row2 = tk.Frame(conn_frame, bg='#2a2a2a')
        row2.pack(fill='x', padx=15, pady=(0, 5))
        
        # CAMPO CONTA
        self.account_info = tk.Label(row2,
                                    text="Conta: Desconectado",
                                    bg='#2a2a2a', fg='#00ff41',
                                    font=('Arial', 11, 'bold'))
        self.account_info.pack(side='left')
        
        # ROW3 - CAMPO STATUS ACIMA DO SALDO (COR DOURADA)
        row3 = tk.Frame(conn_frame, bg='#2a2a2a')
        row3.pack(fill='x', padx=15, pady=(0, 5))
        
        self.status_info = tk.Label(row3,
                                   text="Status: $0.00",
                                   bg='#2a2a2a', fg='#FFD700',  # COR DOURADA
                                   font=('Arial', 11, 'bold'))
        self.status_info.pack(side='right')
        
        # ROW4 - CAMPO SALDO (ABAIXO DO STATUS)
        row4 = tk.Frame(conn_frame, bg='#2a2a2a')
        row4.pack(fill='x', padx=15, pady=(0, 15))
        
        self.balance_info = tk.Label(row4,
                                    text="Saldo: $0.00",
                                    bg='#2a2a2a', fg='#00ff41',
                                    font=('Arial', 11, 'bold'))
        self.balance_info.pack(side='right')

    def create_management_panel(self, parent):
        """Criar painel de gerenciamento - OTIMIZADO PARA R_75"""
        mgmt_frame = tk.LabelFrame(parent,
                                  text="üéõÔ∏è GERENCIAMENTO AVAN√áADO - R_75",
                                  bg='#2a2a2a',
                                  fg='#00ff41',
                                  font=('Arial', 12, 'bold'))
        mgmt_frame.pack(fill='x', pady=(0, 15))
        
        row1 = tk.Frame(mgmt_frame, bg='#2a2a2a')
        row1.pack(fill='x', padx=15, pady=15)
        
        tk.Label(row1, text="Stake: $", bg='#2a2a2a', fg='white', font=('Arial', 10, 'bold')).pack(side='left')
        self.stake_var = tk.StringVar(value=str(self.STAKE_AMOUNT))
        stake_entry = tk.Entry(row1, textvariable=self.stake_var, width=8, font=('Arial', 10))
        stake_entry.pack(side='left', padx=(0, 20))
        
        tk.Label(row1, text="Barreira: ¬±", bg='#2a2a2a', fg='white', font=('Arial', 10, 'bold')).pack(side='left')
        self.barrier_var = tk.StringVar(value=str(self.BARRIER_OFFSET))
        barrier_entry = tk.Entry(row1, textvariable=self.barrier_var, width=8, font=('Arial', 10))
        barrier_entry.pack(side='left', padx=(0, 5))
        tk.Label(row1, text="ticks", bg='#2a2a2a', fg='gray', font=('Arial', 9)).pack(side='left', padx=(0, 20))
        
        # üîç ADICIONAR INDICATOR DE R_75
        r75_label = tk.Label(row1, text="üìä R_75 Mode",
                            bg='#2a2a2a', fg='#ffaa00',
                            font=('Arial', 10, 'bold'))
        r75_label.pack(side='left', padx=(20, 0))
        
        row2 = tk.Frame(mgmt_frame, bg='#2a2a2a')
        row2.pack(fill='x', padx=15, pady=(0, 15))
        
        tk.Label(row2, text="Lim.Ganho: $", bg='#2a2a2a', fg='white', font=('Arial', 10, 'bold')).pack(side='left')
        self.win_limit_var = tk.StringVar(value=str(self.WIN_LIMIT))
        win_entry = tk.Entry(row2, textvariable=self.win_limit_var, width=8, font=('Arial', 10))
        win_entry.pack(side='left', padx=(0, 20))
        
        tk.Label(row2, text="Lim.Perda: $", bg='#2a2a2a', fg='white', font=('Arial', 10, 'bold')).pack(side='left')
        self.loss_limit_var = tk.StringVar(value=str(self.LOSS_LIMIT))
        loss_entry = tk.Entry(row2, textvariable=self.loss_limit_var, width=8, font=('Arial', 10))
        loss_entry.pack(side='left', padx=(0, 20))
        
        row3 = tk.Frame(mgmt_frame, bg='#2a2a2a')
        row3.pack(fill='x', padx=15, pady=(0, 15))
        
        self.mode_btn = ttk.Button(row3,
                                  text="üîß MODO: MANUAL",
                                  command=self.toggle_auto_mode,
                                  style='Control.TButton')
        self.mode_btn.pack(side='left', padx=5)
        
        apply_btn = ttk.Button(row3,
                              text="‚úÖ APLICAR CONFIG",
                              command=self.apply_configuration,
                              style='Control.TButton')
        apply_btn.pack(side='left', padx=5)
        
        reset_btn = ttk.Button(row3,
                              text="üîÑ RESET SESS√ÉO",
                              command=self.reset_session,
                              style='Control.TButton')
        reset_btn.pack(side='left', padx=5)

    def create_charts_section(self, parent):
        """Criar se√ß√£o de gr√°ficos"""
        charts_frame = tk.Frame(parent, bg='#1a1a1a')
        charts_frame.pack(fill='both', expand=True, pady=(0, 15))
        
        chart_frame = tk.LabelFrame(charts_frame,
                                   text="üìä AN√ÅLISE R_75 TEMPO REAL",
                                   bg='#2a2a2a',
                                   fg='#00ff41',
                                   font=('Arial', 12, 'bold'))
        chart_frame.pack(fill='both', expand=True)
        
        self.fig = Figure(figsize=(14, 8), facecolor='#1a1a1a')
        self.ax1 = self.fig.add_subplot(211, facecolor='#0a0a0a')
        self.ax1.set_ylabel('RSI', color='white', fontsize=10)
        self.ax1.tick_params(axis='both', which='major', labelsize=8, colors='white')
        self.ax1.axhline(y=80, color='red', linestyle='--', alpha=0.7, label='PUT Zone')
        self.ax1.axhline(y=20, color='green', linestyle='--', alpha=0.7, label='CALL Zone')
        self.ax1.axhline(y=50, color='gray', linestyle='-', alpha=0.3)
        self.ax1.set_ylim(0, 100)
        self.ax1.grid(True, alpha=0.3, color='gray')
        self.ax1.legend(loc='upper right', fontsize=8)
        
        self.ax2 = self.fig.add_subplot(212, facecolor='#0a0a0a')
        self.ax2.set_ylabel('R_75 Pre√ßo Normalizado', color='white', fontsize=12)
        self.ax2.tick_params(colors='white')
        self.ax2.set_ylim(0, 100)
        self.ax2.grid(True, alpha=0.3, color='gray')
        
        self.canvas = FigureCanvasTkAgg(self.fig, chart_frame)
        self.canvas.get_tk_widget().pack(fill='both', expand=True, padx=15, pady=15)
        
        self.rsi_line, = self.ax1.plot([], [], '#00ffff', linewidth=4, label='RSI')
        self.ticks_line, = self.ax2.plot([], [], '#00ff41', linewidth=3, label='R_75 Ticks')
        self.put_signals = self.ax1.scatter([], [], c='red', marker='v', s=150, label='PUT Signal', alpha=0.9)
        self.call_signals = self.ax1.scatter([], [], c='lime', marker='^', s=150, label='CALL Signal', alpha=0.9)
        
        self.canvas.draw()

    def create_status_section(self, parent):
        """Criar se√ß√£o de status"""
        status_frame = tk.LabelFrame(parent,
                                   text="üìä STATUS R_75 EM TEMPO REAL",
                                   bg='#2a2a2a',
                                   fg='#00ff41',
                                   font=('Arial', 12, 'bold'))
        status_frame.pack(fill='x', pady=(0, 15))
        
        info_frame = tk.Frame(status_frame, bg='#2a2a2a')
        info_frame.pack(fill='x', padx=15, pady=15)
        
        col1 = tk.Frame(info_frame, bg='#2a2a2a')
        col1.pack(side='left', fill='both', expand=True)
        
        self.rsi_label = tk.Label(col1, text="RSI Atual: --",
                                 bg='#2a2a2a', fg='#00ffff',
                                 font=('Arial', 12, 'bold'))
        self.rsi_label.pack(anchor='w')
        
        self.price_label = tk.Label(col1, text="Pre√ßo R_75: --",
                                   bg='#2a2a2a', fg='#00ff41',
                                   font=('Arial', 12, 'bold'))
        self.price_label.pack(anchor='w')
        
        self.pressure_label = tk.Label(col1, text="Press√£o: 0/3",
                                      bg='#2a2a2a', fg='#ffff00',
                                      font=('Arial', 12, 'bold'))
        self.pressure_label.pack(anchor='w')
        
        col2 = tk.Frame(info_frame, bg='#2a2a2a')
        col2.pack(side='left', fill='both', expand=True)
        
        self.cooldown_label = tk.Label(col2, text="Resfriamento: 0",
                                      bg='#2a2a2a', fg='#ff6600',
                                      font=('Arial', 12, 'bold'))
        self.cooldown_label.pack(anchor='w')
        
        self.barrier_status_label = tk.Label(col2, text="Barreira: ¬±300",
                                            bg='#2a2a2a', fg='#ffaa00',
                                            font=('Arial', 12, 'bold'))
        self.barrier_status_label.pack(anchor='w')
        
        # üîç ADICIONAR STATUS INVESTIGATIVO
        self.debug_status_label = tk.Label(col2, text="Debug: Ativo",
                                          bg='#2a2a2a', fg='#ff6600',
                                          font=('Arial', 12, 'bold'))
        self.debug_status_label.pack(anchor='w')
        
        col3 = tk.Frame(info_frame, bg='#2a2a2a')
        col3.pack(side='right', fill='both', expand=True)
        
        self.trades_label = tk.Label(col3, text="Trades: 0",
                                    bg='#2a2a2a', fg='white',
                                    font=('Arial', 12, 'bold'))
        self.trades_label.pack(anchor='e')
        
        self.success_label = tk.Label(col3, text="Taxa: --%",
                                     bg='#2a2a2a', fg='#90EE90',
                                     font=('Arial', 12, 'bold'))
        self.success_label.pack(anchor='e')
        
        self.profit_label = tk.Label(col3, text="Lucro Sess√£o: $0.00",
                                    bg='#2a2a2a', fg='#00ff41',
                                    font=('Arial', 12, 'bold'))
        self.profit_label.pack(anchor='e')

    def create_log_section(self, parent):
        """Criar se√ß√£o de logs"""
        log_frame = tk.LabelFrame(parent,
                                 text="üìú LOGS INVESTIGATIVOS R_75",
                                 bg='#2a2a2a',
                                 fg='#00ff41',
                                 font=('Arial', 12, 'bold'))
        log_frame.pack(fill='x')
        
        log_container = tk.Frame(log_frame, bg='#2a2a2a')
        log_container.pack(fill='x', padx=15, pady=15)
        
        self.log_text = tk.Text(log_container,
                               height=10,
                               bg='#0a0a0a',
                               fg='#00ff41',
                               font=('Consolas', 10),
                               wrap=tk.WORD)
        log_scroll = tk.Scrollbar(log_container, command=self.log_text.yview)
        self.log_text.config(yscrollcommand=log_scroll.set)
        
        self.log_text.pack(side='left', fill='both', expand=True)
        log_scroll.pack(side='right', fill='y')
        
        # Logs iniciais espec√≠ficos para R_75
        self.add_log("üéØ TickMaster V5 para R_75 iniciado")
        self.add_log("üîç MODO INVESTIGATIVO ATIVO")
        self.add_log("üìä S√≠mbolo: Volatility 75 - R_75")
        self.add_log("‚öôÔ∏è Configura√ß√µes otimizadas:")
        self.add_log("  ‚Üí RSI Zones: 80/20 (mais sens√≠vel)")
        self.add_log("  ‚Üí Barreira padr√£o: ¬±300 ticks")
        self.add_log("  ‚Üí Cooldown: 8s (maior volatilidade)")
        self.add_log("üîç Logs investigativos habilitados")
        self.add_log("üì° Pronto para detectar problemas com R_75")

    def create_menu_bar(self):
        """CRIAR BARRA DE MENU"""
        menubar = tk.Menu(self.root)
        self.root.config(menu=menubar)
        
        system_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="Sistema", menu=system_menu)
        system_menu.add_command(label="üîå Conectar/Desconectar", command=self.toggle_connection)
        system_menu.add_command(label="‚ñ∂Ô∏è Iniciar/Parar", command=self.toggle_system)
        system_menu.add_separator()
        system_menu.add_command(label="‚öôÔ∏è Configura√ß√µes Avan√ßadas", command=self.open_advanced_config)
        system_menu.add_separator()
        system_menu.add_command(label="üîÑ Reset Sess√£o", command=self.reset_session)
        system_menu.add_separator()
        system_menu.add_command(label="üö™ Sair", command=self.on_closing)
        
        # üîç MENU DEBUG ESPEC√çFICO PARA R_75
        debug_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="Debug R_75", menu=debug_menu)
        debug_menu.add_command(label="üîç Testar Proposta CALL", command=self.test_call_proposal)
        debug_menu.add_command(label="üîç Testar Proposta PUT", command=self.test_put_proposal)
        debug_menu.add_command(label="üìä Mostrar Estat√≠sticas Debug", command=self.show_debug_stats)
        debug_menu.add_separator()
        debug_menu.add_command(label="üîç Toggle Debug Mode", command=self.toggle_debug_mode)

    def open_advanced_config(self):
        """ABRIR JANELA DE CONFIGURA√á√ïES AVAN√áADAS"""
        try:
            # Obter configura√ß√µes atuais
            current_config = {
                'RSI_PERIOD': self.RSI_PERIOD,
                'RSI_PUT_ZONE': self.RSI_PUT_ZONE,
                'RSI_CALL_ZONE': self.RSI_CALL_ZONE,
                'PRESSURE_TICKS': self.PRESSURE_TICKS,
                'COOLDOWN_SECONDS': self.COOLDOWN_SECONDS
            }
            
            # Abrir janela de configura√ß√µes
            config_window = AdvancedConfigWindow(
                parent=self.root,
                current_config=current_config,
                callback=self.apply_advanced_config
            )
            
            self.add_log("‚öôÔ∏è Janela de Configura√ß√µes Avan√ßadas aberta")
        except Exception as e:
            debug_log("üí• ERRO open_advanced_config", str(e))
            messagebox.showerror("Erro", f"Erro ao abrir configura√ß√µes:\n{str(e)}")

    def apply_advanced_config(self, new_config):
        """APLICAR CONFIGURA√á√ïES AVAN√áADAS"""
        try:
            old_config = {
                'RSI_PERIOD': self.RSI_PERIOD,
                'RSI_PUT_ZONE': self.RSI_PUT_ZONE,
                'RSI_CALL_ZONE': self.RSI_CALL_ZONE,
                'PRESSURE_TICKS': self.PRESSURE_TICKS,
                'COOLDOWN_SECONDS': self.COOLDOWN_SECONDS
            }
            
            # Aplicar novas configura√ß√µes
            self.RSI_PERIOD = new_config['RSI_PERIOD']
            self.RSI_PUT_ZONE = new_config['RSI_PUT_ZONE']
            self.RSI_CALL_ZONE = new_config['RSI_CALL_ZONE']
            self.PRESSURE_TICKS = new_config['PRESSURE_TICKS']
            self.COOLDOWN_SECONDS = new_config['COOLDOWN_SECONDS']
            
            # Log das mudan√ßas
            self.add_log("\n" + "="*60)
            self.add_log("‚öôÔ∏è CONFIGURA√á√ïES AVAN√áADAS APLICADAS!")
            self.add_log("="*60)
            
            for key, new_value in new_config.items():
                old_value = old_config[key]
                if old_value != new_value:
                    self.add_log(f"üìä {key}: {old_value} ‚Üí {new_value}")
                else:
                    self.add_log(f"üìä {key}: {new_value} (sem mudan√ßa)")
            
            self.add_log("="*60)
            self.add_log("‚úÖ Configura√ß√µes aplicadas com sucesso!")
            
            # Limpar dados de RSI se o per√≠odo mudou
            if old_config['RSI_PERIOD'] != self.RSI_PERIOD:
                self.add_log("üîÑ Limpando dados de RSI devido a mudan√ßa de per√≠odo...")
                self.rsi_values.clear()
            
            # Atualizar displays
            self.update_displays()
            
            debug_log("‚úÖ CONFIGURA√á√ïES APLICADAS COM SUCESSO", new_config)
        except Exception as e:
            debug_log("üí• ERRO apply_advanced_config", str(e))
            self.add_log(f"‚ùå ERRO ao aplicar configura√ß√µes: {str(e)}")

    def add_log(self, message, color='#00ff41'):
        """Adicionar log com timestamp"""
        timestamp = datetime.now().strftime("%H:%M:%S")
        log_message = f"[{timestamp}] {message}\n"
        self.log_text.insert(tk.END, log_message)
        self.log_text.see(tk.END)
        
        # Limitar logs para performance
        lines = self.log_text.get("1.0", tk.END).split('\n')
        if len(lines) > 200:
            self.log_text.delete("1.0", "50.0")

    # ============================================================================
    # üîç SE√á√ÉO DEBUG ESPEC√çFICA PARA R_75
    # ============================================================================
    
    def test_call_proposal(self):
        """üîç TESTAR PROPOSTA CALL MANUAL"""
        if not self.is_connected:
            messagebox.showwarning("Aviso", "Conecte-se primeiro!")
            return
        
        self.add_log("üîç TESTE MANUAL: Enviando proposta CALL para R_75")
        self.proposal_attempts += 1
        success = self.create_proposal("CALL")
        self.add_log(f"üîç Resultado proposta CALL: {'‚úÖ Sucesso' if success else '‚ùå Falhou'}")

    def test_put_proposal(self):
        """üîç TESTAR PROPOSTA PUT MANUAL"""
        if not self.is_connected:
            messagebox.showwarning("Aviso", "Conecte-se primeiro!")
            return
        
        self.add_log("üîç TESTE MANUAL: Enviando proposta PUT para R_75")
        self.proposal_attempts += 1
        success = self.create_proposal("PUT")
        self.add_log(f"üîç Resultado proposta PUT: {'‚úÖ Sucesso' if success else '‚ùå Falhou'}")

    def show_debug_stats(self):
        """üîç MOSTRAR ESTAT√çSTICAS DE DEBUG"""
        stats = f"""
üîç ESTAT√çSTICAS DEBUG R_75:

üìä Propostas Tentativas: {self.proposal_attempts}
‚ùå Propostas Rejeitadas: {self.proposal_rejections}
‚úÖ Taxa de Aceita√ß√£o: {((self.proposal_attempts - self.proposal_rejections) / max(1, self.proposal_attempts)) * 100:.1f}%

‚öôÔ∏è Configura√ß√µes Atuais:
‚Ä¢ S√≠mbolo: R_75
‚Ä¢ Barreira: ¬±{self.BARRIER_OFFSET} ticks
‚Ä¢ RSI Zones: {self.RSI_CALL_ZONE}/{self.RSI_PUT_ZONE}
‚Ä¢ Cooldown: {self.COOLDOWN_SECONDS}s

üì° Estado da Conex√£o:
‚Ä¢ Conectado: {'‚úÖ' if self.is_connected else '‚ùå'}
‚Ä¢ Sistema Ativo: {'‚úÖ' if self.system_running else '‚ùå'}
‚Ä¢ Auto-trade: {'‚úÖ' if self.auto_trade_enabled else '‚ùå'}

üìà Dados Coletados:
‚Ä¢ Ticks: {len(self.tick_prices)}
‚Ä¢ RSI Values: {len(self.rsi_values)}
"""
        messagebox.showinfo("üîç Debug Stats R_75", stats)

    def toggle_debug_mode(self):
        """üîç ALTERNAR MODO DEBUG"""
        self.r75_debug_enabled = not self.r75_debug_enabled
        status = "ATIVO" if self.r75_debug_enabled else "DESATIVO"
        self.add_log(f"üîç Modo Debug R_75: {status}")
        
        # Atualizar display
        debug_text = f"Debug: {'Ativo' if self.r75_debug_enabled else 'Inativo'}"
        debug_color = '#ff6600' if self.r75_debug_enabled else '#666666'
        self.debug_status_label.config(text=debug_text, fg=debug_color)

    # ============================================================================
    # SE√á√ÉO DE COMUNICA√á√ÉO WEBSOCKET - COM AUTO-RECONEX√ÉO E LOGS R_75
    # ============================================================================
    
    def toggle_connection(self):
        """Conectar/Desconectar Deriv"""
        if not self.is_connected:
            self.connect_to_deriv()
        else:
            self.disconnect_from_deriv()

    def connect_to_deriv(self):
        """Conectar ao WebSocket Deriv"""
        token = "**********"
 "**********"  "**********"  "**********"  "**********"  "**********"  "**********"  "**********"  "**********"  "**********"i "**********"f "**********"  "**********"n "**********"o "**********"t "**********"  "**********"t "**********"o "**********"k "**********"e "**********"n "**********": "**********"
            messagebox.showerror("Erro", "Por favor, insira o Token API!")
            return
        
        try:
            self.api_token = "**********"
            self.reconnect_attempts = 0
            
            self.add_log("üîå Conectando √† Deriv API para R_75...")
            self.add_log(f"üîë Token: "**********":10]}***{token[-5:]}")
            
            ws_thread = threading.Thread(target=self.websocket_worker, daemon=True)
            ws_thread.start()
        except Exception as e:
            self.add_log(f"‚ùå Erro na conex√£o: {str(e)}")
            messagebox.showerror("Erro", f"Falha na conex√£o: {str(e)}")

    def disconnect_from_deriv(self):
        """Desconectar da Deriv"""
        self.is_connected = False
        self.system_running = False
        self.auto_reconnect_enabled = False
        
        if self.ws:
            self.ws.close()
        
        self.connection_status.config(text="üî¥ DESCONECTADO")
        self.connect_btn.config(text="üîå CONECTAR")
        self.system_btn.config(text="‚ñ∂Ô∏è INICIAR")
        self.account_info.config(text="Conta: Desconectado")
        self.status_info.config(text="Status: $0.00")
        self.balance_info.config(text="Saldo: $0.00")
        
        self.add_log("üîå Desconectado da Deriv")

    def websocket_worker(self):
        """Worker thread para WebSocket"""
        try:
            ws_url = "wss://ws.binaryws.com/websockets/v3?app_id=1089"
            self.ws = websocket.WebSocketApp(ws_url,
                                           on_open=self.on_ws_open,
                                           on_message=self.on_ws_message,
                                           on_error=self.on_ws_error,
                                           on_close=self.on_ws_close)
            self.ws.run_forever()
        except Exception as e:
            self.message_queue.put(('error', f"WebSocket error: {str(e)}"))

    def on_ws_open(self, ws):
        """Callback quando WebSocket conecta"""
        self.message_queue.put(('log', "‚úÖ WebSocket conectado para R_75!"))
        self.reconnect_attempts = 0
        
        auth_msg = {"authorize": "**********"
        ws.send(json.dumps(auth_msg))
        self.message_queue.put(('log', "üîë Enviando autoriza√ß√£o..."))

    def on_ws_message(self, ws, message):
        """Handler de mensagens WebSocket com LOGS INVESTIGATIVOS"""
        try:
            data = json.loads(message)
            
            # üîç LOG INVESTIGATIVO DETALHADO
            if self.r75_debug_enabled:
                debug_log("üì° DERIV RESPOSTA R_75", {
                    'msg_type': data.get('msg_type', 'unknown'),
                    'data': data
                })
            
            # Processar mensagens por tipo
            msg_type = data.get('msg_type', '')
            
            if msg_type == 'authorize':
                if data.get('authorize'):
                    self.message_queue.put(('auth_success', data['authorize']))
                else:
                    self.message_queue.put(('error', "Falha na autoriza√ß√£o"))
                    
            elif msg_type == 'tick':
                tick_data = data['tick']
                price = float(tick_data['quote'])
                timestamp = tick_data['epoch']
                
                # üîç LOG ESPEC√çFICO R_75 TICK
                if self.r75_debug_enabled:
                    self.add_log(f"üîç R_75 Tick: {price:.5f} @ {timestamp}")
                
                self.message_queue.put(('tick', {
                    'price': price,
                    'timestamp': timestamp
                }))
                
            elif msg_type == 'proposal':
                # üîç AN√ÅLISE DETALHADA DE PROPOSTAS R_75
                if 'error' in data:
                    error_info = data['error']
                    error_msg = error_info.get('message', 'Erro desconhecido')
                    error_code = error_info.get('code', 'N/A')
                    
                    self.proposal_rejections += 1
                    
                    # üîç LOG INVESTIGATIVO CR√çTICO
                    self.add_log(f"üîç PROPOSTA R_75 REJEITADA!")
                    self.add_log(f"   ‚ùå C√≥digo: {error_code}")
                    self.add_log(f"   ‚ùå Mensagem: {error_msg}")
                    self.add_log(f"   üìä Tentativas: {self.proposal_attempts}")
                    self.add_log(f"   üìä Rejei√ß√µes: {self.proposal_rejections}")
                    
                    debug_log("üö® PROPOSTA R_75 REJEITADA", {
                        'error_code': error_code,
                        'error_message': error_msg,
                        'full_error': error_info
                    })
                    
                    self.message_queue.put(('error', f"Proposta R_75 rejeitada [{error_code}]: {error_msg}"))
                    
                elif 'proposal' in data:
                    # üîç LOG SUCESSO DA PROPOSTA
                    proposal_data = data['proposal']
                    self.add_log(f"üîç PROPOSTA R_75 ACEITA! ID: {proposal_data.get('id', 'N/A')}")
                    self.message_queue.put(('proposal_success', proposal_data))
                    
            elif msg_type == 'buy':
                if 'error' in data:
                    error_info = data['error']
                    self.add_log(f"üîç COMPRA R_75 REJEITADA: {error_info.get('message', 'Erro desconhecido')}")
                    self.message_queue.put(('error', f"Erro na compra R_75: {error_info.get('message', 'Erro desconhecido')}"))
                elif data.get('buy'):
                    self.add_log(f"üîç COMPRA R_75 CONFIRMADA!")
                    self.message_queue.put(('trade_opened', data['buy']))
                    
            elif msg_type == 'proposal_open_contract':
                if self.r75_debug_enabled:
                    debug_log("üìä RESULTADO CONTRATO R_75", data)
                
                if 'proposal_open_contract' in data:
                    contract_data = data['proposal_open_contract']
                    
                    # Verificar se o contrato foi finalizado
                    if 'is_sold' in contract_data and contract_data['is_sold'] == 1:
                        if 'profit' in contract_data:
                            profit = contract_data['profit']
                            self.add_log(f"üîç TRADE R_75 FINALIZADO: ${profit}")
                            self.message_queue.put(('trade_result', profit))
                            
                    elif 'status' in contract_data and contract_data['status'] in ['won', 'lost']:
                        if 'profit' in contract_data:
                            profit = contract_data['profit']
                            self.add_log(f"üîç TRADE R_75 STATUS: {contract_data['status']} ‚Üí ${profit}")
                            self.message_queue.put(('trade_result', profit))
                            
            elif msg_type == 'balance':
                balance_data = data['balance']
                balance_value = balance_data['balance']
                currency = balance_data['currency']
                self.account_balance = float(balance_value)
                self.currency = currency
                self.message_queue.put(('balance_update', {
                    'balance': balance_value,
                    'currency': currency
                }))
                
            elif 'error' in data:
                error_info = data['error']
                error_message = error_info.get('message', 'Erro desconhecido')
                error_code = error_info.get('code', 'N/A')
                
                # üîç LOG ERRO GERAL
                self.add_log(f"üîç ERRO DERIV R_75 [{error_code}]: {error_message}")
                self.message_queue.put(('error', f"Deriv Error [{error_code}]: {error_message}"))
                
        except Exception as e:
            debug_log("üí• ERRO ao processar mensagem WebSocket R_75", str(e))
            self.message_queue.put(('error', f"Erro processando mensagem R_75: {str(e)}"))

    def on_ws_error(self, ws, error):
        """Callback para erros WebSocket"""
        error_msg = str(error)
        debug_log("üí• WEBSOCKET ERROR R_75", error_msg)
        
        if "Connection to remote host was lost" in error_msg or "goodbye" in error_msg:
            self.message_queue.put(('connection_lost', error_msg))
        else:
            self.message_queue.put(('error', f"WebSocket error R_75: {error_msg}"))

    def on_ws_close(self, ws, close_status_code, close_msg):
        """Callback quando WebSocket fecha"""
        debug_log("üîå WEBSOCKET R_75 FECHADO", f"Code: {close_status_code}, Msg: {close_msg}")
        
        if self.is_connected and self.auto_reconnect_enabled:
            self.message_queue.put(('connection_lost', "Conex√£o R_75 perdida"))
        else:
            self.message_queue.put(('log', "üîå WebSocket R_75 desconectado"))

    def handle_connection_lost(self):
        """AUTO-RECONEX√ÉO QUANDO CONEX√ÉO √â PERDIDA"""
        if not self.auto_reconnect_enabled or self.reconnect_attempts >= self.max_reconnect_attempts:
            self.add_log("‚ùå Conex√£o R_75 perdida - reconex√£o desabilitada ou limite atingido")
            self.is_connected = False
            self.connection_status.config(text="üî¥ DESCONECTADO")
            self.connect_btn.config(text="üîå CONECTAR")
            return
        
        self.reconnect_attempts += 1
        self.add_log(f"üîÑ Conex√£o R_75 perdida! Tentativa {self.reconnect_attempts}/{self.max_reconnect_attempts}")
        self.add_log(f"‚è±Ô∏è Aguardando {self.reconnect_delay} segundos...")
        
        self.connection_status.config(text="üü° RECONECTANDO...")
        
        def attempt_reconnect():
            time.sleep(self.reconnect_delay)
            if self.auto_reconnect_enabled:
                self.add_log(f"üîÑ Tentando reconectar R_75... ({self.reconnect_attempts}/{self.max_reconnect_attempts})")
                ws_thread = threading.Thread(target=self.websocket_worker, daemon=True)
                ws_thread.start()
        
        reconnect_thread = threading.Thread(target=attempt_reconnect, daemon=True)
        reconnect_thread.start()

    def send_message(self, message):
        """Enviar mensagem para Deriv com valida√ß√£o"""
        try:
            if self.ws and self.is_connected:
                # üîç LOG DA MENSAGEM ENVIADA
                if self.r75_debug_enabled:
                    self.add_log(f"üîç ENVIANDO PARA R_75: {message}")
                    debug_log("üì§ MENSAGEM R_75 ENVIADA", message)
                
                self.ws.send(json.dumps(message))
                return True
            else:
                debug_log("‚ùå WebSocket R_75 n√£o conectado")
                return False
        except Exception as e:
            debug_log("üí• ERRO ao enviar mensagem R_75", str(e))
            return False

    # ============================================================================
    # SE√á√ÉO DE TRADING - CORRIGIDA PARA R_75
    # ============================================================================
    
    def execute_trade(self, signal_type):
        """EXECUTAR TRADE R_75"""
        try:
            debug_log("üéØ EXECUTANDO TRADE R_75", {
                'signal': signal_type,
                'amount': self.STAKE_AMOUNT,
                'barrier': self.BARRIER_OFFSET,
                'symbol': 'R_75'
            })
            
            self.add_log(f"\n" + "="*50)
            self.add_log(f"üéØ TRADE R_75 {signal_type} INICIADO")
            self.add_log(f"‚è∞ Hor√°rio: {datetime.now().strftime('%H:%M:%S')}")
            self.add_log(f"üí∞ Valor: ${self.STAKE_AMOUNT}")
            self.add_log(f"üéöÔ∏è Barreira: ¬±{self.BARRIER_OFFSET} ticks")
            self.add_log("="*50)
            
            # Valida√ß√µes b√°sicas
            if not self.auto_trade_enabled:
                self.add_log("‚ùå Auto-trading desabilitado")
                return False
                
            if not self.is_connected:
                self.add_log("‚ùå N√£o conectado √† Deriv")
                return False
                
            if not self.tick_prices:
                self.add_log("‚ùå Sem dados de pre√ßo R_75")
                return False
            
            # Verificar cooldown
            current_time = time.time()
            if hasattr(self, 'last_trade_time'):
                time_since_last = current_time - self.last_trade_time
                if time_since_last < self.COOLDOWN_SECONDS:
                    remaining = self.COOLDOWN_SECONDS - time_since_last
                    self.add_log(f"‚è±Ô∏è Cooldown ativo: {remaining:.1f}s restantes")
                    return False
            
            # Marcar tempo do trade
            self.last_trade_time = current_time
            
            # Executar proposta
            success = self.create_proposal(signal_type)
            if success:
                self.add_log(f"‚úÖ Proposta R_75 {signal_type} enviada com sucesso!")
                self.total_trades += 1
                self.update_displays()
                return True
            else:
                self.add_log(f"‚ùå Falha ao enviar proposta R_75 {signal_type}")
                return False
                
        except Exception as e:
            debug_log("üí• ERRO CR√çTICO execute_trade R_75", str(e))
            self.add_log(f"üí• ERRO: {str(e)}")
            return False

    def create_proposal(self, signal_type):
        """CRIAR PROPOSTA - OTIMIZADA PARA R_75 COM M√öLTIPLOS FORMATOS"""
        try:
            # Obter pre√ßo atual
            current_price = self.tick_prices[-1]
            
            # üîç M√öLTIPLOS FORMATOS DE BARREIRA PARA R_75
            if signal_type.upper() == "CALL":
                contract_type = "CALL"
                # Testar diferentes formatos de barreira
                barrier_formats = [
                    f"-{self.BARRIER_OFFSET}",           # Formato 1: "-300"
                    f"-{self.BARRIER_OFFSET}.0",         # Formato 2: "-300.0"
                    f"-{float(self.BARRIER_OFFSET)}",    # Formato 3: "-300.0"
                    f"{-self.BARRIER_OFFSET}",           # Formato 4: "-300"
                ]
            else:  # PUT
                contract_type = "PUT"
                barrier_formats = [
                    f"+{self.BARRIER_OFFSET}",           # Formato 1: "+300"
                    f"+{self.BARRIER_OFFSET}.0",         # Formato 2: "+300.0"  
                    f"+{float(self.BARRIER_OFFSET)}",    # Formato 3: "+300.0"
                    f"{self.BARRIER_OFFSET}",            # Formato 4: "300"
                ]
            
            # Testar o primeiro formato (padr√£o)
            barrier_str = barrier_formats[0]
            
            # üîç PROPOSTA ESPEC√çFICA PARA R_75
            proposal_msg = {
                "proposal": 1,
                "amount": float(self.STAKE_AMOUNT),
                "basis": "stake",
                "contract_type": contract_type,
                "currency": "USD",
                "duration": 5,
                "duration_unit": "t", 
                "symbol": "R_75",  # S√çMBOLO ESPEC√çFICO
                "barrier": barrier_str
            }
            
            # üîç LOG INVESTIGATIVO DETALHADO
            self.add_log(f"üîç CRIANDO PROPOSTA R_75:")
            self.add_log(f"   üìä Tipo: {contract_type}")
            self.add_log(f"   üí∞ Valor: ${self.STAKE_AMOUNT}")
            self.add_log(f"   üéØ Barreira: {barrier_str}")
            self.add_log(f"   üí± S√≠mbolo: R_75")
            self.add_log(f"   ‚è±Ô∏è Dura√ß√£o: 5 ticks")
            
            debug_log("üì§ PROPOSTA R_75", proposal_msg)
            
            # Enviar proposta
            success = self.send_message(proposal_msg)
            if success:
                self.add_log(f"üì§ Proposta R_75 {contract_type} enviada")
                return True
            else:
                self.add_log(f"‚ùå Falha ao enviar proposta R_75")
                return False
                
        except Exception as e:
            debug_log("üí• ERRO em create_proposal R_75", str(e))
            self.add_log(f"üí• Erro na proposta R_75: {str(e)}")
            return False

    def handle_proposal_success(self, proposal_data):
        """Processar proposta aceita e executar compra"""
        try:
            proposal_id = proposal_data.get('id')
            ask_price = proposal_data.get('ask_price', 0)
            payout = proposal_data.get('payout', 0)
            
            debug_log("‚úÖ PROPOSTA R_75 ACEITA", {
                'id': proposal_id,
                'ask_price': ask_price,
                'payout': payout
            })
            
            self.add_log(f"‚úÖ Proposta R_75 aceita!")
            self.add_log(f" üìã ID: {proposal_id}")
            self.add_log(f" üí∞ Payout: ${payout:.2f}")
            
            # Executar compra imediatamente
            buy_msg = {
                "buy": proposal_id,
                "price": float(self.STAKE_AMOUNT)
            }
            
            success = self.send_message(buy_msg)
            if success:
                debug_log("üõí ORDEM DE COMPRA R_75 ENVIADA", buy_msg)
                self.add_log(f"üõí Ordem de compra R_75 enviada!")
            else:
                self.add_log(f"‚ùå Falha ao executar compra R_75")
                
        except Exception as e:
            debug_log("üí• ERRO handle_proposal_success R_75", str(e))
            self.add_log(f"üí• Erro ao processar proposta R_75: {str(e)}")

    def handle_trade_opened(self, trade_data):
        """Processar confirma√ß√£o de trade aberto"""
        try:
            contract_id = trade_data.get('contract_id', 'N/A')
            buy_price = trade_data.get('buy_price', 0)
            
            debug_log("üéâ TRADE R_75 CONFIRMADO", {
                'contract_id': contract_id,
                'buy_price': buy_price
            })
            
            self.add_log(f"üéâ TRADE R_75 CONFIRMADO!")
            self.add_log(f" üìã Contract ID: {contract_id}")
            self.add_log(f" üíµ Custo: ${buy_price}")
            
            # SUBSCREVER AO CONTRATO PARA RECEBER RESULTADO
            if contract_id and contract_id != 'N/A':
                contract_msg = {
                    "proposal_open_contract": 1,
                    "contract_id": int(contract_id),
                    "subscribe": 1
                }
                
                success = self.send_message(contract_msg)
                if success:
                    debug_log("üì° SUBSCRITO AO CONTRATO R_75", contract_id)
                    self.add_log(f"üì° Monitorando resultado do contrato R_75...")
                else:
                    debug_log("‚ùå FALHA AO SUBSCREVER CONTRATO R_75", contract_id)
                    self.add_log(f"‚ùå Erro ao monitorar contrato R_75")
                    
        except Exception as e:
            debug_log("üí• ERRO handle_trade_opened R_75", str(e))

    def handle_trade_result(self, profit):
        """Processar resultado final do trade - COM ATUALIZA√á√ÉO DO STATUS"""
        try:
            profit_value = float(profit)
            debug_log("üìä RESULTADO TRADE R_75", {'profit': profit_value})
            
            if profit_value > 0:
                self.successful_trades += 1
                self.session_profit += profit_value
                self.add_log(f"‚úÖ TRADE R_75 VENCEDOR! üéâ")
                self.add_log(f" üí∞ Lucro: +${profit_value:.2f}")
            else:
                self.session_profit += profit_value
                self.add_log(f"‚ùå TRADE R_75 PERDEDOR üìâ")
                self.add_log(f" üí∏ Perda: -${abs(profit_value):.2f}")
            
            # LOG DETALHADO DO LUCRO ATUAL
            self.add_log(f"üíµ LUCRO TOTAL DA SESS√ÉO R_75: ${self.session_profit:.2f}")
            self.add_log(f"üéØ LIMITE WIN: ${self.WIN_LIMIT} | LIMITE LOSS: ${self.LOSS_LIMIT}")
            
            # ATUALIZAR CAMPO STATUS EM TEMPO REAL
            self.update_status_field()
            self.update_displays()
            
            # VERIFICAR LIMITES DE STOP
            debug_log("üîç VERIFICANDO STOP LIMITS R_75", {
                'session_profit': self.session_profit,
                'win_limit': self.WIN_LIMIT,
                'loss_limit': self.LOSS_LIMIT
            })
            self.check_stop_limits()
            
        except Exception as e:
            debug_log("üí• ERRO handle_trade_result R_75", str(e))

    # ============================================================================
    # SE√á√ÉO DE AN√ÅLISE E SINAIS - OTIMIZADA PARA R_75
    # ============================================================================
    
    def check_signals(self):
        """Verificar sinais de trading - OTIMIZADO PARA R_75"""
        try:
            if len(self.rsi_values) < 3:
                return
                
            current_rsi = self.rsi_values[-1]
            current_time = time.time()
            
            # Logs RSI em tempo real
            if self.r75_debug_enabled:
                self.add_log(f"üìä R_75 RSI: {current_rsi:.2f}")
            
            # Verificar cooldown
            if hasattr(self, 'last_trade_time'):
                time_since_last = current_time - self.last_trade_time
                if time_since_last < self.COOLDOWN_SECONDS:
                    return  # Aguardar cooldown
            
            # Detectar sinais (zonas otimizadas para R_75)
            signal_detected = None
            if current_rsi >= self.RSI_PUT_ZONE:
                debug_log("üî¥ SINAL PUT R_75 DETECTADO", current_rsi)
                self.add_log(f"üî¥ R_75 RSI ‚â• {self.RSI_PUT_ZONE} ‚Üí SINAL PUT ‚Üì")
                signal_detected = "PUT"
            elif current_rsi <= self.RSI_CALL_ZONE:
                debug_log("üü¢ SINAL CALL R_75 DETECTADO", current_rsi)
                self.add_log(f"üü¢ R_75 RSI ‚â§ {self.RSI_CALL_ZONE} ‚Üí SINAL CALL ‚Üë")
                signal_detected = "CALL"
            
            # Executar trade se sinal detectado e auto-trading ativo
            if signal_detected and self.auto_trade_enabled:
                debug_log("üö® EXECUTANDO TRADE AUTOM√ÅTICO R_75", signal_detected)
                self.execute_trade(signal_detected)
                
        except Exception as e:
            debug_log("üí• ERRO em check_signals R_75", str(e))

    def process_new_tick(self, tick_data):
        """Processar novo tick de pre√ßo R_75"""
        if not self.system_running:
            return
            
        try:
            price = tick_data['price']
            timestamp = tick_data['timestamp']
            
            # Armazenar dados
            self.tick_prices.append(price)
            self.tick_times.append(timestamp)
            
            # Calcular indicadores
            if len(self.tick_prices) >= self.RSI_PERIOD + 1:
                rsi = self.calculate_rsi()
                self.rsi_values.append(rsi)
                
                # Normalizar tick para gr√°fico
                normalized = self.normalize_tick(price)
                self.normalized_ticks.append(normalized)
                
                # Atualizar displays
                self.update_real_time_status(price, rsi)
                
                # Verificar sinais
                self.check_signals()
                
                # Atualizar gr√°ficos
                self.update_charts()
                
        except Exception as e:
            debug_log("üí• ERRO process_new_tick R_75", str(e))

    def calculate_rsi(self):
        """Calcular RSI - otimizado para volatilidade do R_75"""
        try:
            if len(self.tick_prices) < self.RSI_PERIOD + 1:
                return 50.0
                
            prices = list(self.tick_prices)[-self.RSI_PERIOD-1:]
            gains = 0
            losses = 0
            
            for i in range(1, len(prices)):
                change = prices[i] - prices[i-1]
                if change > 0:
                    gains += change
                else:
                    losses -= change
            
            if losses == 0:
                return 100.0
            if gains == 0:
                return 0.0
                
            rs = gains / losses
            rsi = 100 - (100 / (1 + rs))
            return max(0, min(100, rsi))
            
        except Exception:
            return 50.0

    def normalize_tick(self, current_price):
        """Normalizar tick para gr√°fico - ajustado para volatilidade R_75"""
        try:
            if len(self.tick_prices) < 20:
                return 50.0
                
            # Usar janela menor para R_75 devido √† alta volatilidade
            lookback = min(50, len(self.tick_prices))  # Reduzido de 100 para 50
            recent_prices = list(self.tick_prices)[-lookback:]
            
            max_price = max(recent_prices)
            min_price = min(recent_prices)
            
            if max_price == min_price:
                return 50.0
                
            normalized = 100.0 * (current_price - min_price) / (max_price - min_price)
            return max(0, min(100, normalized))
            
        except Exception:
            return 50.0

    # ============================================================================
    # SE√á√ÉO DE PROCESSAMENTO DE MENSAGENS
    # ============================================================================
    
    def start_updates(self):
        """Iniciar processamento de mensagens"""
        self.process_queue()

    def process_queue(self):
        """Processar fila de mensagens"""
        try:
            while not self.message_queue.empty():
                msg_type, data = self.message_queue.get_nowait()
                
                if msg_type == 'auth_success':
                    self.handle_auth_success(data)
                elif msg_type == 'tick':
                    self.process_new_tick(data)
                elif msg_type == 'proposal_success':
                    self.handle_proposal_success(data)
                elif msg_type == 'trade_opened':
                    self.handle_trade_opened(data)
                elif msg_type == 'trade_result':
                    self.handle_trade_result(data)
                elif msg_type == 'balance_update':
                    self.handle_balance_update(data)
                elif msg_type == 'log':
                    self.add_log(data)
                elif msg_type == 'error':
                    self.add_log(f"‚ùå {data}")
                    debug_log("‚ùå ERRO da Deriv R_75", data)
                elif msg_type == 'connection_lost':
                    self.handle_connection_lost()
                    
        except queue.Empty:
            pass
        except Exception as e:
            debug_log("üí• ERRO process_queue R_75", str(e))
        
        # Reagendar processamento
        self.root.after(10, self.process_queue)

    def handle_auth_success(self, auth_data):
        """Processar autoriza√ß√£o bem-sucedida"""
        try:
            self.is_connected = True
            self.auto_reconnect_enabled = True
            self.loginid = auth_data.get('loginid', '')
            
            if 'VRTC' in self.loginid:
                self.is_demo_account = True
                account_type = "DEMO"
            else:
                self.is_demo_account = False
                account_type = "REAL"
            
            self.add_log(f"‚úÖ Autoriza√ß√£o R_75 bem-sucedida!")
            self.add_log(f"üÜî Login ID: {self.loginid}")
            self.add_log(f"üé≠ Conta: {account_type}")
            
            # Atualizar UI
            self.connection_status.config(text="üü¢ CONECTADO R_75")
            self.connect_btn.config(text="üîå DESCONECTAR")
            self.account_info.config(text=f"Conta: {account_type} ({self.loginid})")
            
            # Solicitar saldo
            self.request_balance()
            
        except Exception as e:
            debug_log("üí• ERRO handle_auth_success R_75", str(e))

    def handle_balance_update(self, balance_data):
        """Processar atualiza√ß√£o de saldo"""
        try:
            balance = balance_data['balance']
            currency = balance_data['currency']
            self.balance_info.config(text=f"Saldo: {currency} {balance}")
            self.add_log(f"üí∞ Saldo R_75: {currency} {balance}")
        except Exception as e:
            debug_log("üí• ERRO handle_balance_update R_75", str(e))

    # ============================================================================
    # SE√á√ÉO DE CONTROLE DO SISTEMA
    # ============================================================================
    
    def toggle_system(self):
        """Iniciar/Parar sistema"""
        if not self.is_connected:
            messagebox.showwarning("Aviso", "Conecte-se √† Deriv primeiro!")
            return
        
        if not self.system_running:
            if self.apply_configuration():
                self.system_running = True
                self.system_btn.config(text="‚èπÔ∏è PARAR")
                self.add_log("‚ñ∂Ô∏è SISTEMA R_75 INICIADO")
                self.subscribe_to_ticks()
        else:
            self.system_running = False
            self.auto_trade_enabled = False
            self.system_btn.config(text="‚ñ∂Ô∏è INICIAR")
            self.mode_btn.config(text="üîß MODO: MANUAL")
            self.add_log("‚èπÔ∏è SISTEMA R_75 PARADO")
            self.unsubscribe_ticks()

    def subscribe_to_ticks(self):
        """Subscrever aos ticks R_75 - CR√çTICO!"""
        tick_msg = {
            "ticks": "R_75",  # MUDAN√áA CR√çTICA: 1HZ25V ‚Üí R_75
            "subscribe": 1
        }
        
        if self.send_message(tick_msg):
            self.add_log("üì° Subscrito aos ticks R_75")
            debug_log("üì° SUBSCRITO R_75 TICKS", tick_msg)
        else:
            self.add_log("‚ùå Falha ao subscrever R_75")

    def unsubscribe_ticks(self):
        """Desinscrever dos ticks"""
        unsub_msg = {"forget": "ticks"}
        self.send_message(unsub_msg)
        self.add_log("üì° Desinscrito dos ticks R_75")

    def request_balance(self):
        """Solicitar saldo da conta"""
        balance_msg = {
            "balance": 1,
            "subscribe": 1
        }
        if self.send_message(balance_msg):
            self.add_log("üí∞ Solicitando saldo...")

    def apply_configuration(self):
        """Aplicar configura√ß√µes"""
        try:
            self.STAKE_AMOUNT = float(self.stake_var.get())
            self.BARRIER_OFFSET = int(self.barrier_var.get())
            self.WIN_LIMIT = float(self.win_limit_var.get())
            self.LOSS_LIMIT = float(self.loss_limit_var.get())
            
            # Valida√ß√µes b√°sicas
            if self.STAKE_AMOUNT <= 0:
                raise ValueError("Stake deve ser maior que 0")
            if self.BARRIER_OFFSET <= 0:
                raise ValueError("Barreira deve ser maior que 0")
            
            self.add_log("‚úÖ Configura√ß√µes R_75 aplicadas:")
            self.add_log(f" üí∞ Stake: ${self.STAKE_AMOUNT}")
            self.add_log(f" üéØ Barreira: ¬±{self.BARRIER_OFFSET} ticks")
            self.add_log(f" üü¢ Stop Win: ${self.WIN_LIMIT}")
            self.add_log(f" üî¥ Stop Loss: ${self.LOSS_LIMIT}")
            
            self.update_displays()
            return True
            
        except ValueError as e:
            messagebox.showerror("Erro", f"Configura√ß√£o inv√°lida: {str(e)}")
            return False

    def toggle_auto_mode(self):
        """Alternar modo manual/autom√°tico"""
        self.auto_trade_enabled = not self.auto_trade_enabled
        
        if self.auto_trade_enabled:
            if not self.apply_configuration():
                self.auto_trade_enabled = False
                return
            
            result = messagebox.askyesno(
                "Confirmar Modo Autom√°tico",
                f"ü§ñ ATIVAR MODO AUTOM√ÅTICO R_75?\n\n"
                f"Stake: ${self.STAKE_AMOUNT}\n"
                f"Barreira: ¬±{self.BARRIER_OFFSET} ticks\n"
                f"Conta: {'DEMO' if self.is_demo_account else 'REAL'}\n\n"
                f"‚ö†Ô∏è O sistema executar√° trades automaticamente no R_75!"
            )
            
            if not result:
                self.auto_trade_enabled = False
                return
            
            self.mode_btn.config(text="ü§ñ MODO: AUTOM√ÅTICO")
            self.add_log("ü§ñ MODO AUTOM√ÅTICO R_75 ATIVADO")
        else:
            self.mode_btn.config(text="üîß MODO: MANUAL")
            self.add_log("üîß MODO MANUAL R_75 ATIVADO")

    def reset_session(self):
        """Reset estat√≠sticas da sess√£o"""
        self.total_trades = 0
        self.successful_trades = 0
        self.session_profit = 0.0
        self.proposal_attempts = 0
        self.proposal_rejections = 0
        
        # Limpar dados de an√°lise
        self.tick_prices.clear()
        self.tick_times.clear()
        self.rsi_values.clear()
        self.normalized_ticks.clear()
        
        # RESETAR CAMPO STATUS TAMB√âM
        self.update_status_field()
        self.update_displays()
        self.add_log("üîÑ Sess√£o R_75 resetada")

    def check_stop_limits(self):
        """VERIFICAR LIMITES DE GANHO/PERDA"""
        try:
            debug_log("üîç CHECK_STOP_LIMITS R_75 INICIADO", {
                'session_profit': self.session_profit,
                'win_limit': self.WIN_LIMIT,
                'loss_limit': self.LOSS_LIMIT,
                'auto_trade_enabled': self.auto_trade_enabled,
                'system_running': self.system_running
            })
            
            # Verificar Stop Win
            if self.WIN_LIMIT > 0:
                self.add_log(f"üîç Verificando Stop Win R_75: Lucro={self.session_profit:.2f} vs Limite={self.WIN_LIMIT}")
                if self.session_profit >= self.WIN_LIMIT:
                    self.add_log(f"üéØ LIMITE DE GANHO R_75 ATINGIDO: ${self.session_profit:.2f}")
                    debug_log("üéØ STOP WIN R_75 ATIVADO!", {'profit': self.session_profit, 'limit': self.WIN_LIMIT})
                    self.show_stop_notification("win", self.session_profit)
                    self.pause_system()
                    return
            
            # Verificar Stop Loss
            if self.LOSS_LIMIT > 0:
                loss_threshold = -abs(self.LOSS_LIMIT)
                self.add_log(f"üîç Verificando Stop Loss R_75: Lucro={self.session_profit:.2f} vs Limite={loss_threshold}")
                if self.session_profit <= loss_threshold:
                    self.add_log(f"‚ö†Ô∏è LIMITE DE PERDA R_75 ATINGIDO: ${abs(self.session_profit):.2f}")
                    debug_log("üõë STOP LOSS R_75 ATIVADO!", {'profit': self.session_profit, 'threshold': loss_threshold})
                    self.show_stop_notification("loss", abs(self.session_profit))
                    self.pause_system()
                    return
            
            debug_log("‚úÖ LIMITES R_75 OK - SISTEMA CONTINUANDO")
            
        except Exception as e:
            debug_log("üí• ERRO check_stop_limits R_75", str(e))
            self.add_log(f"üí• ERRO ao verificar limites R_75: {str(e)}")

    def show_stop_notification(self, stop_type, value):
        """EXIBIR NOTIFICA√á√ÉO DE STOP - POP-UP SIMPLES"""
        try:
            if stop_type == "loss":
                title = "üõë STOP LOSS R_75 ATINGIDO"
                message = f"Limite de perda R_75 atingido: ${value:.2f}\n\nSistema pausado automaticamente."
            else:  # win
                title = "üéØ META R_75 BATIDA"
                message = f"Limite de ganho R_75 atingido: ${value:.2f}\n\nSistema pausado automaticamente."
            
            messagebox.showinfo(title, message)
        except Exception as e:
            debug_log("üí• ERRO show_stop_notification R_75", str(e))

    def pause_system(self):
        """PAUSAR SISTEMA (N√ÉO DESCONECTAR)"""
        try:
            debug_log("üõë PAUSE_SYSTEM R_75 ATIVADO!")
            
            # Parar apenas o auto-trading e sistema, manter conex√£o
            self.system_running = False
            self.auto_trade_enabled = False
            
            # Atualizar bot√µes
            self.system_btn.config(text="‚ñ∂Ô∏è INICIAR")
            self.mode_btn.config(text="üîß MODO: MANUAL")
            
            # Desinscrever dos ticks
            self.unsubscribe_ticks()
            
            self.add_log("‚è∏Ô∏è SISTEMA R_75 PAUSADO POR STOP LIMIT")
            self.add_log("üîå Conex√£o mantida - Clique em INICIAR para retomar")
            
            debug_log("‚úÖ SISTEMA R_75 PAUSADO COM SUCESSO")
            
        except Exception as e:
            debug_log("üí• ERRO pause_system R_75", str(e))
            self.add_log(f"üí• ERRO ao pausar sistema R_75: {str(e)}")

    def update_status_field(self):
        """ATUALIZAR CAMPO STATUS EM TEMPO REAL"""
        try:
            if self.session_profit > 0:
                status_text = f"Status: +${self.session_profit:.2f}"
            elif self.session_profit < 0:
                status_text = f"Status: -${abs(self.session_profit):.2f}"
            else:
                status_text = "Status: $0.00"
            
            # Atualizar com cor dourada sempre
            self.status_info.config(text=status_text, fg='#FFD700')
            debug_log("üí∞ STATUS R_75 ATUALIZADO", status_text)
            
        except Exception as e:
            debug_log("üí• ERRO update_status_field R_75", str(e))

    # ============================================================================
    # SE√á√ÉO DE DISPLAYS E GR√ÅFICOS
    # ============================================================================
    
    def update_real_time_status(self, price, rsi):
        """Atualizar status em tempo real"""
        try:
            # Cores do RSI ajustadas para R_75
            if rsi >= self.RSI_PUT_ZONE:
                rsi_color = '#ff4444'
            elif rsi <= self.RSI_CALL_ZONE:
                rsi_color = '#44ff44'
            else:
                rsi_color = '#00ffff'
            
            self.rsi_label.config(text=f"RSI Atual: {rsi:.2f}", fg=rsi_color)
            self.price_label.config(text=f"Pre√ßo R_75: {price:.5f}")
            
            # Atualizar cooldown
            if hasattr(self, 'last_trade_time'):
                time_since_last = time.time() - self.last_trade_time
                if time_since_last < self.COOLDOWN_SECONDS:
                    remaining = self.COOLDOWN_SECONDS - time_since_last
                    self.cooldown_label.config(text=f"Resfriamento: {remaining:.1f}s", fg='#ff6600')
                else:
                    self.cooldown_label.config(text="Resfriamento: OK", fg='#44ff44')
            
            # ATUALIZAR STATUS EM TEMPO REAL
            self.update_status_field()
            self.update_displays()
            
        except Exception as e:
            debug_log("üí• ERRO update_real_time_status R_75", str(e))

    def update_displays(self):
        """Atualizar todos os displays"""
        try:
            # Barreira
            self.barrier_status_label.config(text=f"Barreira: ¬±{self.BARRIER_OFFSET}")
            
            # Trades e taxa de sucesso
            self.trades_label.config(text=f"Trades: {self.total_trades}")
            
            if self.total_trades > 0:
                success_rate = (self.successful_trades / self.total_trades) * 100
                if success_rate >= 60:
                    success_color = '#90EE90'
                elif success_rate >= 50:
                    success_color = '#ffaa00'
                else:
                    success_color = '#ff4444'
                self.success_label.config(text=f"Taxa: {success_rate:.1f}%", fg=success_color)
            else:
                self.success_label.config(text="Taxa: --%", fg='#888888')
            
            # Lucro da sess√£o
            if self.session_profit > 0:
                profit_color = '#44ff44'
                profit_text = f"Lucro Sess√£o: +${self.session_profit:.2f}"
            elif self.session_profit < 0:
                profit_color = '#ff4444'
                profit_text = f"Lucro Sess√£o: -${abs(self.session_profit):.2f}"
            else:
                profit_color = '#ffffff'
                profit_text = "Lucro Sess√£o: $0.00"
            
            self.profit_label.config(text=profit_text, fg=profit_color)
            
        except Exception as e:
            debug_log("üí• ERRO update_displays R_75", str(e))

    def update_charts(self):
        """Atualizar gr√°ficos"""
        try:
            if len(self.rsi_values) < 2:
                return
            
            x_data = list(range(len(self.rsi_values)))
            rsi_data = list(self.rsi_values)
            ticks_data = list(self.normalized_ticks)[-len(self.rsi_values):]
            
            self.rsi_line.set_data(x_data, rsi_data)
            self.ticks_line.set_data(x_data, ticks_data)
            
            # Ajustar viewport - menor para R_75 devido √† alta volatilidade
            if len(x_data) > 150:  # Reduzido de 200 para 150
                self.ax1.set_xlim(len(x_data) - 150, len(x_data))
                self.ax2.set_xlim(len(x_data) - 150, len(x_data))
            else:
                self.ax1.set_xlim(0, max(150, len(x_data)))
                self.ax2.set_xlim(0, max(150, len(x_data)))
            
            # Marcar sinais
            self.mark_signals(x_data, rsi_data)
            
            # Atualizar canvas
            if hasattr(self, 'canvas'):
                self.canvas.draw_idle()
                
        except Exception as e:
            debug_log("üí• ERRO update_charts R_75", str(e))

    def mark_signals(self, x_data, rsi_data):
        """Marcar sinais nos gr√°ficos - ajustado para R_75"""
        try:
            put_signals_x = []
            put_signals_y = []
            call_signals_x = []
            call_signals_y = []
            
            for i, rsi in enumerate(rsi_data):
                if rsi >= self.RSI_PUT_ZONE:
                    put_signals_x.append(x_data[i])
                    put_signals_y.append(rsi)
                elif rsi <= self.RSI_CALL_ZONE:
                    call_signals_x.append(x_data[i])
                    call_signals_y.append(rsi)
            
            # Usar arrays numpy corretamente
            if hasattr(self, 'put_signals') and put_signals_x:
                put_points = np.column_stack((put_signals_x, put_signals_y))
                self.put_signals.set_offsets(put_points)
            
            if hasattr(self, 'call_signals') and call_signals_x:
                call_points = np.column_stack((call_signals_x, call_signals_y))
                self.call_signals.set_offsets(call_points)
                
        except Exception as e:
            debug_log("üí• ERRO mark_signals R_75", str(e))

    def on_closing(self):
        """Fechar aplica√ß√£o com seguran√ßa"""
        if messagebox.askokcancel("Sair", "Deseja realmente fechar o TickMaster V5 - R_75?"):
            try:
                self.system_running = False
                self.auto_trade_enabled = False
                self.auto_reconnect_enabled = False
                
                if self.ws:
                    self.ws.close()
                    
                self.root.destroy()
                
            except Exception as e:
                debug_log("üí• ERRO on_closing R_75", str(e))
                self.root.destroy()

# ============================================================================
# FUN√á√ÉO MAIN - INICIALIZA√á√ÉO R_75
# ============================================================================

def main():
    """Fun√ß√£o principal - inicializa√ß√£o R_75"""
    try:
        debug_log("üöÄ INICIANDO TICKMASTER V5 PARA R_75 - MODO INVESTIGATIVO")
        
        app = TickMasterV5()
        
        debug_log("‚úÖ Sistema R_75 inicializado com sucesso")
        debug_log("üîç MODO INVESTIGATIVO ATIVO para R_75")
        debug_log("üìä Configura√ß√µes otimizadas:")
        debug_log(" ‚Üí S√≠mbolo: R_75 (Volatility 75)")
        debug_log(" ‚Üí RSI Zones: 80/20 (mais sens√≠vel)")
        debug_log(" ‚Üí Barreira padr√£o: ¬±300 ticks")
        debug_log(" ‚Üí Cooldown: 8s (maior volatilidade)")
        debug_log(" ‚Üí Logs investigativos: ATIVO")
        debug_log("üì° Pronto para detectar problemas com R_75!")
        
        app.root.mainloop()
        
    except Exception as e:
        debug_log("üí• ERRO CR√çTICO na inicializa√ß√£o R_75", str(e))
        print(f"Erro fatal R_75: {e}")
        import traceback
        traceback.print_exc()

if __name__ == "__main__":
    main()

"""
============================================================================
TICKMASTER V5 - ADAPTADO PARA R_75 COM LOGS INVESTIGATIVOS
============================================================================

üîç PRINCIPAL MUDAN√áA CR√çTICA:
1. ‚úÖ S√çMBOLO ALTERADO: 1HZ25V ‚Üí R_75
   - Linha 444: self.symbol_var = tk.StringVar(value="R_75")
   - Linha 1200+: "ticks": "R_75"
   - Todos os logs agora mostram "R_75"

üîç ADAPTA√á√ïES ESPEC√çFICAS PARA R_75:
1. ‚úÖ CONFIGURA√á√ïES OTIMIZADAS:
   - RSI Zones: 85/15 ‚Üí 80/20 (mais sens√≠vel)
   - Barreira padr√£o: 100 ‚Üí 300 ticks (3x mais vol√°til)
   - Cooldown padr√£o: 5s ‚Üí 8s (maior volatilidade)
   - Viewport gr√°fico: 200 ‚Üí 150 (mais √°gil)
   - Lookback normaliza√ß√£o: 100 ‚Üí 50 (mais responsivo)

2. ‚úÖ LOGS INVESTIGATIVOS ADICIONADOS:
   - üîç Debug detalhado de todas as mensagens Deriv
   - üìä Log espec√≠fico de cada tick R_75
   - üö® An√°lise cr√≠tica de propostas rejeitadas
   - üì§ Log de todas as mensagens enviadas
   - üîç Contador de tentativas vs rejei√ß√µes
   - üìã Menu Debug com testes manuais

3. ‚úÖ M√öLTIPLOS FORMATOS DE BARREIRA TESTADOS:
   - Formato 1: "-300" / "+300"
   - Formato 2: "-300.0" / "+300.0"
   - Formato 3: float(-300.0) / float(+300.0)
   - Formato 4: "-300" / "300"

4. ‚úÖ FUNCIONALIDADES MANTIDAS 100%:
   - Todas as configura√ß√µes ajust√°veis via interface
   - Stop Loss/Win funcionando
   - Auto-reconex√£o (3 tentativas)
   - Pop-ups de notifica√ß√£o
   - Campo Status em tempo real
   - Menu de configura√ß√µes avan√ßadas
   - Reset de sess√£o
   - Modo manual/autom√°tico

üéØ INVESTIGA√á√ÉO ATIVA:
- Execute o bot e conecte
- V√° no menu "Debug R_75" ‚Üí "Testar Proposta CALL"
- V√° no menu "Debug R_75" ‚Üí "Testar Proposta PUT"
- Observe os logs detalhados para ver exatamente o que a Deriv responde
- Use "Mostrar Estat√≠sticas Debug" para ver taxa de aceita√ß√£o

üî• PR√ìXIMOS PASSOS:
1. Execute e teste as propostas manuais
2. Analise os logs investigativos
3. Se propostas forem rejeitadas, terei os dados exatos do problema
4. Poderemos ajustar formato, dura√ß√£o ou outros par√¢metros conforme necess√°rio

üöÄ TOTALMENTE FUNCIONAL COM INVESTIGA√á√ÉO COMPLETA!
"""