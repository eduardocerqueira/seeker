#date: 2025-08-08T16:51:44Z
#url: https://api.github.com/gists/269ec86255cb8c6434929630db83c115
#owner: https://api.github.com/users/datavudeja

ï»¿import spacy
from spacy.training import Example
from spacy.util import minibatch, compounding
import random

nlp = spacy.load("en_core_web_sm")

# Add custom entity recognizer
ner = nlp.get_pipe("ner")
ner.add_label("CUSTOM_ENTITY")

# Assuming you have training data
TRAIN_DATA = [
    ("Users with status VIP", {"entities": [(13, 16, "CUSTOM_ENTITY")]}),
    ("Employees marked as Manager", {"entities": [(20, 27, "CUSTOM_ENTITY")]}),
    # Add more examples here
]

other_pipes = [pipe for pipe in nlp.pipe_names if pipe != "ner"]
with nlp.disable_pipes(*other_pipes):  # only train NER
    optimizer = nlp.begin_training()
    for itn in range(10):
        random.shuffle(TRAIN_DATA)
        losses = {}
        batches = minibatch(TRAIN_DATA, size=compounding(4.0, 32.0, 1.001))
        for batch in batches:
            examples = [Example.from_dict(nlp.make_doc(text), annotations) for text, annotations in batch]
            nlp.update(examples, drop=0.5, sgd=optimizer, losses=losses)
        print("Losses", losses)

def parse_nlp_query(query):
    doc = nlp(query)
    conditions = []
    current_condition = []

 "**********"  "**********"  "**********"  "**********"  "**********"f "**********"o "**********"r "**********"  "**********"t "**********"o "**********"k "**********"e "**********"n "**********"  "**********"i "**********"n "**********"  "**********"d "**********"o "**********"c "**********": "**********"
        # Check for custom entities
 "**********"  "**********"  "**********"  "**********"  "**********"  "**********"  "**********"  "**********"  "**********"i "**********"f "**********"  "**********"a "**********"n "**********"y "**********"( "**********"e "**********"n "**********"t "**********". "**********"l "**********"a "**********"b "**********"e "**********"l "**********"_ "**********"  "**********"= "**********"= "**********"  "**********"" "**********"C "**********"U "**********"S "**********"T "**********"O "**********"M "**********"_ "**********"E "**********"N "**********"T "**********"I "**********"T "**********"Y "**********"" "**********"  "**********"f "**********"o "**********"r "**********"  "**********"e "**********"n "**********"t "**********"  "**********"i "**********"n "**********"  "**********"d "**********"o "**********"c "**********". "**********"e "**********"n "**********"t "**********"s "**********"  "**********"i "**********"f "**********"  "**********"e "**********"n "**********"t "**********". "**********"s "**********"t "**********"a "**********"r "**********"t "**********"  "**********"< "**********"= "**********"  "**********"t "**********"o "**********"k "**********"e "**********"n "**********". "**********"i "**********"  "**********"< "**********"  "**********"e "**********"n "**********"t "**********". "**********"e "**********"n "**********"d "**********") "**********": "**********"
            # If the token is part of a CUSTOM_ENTITY, treat it specially
            entity_text = "**********"= token.i < ent.end)
            if entity_text:
                current_condition.append(f"status == '{entity_text}'")

 "**********"  "**********"  "**********"  "**********"  "**********"  "**********"  "**********"  "**********"  "**********"e "**********"l "**********"i "**********"f "**********"  "**********"t "**********"o "**********"k "**********"e "**********"n "**********". "**********"t "**********"e "**********"x "**********"t "**********". "**********"l "**********"o "**********"w "**********"e "**********"r "**********"( "**********") "**********"  "**********"i "**********"n "**********"  "**********"[ "**********"" "**********"j "**********"o "**********"i "**********"n "**********"e "**********"d "**********"" "**********", "**********"  "**********"" "**********"s "**********"i "**********"n "**********"c "**********"e "**********"" "**********", "**********"  "**********"" "**********"a "**********"f "**********"t "**********"e "**********"r "**********"" "**********", "**********"  "**********"" "**********"b "**********"e "**********"f "**********"o "**********"r "**********"e "**********"" "**********"] "**********": "**********"
            date = next((ent.text for ent in doc.ents if ent.label_ == "DATE"), None)
            if date:
                op = "**********"
                current_condition.append(f"date_joined {op} '{date}'")
 "**********"  "**********"  "**********"  "**********"  "**********"  "**********"  "**********"  "**********"  "**********"e "**********"l "**********"i "**********"f "**********"  "**********"t "**********"o "**********"k "**********"e "**********"n "**********". "**********"t "**********"e "**********"x "**********"t "**********". "**********"l "**********"o "**********"w "**********"e "**********"r "**********"( "**********") "**********"  "**********"= "**********"= "**********"  "**********"" "**********"n "**********"a "**********"m "**********"e "**********"" "**********"  "**********"a "**********"n "**********"d "**********"  "**********"t "**********"o "**********"k "**********"e "**********"n "**********". "**********"i "**********"  "**********"+ "**********"  "**********"1 "**********"  "**********"< "**********"  "**********"l "**********"e "**********"n "**********"( "**********"d "**********"o "**********"c "**********") "**********": "**********"
            name_condition = "**********"
            current_condition.append(f"name == '{name_condition}'")
 "**********"  "**********"  "**********"  "**********"  "**********"  "**********"  "**********"  "**********"  "**********"e "**********"l "**********"i "**********"f "**********"  "**********"t "**********"o "**********"k "**********"e "**********"n "**********". "**********"t "**********"e "**********"x "**********"t "**********". "**********"l "**********"o "**********"w "**********"e "**********"r "**********"( "**********") "**********"  "**********"= "**********"= "**********"  "**********"" "**********"o "**********"n "**********"l "**********"i "**********"n "**********"e "**********"" "**********": "**********"
            current_condition.append("online == true")
 "**********"  "**********"  "**********"  "**********"  "**********"  "**********"  "**********"  "**********"  "**********"e "**********"l "**********"i "**********"f "**********"  "**********"t "**********"o "**********"k "**********"e "**********"n "**********". "**********"t "**********"e "**********"x "**********"t "**********". "**********"l "**********"o "**********"w "**********"e "**********"r "**********"( "**********") "**********"  "**********"= "**********"= "**********"  "**********"" "**********"o "**********"f "**********"f "**********"l "**********"i "**********"n "**********"e "**********"" "**********": "**********"
            current_condition.append("online == false")
 "**********"  "**********"  "**********"  "**********"  "**********"  "**********"  "**********"  "**********"  "**********"e "**********"l "**********"i "**********"f "**********"  "**********"t "**********"o "**********"k "**********"e "**********"n "**********". "**********"t "**********"e "**********"x "**********"t "**********". "**********"l "**********"o "**********"w "**********"e "**********"r "**********"( "**********") "**********"  "**********"i "**********"n "**********"  "**********"[ "**********"" "**********"o "**********"r "**********"" "**********", "**********"  "**********"" "**********"a "**********"n "**********"d "**********"" "**********"] "**********": "**********"
            if current_condition:
                conditions.append(" ".join(current_condition))
                current_condition = []
            conditions.append(token.text.lower())
 "**********"  "**********"  "**********"  "**********"  "**********"  "**********"  "**********"  "**********"  "**********"e "**********"l "**********"i "**********"f "**********"  "**********"t "**********"o "**********"k "**********"e "**********"n "**********". "**********"t "**********"e "**********"x "**********"t "**********". "**********"l "**********"o "**********"w "**********"e "**********"r "**********"( "**********") "**********"  "**********"= "**********"= "**********"  "**********"" "**********"n "**********"o "**********"t "**********"" "**********": "**********"
            current_condition.append("not")
    
    if current_condition:
        conditions.append(" ".join(current_condition))

    # Join conditions with appropriate logical operators
    query_string = " ".join(conditions)
    query_string = query_string.replace(" and ", " AND ").replace(" or ", " OR ").replace(" not ", " NOT ")

    return query_string

# Example usage
if __name__ == "__main__":
    query = "Show users with status VIP who joined after 2020-01-01"
    print(parse_nlp_query(query))