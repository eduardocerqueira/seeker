#date: 2025-11-18T17:08:53Z
#url: https://api.github.com/gists/922e3bbfac8a2f513f86317a5c54c305
#owner: https://api.github.com/users/danslaughter2

#!/usr/bin/env python3
"""
insert-doc.py - Manage numbered documentation files and directories

This script helps maintain a numbered sequence of documentation files and folders
by providing insert and remove operations that automatically handle renumbering.

FEATURES:
---------
1. Insert Operations (before/after):
   - Insert a new file or directory before or after a reference item
   - Automatically renumbers all subsequent items to make space
   - Creates files (items with extensions) or directories (items without)

2. Remove Operations:
   - Remove an existing file or directory
   - Automatically renumbers all subsequent items to close the gap

3. Git Integration:
   - Automatically detects if files/directories are tracked by git
   - Uses 'git mv' for tracked items (preserves git history)
   - Uses 'git rm -rf' for tracked items being removed
   - Uses regular 'mv'/'rm' for untracked items
   - New files are created with 'touch' but not automatically tracked

NAMING CONVENTION:
------------------
Items must follow the pattern: NN-name
  - NN: Numeric prefix with leading zeros (e.g., 01, 02, 10)
  - name: The actual name (can contain hyphens, underscores, etc.)

Examples:
  - 01-introduction.md
  - 02-getting-started.md
  - 03-advanced-topics (directory)

ALGORITHM:
----------
For insert operations:
  1. Parse the reference item to extract its number and width
  2. Calculate new number (same as reference for 'before', +1 for 'after')
  3. Renumber existing items in REVERSE order (prevents filename conflicts)
  4. Create the new item with the calculated number

For remove operations:
  1. Parse the reference item to extract its number
  2. Remove the item using git rm (if tracked) or regular rm
  3. Renumber subsequent items FORWARD (decrement each by 1)

USAGE EXAMPLES:
---------------
# Insert a new file before position 02
./insert-doc.py before 02-getting-started.md new-section.md
# Result: Creates 02-new-section.md, renames 02-getting-started.md → 03-getting-started.md

# Insert a new directory after position 03
./insert-doc.py after 03-basics advanced
# Result: Creates 04-advanced/, renames 04-... → 05-..., etc.

# Remove a file and renumber everything after it
./insert-doc.py remove 05-deprecated.md
# Result: Deletes 05-deprecated.md, renames 06-... → 05-..., 07-... → 06-..., etc.

AUTHOR: Generated by Claude Code
"""

import os
import re
import sys
import subprocess
from pathlib import Path


def usage():
    """Display usage information."""
    script_name = os.path.basename(sys.argv[0])
    print(f"Usage: {script_name} {{after|before|remove}} REFERENCE [NEW_NAME]")
    print("")
    print("Insert operations:")
    print(f"  {script_name} after 01-foo.md bar.md      # Creates 02-bar.md file")
    print(f"  {script_name} before 02-baz.md bar.md     # Creates 02-bar.md file")
    print(f"  {script_name} after 03-docs bar            # Creates 04-bar/ folder")
    print(f"  {script_name} before 02-section new-topic  # Creates 02-new-topic/ folder")
    print("")
    print("Remove operations:")
    print(f"  {script_name} remove 04-querying.md        # Removes file and renumbers subsequent items")
    print(f"  {script_name} remove 06-advanced-topics    # Removes directory and renumbers subsequent items")
    sys.exit(1)


def is_git_tracked(path):
    """
    Check if a file or directory is tracked by git.

    Uses 'git ls-files --error-unmatch' which returns 0 if the file is tracked
    and non-zero if it's not tracked or git is not available.

    Args:
        path (str): Path to the file or directory to check

    Returns:
        bool: True if the path is tracked by git, False otherwise

    Note:
        Returns False if git command is not found (not a git repository)
    """
    try:
        result = subprocess.run(
            ['git', 'ls-files', '--error-unmatch', path],
            cwd=os.getcwd(),
            capture_output=True,
            text=True
        )
        return result.returncode == 0
    except FileNotFoundError:
        # git command not found
        return False


def git_mv(old_path, new_path):
    """
    Move/rename a file or directory, using git mv if tracked.

    This function preserves git history by using 'git mv' for tracked files,
    while falling back to regular filesystem operations for untracked items.

    Args:
        old_path (str): Source path
        new_path (str): Destination path

    Raises:
        subprocess.CalledProcessError: If git mv fails
        OSError: If regular rename fails
    """
    if is_git_tracked(old_path):
        print(f"  git mv {old_path} -> {new_path}")
        subprocess.run(['git', 'mv', old_path, new_path], check=True)
    else:
        print(f"  mv {old_path} -> {new_path}")
        os.rename(old_path, new_path)


def git_rm(path):
    """
    Remove a file or directory, using git rm if tracked.

    Uses 'git rm -rf' to force removal even if the file has staged changes.
    This is necessary because renumbering operations may have staged the file.

    Args:
        path (str): Path to remove

    Raises:
        subprocess.CalledProcessError: If git rm fails
        OSError: If regular removal fails

    Note:
        The -f flag is required to handle files with staged changes from
        previous git mv operations in the same script execution.
    """
    if is_git_tracked(path):
        print(f"  git rm -rf {path}")
        subprocess.run(['git', 'rm', '-rf', path], check=True)
    else:
        print(f"  rm -r {path}")
        if os.path.isdir(path):
            import shutil
            shutil.rmtree(path)
        else:
            os.remove(path)


def extract_number_prefix(name):
    """
    Extract the numeric prefix from a filename or directory name.

    Parses names following the pattern 'NN-basename' where NN is a numeric
    prefix with optional leading zeros.

    Args:
        name (str): The filename or directory name to parse

    Returns:
        tuple or None: (prefix_str, prefix_num, basename) if pattern matches
            - prefix_str (str): The numeric prefix as a string (preserves leading zeros)
            - prefix_num (int): The numeric value of the prefix
            - basename (str): The rest of the name after the hyphen
        Returns None if the name doesn't match the pattern

    Examples:
        >>> extract_number_prefix('01-intro.md')
        ('01', 1, 'intro.md')
        >>> extract_number_prefix('10-advanced-topics')
        ('10', 10, 'advanced-topics')
        >>> extract_number_prefix('no-prefix.md')
        None
    """
    match = re.match(r'^(\d+)-(.+)$', name)
    if match:
        prefix_str = match.group(1)
        prefix_num = int(prefix_str)
        basename = match.group(2)
        return prefix_str, prefix_num, basename
    return None


def get_numbered_items():
    """
    Get all numbered files and directories in the current directory.

    Scans the current directory for items matching the numbered pattern,
    extracts their numeric prefixes, and returns them sorted by number.

    Returns:
        list[dict]: List of dictionaries, sorted by prefix_num, each containing:
            - name (str): Full name of the item (e.g., '01-intro.md')
            - prefix_str (str): String representation of the prefix ('01')
            - prefix_num (int): Numeric value of the prefix (1)
            - basename (str): Name without the numeric prefix ('intro.md')
            - is_dir (bool): True if item is a directory

    Note:
        Only items matching the pattern '^[0-9]+-' are included.
        Items are sorted numerically, not lexicographically.
    """
    items = []
    for item in os.listdir('.'):
        result = extract_number_prefix(item)
        if result:
            prefix_str, prefix_num, basename = result
            items.append({
                'name': item,
                'prefix_str': prefix_str,
                'prefix_num': prefix_num,
                'basename': basename,
                'is_dir': os.path.isdir(item)
            })

    # Sort by numeric prefix (not lexicographic)
    items.sort(key=lambda x: x['prefix_num'])
    return items


def format_number(num, width):
    """
    Format a number with leading zeros to match a specified width.

    Args:
        num (int): The number to format
        width (int): The desired width (number of digits)

    Returns:
        str: The formatted number with leading zeros

    Examples:
        >>> format_number(5, 2)
        '05'
        >>> format_number(10, 3)
        '010'
        >>> format_number(7, 1)
        '7'
    """
    return str(num).zfill(width)


def insert_item(position, reference, new_name):
    """
    Insert a new file or directory before or after a reference item.

    This function implements the insert operation by:
    1. Calculating where the new item should be inserted
    2. Renumbering existing items in REVERSE order to make space
    3. Creating the new item with the appropriate number

    Args:
        position (str): Either 'before' or 'after'
        reference (str): The reference item (e.g., '02-getting-started.md')
        new_name (str): The name for the new item (e.g., 'new-section.md')

    Example:
        Given files: 01-intro.md, 02-basics.md, 03-advanced.md
        insert_item('before', '02-basics.md', 'new.md')
        Result: 01-intro.md, 02-new.md, 03-basics.md, 04-advanced.md

    Algorithm:
        - 'before': new_num = reference_num (reference and later items shift up)
        - 'after': new_num = reference_num + 1 (items after reference shift up)
        - Renumbering is done in REVERSE order to avoid filename conflicts

    File vs Directory:
        - If new_name contains a dot (.), it's created as a file (using touch)
        - If new_name has no dot, it's created as a directory (using mkdir)

    Exits:
        Exits with status 1 if reference doesn't exist or lacks a number prefix
    """
    # Check if reference exists
    if not os.path.exists(reference):
        print(f"Error: Reference '{reference}' not found")
        sys.exit(1)

    # Extract number from reference
    result = extract_number_prefix(reference)
    if not result:
        print(f"Error: Reference '{reference}' doesn't have a number prefix (e.g., 01-)")
        sys.exit(1)

    ref_prefix_str, ref_prefix_num, _ = result
    num_width = len(ref_prefix_str)  # Preserve leading zero width

    # Calculate the new number for the inserted item
    if position == 'after':
        new_num = ref_prefix_num + 1
    else:  # before
        new_num = ref_prefix_num

    # Get all numbered items
    items = get_numbered_items()

    # Renumber items from the insertion point onwards
    # Process in REVERSE order to prevent filename conflicts
    # Example: To insert at 02, rename 03->04, then 02->03 (not 02->03 then 03->04!)
    print(f"Renumbering items from {new_num} onwards...")
    for item in reversed(items):
        if item['prefix_num'] >= new_num:
            old_num = item['prefix_num']
            next_num = old_num + 1
            formatted_num = format_number(next_num, num_width)
            new_item_name = f"{formatted_num}-{item['basename']}"

            print(f"Renaming: {item['name']} -> {new_item_name}")
            git_mv(item['name'], new_item_name)

    # Create the new item
    formatted_new_num = format_number(new_num, num_width)
    new_item_name = f"{formatted_new_num}-{new_name}"

    # Determine if it's a file or directory based on whether it has an extension
    basename_only = os.path.basename(new_name)
    if '.' in basename_only:
        # Has extension, create as file (not automatically tracked by git)
        print(f"Creating file: {new_item_name}")
        Path(new_item_name).touch()
    else:
        # No extension, create as directory
        print(f"Creating directory: {new_item_name}/")
        os.makedirs(new_item_name)

    print("Done!")


def remove_item(reference):
    """
    Remove a file or directory and renumber all subsequent items.

    This function implements the remove operation by:
    1. Removing the specified item (using git rm if tracked)
    2. Renumbering all subsequent items downward to close the gap

    Args:
        reference (str): The item to remove (e.g., '03-old-section.md')

    Example:
        Given files: 01-intro.md, 02-basics.md, 03-old.md, 04-advanced.md
        remove_item('03-old.md')
        Result: 01-intro.md, 02-basics.md, 03-advanced.md

    Algorithm:
        - Remove the specified item first (git rm -rf or regular rm)
        - Then process remaining items in FORWARD order
        - Each item with number > removed_num gets decremented by 1

    Note:
        Unlike insert_item which processes in reverse, remove_item processes
        in forward order because there are no filename conflicts when
        decrementing numbers (we just removed a number, creating a gap).

    Exits:
        Exits with status 1 if reference doesn't exist or lacks a number prefix
    """
    # Check if reference exists
    if not os.path.exists(reference):
        print(f"Error: Reference '{reference}' not found")
        sys.exit(1)

    # Extract number from reference
    result = extract_number_prefix(reference)
    if not result:
        print(f"Error: Reference '{reference}' doesn't have a number prefix (e.g., 01-)")
        sys.exit(1)

    ref_prefix_str, ref_prefix_num, _ = result
    num_width = len(ref_prefix_str)  # Preserve leading zero width

    # Remove the item first
    print(f"Removing: {reference}")
    git_rm(reference)

    # Get all numbered items (after removal, so this won't include deleted item)
    items = get_numbered_items()

    # Renumber items after the removed item
    # Process in FORWARD order (safe because we're decrementing and created a gap)
    print(f"Renumbering items after {ref_prefix_num}...")
    for item in items:
        if item['prefix_num'] > ref_prefix_num:
            old_num = item['prefix_num']
            prev_num = old_num - 1  # Decrement to close the gap
            formatted_num = format_number(prev_num, num_width)
            new_item_name = f"{formatted_num}-{item['basename']}"

            print(f"Renaming: {item['name']} -> {new_item_name}")
            git_mv(item['name'], new_item_name)

    print("Done!")


def main():
    """
    Main entry point for the script.

    Parses command-line arguments and dispatches to the appropriate operation:
    - 'after' or 'before': Calls insert_item() with 3 arguments
    - 'remove': Calls remove_item() with 2 arguments

    Command-line format:
        insert-doc.py {after|before|remove} REFERENCE [NEW_NAME]

    Exits:
        Calls usage() and exits if arguments are invalid
    """
    # Check arguments
    if len(sys.argv) < 3:
        usage()

    operation = sys.argv[1]
    reference = sys.argv[2]

    if operation in ['after', 'before']:
        if len(sys.argv) != 4:
            print(f"Error: '{operation}' operation requires 3 arguments")
            usage()
        new_name = sys.argv[3]
        insert_item(operation, reference, new_name)

    elif operation == 'remove':
        if len(sys.argv) != 3:
            print(f"Error: 'remove' operation requires 2 arguments")
            usage()
        remove_item(reference)

    else:
        print(f"Error: Operation must be 'after', 'before', or 'remove'")
        usage()


if __name__ == '__main__':
    main()


"""
MAINTENANCE NOTES AND EDGE CASES:
==================================

1. Leading Zeros:
   - The script preserves the width of numeric prefixes
   - If reference is '01-foo', all numbers will be 2 digits ('01', '02', etc.)
   - If reference is '001-foo', all numbers will be 3 digits ('001', '002', etc.)

2. Git Integration:
   - The script checks each file individually for git tracking status
   - Mixed tracked/untracked files in the same directory are handled correctly
   - The -f flag in 'git rm -rf' is required because previous 'git mv' operations
     in the same script run may have staged files that we're now trying to remove

3. Filename Conflict Avoidance:
   - Insert operations process in REVERSE order (high to low numbers)
     This prevents conflicts: 03->04, 02->03 works, but 02->03, 03->04 fails
   - Remove operations process in FORWARD order (low to high numbers)
     This is safe because we're decrementing into a gap we just created

4. File vs Directory Detection:
   - Simple heuristic: presence of '.' in basename
   - Limitation: Directories with dots (e.g., '03-version.2') will be created as files
   - Workaround: Manually create the directory first if it needs a dot in the name

5. Error Handling:
   - Script exits with status 1 on errors (reference not found, bad prefix, etc.)
   - Git command failures will raise CalledProcessError and crash the script
   - This is intentional: better to fail fast than continue with inconsistent state

6. Concurrent Execution:
   - NOT safe for concurrent execution in the same directory
   - Multiple simultaneous runs will cause filename conflicts and race conditions

7. Testing:
   - Always test in a git repository with both tracked and untracked test files
   - Verify that 'git status' shows correct renames and deletions after operations
   - Test edge cases: inserting at start/end, removing first/last item

8. Future Enhancements:
   - Add --dry-run flag to preview changes without executing
   - Add support for gaps in numbering (e.g., 01, 03, 05)
   - Add interactive mode to confirm operations
   - Add support for renaming (combination of insert + remove)
"""
