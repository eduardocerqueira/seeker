#date: 2024-04-22T16:53:01Z
#url: https://api.github.com/gists/dee24b307d772c0c7f2c5641812e1af3
#owner: https://api.github.com/users/rnetonet

"""
Grammar:
========
Expression --> AndTerm { OR AndTerm}+
AndTerm --> Condition { AND Condition}+
Condition --> Terminal (>,<,>=,<=,==) Terminal | (Expression)
Terminal --> Number or String or Variable

Usage:
======
from boolparser import *
p = BooleanParser('<expression text>')
p.evaluate(variable_dict) # variable_dict is a dictionary providing values for variables that appear in <expression text>
"""

 "**********"c "**********"l "**********"a "**********"s "**********"s "**********"  "**********"T "**********"o "**********"k "**********"e "**********"n "**********"T "**********"y "**********"p "**********"e "**********": "**********"
	NUM, STR, VAR, GT, GTE, LT, LTE, EQ, NEQ, LP, RP, AND, OR = range(13)

class TreeNode:
	tokenType = "**********"
	value = None
	left = None
	right = None

 "**********"	 "**********"d "**********"e "**********"f "**********"  "**********"_ "**********"_ "**********"i "**********"n "**********"i "**********"t "**********"_ "**********"_ "**********"( "**********"s "**********"e "**********"l "**********"f "**********", "**********"  "**********"t "**********"o "**********"k "**********"e "**********"n "**********"T "**********"y "**********"p "**********"e "**********") "**********": "**********"
		self.tokenType = "**********"

 "**********"c "**********"l "**********"a "**********"s "**********"s "**********"  "**********"T "**********"o "**********"k "**********"e "**********"n "**********"i "**********"z "**********"e "**********"r "**********": "**********"
	expression = None
	tokens = "**********"
	tokenTypes = "**********"
	i = 0

	def __init__(self, exp):
		self.expression = exp

	def next(self):
		self.i += 1
		return self.tokens[self.i-1]
	
	def peek(self):
		return self.tokens[self.i]
	
	def hasNext(self):
		return self.i < len(self.tokens)

 "**********"	 "**********"d "**********"e "**********"f "**********"  "**********"n "**********"e "**********"x "**********"t "**********"T "**********"o "**********"k "**********"e "**********"n "**********"T "**********"y "**********"p "**********"e "**********"( "**********"s "**********"e "**********"l "**********"f "**********") "**********": "**********"
		return self.tokenTypes[self.i]
	
 "**********"	 "**********"d "**********"e "**********"f "**********"  "**********"n "**********"e "**********"x "**********"t "**********"T "**********"o "**********"k "**********"e "**********"n "**********"T "**********"y "**********"p "**********"e "**********"I "**********"s "**********"O "**********"p "**********"e "**********"r "**********"a "**********"t "**********"o "**********"r "**********"( "**********"s "**********"e "**********"l "**********"f "**********") "**********": "**********"
		t = "**********"
 "**********"	 "**********"	 "**********"r "**********"e "**********"t "**********"u "**********"r "**********"n "**********"  "**********"t "**********"  "**********"= "**********"= "**********"  "**********"T "**********"o "**********"k "**********"e "**********"n "**********"T "**********"y "**********"p "**********"e "**********". "**********"G "**********"T "**********"  "**********"o "**********"r "**********"  "**********"t "**********"  "**********"= "**********"= "**********"  "**********"T "**********"o "**********"k "**********"e "**********"n "**********"T "**********"y "**********"p "**********"e "**********". "**********"G "**********"T "**********"E "**********"  "**********"\ "**********"
 "**********"	 "**********"	 "**********"	 "**********"o "**********"r "**********"  "**********"t "**********"  "**********"= "**********"= "**********"  "**********"T "**********"o "**********"k "**********"e "**********"n "**********"T "**********"y "**********"p "**********"e "**********". "**********"L "**********"T "**********"  "**********"o "**********"r "**********"  "**********"t "**********"  "**********"= "**********"= "**********"  "**********"T "**********"o "**********"k "**********"e "**********"n "**********"T "**********"y "**********"p "**********"e "**********". "**********"L "**********"T "**********"E "**********"  "**********"\ "**********"
 "**********"	 "**********"	 "**********"	 "**********"o "**********"r "**********"  "**********"t "**********"  "**********"= "**********"= "**********"  "**********"T "**********"o "**********"k "**********"e "**********"n "**********"T "**********"y "**********"p "**********"e "**********". "**********"E "**********"Q "**********"  "**********"o "**********"r "**********"  "**********"t "**********"  "**********"= "**********"= "**********"  "**********"T "**********"o "**********"k "**********"e "**********"n "**********"T "**********"y "**********"p "**********"e "**********". "**********"N "**********"E "**********"Q "**********"

 "**********"	 "**********"d "**********"e "**********"f "**********"  "**********"t "**********"o "**********"k "**********"e "**********"n "**********"i "**********"z "**********"e "**********"( "**********"s "**********"e "**********"l "**********"f "**********") "**********": "**********"
		import re
		reg = re.compile(r'(\bAND\b|\bOR\b|!=|==|<=|>=|<|>|\(|\))')
		self.tokens = "**********"
		self.tokens = "**********"= '']

		self.tokenTypes = "**********"
 "**********"	 "**********"	 "**********"f "**********"o "**********"r "**********"  "**********"t "**********"  "**********"i "**********"n "**********"  "**********"s "**********"e "**********"l "**********"f "**********". "**********"t "**********"o "**********"k "**********"e "**********"n "**********"s "**********": "**********"
			if t == 'AND':
				self.tokenTypes.append(TokenType.AND)
			elif t == 'OR':
				self.tokenTypes.append(TokenType.OR)
			elif t == '(':
				self.tokenTypes.append(TokenType.LP)
			elif t == ')':
				self.tokenTypes.append(TokenType.RP)
			elif t == '<':
				self.tokenTypes.append(TokenType.LT)
			elif t == '<=':
				self.tokenTypes.append(TokenType.LTE)
			elif t == '>':
				self.tokenTypes.append(TokenType.GT)
			elif t == '>=':
				self.tokenTypes.append(TokenType.GTE)
			elif t == '==':
				self.tokenTypes.append(TokenType.EQ)
			elif t == '!=':
				self.tokenTypes.append(TokenType.NEQ)
			else:
				# number of string or variable
				if t[0] == '"' and t[-1] == '"':
					self.tokenTypes.append(TokenType.STR)
				else:
					try:
						number = float(t)
						self.tokenTypes.append(TokenType.NUM)
					except:
						if re.search('^[a-zA-Z_]+$', t):
							self.tokenTypes.append(TokenType.VAR)
						else:
							self.tokenTypes.append(None)

class BooleanParser:
	tokenizer = "**********"
	root = None

	def __init__(self, exp):
		self.tokenizer = "**********"
		self.tokenizer.tokenize()
		self.parse()

	def parse(self):
		self.root = self.parseExpression()

	def parseExpression(self):
		andTerm1 = self.parseAndTerm()
 "**********"	 "**********"	 "**********"w "**********"h "**********"i "**********"l "**********"e "**********"  "**********"s "**********"e "**********"l "**********"f "**********". "**********"t "**********"o "**********"k "**********"e "**********"n "**********"i "**********"z "**********"e "**********"r "**********". "**********"h "**********"a "**********"s "**********"N "**********"e "**********"x "**********"t "**********"( "**********") "**********"  "**********"a "**********"n "**********"d "**********"  "**********"s "**********"e "**********"l "**********"f "**********". "**********"t "**********"o "**********"k "**********"e "**********"n "**********"i "**********"z "**********"e "**********"r "**********". "**********"n "**********"e "**********"x "**********"t "**********"T "**********"o "**********"k "**********"e "**********"n "**********"T "**********"y "**********"p "**********"e "**********"( "**********") "**********"  "**********"= "**********"= "**********"  "**********"T "**********"o "**********"k "**********"e "**********"n "**********"T "**********"y "**********"p "**********"e "**********". "**********"O "**********"R "**********": "**********"
			self.tokenizer.next()
			andTermX = self.parseAndTerm()
			andTerm = "**********"
			andTerm.left = andTerm1
			andTerm.right = andTermX
			andTerm1 = andTerm
		return andTerm1

	def parseAndTerm(self):
		condition1 = self.parseCondition()
 "**********"	 "**********"	 "**********"w "**********"h "**********"i "**********"l "**********"e "**********"  "**********"s "**********"e "**********"l "**********"f "**********". "**********"t "**********"o "**********"k "**********"e "**********"n "**********"i "**********"z "**********"e "**********"r "**********". "**********"h "**********"a "**********"s "**********"N "**********"e "**********"x "**********"t "**********"( "**********") "**********"  "**********"a "**********"n "**********"d "**********"  "**********"s "**********"e "**********"l "**********"f "**********". "**********"t "**********"o "**********"k "**********"e "**********"n "**********"i "**********"z "**********"e "**********"r "**********". "**********"n "**********"e "**********"x "**********"t "**********"T "**********"o "**********"k "**********"e "**********"n "**********"T "**********"y "**********"p "**********"e "**********"( "**********") "**********"  "**********"= "**********"= "**********"  "**********"T "**********"o "**********"k "**********"e "**********"n "**********"T "**********"y "**********"p "**********"e "**********". "**********"A "**********"N "**********"D "**********": "**********"
			self.tokenizer.next()
			conditionX = self.parseCondition()
			condition = "**********"
			condition.left = condition1
			condition.right = conditionX
			condition1 = condition
		return condition1

	def parseCondition(self):
 "**********"	 "**********"	 "**********"i "**********"f "**********"  "**********"s "**********"e "**********"l "**********"f "**********". "**********"t "**********"o "**********"k "**********"e "**********"n "**********"i "**********"z "**********"e "**********"r "**********". "**********"h "**********"a "**********"s "**********"N "**********"e "**********"x "**********"t "**********"( "**********") "**********"  "**********"a "**********"n "**********"d "**********"  "**********"s "**********"e "**********"l "**********"f "**********". "**********"t "**********"o "**********"k "**********"e "**********"n "**********"i "**********"z "**********"e "**********"r "**********". "**********"n "**********"e "**********"x "**********"t "**********"T "**********"o "**********"k "**********"e "**********"n "**********"T "**********"y "**********"p "**********"e "**********"( "**********") "**********"  "**********"= "**********"= "**********"  "**********"T "**********"o "**********"k "**********"e "**********"n "**********"T "**********"y "**********"p "**********"e "**********". "**********"L "**********"P "**********": "**********"
			self.tokenizer.next()
			expression = self.parseExpression()
 "**********"	 "**********"	 "**********"	 "**********"i "**********"f "**********"  "**********"s "**********"e "**********"l "**********"f "**********". "**********"t "**********"o "**********"k "**********"e "**********"n "**********"i "**********"z "**********"e "**********"r "**********". "**********"h "**********"a "**********"s "**********"N "**********"e "**********"x "**********"t "**********"( "**********") "**********"  "**********"a "**********"n "**********"d "**********"  "**********"s "**********"e "**********"l "**********"f "**********". "**********"t "**********"o "**********"k "**********"e "**********"n "**********"i "**********"z "**********"e "**********"r "**********". "**********"n "**********"e "**********"x "**********"t "**********"T "**********"o "**********"k "**********"e "**********"n "**********"T "**********"y "**********"p "**********"e "**********"( "**********") "**********"  "**********"= "**********"= "**********"  "**********"T "**********"o "**********"k "**********"e "**********"n "**********"T "**********"y "**********"p "**********"e "**********". "**********"R "**********"P "**********": "**********"
				self.tokenizer.next()
				return expression
			else:
				raise Exception("Closing ) expected, but got " + self.tokenizer.next())

		terminal1 = self.parseTerminal()
 "**********"	 "**********"	 "**********"i "**********"f "**********"  "**********"s "**********"e "**********"l "**********"f "**********". "**********"t "**********"o "**********"k "**********"e "**********"n "**********"i "**********"z "**********"e "**********"r "**********". "**********"h "**********"a "**********"s "**********"N "**********"e "**********"x "**********"t "**********"( "**********") "**********"  "**********"a "**********"n "**********"d "**********"  "**********"s "**********"e "**********"l "**********"f "**********". "**********"t "**********"o "**********"k "**********"e "**********"n "**********"i "**********"z "**********"e "**********"r "**********". "**********"n "**********"e "**********"x "**********"t "**********"T "**********"o "**********"k "**********"e "**********"n "**********"T "**********"y "**********"p "**********"e "**********"I "**********"s "**********"O "**********"p "**********"e "**********"r "**********"a "**********"t "**********"o "**********"r "**********"( "**********") "**********": "**********"
			condition = "**********"
			self.tokenizer.next()
			terminal2 = self.parseTerminal()
			condition.left = terminal1
			condition.right = terminal2
			return condition
		else:
			raise Exception('Operator expected, but got ' + self.tokenizer.next())
	
	def parseTerminal(self):
 "**********"	 "**********"	 "**********"i "**********"f "**********"  "**********"s "**********"e "**********"l "**********"f "**********". "**********"t "**********"o "**********"k "**********"e "**********"n "**********"i "**********"z "**********"e "**********"r "**********". "**********"h "**********"a "**********"s "**********"N "**********"e "**********"x "**********"t "**********"( "**********") "**********": "**********"
			tokenType = "**********"
 "**********"	 "**********"	 "**********"	 "**********"i "**********"f "**********"  "**********"t "**********"o "**********"k "**********"e "**********"n "**********"T "**********"y "**********"p "**********"e "**********"  "**********"= "**********"= "**********"  "**********"T "**********"o "**********"k "**********"e "**********"n "**********"T "**********"y "**********"p "**********"e "**********". "**********"N "**********"U "**********"M "**********": "**********"
				n = "**********"
				n.value = "**********"
				return n
 "**********"	 "**********"	 "**********"	 "**********"e "**********"l "**********"i "**********"f "**********"  "**********"t "**********"o "**********"k "**********"e "**********"n "**********"T "**********"y "**********"p "**********"e "**********"  "**********"= "**********"= "**********"  "**********"T "**********"o "**********"k "**********"e "**********"n "**********"T "**********"y "**********"p "**********"e "**********". "**********"S "**********"T "**********"R "**********"  "**********"o "**********"r "**********"  "**********"t "**********"o "**********"k "**********"e "**********"n "**********"T "**********"y "**********"p "**********"e "**********"  "**********"= "**********"= "**********"  "**********"T "**********"o "**********"k "**********"e "**********"n "**********"T "**********"y "**********"p "**********"e "**********". "**********"V "**********"A "**********"R "**********": "**********"
				n = "**********"
				n.value = "**********"
				return n
			else:
				raise Exception('NUM, STR, or VAR expected, but got ' + self.tokenizer.next())
		
		else:
			raise Exception('NUM, STR, or VAR expected, but got ' + self.tokenizer.next())
	
	def evaluate(self, variable_dict):
		return self.evaluateRecursive(self.root, variable_dict)
	
	def evaluateRecursive(self, treeNode, variable_dict):
 "**********"	 "**********"	 "**********"i "**********"f "**********"  "**********"t "**********"r "**********"e "**********"e "**********"N "**********"o "**********"d "**********"e "**********". "**********"t "**********"o "**********"k "**********"e "**********"n "**********"T "**********"y "**********"p "**********"e "**********"  "**********"= "**********"= "**********"  "**********"T "**********"o "**********"k "**********"e "**********"n "**********"T "**********"y "**********"p "**********"e "**********". "**********"N "**********"U "**********"M "**********"  "**********"o "**********"r "**********"  "**********"t "**********"r "**********"e "**********"e "**********"N "**********"o "**********"d "**********"e "**********". "**********"t "**********"o "**********"k "**********"e "**********"n "**********"T "**********"y "**********"p "**********"e "**********"  "**********"= "**********"= "**********"  "**********"T "**********"o "**********"k "**********"e "**********"n "**********"T "**********"y "**********"p "**********"e "**********". "**********"S "**********"T "**********"R "**********": "**********"
			return treeNode.value
 "**********"	 "**********"	 "**********"i "**********"f "**********"  "**********"t "**********"r "**********"e "**********"e "**********"N "**********"o "**********"d "**********"e "**********". "**********"t "**********"o "**********"k "**********"e "**********"n "**********"T "**********"y "**********"p "**********"e "**********"  "**********"= "**********"= "**********"  "**********"T "**********"o "**********"k "**********"e "**********"n "**********"T "**********"y "**********"p "**********"e "**********". "**********"V "**********"A "**********"R "**********": "**********"
			return variable_dict.get(treeNode.value)
		
		left = self.evaluateRecursive(treeNode.left, variable_dict)
		right = self.evaluateRecursive(treeNode.right, variable_dict)
 "**********"	 "**********"	 "**********"i "**********"f "**********"  "**********"t "**********"r "**********"e "**********"e "**********"N "**********"o "**********"d "**********"e "**********". "**********"t "**********"o "**********"k "**********"e "**********"n "**********"T "**********"y "**********"p "**********"e "**********"  "**********"= "**********"= "**********"  "**********"T "**********"o "**********"k "**********"e "**********"n "**********"T "**********"y "**********"p "**********"e "**********". "**********"G "**********"T "**********": "**********"
			return left > right
 "**********"	 "**********"	 "**********"e "**********"l "**********"i "**********"f "**********"  "**********"t "**********"r "**********"e "**********"e "**********"N "**********"o "**********"d "**********"e "**********". "**********"t "**********"o "**********"k "**********"e "**********"n "**********"T "**********"y "**********"p "**********"e "**********"  "**********"= "**********"= "**********"  "**********"T "**********"o "**********"k "**********"e "**********"n "**********"T "**********"y "**********"p "**********"e "**********". "**********"G "**********"T "**********"E "**********": "**********"
			return left >= right
 "**********"	 "**********"	 "**********"e "**********"l "**********"i "**********"f "**********"  "**********"t "**********"r "**********"e "**********"e "**********"N "**********"o "**********"d "**********"e "**********". "**********"t "**********"o "**********"k "**********"e "**********"n "**********"T "**********"y "**********"p "**********"e "**********"  "**********"= "**********"= "**********"  "**********"T "**********"o "**********"k "**********"e "**********"n "**********"T "**********"y "**********"p "**********"e "**********". "**********"L "**********"T "**********": "**********"
			return left < right
 "**********"	 "**********"	 "**********"e "**********"l "**********"i "**********"f "**********"  "**********"t "**********"r "**********"e "**********"e "**********"N "**********"o "**********"d "**********"e "**********". "**********"t "**********"o "**********"k "**********"e "**********"n "**********"T "**********"y "**********"p "**********"e "**********"  "**********"= "**********"= "**********"  "**********"T "**********"o "**********"k "**********"e "**********"n "**********"T "**********"y "**********"p "**********"e "**********". "**********"L "**********"T "**********"E "**********": "**********"
			return left <= right
 "**********"	 "**********"	 "**********"e "**********"l "**********"i "**********"f "**********"  "**********"t "**********"r "**********"e "**********"e "**********"N "**********"o "**********"d "**********"e "**********". "**********"t "**********"o "**********"k "**********"e "**********"n "**********"T "**********"y "**********"p "**********"e "**********"  "**********"= "**********"= "**********"  "**********"T "**********"o "**********"k "**********"e "**********"n "**********"T "**********"y "**********"p "**********"e "**********". "**********"E "**********"Q "**********": "**********"
			return left == right
 "**********"	 "**********"	 "**********"e "**********"l "**********"i "**********"f "**********"  "**********"t "**********"r "**********"e "**********"e "**********"N "**********"o "**********"d "**********"e "**********". "**********"t "**********"o "**********"k "**********"e "**********"n "**********"T "**********"y "**********"p "**********"e "**********"  "**********"= "**********"= "**********"  "**********"T "**********"o "**********"k "**********"e "**********"n "**********"T "**********"y "**********"p "**********"e "**********". "**********"N "**********"E "**********"Q "**********": "**********"
			return left != right
 "**********"	 "**********"	 "**********"e "**********"l "**********"i "**********"f "**********"  "**********"t "**********"r "**********"e "**********"e "**********"N "**********"o "**********"d "**********"e "**********". "**********"t "**********"o "**********"k "**********"e "**********"n "**********"T "**********"y "**********"p "**********"e "**********"  "**********"= "**********"= "**********"  "**********"T "**********"o "**********"k "**********"e "**********"n "**********"T "**********"y "**********"p "**********"e "**********". "**********"A "**********"N "**********"D "**********": "**********"
			return left and right
 "**********"	 "**********"	 "**********"e "**********"l "**********"i "**********"f "**********"  "**********"t "**********"r "**********"e "**********"e "**********"N "**********"o "**********"d "**********"e "**********". "**********"t "**********"o "**********"k "**********"e "**********"n "**********"T "**********"y "**********"p "**********"e "**********"  "**********"= "**********"= "**********"  "**********"T "**********"o "**********"k "**********"e "**********"n "**********"T "**********"y "**********"p "**********"e "**********". "**********"O "**********"R "**********": "**********"
			return left or right
		else:
			raise Exception('Unexpected type ' + str(treeNode.tokenType))

		