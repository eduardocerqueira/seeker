#date: 2025-02-18T16:42:58Z
#url: https://api.github.com/gists/fe6d337da0ef7c7a4e9d3de7f0b2be33
#owner: https://api.github.com/users/WillemJan

#!/usr/bin/env python3

import os
import sys
import errno
import stat
import time
import urllib.parse
import datetime
import multiprocessing as mp
from concurrent.futures import ProcessPoolExecutor, as_completed
from collections import defaultdict
from functools import partial
from itertools import chain
from fusepy import FUSE, Operations, LoggingMixIn
from warcio.archiveiterator import ArchiveIterator
import logging

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

def process_warc_file(warc_file):
    """Process a single WARC file and return its contents and metadata."""
    try:
        files = {}
        file_attrs = {}
        warc_metadata = {
            'warc_info': {
                'filename': os.path.basename(warc_file),
                'size': os.path.getsize(warc_file),
                'date': '',
                'software': '',
                'format': '',
                'conformsTo': '',
                'robots': ''
            },
            'stats': {
                'start_time': None,
                'end_time': None,
                'file_types': defaultdict(int),
                'total_size': 0,
                'total_files': 0,
                'urls': set(),
                'domains': set(),
                'mime_types': defaultdict(int)
            }
        }

        with open(warc_file, 'rb') as stream:
            # First pass: collect WARC-Info
            archive = ArchiveIterator(stream)
            for record in archive:
                if record.rec_type == 'warcinfo':
                    warc_info = record.content_stream().read().decode('utf-8', errors='ignore')
                    for line in warc_info.splitlines():
                        if ':' in line:
                            key, value = line.split(':', 1)
                            key = key.strip().lower()
                            if key in ['software', 'format', 'conformsto', 'robots']:
                                warc_metadata['warc_info'][key] = value.strip()
                    break

            # Reset and process response records
            stream.seek(0)
            archive = ArchiveIterator(stream)
            for record in archive:
                if record.rec_headers.get_header("WARC-Type") != "response":
                    continue
                
                target_uri = record.rec_headers.get_header("WARC-Target-URI")
                if not target_uri:
                    continue

                warc_date = record.rec_headers.get_header("WARC-Date")
                content_type = record.rec_headers.get_header('Content-Type', '')
                
                # Update statistics
                stats = warc_metadata['stats']
                if warc_date:
                    if not stats['start_time'] or warc_date < stats['start_time']:
                        stats['start_time'] = warc_date
                    if not stats['end_time'] or warc_date > stats['end_time']:
                        stats['end_time'] = warc_date

                parsed_url = urllib.parse.urlparse(target_uri)
                domain = parsed_url.netloc
                stats['urls'].add(target_uri)
                stats['domains'].add(domain)
                stats['mime_types'][content_type] += 1

                # Process content
                content = record.content_stream().read()
                path = parsed_url.path
                if not path or path.endswith('/'):
                    path = path + "index.html"
                if path.startswith('/'):
                    path = path[1:]

                file_path = path
                stats['total_size'] += len(content)
                stats['total_files'] += 1

                _, ext = os.path.splitext(file_path)
                ext = ext.lower() if ext else 'no_extension'
                stats['file_types'][ext] += 1

                files[file_path] = content
                now = time.time()
                file_attrs[file_path] = {
                    'st_mode': stat.S_IFREG | 0o444,
                    'st_nlink': 1,
                    'st_size': len(content),
                    'st_blocks': (len(content) + 511) // 512,
                    'st_blksize': 512,
                    'st_ctime': now,
                    'st_mtime': now,
                    'st_atime': now,
                }

        return {
            'files': files,
            'file_attrs': file_attrs,
            'metadata': warc_metadata,
            'warc_file': warc_file
        }
    except Exception as e:
        logger.error(f"Error processing WARC file {warc_file}: {str(e)}")
        return None

class WarcFuseFS(LoggingMixIn, Operations):
    def __init__(self, warc_dir):
        self.files = {}
        self.file_attrs = {}
        self.directories = {}
        self.warc_metadata = {}
        
        # Initialize process pool
        self.num_cores = mp.cpu_count()
        logger.info(f"Initializing with {self.num_cores} cores")
        
        self.process_warc_files(warc_dir)
        self.create_manifest_files()
        self.build_directory_tree()

    def format_dir_name(self, warc_file, timestamp, domain):
        """Create a human-readable directory name."""
        warc_name = os.path.basename(warc_file).split('.')[0]
        try:
            date_obj = datetime.datetime.strptime(timestamp, "%Y%m%d%H%M%S")
            date_str = date_obj.strftime("%Y_%b_%d").lower()
        except:
            date_str = "unknown_date"
        return f"{warc_name}_{date_str}_{domain}"

    def process_warc_files(self, warc_dir):
        """Process all WARC files in parallel."""
        warc_files = sorted(
            os.path.join(warc_dir, f)
            for f in os.listdir(warc_dir)
            if f.endswith('.warc') or f.endswith('.warc.gz')
        )

        logger.info(f"Found {len(warc_files)} WARC files to process")
        
        # Process WARC files in parallel
        with ProcessPoolExecutor(max_workers=self.num_cores) as executor:
            futures = [executor.submit(process_warc_file, warc_file) 
                      for warc_file in warc_files]
            
            for future in as_completed(futures):
                result = future.result()
                if result is None:
                    continue
                
                # Extract domain and timestamp from metadata
                metadata = result['metadata']
                warc_date = metadata['stats']['start_time']
                for domain in metadata['stats']['domains']:
                    timestamp = "unknown_date"
                    if warc_date:
                        try:
                            dt = datetime.datetime.fromisoformat(warc_date.replace("Z", ""))
                            timestamp = dt.strftime("%Y%m%d%H%M%S")
                        except:
                            pass
                    
                    dir_name = self.format_dir_name(result['warc_file'], timestamp, domain)
                    
                    # Update files and attributes with proper paths
                    for file_path, content in result['files'].items():
                        full_path = f"/{dir_name}/{file_path}"
                        self.files[full_path] = content
                        self.file_attrs[full_path] = result['file_attrs'][file_path]
                    
                    self.warc_metadata[dir_name] = metadata

        logger.info("Finished processing WARC files")

    def create_manifest_files(self):
        """Creates high-level manifest files for each WARC snapshot."""
        for dir_name, metadata in self.warc_metadata.items():
            manifest_content = self.generate_manifest_content(dir_name, metadata)
            manifest_path = f"/{dir_name}.txt"
            self.files[manifest_path] = manifest_content.encode('utf-8')
            
            now = time.time()
            self.file_attrs[manifest_path] = {
                'st_mode': stat.S_IFREG | 0o444,
                'st_nlink': 1,
                'st_size': len(manifest_content),
                'st_blocks': (len(manifest_content) + 511) // 512,
                'st_blksize': 512,
                'st_ctime': now,
                'st_mtime': now,
                'st_atime': now,
            }

    def generate_manifest_content(self, dir_name, metadata):
        """Generate the content for a manifest file."""
        return f"""WARC Snapshot Manifest: {dir_name}
{'=' * 80}

WARC Information:
{'-' * 20}
Filename: {metadata['warc_info']['filename']}
Size: {self.format_size(metadata['warc_info']['size'])}
Date: {metadata['warc_info']['date']}
Software: {metadata['warc_info']['software']}
Format: {metadata['warc_info']['format']}
Conforms To: {metadata['warc_info']['conformsTo']}
Robots Policy: {metadata['warc_info']['robots']}

Harvest Statistics:
{'-' * 20}
Start Time: {metadata['stats']['start_time']}
End Time: {metadata['stats']['end_time']}
Duration: {self.calculate_duration(metadata['stats']['start_time'], metadata['stats']['end_time'])}
Total Files: {metadata['stats']['total_files']:,}
Total Size: {self.format_size(metadata['stats']['total_size'])}
Unique URLs: {len(metadata['stats']['urls']):,}
Unique Domains: {len(metadata['stats']['domains']):,}

File Types:
{'-' * 20}
{self.format_dict(metadata['stats']['file_types'])}

MIME Types:
{'-' * 20}
{self.format_dict(metadata['stats']['mime_types'])}
"""

    def format_dict(self, d):
        """Format a dictionary for display in the manifest."""
        return '\n'.join(f"{k[1:] if isinstance(k, str) and k.startswith('.') else k or 'unspecified'}: {v:,}"
                        for k, v in sorted(d.items()))

    def calculate_duration(self, start_time, end_time):
        """Calculate the duration between two ISO format timestamps."""
        if not (start_time and end_time):
            return "Unknown"
        try:
            start = datetime.datetime.fromisoformat(start_time.replace("Z", ""))
            end = datetime.datetime.fromisoformat(end_time.replace("Z", ""))
            return str(end - start)
        except:
            return "Unknown"

    def format_size(self, size_bytes):
        """Format bytes into human readable format."""
        for unit in ['B', 'KB', 'MB', 'GB', 'TB']:
            if size_bytes < 1024:
                return f"{size_bytes:.2f} {unit}"
            size_bytes /= 1024
        return f"{size_bytes:.2f} PB"

    def build_directory_tree(self):
        """Constructs a virtual directory structure from file paths."""
        self.directories['/'] = set()
        for file_path in self.files:
            parts = file_path.strip('/').split('/')
            current_path = '/'
            for part in parts[:-1]:
                if current_path not in self.directories:
                    self.directories[current_path] = set()
                self.directories[current_path].add(part)
                current_path = os.path.join(current_path, part)
                if not current_path.startswith('/'):
                    current_path = '/' + current_path
                if current_path not in self.directories:
                    self.directories[current_path] = set()
            parent = '/' + '/'.join(parts[:-1]) if parts[:-1] else '/'
            if parent not in self.directories:
                self.directories[parent] = set()
            self.directories[parent].add(parts[-1])

    def getattr(self, path, fh=None):
        """Get file attributes."""
        now = time.time()
        if path == '/':
            return {'st_mode': stat.S_IFDIR | 0o755, 'st_nlink': 2, 'st_size': 4096,
                    'st_blocks': 8, 'st_blksize': 4096, 'st_ctime': now, 'st_mtime': now, 'st_atime': now}
        if path in self.directories:
            return {'st_mode': stat.S_IFDIR | 0o755, 'st_nlink': 2, 'st_size': 4096,
                    'st_blocks': 8, 'st_blksize': 4096, 'st_ctime': now, 'st_mtime': now, 'st_atime': now}
        elif path in self.files:
            return self.file_attrs[path]
        else:
            raise OSError(errno.ENOENT, os.strerror(errno.ENOENT), path)

    def readdir(self, path, fh):
        """Read directory contents."""
        entries = ['.', '..']
        if path in self.directories:
            entries.extend(sorted(self.directories[path]))
        return entries

    def open(self, path, flags):
        """Open a file."""
        if path in self.files:
            return 0
        else:
            raise OSError(errno.ENOENT, os.strerror(errno.ENOENT), path)

    def read(self, path, size, offset, fh):
        """Read file contents."""
        if path in self.files:
            content = self.files[path]
            return content[offset:offset + size]
        else:
            raise OSError(errno.ENOENT, os.strerror(errno.ENOENT), path)

    def statfs(self, path):
        """Get filesystem statistics."""
        return {
            'f_bsize': 4096,
            'f_frsize': 4096,
            'f_blocks': 1024 * 1024,
            'f_bfree': 1024 * 512,
            'f_bavail': 1024 * 512,
            'f_files': len(self.files) + len(self.directories),
            'f_ffree': 1024 * 1024,
            'f_favail': 1024 * 1024,
        }

# Entry point
def main(mountpoint, warc_directory):
    fs = WarcFuseFS(warc_directory)
    FUSE(fs, mountpoint, nothreads=True, foreground=True)

if __name__ == '__main__':
    if len(sys.argv) != 3:
        print("Usage: python3 warc_fs.py <mountpoint> <warc_directory>")
        sys.exit(1)

    mountpoint = sys.argv[1]
    warc_directory = sys.argv[2]
    main(mountpoint, warc_directory)
