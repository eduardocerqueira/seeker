#date: 2025-09-30T17:08:52Z
#url: https://api.github.com/gists/b173ba3de9bba6f4d87938b2cafdd50e
#owner: https://api.github.com/users/DPAZ77

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Editor PNG interativo para adicionar data/hora sobre imagens.
- Roda no Termux / Linux com navegador e Python compartilhando localhost.
- Salva imagens em PNG lossless com overlay de data/hora.
- Permite rotacionar, escolher formato de data e pular imagens.
- Move originais para subpasta _originais/
"""

import os, re, json, base64, threading, urllib.parse, shutil, subprocess
from http.server import HTTPServer, BaseHTTPRequestHandler
from socketserver import ThreadingMixIn
from io import BytesIO
from PIL import Image, ImageFont, ImageDraw
import webbrowser, argparse, datetime, time

# -------- Configurações --------
HOST = "127.0.0.1"
PORT = 8000
EXTENSOES_PERMITIDAS = ('.jpg','.jpeg','.png','.bmp','.webp')
DEFAULT_OUTPUT_SUFFIX = "_com_data"
FONTS_DIR = "/storage/emulated/0/Biblioteca/02_Vídeos/05_Inshot/02_temporario_inshot/01_imagens_para_editar/00_Python/fontes"

STATE = {
    "images": [,
    "index": 0,
    "input_dir": None,
    "output_dir": None,
    "lock": threading.Lock(),
    "config": {
        "font_mode": "dynamic",
        "fixed_font_size": 8,
        "date_format": 0,
        "margin_lines": 0,
        "selected_font": None,
        "batch_mode": False,'.webp')
DEFAULT_OUTPUT_SUFFIX = "_com_data"
FONTS_DIR = "/storage/emulated/0/Biblioteca/02_Vídeos/05_Inshot/02_temporario_inshot/01_imagens_para_editar/00_Python/fontes"

STATE = {
    "images": [,"selected_images": [,
        "batch_rotation": {}
    }
}

# ---------- Utilitários ----------
def find_images(root):
    imgs=[]
    for root_dir, _, files in os.walk(root):
        for f in sorted(files):
            if f.lower().endswith(EXTENSOES_PERMITIDAS):
                full=os.path.join(root_dir,f)
                rel=os.path.relpath(root_dir,root)
                imgs.append((full,rel,f))
    return imgs

def extrair_datetime_de_nome(nome):
    s=os.path.splitext(nome)[0]
    m=re.search(r'(20\d{2})(\d{2})(\d{2})[_\-]?(\d{2})(\d{2})(\d{2})',s)
    if m:
        y,mo,d,hh,mm,ss=m.groups()
        try: return datetime.datetime(int(y),int(mo),int(d),int(hh),int(mm),int(ss))
        except: pass
    m=re.search(r'(20\d{2})(\d{2})(\d{2})',s)
    if m:
        y,mo,d=m.groups()
        try: return datetime.datetime(int(y),int(mo),int(d))
        except: pass
    m=re.search(r'(20\d{2})[-/](\d{2})[-/](\d{2})[_\sT\-:]{1,}(\d{2})[-:](\d{2})[-:](\d{2})',s)
    if m:
        y,mo,d,hh,mm,ss=m.groups()
        try: return datetime.datetime(int(y),int(mo),int(d),int(hh),int(mm),int(ss))
        except: pass
    return None

def salvar_imagem_png_lossless(pil_image,destino_path):
    pil_image.save(destino_path,format="PNG",compress_level=0)

def abrir_navegador(url):
    """Abre URL no Brave ou Chrome automaticamente"""
    try:
        subprocess.run(['am', 'start', '-a', 'android.intent.action.VIEW', '-d', url, '-n','.webp')
DEFAULT_OUTPUT_SUFFIX = "_com_data"
FONTS_DIR = "/storage/emulated/0/Biblioteca/02_Vídeos/05_Inshot/02_temporario_inshot/01_imagens_para_editar/00_Python/fontes"

STATE = {
    "images": [,"selected_images": [,'com.brave.browser/com.google.android.apps.chrome.Main', 
                      check=False, capture_output=True, timeout=3)
        return
    except:
        pass
    
    try:
        subprocess.run(['am', 'start', '-a', 'android.intent.action.VIEW', '-d', url, '-n','.webp')
DEFAULT_OUTPUT_SUFFIX = "_com_data"
FONTS_DIR = "/storage/emulated/0/Biblioteca/02_Vídeos/05_Inshot/02_temporario_inshot/01_imagens_para_editar/00_Python/fontes"

STATE = {
    "images": [,"selected_images": [,'com.brave.browser/com.google.android.apps.chrome.Main','com.android.chrome/com.google.android.apps.chrome.Main', 
                      check=False, capture_output=True, timeout=3)
        return
    except:
        pass
    
    try:
        webbrowser.open(url)
    except:
        print(f"Abra manualmente: {url}")

def get_available_fonts():
    """Retorna lista de fontes disponíveis na pasta"""
    if not os.path.exists(FONTS_DIR):
        return []
    fonts = []
    for f in os.listdir(FONTS_DIR):
        if f.lower().endswith(('.ttf', '.otf')):
            fonts.append(f)
    return sorted(fonts)

def format_datetime(dt, format_index):
    """Formata datetime conforme o índice escolhido"""
    if not dt:
        return ""
    
    dias_semana = ['segunda-feira', 'terça-feira', 'quarta-feira', 'quinta-feira', 'sexta-feira', 'sábado', 'domingo']
    dias_semana_abrev = ['seg.', 'ter.', 'qua.', 'qui.', 'sex.', 'sáb.', 'dom.']
    meses = ['janeiro', 'fevereiro', 'março', 'abril', 'maio', 'junho', 'julho', 'agosto', 'setembro', 'outubro', 'novembro', 'dezembro']
    meses_abrev = ['jan.', 'fev.', 'mar.', 'abr.', 'mai.', 'jun.', 'jul.', 'ago.', 'set.', 'out.', 'nov.', 'dez.']
    
    dia_semana = dias_semana[dt.weekday()]
    dia_semana_abrev = dias_semana_abrev[dt.weekday()]
    mes = meses[dt.month - 1]
    mes_abrev = meses_abrev[dt.month - 1]
    
    formats = [
        f"{dia_semana}, {dt.day} de {mes} de {dt.year}",
        f"{dt.day} de {mes_abrev} de {dt.year}",
        f"{dt.day:02d}/{dt.month:02d}/{dt.year}",
        f"{dt.day:02d}/{dt.month:02d}/{dt.year} {dt.hour:02d}:{dt.minute:02d}:{dt.second:02d}",
        f"{dt.day:02d}/{dt.month:02d}/{dt.year} {dt.hour:02d}:{dt.minute:02d}",
        f"{dia_semana}, {dt.day} {mes} {dt.year}, {dt.hour:02d}:{dt.minute:02d}",
        f"{dia_semana_abrev}, {dt.day} {mes_abrev} {dt.year} {dt.hour:02d}:{dt.minute:02d}:{dt.second:02d}",
        f"{dia_semana_abrev}, {dt.day} {mes_abrev} {dt.year} {dt.hour:02d}:{dt.minute:02d}"
    ]
    
    return formats[format_index] if 0 <= format_index < len(formats) else formats[0]

def reload_images():
    """Recarrega todas as imagens da pasta"""
    with STATE['lock']:
        input_dir = STATE['input_dir']
        if not input_dir:
            return False
        
        imgs_raw = find_images(input_dir)
        STATE['images'] = []
        for full, rel, fname in imgs_raw:
            dt = extrair_datetime_de_nome(fname)
            STATE['images'].append({
                "path": full,
                "relpath": rel,
                "filename": fname,
                "datetime": dt
            })
        STATE['index'] = 0
        return True

# ---------- HTTP Server ----------
HTML_PAGE=None

class ThreadedHTTPServer(ThreadingMixIn,HTTPServer):
    daemon_threads=True

class Handler(BaseHTTPRequestHandler):
    def log_message(self, format, *args):
        pass
    
    def _set_json(self):
        self.send_response(200)
        self.send_header('Content-type','application/json')
        self.send_header('Access-Control-Allow-Origin','*')
        self.end_headers()
    
    def _set_html(self):
        self.send_response(200)
        self.send_header('Content-type','text/html; charset=utf-8')
        self.end_headers()
    
    def do_OPTIONS(self):
        self.send_response(200)
        self.send_header('Access-Control-Allow-Origin','*')
        self.send_header('Access-Control-Allow-Methods','GET, POST, OPTIONS')
        self.send_header('Access-Control-Allow-Headers','Content-Type')
        self.end_headers()
    
    def do_GET(self):
        path=urllib.parse.urlparse(self.path).path
        if path in ['/', '/index.html']:
            self._set_html()
            self.wfile.write(HTML_PAGE.encode('utf-8'))
            return
        if path=='/next':
            with STATE['lock']:
                idx=STATE['index']
                imgs=STATE['images']
                if idx>=len(imgs):
                    self._set_json()
                    self.wfile.write(json.dumps({"status":"done"}).encode('utf-8'))
                    return
                item=imgs[idx]
                pil=Image.open(item['path']).convert("RGBA")
                buf=BytesIO()
                pil.save(buf,format="PNG",compress_level=0)
                data_url=f"data:image/png;base64,{base64.b64encode(buf.getvalue()).decode()}"
                dt_iso=item['datetime'].isoformat() if item['datetime'] else None
                resp={
                    "status":"ok",
                    "image":data_url,'.webp')
DEFAULT_OUTPUT_SUFFIX = "_com_data"
FONTS_DIR = "/storage/emulated/0/Biblioteca/02_Vídeos/05_Inshot/02_temporario_inshot/01_imagens_para_editar/00_Python/fontes"

STATE = {
    "images": [,"selected_images": [,'com.brave.browser/com.google.android.apps.chrome.Main','com.android.chrome/com.google.android.apps.chrome.Main',"filename":item['filename','.webp')
DEFAULT_OUTPUT_SUFFIX = "_com_data"
FONTS_DIR = "/storage/emulated/0/Biblioteca/02_Vídeos/05_Inshot/02_temporario_inshot/01_imagens_para_editar/00_Python/fontes"

STATE = {
    "images": [,"selected_images": [,'com.brave.browser/com.google.android.apps.chrome.Main','com.android.chrome/com.google.android.apps.chrome.Main',"filename":item['filename',"relpath":item['relpath',
                    "index":idx+1,
                    "total":len(imgs),
                    "datetime_iso":dt_iso,
                    "config": STATE['config']
                }
                self._set_json()
                self.wfile.write(json.dumps(resp).encode('utf-8'))
                return
        if path=='/get_fonts':
            fonts = get_available_fonts()
            self._set_json()
            self.wfile.write(json.dumps({"fonts": fonts}).encode('utf-8'))
            return
        if path=='/get_config':
            self._set_json()
            self.wfile.write(json.dumps(STATE['config']).encode('utf-8'))
            return
        if path=='/get_batch_images':
            with STATE['lock']:
                imgs = STATE['images']
                batch_data = []
                for idx, item in enumerate(imgs):
                    try:
                        pil = Image.open(item['path'])
                        pil.thumbnail((200, 200), Image.Resampling.LANCZOS)
                        buf = BytesIO()
                        pil.save(buf, format="JPEG", quality=70)
                        thumb_url = f"data:image/jpeg;base64,{base64.b64encode(buf.getvalue()).decode()}"
                        batch_data.append({
                            "index": idx,'.webp')
DEFAULT_OUTPUT_SUFFIX = "_com_data"
FONTS_DIR = "/storage/emulated/0/Biblioteca/02_Vídeos/05_Inshot/02_temporario_inshot/01_imagens_para_editar/00_Python/fontes"

STATE = {
    "images": [,"selected_images": [,'com.brave.browser/com.google.android.apps.chrome.Main','com.android.chrome/com.google.android.apps.chrome.Main',"filename":item['filename',"relpath":item['relpath',"filename": item['filename',
                            "thumbnail": thumb_url
                        })
                    except Exception as e:
                        print(f"Erro ao processar thumbnail {item['filename']}: {e}")
                        pass
            self._set_json()
            self.wfile.write(json.dumps({"images": batch_data, "total": len(batch_data)}).encode('utf-8'))
            return
        self.send_response(404)
        self.end_headers()
        self.wfile.write(b'Not found')
        
    def do_POST(self):
        path=urllib.parse.urlparse(self.path).path
        length=int(self.headers.get('content-length',0))
        body=self.rfile.read(length)
        
        if path=='/save':
            try:
                payload=json.loads(body.decode('utf-8'))
                data_url=payload.get('image')
                filename=payload.get('filename')
                relpath=payload.get('relpath','.')
                out_base=STATE['output_dir']
                if not out_base: raise Exception("Output dir não configurado")
                
                destino_dir=os.path.join(out_base,relpath) if relpath!="." else out_base
                os.makedirs(destino_dir,exist_ok=True)
                name_root=os.path.splitext(filename)[0]
                out_path=os.path.join(destino_dir,f"{name_root}{DEFAULT_OUTPUT_SUFFIX}.png")
                
                header,b64=data_url.split(',',1)
                img_data=base64.b64decode(b64)
                img=Image.open(BytesIO(img_data))
                salvar_imagem_png_lossless(img,out_path)
                
                with STATE['lock']:
                    idx=STATE['index']
                    original_path=STATE['images'][idx]['path']
                    
                    originais_dir=os.path.join(out_base,"_originais",relpath) if relpath!="." else os.path.join(out_base,"_originais")
                    os.makedirs(originais_dir,exist_ok=True)
                    
                    dest_original=os.path.join(originais_dir,filename)
                    shutil.move(original_path,dest_original)
                    
                    STATE['index']+=1
                
                self._set_json()
                self.wfile.write(json.dumps({"status":"ok","saved":out_path,"moved_to":dest_original}).encode('utf-8'))
                return
            except Exception as e:
                self._set_json()
                self.wfile.write(json.dumps({"status":"error","msg":str(e)}).encode('utf-8'))
                return
        
        if path=='/skip':
            with STATE['lock']: STATE['index']+=1
            self._set_json()
            self.wfile.write(json.dumps({"status":"ok","skipped":True}).encode('utf-8'))
            return
        
        if path=='/back':
            with STATE['lock']:
                if STATE['index']>0: STATE['index']-=1
            self._set_json()
            self.wfile.write(json.dumps({"status":"ok","back":True}).encode('utf-8'))
            return
        
        if path=='/update_config':
            try:
                payload=json.loads(body.decode('utf-8'))
                STATE['config'].update(payload)
                self._set_json()
                self.wfile.write(json.dumps({"status":"ok","config":STATE['config']}).encode('utf-8'))
                return
            except Exception as e:
                self._set_json()
                self.wfile.write(json.dumps({"status":"error","msg":str(e)}).encode('utf-8'))
                return
        
        if path=='/reset_config':
            STATE['config'] = {
                "font_mode": "dynamic",
                "fixed_font_size": 8,
                "date_format": 0,
                "margin_lines": 0,
                "selected_font": None,
                "batch_mode": False,'.webp')
DEFAULT_OUTPUT_SUFFIX = "_com_data"
FONTS_DIR = "/storage/emulated/0/Biblioteca/02_Vídeos/05_Inshot/02_temporario_inshot/01_imagens_para_editar/00_Python/fontes"

STATE = {
    "images": [,"selected_images": [,'com.brave.browser/com.google.android.apps.chrome.Main','com.android.chrome/com.google.android.apps.chrome.Main',"filename":item['filename',"relpath":item['relpath',"filename": item['filename',"selected_images": [,
                "batch_rotation": {}
            }
            self._set_json()
            self.wfile.write(json.dumps({"status":"ok"}).encode('utf-8'))
            return
        
        if path=='/reload_images':
            try:
                success = reload_images()
                if success:
                    self._set_json()
                    self.wfile.write(json.dumps({"status":"ok","total":len(STATE['images'])}).encode('utf-8'))
                else:
                    raise Exception("Falha ao recarregar imagens")
                return
            except Exception as e:
                self._set_json()
                self.wfile.write(json.dumps({"status":"error","msg":str(e)}).encode('utf-8'))
                return
        
        if path=='/set_datetime':
            try:
                payload=json.loads(body.decode('utf-8'))
                datetime_str = payload.get('datetime')
                dt = datetime.datetime.strptime(datetime_str, "%Y-%m-%d %H:%M:%S")
                with STATE['lock']:
                    idx = STATE['index']
                    if idx < len(STATE['images']):
                        STATE['images'][idx]['datetime'] = dt
                self._set_json()
                self.wfile.write(json.dumps({"status":"ok","datetime_iso":dt.isoformat()}).encode('utf-8'))
                return
            except Exception as e:
                self._set_json()
                self.wfile.write(json.dumps({"status":"error","msg":str(e)}).encode('utf-8'))
                return
        
        if path=='/set_batch_rotation':
            try:
                payload=json.loads(body.decode('utf-8'))
                index = payload.get('index')
                rotation = payload.get('rotation', 0)
                STATE['config']['batch_rotation'][str(index)] = rotation
                self._set_json()
                self.wfile.write(json.dumps({"status":"ok"}).encode('utf-8'))
                return
            except Exception as e:
                self._set_json()
                self.wfile.write(json.dumps({"status":"error","msg":str(e)}).encode('utf-8'))
                return
        
        if path=='/batch_process':
            try:
                payload=json.loads(body.decode('utf-8'))
                selected_indices = payload.get('selected_images',])
                
                processed = 0
                for idx in selected_indices:
                    if idx >= len(STATE'images']):
                        continue
                    
                    item = STATE'images']idx]
                    pil = Image.open(item'path']).convert("RGBA")
                    
                    # Aplicar rotação se houver
                    rotation = STATE'config']'batch_rotation'].get(str(idx),0)
                    if rotation > 0:
                        pil = pil.rotate(-rotation,expand=True)
                    
                    if item['datetime':
                        draw = ImageDraw.Draw(pil)
                        dt_text = format_datetime(item['datetime', STATE['config']['date_format'])
                        
                        if STATE['config']['font_mode'] == 'fixed':
                            fontSize = STATE['config']['fixed_font_size'] * 5
                        else:
                            fontSize = max(20, round(min(pil.width, pil.height) * 0.04))
                        
                        # Carregar fonte selecionada
                        font = None
                        if STATE['config']['selected_font']:
                            font_path = os.path.join(FONTS_DIR, STATE['config']['selected_font'])
                            if os.path.exists(font_path):
                                try:
                                    font = ImageFont.truetype(font_path, fontSize)
                                except Exception as e:
                                    print(f"Erro ao carregar fonte {font_path}: {e}")
                                    pass
                        
                        # Fallback para fonte do sistema
                        if not font:
                            try:
                                font = ImageFont.truetype("/system/fonts/Roboto-Regular.ttf", fontSize)
                            except:
                                font = ImageFont.load_default()
                        
                        # Para calcular o tamanho do texto (textbbox não estava na versão do PIL do Claude)
                        # Usando um workaround simples para ter o W para alinhamento
                        try:
                            bbox = draw.textbbox((0, 0), dt_text, font=font)
                            textW = bbox[2] - bbox[0]
                        except:
                            textW = fontSize * len(dt_text) * 0.5 # Estimativa
                        
                        marginOffset = STATE['config']['margin_lines'] * fontSize * 0.8
                        x = pil.width - textW - 15 - marginOffset
                        y = pil.height - 15 - marginOffset
                        
                        # Desenha sombra preta
                        for dx in [-2,-1,0,1,2]:
                            for dy in [-2,-1,0,1,2]:
                                draw.text((x+dx, y+dy), dt_text, font=font, fill='black')
                        
                        # Desenha texto amarelo
                        draw.text((x, y), dt_text, font=font, fill='#FEFE11')
                    
                    relpath = item['relpath']
                    filename = item['filename']
                    out_base = STATE['output_dir']
                    
                    destino_dir = os.path.join(out_base, relpath) if relpath != "." else out_base
                    os.makedirs(destino_dir, exist_ok=True)
                    name_root = os.path.splitext(filename)[0]
                    out_path = os.path.join(destino_dir, f"{name_root}{DEFAULT_OUTPUT_SUFFIX}.png")
                    
                    salvar_imagem_png_lossless(pil, out_path)
                    
                    # Move original
                    originais_dir = os.path.join(out_base, "_originais", relpath) if relpath != "." else os.path.join(out_base, "_originais")
                    os.makedirs(originais_dir, exist_ok=True)
                    dest_original = os.path.join(originais_dir,])
                
                processed = 0
                for idx in selected_indices:
                    if idx >= len(STATE'images']):
                        continue
                    
                    item = STATE'images']idx]
                    pil = Image.open(item'path']).convert("RGBA")
                    
                    # Aplicar rotação se houver
                    rotation = STATE'config']'batch_rotation'].get(str(idx),0)
                    if rotation > 0:
                        pil = pil.rotate(-rotation,expand=True)
                    
                    if item['datetime':
                        draw = ImageDraw.Draw(pil)
                        dt_text = format_datetime(item['datetime',filename)
                    shutil.move(item['path', dest_original)
                    
                    processed += 1
                
                # Limpar rotações do batch
                STATE['config']['batch_rotation'] = {}
                
                self._set_json()
                self.wfile.write(json.dumps({"status":"ok","processed":processed}).encode('utf-8'))
                return
            except Exception as e:
                self._set_json()
                self.wfile.write(json.dumps({"status":"error","msg":str(e)}).encode('utf-8'))
                return
        
        if path=='/set_output_dir':
            try:
                payload=json.loads(body.decode('utf-8'))
                new_output = payload.get('output_dir')
                if new_output and os.path.isdir(new_output):
                    STATE['output_dir'] = new_output
                    self._set_json()
                    self.wfile.write(json.dumps({"status":"ok","output_dir":new_output}).encode('utf-8'))
                else:
                    raise Exception("Diretório inválido")
                return
            except Exception as e:
                self._set_json()
                self.wfile.write(json.dumps({"status":"error","msg":str(e)}).encode('utf-8'))
                return
        
        self.send_response(404)
        self.end_headers()
        self.wfile.write(b'Not found')

# ---------- HTML + JS ----------
def build_html():
    return """
<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>Editor PNG</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<style>
body{font-family:Arial;background:#222;color:#fff;margin:0;padding:0;display:flex;flex-direction:column;align-items:center;height:100vh;overflow:hidden;}
.viewer{background:#111;padding:12px;border-radius:8px;display:flex;flex-direction:column;align-items:center;width:100%;max-width:1100px;position:relative;flex:1;}
canvas{border-radius:6px;background:#000;max-width:100%;height:auto;}

/* Controles reorganizados - LATERAL ESQUERDA FIXA */
.controls-left{position:absolute;left:15px;top:15px;display:flex;flex-direction:column;gap:15px;z-index:10;}

/* Controles superior - ALINHADOS À DIREITA */
.controls-top{position:absolute;top:15px;right:15px;display:flex;gap:15px;z-index:10;flex-direction:row;}

.btn-wrapper{display:flex;flex-direction:column;align-items:center;gap:4px;}
button{padding:0;border-radius:50%;border:none;cursor:pointer;width:45px;height:45px;display:flex;align-items:center;justify-content:center;transition:transform 0.2s,box-shadow 0.2s;box-shadow:0 3px 6px rgba(0,0,0,0.4);}
button:hover{transform:scale(1.05);box-shadow:0 4px 8px rgba(0,0,0,0.6);}
button:active{transform:scale(0.95);}
.btn-rotate{background:#2ecc71;}
.btn-save{background:#f39c12;}
.btn-skip{background:#e74c3c;}
.btn-back{background:#9b59b6;}
.btn-datetime{background:#e67e22;}
.btn-font-mode{background:#1abc9c;}
.btn-reset{background:#95a5a6;}
.btn-fonts{background:#8e44ad;}
.btn-date-format{background:#16a085;}
.btn-margin{background:#d35400;}
.btn-output{background:#c0392b;}
.btn-batch{background:#27ae60;}
button svg{width:24px;height:24px;}
.btn-label{font-size:10px;color:white;text-shadow:1px 1px 2px rgba(0,0,0,0.8);pointer-events:none;}
.status{margin-top:8px;font-size:14px;color:#ddd;text-align:center;}

/* Popup styles - Botões retangulares */
.popup{display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.8);z-index:1000;align-items:center;justify-content:center;}
.popup.active{display:flex;}
.popup-content{background:white;color:#333;padding:25px 25px 80px 25px;border-radius:12px;max-width:500px;width:90%;max-height:80vh;overflow-y:auto;position:relative;}
.popup-content h3{margin-top:0;color:#2c3e50;}
.popup-input{width:100%;padding:10px;margin:10px 0;border:2px solid #3498db;border-radius:6px;font-size:14px;box-sizing:border-box;}
.popup-hint{font-size:12px;color:#7f8c8d;margin:5px 0 15px 0;}

/* Botões do popup - RETANGULARES */
.popup-buttons{position:absolute;bottom:0;left:0;right:0;display:flex;gap:0;border-radius:0 0 12px 12px;overflow:hidden;}
.popup-btn-confirm{flex:1;background:#27ae60;color:white;border:none;padding:15px;cursor:pointer;font-size:14px;font-weight:bold;border-radius:0;}
.popup-btn-confirm:hover{background:#229954;}
.popup-btn-cancel{flex:1;background:#e74c3c;color:white;border:none;padding:15px;cursor:pointer;font-size:14px;font-weight:bold;border-radius:0;}
.popup-btn-cancel:hover{background:#c0392b;}

.option-row{display:flex;align-items:center;margin:10px 0;gap:10px;}
.option-radio{width:20px;height:20px;cursor:pointer;}
.option-label{flex:1;font-size:14px;cursor:pointer;}

/* Batch grid - Grid de 3 colunas com miniaturas não distorcidas */
.batch-grid{display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:#111;z-index:999;flex-direction:column;}
.batch-grid.active{display:flex;}
.batch-header{background:#2c3e50;padding:15px;text-align:center;color:white;}
.batch-images{flex:1;overflow-y:auto;display:grid;grid-template-columns:repeat(3,1fr);gap:10px;padding:10px;}
.batch-item{position:relative;cursor:pointer;border:3px solid transparent;border-radius:8px;overflow:hidden;aspect-ratio:1/1;display:flex;align-items:center;justify-content:center;background:#000;}
.batch-item.selected{border-color:#27ae60;}
.batch-item img{max-width:100%;max-height:100%;object-fit:contain;}
.batch-item-rotation{position:absolute;top:5px;right:5px;background:rgba(0,0,0,0.7);color:white;padding:3px 8px;border-radius:4px;font-size:11px;font-weight:bold;}
.batch-controls{background:#2c3e50;padding:15px;display:flex;justify-content:space-around;align-items:center;flex-wrap:wrap;gap:10px;}
.batch-btn{background:#3498db;color:white;border:none;padding:12px;border-radius:50%;width:60px;height:60px;cursor:pointer;display:flex;flex-direction:column;align-items:center;justify-content:center;gap:4px;}

.batch-btn:hover{background:#2980b9;}
.batch-btn svg{width:28px;height:28px;}
.batch-btn-label{font-size:9px;}
.batch-btn.select-all{background:#27ae60;}
.batch-btn.clear{background:#e74c3c;}
.batch-btn.process{background:#f39c12;}
.batch-btn.rotate-batch{background:#9b59b6;}

/* Progress bar */
.progress-container{display:none;position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:white;padding:30px;border-radius:12px;box-shadow:0 10px 30px rgba(0,0,0,0.5);z-index:1002;min-width:300px;}
.progress-container.active{display:block;}
.progress-bar{width:100%;height:30px;background:#ecf0f1;border-radius:15px;overflow:hidden;margin:15px 0;}
.progress-fill{height:100%;background:#27ae60;transition:width 0.3s;display:flex;align-items:center;justify-content:center;color:white;font-weight:bold;font-size:12px;}

/* Success popup */
.success-popup{display:none;position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:white;padding:40px;border-radius:12px;text-align:center;box-shadow:0 10px 30px rgba(0,0,0,0.5);z-index:1001;}
.success-popup.active{display:block;}
.success-icon{font-size:60px;color:#27ae60;margin-bottom:15px;}
.success-text{font-size:18px;color:#2c3e50;font-weight:bold;margin-bottom:20px;}

/* Reload popup */
.reload-options{display:flex;flex-direction:column;gap:10px;margin-top:20px;}
.reload-option-btn{background:#3498db;color:white;border:none;padding:15px;border-radius:6px;cursor:pointer;font-size:14px;font-weight:bold;}
.reload-option-btn:hover{background:#2980b9;}
.reload-option-btn.config{background:#e67e22;}
.reload-option-btn.config:hover{background:#d35400;}
</style>
</head>
<body>
<div class="viewer">
<canvas id="canvas"></canvas>

<div class="controls-top">
<div class="btn-wrapper">
<button id="backBtn" class="btn-back" title="Voltar">
<svg viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2">
<polygon points="19 20 9 12 19 4 19 20"/><line x1="5" y1="19" x2="5" y2="5"/>
</svg>
</button>
<span class="btn-label">Voltar</span>
</div>

<div class="btn-wrapper">
<button id="skipBtn" class="btn-skip" title="Pular">
<svg viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2">
<polygon points="5 4 15 12 5 20 5 4"/><line x1="19" y1="5" x2="19" y2="19"/>
</svg>
</button>
<span class="btn-label">Pular</span>
</div>

<div class="btn-wrapper">
<button id="rotateBtn" class="btn-rotate" title="Rotacionar">
<svg viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2">
<path d="M21.5 2v6h-6M2.5 22v-6h6M2 11.5a10 10 0 0 1 18.8-4.3M22 12.5a10 10 0 0 1-18.8 4.2"/>
</svg>
</button>
<span class="btn-label">Rotacionar</span>
</div>

<div class="btn-wrapper">
<button id="batchBtn" class="btn-batch" title="Processamento em Lote">
<svg viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2">
<rect x="3" y="3" width="7" height="7"/><rect x="14" y="3" width="7" height="7"/>
<rect x="14" y="14" width="7" height="7"/><rect x="3" y="14" width="7" height="7"/>
</svg>
</button>
<span class="btn-label">Lote</span>
</div>

<div class="btn-wrapper">
<button id="saveBtn" class="btn-save" title="Salvar">
<svg viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2">
<path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/>
<polyline points="17 21 17 13 7 13 7 21"/><polyline points="7 3 7 8 15 8"/>
</svg>
</button>
<span class="btn-label">Salvar</span>
</div>
</div>

<div class="controls-left">
<div class="btn-wrapper">
<button id="datetimeBtn" class="btn-datetime" title="Alterar Data/Hora">
<svg viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2">
<rect x="3" y="4" width="18" height="18" rx="2"/>
<line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/>
<line x1="3" y1="10" x2="21" y2="10"/>
</svg>
</button>
<span class="btn-label">Data/Hora</span>
</div>

<div class="btn-wrapper">
<button id="fontModeBtn" class="btn-font-mode" title="Modo da Fonte">
<svg viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2">
<polyline points="4 7 4 4 20 4 20 7"/><line x1="9" y1="20" x2="15" y2="20"/>
<line x1="12" y1="4" x2="12" y2="20"/>
</svg>
</button>
<span class="btn-label" id="fontModeLabel">Modo Fixo</span>
</div>

<div class="btn-wrapper">
<button id="fontsBtn" class="btn-fonts" title="Selecionar Fonte">
<svg viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2">
<path d="M4 20h16M6 16l4-12 4 12M8 12h8"/>
</svg>
</button>
<span class="btn-label">Fontes</span>
</div>

<div class="btn-wrapper">
<button id="dateFormatBtn" class="btn-date-format" title="Formato de Data">
<svg viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2">
<circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/>
</svg>
</button>
<span class="btn-label">Formato</span>
</div>

<div class="btn-wrapper">
<button id="marginBtn" class="btn-margin" title="Espaçamento">
<svg viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2">
<rect x="3" y="3" width="18" height="18" rx="2"/>
<line x1="9" y1="3" x2="9" y2="21"/><line x1="15" y1="3" x2="15" y2="21"/>
</svg>
</button>
<span class="btn-label">Margem</span>
</div>

<div class="btn-wrapper">
<button id="outputBtn" class="btn-output" title="Pasta de Destino">
<svg viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2">
<path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/>
</svg>
</button>
<span class="btn-label">Destino</span>
</div>

<div class="btn-wrapper">
<button id="resetBtn" class="btn-reset" title="Recarregar">
<svg viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2">
<path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8"/>
<path d="M21 3v5h-5"/><path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16"/>
<path d="M8 16H3v5"/>
</svg>
</button>
<span class="btn-label">Recarregar</span>
</div>
</div>

<div class="status" id="status"></div>
</div>

<div id="datetimePopup" class="popup">
<div class="popup-content">
<h3>Alterar Data e Hora</h3>
<div class="popup-hint">Formato: AAAA-MM-DD HH:MM:SS</div>
<input type="text" id="datetimeInput" class="popup-input" placeholder="2024-01-15 14:30:00">
<div class="popup-buttons">
<button class="popup-btn-confirm" id="datetimeConfirm">CONFIRMAR</button>
<button class="popup-btn-cancel" id="datetimeCancel">CANCELAR</button>
</div>
</div>
</div>

<div id="fontModePopup" class="popup">
<div class="popup-content">
<h3>Modo da Fonte</h3>
<div class="option-row">
<input type="radio" name="fontMode" value="dynamic" id="fontDynamic" class="option-radio">
<label for="fontDynamic" class="option-label">Dinâmico (automático)</label>
</div>
<div class="option-row">
<input type="radio" name="fontMode" value="fixed" id="fontFixed" class="option-radio">
<label for="fontFixed" class="option-label">Fixo</label>
</div>
<div id="fontSizeContainer" style="display:none;margin-top:15px;">
<label style="display:block;margin-bottom:5px;font-weight:bold;">Tamanho da fonte (1-20):</label>
<input type="number" id="fontSizeInput" class="popup-input" min="1" max="20" value="8">
</div>
<div class="popup-buttons">
<button class="popup-btn-confirm" id="fontModeConfirm">CONFIRMAR</button>
<button class="popup-btn-cancel" id="fontModeCancel">CANCELAR</button>
</div>
</div>
</div>

<div id="fontsPopup" class="popup">
<div class="popup-content">
<h3>Selecionar Fonte</h3>
<div id="fontsList"></div>
<div class="popup-buttons">
<button class="popup-btn-confirm" id="fontsConfirm">CONFIRMAR</button>
<button class="popup-btn-cancel" id="fontsCancel">CANCELAR</button>
</div>
</div>
</div>

<div id="dateFormatPopup" class="popup">
<div class="popup-content">
<h3>Formato de Data</h3>
<div id="dateFormatList"></div>
<div class="popup-buttons">
<button class="popup-btn-confirm" id="dateFormatConfirm">CONFIRMAR</button>
<button class="popup-btn-cancel" id="dateFormatCancel">CANCELAR</button>
</div>
</div>
</div>

<div id="marginPopup" class="popup">
<div class="popup-content">
<h3>Espaçamento da Fonte</h3>
<div class="popup-hint">Escolha o afastamento do texto em relação à borda da foto</div>
<div class="option-row">
<input type="radio" name="marginMode" value="0" id="margin0" class="option-radio">
<label for="margin0" class="option-label">Próximo (padrão)</label>
</div>
<div class="option-row">
<input type="radio" name="marginMode" value="1" id="margin1" class="option-radio">
<label for="margin1" class="option-label">Médio</label>
</div>
<div class="option-row">
<input type="radio" name="marginMode" value="2" id="margin2" class="option-radio">
<label for="margin2" class="option-label">Afastado</label>
</div>
<div class="popup-buttons">
<button class="popup-btn-confirm" id="marginConfirm">CONFIRMAR</button>
<button class="popup-btn-cancel" id="marginCancel">CANCELAR</button>
</div>
</div>
</div>

<div id="outputPopup" class="popup">
<div class="popup-content">
<h3>Selecionar Pasta de Destino</h3>
<div class="popup-hint">Digite o caminho completo da pasta onde deseja salvar as imagens editadas</div>
<input type="text" id="outputInput" class="popup-input" placeholder="/storage/emulated/0/Pictures">
<div class="popup-hint" style="margin-top:10px;color:#e74c3c;">Nota: O seletor de diretório visual ainda não está implementado. Use o caminho completo.</div>
<div class="popup-buttons">
<button class="popup-btn-confirm" id="outputConfirm">CONFIRMAR</button>
<button class="popup-btn-cancel" id="outputCancel">CANCELAR</button>
</div>
</div>
</div>

<div id="reloadPopup" class="popup">
<div class="popup-content">
<h3>Opções de Recarregamento</h3>
<div class="reload-options">
<button class="reload-option-btn" id="reloadImagesBtn">
<svg viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" style="width:20px;height:20px;display:inline-block;margin-right:8px;vertical-align:middle;">
<path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8"/>
<path d="M21 3v5h-5"/><path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16"/>
<path d="M8 16H3v5"/>
</svg>
Recarregar Imagens
</button>
<button class="reload-option-btn config" id="reloadConfigBtn">
<svg viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" style="width:20px;height:20px;display:inline-block;margin-right:8px;vertical-align:middle;">
<circle cx="12" cy="12" r="3"/><path d="M12 1v6m0 6v6M5.64 5.64l4.24 4.24m4.24 4.24l4.24 4.24M1 12h6m6 0h6M5.64 18.36l4.24-4.24m4.24-4.24l4.24-4.24"/>
</svg>
Redefinir Configurações
</button>
<button class="popup-btn-cancel" id="reloadCancel" style="margin-top:10px;width:100%;border-radius:6px;">FECHAR</button>
</div>
</div>
</div>

<div id="batchGrid" class="batch-grid">
<div class="batch-header">
<h2 style="margin:0;">Selecione as Imagens para Processar</h2>
<p style="margin:5px 0 0 0;font-size:14px;color:#ecf0f1;" id="batchCounter">0 imagens carregadas</p>
</div>
<div class="batch-images" id="batchImages"></div>
<div class="batch-controls">
<button class="batch-btn select-all" id="batchSelectAll" title="Selecionar Todas">
<svg viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2">
<polyline points="20 6 9 17 4 12"/>
</svg>
<span class="batch-btn-label">Selecionar</span>
</button>
<button class="batch-btn clear" id="batchClear" title="Limpar Seleção">
<svg viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2">
<line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/>
</svg>
<span class="batch-btn-label">Limpar</span>
</button>
<button class="batch-btn rotate-batch" id="batchRotateBtn" title="Rotacionar Selecionadas">
<svg viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2">
<path d="M21.5 2v6h-6M2.5 22v-6h6M2 11.5a10 10 0 0 1 18.8-4.3M22 12.5a10 10 0 0 1-18.8 4.2"/>
</svg>
<span class="batch-btn-label">Rotacionar</span>
</button>
<button class="batch-btn process" id="batchProcess" title="Processar Selecionadas">
<svg viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2">
<polyline points="20 6 9 17 4 12"/>
</svg>
<span class="batch-btn-label">Processar</span>
</button>
<button class="batch-btn" id="batchClose" style="background:#95a5a6;" title="Fechar">
<svg viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2">
<line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/>
</svg>
<span class="batch-btn-label">Fechar</span>
</button>
</div>
</div>

<div id="progressContainer" class="progress-container">
<h3 style="margin:0 0 15px 0;color:#2c3e50;">Processando imagens...</h3>
<div class="progress-bar">
<div id="progressFill" class="progress-fill" style="width:0%;">0%</div>
</div>
<p id="progressText" style="color:#7f8c8d;margin:10px 0 0 0;">Preparando...</p>
</div>

<div id="successPopup" class="success-popup">
<div class="success-icon">✓</div>
<div class="success-text">Processamento Concluído!</div>
<button onclick="document.getElementById('successPopup').classList.remove('active')" 
        style="background:#27ae60;color:white;border:none;padding:10px 30px;border-radius:6px;cursor:pointer;font-size:14px;">
OK
</button>
</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const status = document.getElementById('status');

let currentImage = null;
let currentData = null;
let rotation = 0;
let config = {
    font_mode: 'dynamic',
    fixed_font_size: 8,
    date_format: 0,
    margin_lines: 0,
    selected_font: null,
    batch_mode: false,])
                
                processed = 0
                for idx in selected_indices:
                    if idx >= len(STATE'images']):
                        continue
                    
                    item = STATE'images']idx]
                    pil = Image.open(item'path']).convert("RGBA")
                    
                    # Aplicar rotação se houver
                    rotation = STATE'config']'batch_rotation'].get(str(idx),0)
                    if rotation > 0:
                        pil = pil.rotate(-rotation,expand=True)
                    
                    if item['datetime':
                        draw = ImageDraw.Draw(pil)
                        dt_text = format_datetime(item['datetime',filename)
                    shutil.move(item['path',selected_images: [,
    batch_rotation: {}
};

async function loadConfig() {
    try {
        const resp = await fetch('/get_config');
        const data = await resp.json();
        config = data;
        updateFontModeLabel();
    } catch(e) {
        console.error('Erro ao carregar config:', e);
    }
}

function updateFontModeLabel() {
    const label = document.getElementById('fontModeLabel');
    if (config.font_mode === 'dynamic') {
        label.textContent = 'Dinâmico';
    } else {
        label.textContent = 'Fixo';
    }
}

async function loadNext() {
    try {
        const resp = await fetch('/next');
        const data = await resp.json();
        
        if (data.status === 'done') {
            status.textContent = '✅ Todas as imagens foram processadas!';
            canvas.width = 800;
            canvas.height = 600;
            ctx.fillStyle = '#111';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#fff';
            ctx.font = '24px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Concluído!', canvas.width/2, canvas.height/2);
            return;
        }
        
        currentData = data;
        config = data.config;
        updateFontModeLabel();
        rotation = 0;
        
        const img = new Image();
        img.onload = () => {
            currentImage = img;
            drawImage();
            status.textContent = `Imagem ${data.index} de ${data.total}: ${data.filename}`;
        };
        img.src = data.image;
    } catch(e) {
        console.error('Erro ao carregar imagem:', e);
        status.textContent = '❌ Erro ao carregar imagem';
    }
}

function drawImage() {
    if (!currentImage) return;
    
    let w = currentImage.width;
    let h = currentImage.height;
    
    if (rotation === 90 || rotation === 270) {
        canvas.width = h;
        canvas.height = w;
    } else {
        canvas.width = w;
        canvas.height = h;
    }
    
    ctx.save();
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    if (rotation === 90) {
        ctx.translate(canvas.width, 0);
        ctx.rotate(Math.PI / 2);
    } else if (rotation === 180) {
        ctx.translate(canvas.width, canvas.height);
        ctx.rotate(Math.PI);
    } else if (rotation === 270) {
        ctx.translate(0, canvas.height);
        ctx.rotate(-Math.PI / 2);
    }
    
    ctx.drawImage(currentImage, 0, 0, w, h);
    ctx.restore();
    
    if (currentData && currentData.datetime_iso) {
        drawDateTime();
    }
}

function drawDateTime() {
    if (!currentData || !currentData.datetime_iso) return;
    
    const dt = new Date(currentData.datetime_iso);
    const dtText = formatDateTime(dt, config.date_format);
    
    let fontSize;
    if (config.font_mode === 'fixed') {
        fontSize = config.fixed_font_size * 5;
    } else {
        fontSize = Math.max(20, Math.round(Math.min(canvas.width, canvas.height) * 0.04));
    }
    
    let fontFamily = 'Arial, sans-serif';
    if (config.selected_font) {
        const fontName = config.selected_font.replace(/\.(ttf|otf)$/i, '').replace(/[_-]/g, ' ');
        fontFamily = `"${fontName}", Arial, sans-serif`;
    }
    
    ctx.font = `${fontSize}px ${fontFamily}`;
    ctx.textAlign = 'left';
    ctx.textBaseline = 'alphabetic';
    
    const metrics = ctx.measureText(dtText);
    const textW = metrics.width;
    const textH = fontSize * 1.2;
    
    const base_padding = 15;
    const marginOffset = config.margin_lines * fontSize * 0.8;
    
    const x = canvas.width - textW - base_padding - marginOffset;
    const y = canvas.height - base_padding - marginOffset;

    ctx.fillStyle = 'black';
    for (let dx = -2; dx <= 2; dx++) {
        for (let dy = -2; dy <= 2; dy++) {
            ctx.fillText(dtText, x + dx, y + dy);
        }
    }
    
    ctx.fillStyle = '#FEFE11';
    ctx.fillText(dtText, x, y);
}

function formatDateTime(dt, formatIndex) {
    const diasSemana = ['domingo', 'segunda-feira', 'terça-feira', 'quarta-feira', 'quinta-feira', 'sexta-feira', 'sábado'];
    const diasSemanaAbrev = ['dom.', 'seg.', 'ter.', 'qua.', 'qui.', 'sex.', 'sáb.'];
    const meses = ['janeiro', 'fevereiro', 'março', 'abril', 'maio', 'junho', 'julho', 'agosto', 'setembro', 'outubro', 'novembro', 'dezembro'];
    const mesesAbrev = ['jan.', 'fev.', 'mar.', 'abr.', 'mai.', 'jun.', 'jul.', 'ago.', 'set.', 'out.', 'nov.', 'dez.'];
    
    const diaSemana = diasSemana[dt.getDay()];
    const diaSemanaAbrev = diasSemanaAbrev[dt.getDay()];
    const mes = meses[dt.getMonth()];
    const mesAbrev = mesesAbrev[dt.getMonth()];
    const dia = dt.getDate();
    const ano = dt.getFullYear();
    const h = String(dt.getHours()).padStart(2, '0');
    const m = String(dt.getMinutes()).padStart(2, '0');
    const s = String(dt.getSeconds()).padStart(2, '0');
    
    const formats = [
        `${diaSemana}, ${dia} de ${mes} de ${ano}`,
        `${dia} de ${mesAbrev} de ${ano}`,
        `${String(dia).padStart(2,'0')}/${String(dt.getMonth()+1).padStart(2,'0')}/${ano}`,
        `${String(dia).padStart(2,'0')}/${String(dt.getMonth()+1).padStart(2,'0')}/${ano} ${h}:${m}:${s}`,
        `${String(dia).padStart(2,'0')}/${String(dt.getMonth()+1).padStart(2,'0')}/${ano} ${h}:${m}`,
        `${diaSemana}, ${dia} ${mes} ${ano}, ${h}:${m}`,
        `${diaSemanaAbrev}, ${dia} ${mesAbrev} ${ano} ${h}:${m}:${s}`,
        `${diaSemanaAbrev}, ${dia} ${mesAbrev} ${ano} ${h}:${m}`
    ];
    
    return formats[formatIndex] || formats[0];
}

document.getElementById('rotateBtn').addEventListener('click', () => {
    rotation = (rotation + 90) % 360;
    drawImage();
});

document.getElementById('saveBtn').addEventListener('click', async () => {
    if (!currentImage) {
        status.textContent = '❌ Nenhuma imagem carregada';
        return;
    }
    
    try {
        const dataUrl = canvas.toDataURL('image/png');
        const resp = await fetch('/save', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({
                image: dataUrl,
                filename: currentData.filename,
                relpath: currentData.relpath
            })
        });
        
        const result = await resp.json();
        if (result.status === 'ok') {
            status.textContent = '✅ Salvo com sucesso!';
            setTimeout(loadNext, 500);
        } else {
            status.textContent = `❌ Erro: ${result.msg}`;
        }
    } catch(e) {
        console.error('Erro ao salvar:', e);
        status.textContent = '❌ Erro ao salvar';
    }
});

document.getElementById('skipBtn').addEventListener('click', async () => {
    try {
        await fetch('/skip', {method: 'POST'});
        loadNext();
    } catch(e) {
        console.error('Erro ao pular:', e);
    }
});

document.getElementById('backBtn').addEventListener('click', async () => {
    try {
        await fetch('/back', {method: 'POST'});
        loadNext();
    } catch(e) {
        console.error('Erro ao voltar:', e);
    }
});

// Botão Recarregar - Agora abre popup com opções
document.getElementById('resetBtn').addEventListener('click', () => {
    document.getElementById('reloadPopup').classList.add('active');
});

document.getElementById('reloadCancel').addEventListener('click', () => {
    document.getElementById('reloadPopup').classList.remove('active');
});

document.getElementById('reloadImagesBtn').addEventListener('click', async () => {
    try {
        status.textContent = '🔄 Recarregando imagens...';
        document.getElementById('reloadPopup').classList.remove('active');
        
        const resp = await fetch('/reload_images', {method: 'POST'});
        const result = await resp.json();
        
        if (result.status === 'ok') {
            status.textContent = `✅ ${result.total} imagens carregadas`;
            setTimeout(loadNext, 500);
        } else {
            status.textContent = '❌ Erro ao recarregar';
        }
    } catch(e) {
        console.error('Erro ao recarregar:', e);
        status.textContent = '❌ Erro ao recarregar';
    }
});

document.getElementById('reloadConfigBtn').addEventListener('click', async () => {
    if (!confirm('Deseja redefinir todas as configurações para o padrão?')) {
        return;
    }
    
    try {
        const resp = await fetch('/reset_config', {method: 'POST'});
        const result = await resp.json();
        
        if (result.status === 'ok') {
            await loadConfig();
            drawImage();
            document.getElementById('reloadPopup').classList.remove('active');
            status.textContent = '✅ Configurações redefinidas';
        }
    } catch(e) {
        console.error('Erro ao redefinir:', e);
    }
});

document.getElementById('datetimeBtn').addEventListener('click', () => {
    const popup = document.getElementById('datetimePopup');
    const input = document.getElementById('datetimeInput');
    
    if (currentData && currentData.datetime_iso) {
        const dt = new Date(currentData.datetime_iso);
        const y = dt.getFullYear();
        const m = String(dt.getMonth() + 1).padStart(2, '0');
        const d = String(dt.getDate()).padStart(2, '0');
        const h = String(dt.getHours()).padStart(2, '0');
        const min = String(dt.getMinutes()).padStart(2, '0');
        const s = String(dt.getSeconds()).padStart(2, '0');
        input.value = `${y}-${m}-${d} ${h}:${min}:${s}`;
    } else {
        input.value = '';
    }
    
    popup.classList.add('active');
});

document.getElementById('datetimeConfirm').addEventListener('click', async () => {
    const input = document.getElementById('datetimeInput');
    const value = input.value.trim();
    
    if (!value) {
        alert('Por favor, insira uma data válida');
        return;
    }
    
    try {
        const resp = await fetch('/set_datetime', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({datetime: value})
        });
        
        const result = await resp.json();
        if (result.status === 'ok') {
            currentData.datetime_iso = result.datetime_iso;
            drawImage();
            document.getElementById('datetimePopup').classList.remove('active');
            status.textContent = '✅ Data/hora atualizada';
        } else {
            alert(`Erro: ${result.msg}`);
        }
    } catch(e) {
        console.error('Erro ao alterar data:', e);
        alert('Erro ao alterar data/hora');
    }
});

document.getElementById('datetimeCancel').addEventListener('click', () => {
    document.getElementById('datetimePopup').classList.remove('active');
});

document.getElementById('fontModeBtn').addEventListener('click', () => {
    const popup = document.getElementById('fontModePopup');
    
    if (config.font_mode === 'dynamic') {
        document.getElementById('fontDynamic').checked = true;
        document.getElementById('fontSizeContainer').style.display = 'none';
    } else {
        document.getElementById('fontFixed').checked = true;
        document.getElementById('fontSizeContainer').style.display = 'block';
        document.getElementById('fontSizeInput').value = config.fixed_font_size;
    }
    
    popup.classList.add('active');
});

document.querySelectorAll('input[name="fontMode"]').forEach(radio => {
    radio.addEventListener('change', (e) => {
        const container = document.getElementById('fontSizeContainer');
        if (e.target.value === 'fixed') {
            container.style.display = 'block';
        } else {
            container.style.display = 'none';
        }
    });
});

document.getElementById('fontModeConfirm').addEventListener('click', async () => {
    const mode = document.querySelector('input[name="fontMode"]:checked').value;
    const size = parseInt(document.getElementById('fontSizeInput').value) || 8;
    
    try {
        const resp = await fetch('/update_config', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({
                font_mode: mode,
                fixed_font_size: size
            })
        });
        
        const result = await resp.json();
        if (result.status === 'ok') {
            config = result.config;
            updateFontModeLabel();
            drawImage();
            document.getElementById('fontModePopup').classList.remove('active');
            status.textContent = '✅ Modo de fonte atualizado';
        }
    } catch(e) {
        console.error('Erro ao atualizar modo:', e);
    }
});

document.getElementById('fontModeCancel').addEventListener('click', () => {
    document.getElementById('fontModePopup').classList.remove('active');
});

document.getElementById('fontsBtn').addEventListener('click', async () => {
    try {
        const resp = await fetch('/get_fonts');
        const data = await resp.json();
        const fontsList = document.getElementById('fontsList');
        fontsList.innerHTML = '';
        
        const rowNone = document.createElement('div');
        rowNone.className = 'option-row';
        const radioNone = document.createElement('input');
        radioNone.type = 'radio'; 
        radioNone.name = 'fontSelect'; 
        radioNone.value = ''; 
        radioNone.className = 'option-radio'; 
        radioNone.id = 'font_none';
        if (config.selected_font === null || config.selected_font === '') { 
            radioNone.checked = true; 
        }
        const labelNone = document.createElement('label');
        labelNone.htmlFor = 'font_none'; 
        labelNone.className = 'option-label'; 
        labelNone.textContent = '(Padrão do sistema)';
        rowNone.appendChild(radioNone); 
        rowNone.appendChild(labelNone); 
        fontsList.appendChild(rowNone);
        
        if (data.fonts.length === 0) {
            fontsList.innerHTML += '<p style="color:#e74c3c;">Nenhuma fonte encontrada na pasta</p>';
        } else {
            data.fonts.forEach(font => {
                const row = document.createElement('div');
                row.className = 'option-row';
                
                const radio = document.createElement('input');
                radio.type = 'radio';
                radio.name = 'fontSelect';
                radio.value = font;
                radio.className = 'option-radio';
                radio.id = `font_${font}`;
                
                if (config.selected_font === font) {
                    radio.checked = true;
                }
                
                const label = document.createElement('label');
                label.htmlFor = `font_${font}`;
                label.className = 'option-label';
                label.textContent = font;
                
                row.appendChild(radio);
                row.appendChild(label);
                fontsList.appendChild(row);
            });
        }
        
        document.getElementById('fontsPopup').classList.add('active');
    } catch(e) {
        console.error('Erro ao carregar fontes:', e);
        alert('Erro ao carregar fontes');
    }
});

document.getElementById('fontsConfirm').addEventListener('click', async () => {
    const selected = document.querySelector('input[name="fontSelect"]:checked');
    const fontValue = selected ? selected.value : null;
    
    try {
        const resp = await fetch('/update_config', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({selected_font: fontValue})
        });
        
        const result = await resp.json();
        if (result.status === 'ok') {
            config = result.config;
            drawImage();
            document.getElementById('fontsPopup').classList.remove('active');
            status.textContent = `✅ Fonte selecionada: ${config.selected_font || '(Padrão)'}`;
        }
    } catch(e) {
        console.error('Erro ao selecionar fonte:', e);
    }
});

document.getElementById('fontsCancel').addEventListener('click', () => {
    document.getElementById('fontsPopup').classList.remove('active');
});

document.getElementById('dateFormatBtn').addEventListener('click', () => {
    const popup = document.getElementById('dateFormatPopup');
    const list = document.getElementById('dateFormatList');
    list.innerHTML = '';
    
    const formats = [
        'segunda-feira, 15 de janeiro de 2024 (Exemplo)',
        '15 de jan. de 2024 (Exemplo)',
        '15/01/2024 (Exemplo)',
        '15/01/2024 14:30:45 (Exemplo)',
        '15/01/2024 14:30 (Exemplo)',
        'segunda-feira, 15 janeiro 2024, 14:30 (Exemplo)',
        'seg., 15 jan. 2024 14:30:45 (Exemplo)',
        'seg., 15 jan. 2024 14:30 (Exemplo)'
    ];
    
    formats.forEach((fmt, idx) => {
        const row = document.createElement('div');
        row.className = 'option-row';
        
        const radio = document.createElement('input');
        radio.type = 'radio';
        radio.name = 'dateFormat';
        radio.value = idx;
        radio.className = 'option-radio';
        radio.id = `fmt_${idx}`;
        
        if (config.date_format === idx) {
            radio.checked = true;
        }
        
        const label = document.createElement('label');
        label.htmlFor = `fmt_${idx}`;
        label.className = 'option-label';
        label.textContent = fmt;
        
        row.appendChild(radio);
        row.appendChild(label);
        list.appendChild(row);
    });
    
    popup.classList.add('active');
});

document.getElementById('dateFormatConfirm').addEventListener('click', async () => {
    const selected = document.querySelector('input[name="dateFormat"]:checked');
    
    if (selected) {
        try {
            const resp = await fetch('/update_config', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({date_format: parseInt(selected.value)})
            });
            
            const result = await resp.json();
            if (result.status === 'ok') {
                config = result.config;
                drawImage();
                document.getElementById('dateFormatPopup').classList.remove('active');
                status.textContent = '✅ Formato de data atualizado';
            }
        } catch(e) {
            console.error('Erro ao atualizar formato:', e);
        }
    }
});

document.getElementById('dateFormatCancel').addEventListener('click', () => {
    document.getElementById('dateFormatPopup').classList.remove('active');
});

document.getElementById('marginBtn').addEventListener('click', () => {
    const popup = document.getElementById('marginPopup');
    document.getElementById(`margin${config.margin_lines}`).checked = true;
    popup.classList.add('active');
});

document.getElementById('marginConfirm').addEventListener('click', async () => {
    const selected = document.querySelector('input[name="marginMode"]:checked');
    
    if (selected) {
        try {
            const resp = await fetch('/update_config', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({margin_lines: parseInt(selected.value)})
            });
            
            const result = await resp.json();
            if (result.status === 'ok') {
                config = result.config;
                drawImage();
                document.getElementById('marginPopup').classList.remove('active');
                status.textContent = '✅ Espaçamento atualizado';
            }
        } catch(e) {
            console.error('Erro ao atualizar margem:', e);
        }
    }
});

document.getElementById('marginCancel').addEventListener('click', () => {
    document.getElementById('marginPopup').classList.remove('active');
});

document.getElementById('outputBtn').addEventListener('click', () => {
    const popup = document.getElementById('outputPopup');
    const input = document.getElementById('outputInput');
    popup.classList.add('active');
});

document.getElementById('outputConfirm').addEventListener('click', async () => {
    const input = document.getElementById('outputInput');
    const path = input.value.trim();
    
    if (!path) {
        alert('Por favor, insira um caminho válido');
        return;
    }
    
    try {
        const resp = await fetch('/set_output_dir', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({output_dir: path})
        });
        
        const result = await resp.json();
        if (result.status === 'ok') {
            document.getElementById('outputPopup').classList.remove('active');
            status.textContent = `✅ Pasta de destino definida: ${path}`;
        } else {
            alert(`Erro: ${result.msg}`);
        }
    } catch(e) {
        console.error('Erro ao definir pasta:', e);
        alert('Erro ao definir pasta de destino');
    }
});

document.getElementById('outputCancel').addEventListener('click', () => {
    document.getElementById('outputPopup').classList.remove('active');
});

// Batch Mode - Carregar grid com todas as imagens
document.getElementById('batchBtn').addEventListener('click', async () => {
    try {
        status.textContent = '🔄 Carregando grid de imagens...';
        const resp = await fetch('/get_batch_images');
        const data = await resp.json();
        
        const grid = document.getElementById('batchImages');
        const counter = document.getElementById('batchCounter');
        grid.innerHTML = '';
        
        counter.textContent = `${data.total} imagens carregadas`;
        
        if (data.images.length === 0) {
            grid.innerHTML = '<p style="color:#e74c3c;text-align:center;grid-column:1/-1;padding:40px;">Nenhuma imagem encontrada</p>';
        } else {
            data.images.forEach(img => {
                const item = document.createElement('div');
                item.className = 'batch-item';
                item.dataset.index = img.index;
                item.dataset.rotation = '0';
                
                const imgEl = document.createElement('img');
                imgEl.src = img.thumbnail;
                imgEl.alt = img.filename;
                
                const rotationLabel = document.createElement('div');
                rotationLabel.className = 'batch-item-rotation';
                rotationLabel.textContent = '0°';
                rotationLabel.style.display = 'none';
                
                item.appendChild(imgEl);
                item.appendChild(rotationLabel);
                
                item.addEventListener('click', (e) => {
                    if (!e.shiftKey) {
                        item.classList.toggle('selected');
                    }
                });
                
                grid.appendChild(item);
            });
        }
        
        document.getElementById('batchGrid').classList.add('active');
        status.textContent = '';
    } catch(e) {
        console.error('Erro ao carregar lote:', e);
        alert('Erro ao carregar imagens para lote');
    }
});

document.getElementById('batchSelectAll').addEventListener('click', () => {
    document.querySelectorAll('.batch-item').forEach(item => {
        item.classList.add('selected');
    });
});

document.getElementById('batchClear').addEventListener('click', () => {
    document.querySelectorAll('.batch-item').forEach(item => {
        item.classList.remove('selected');
    });
});

document.getElementById('batchClose').addEventListener('click', () => {
    document.getElementById('batchGrid').classList.remove('active');
});

// Botão de rotação no batch - rotaciona TODAS as imagens selecionadas
document.getElementById('batchRotateBtn').addEventListener('click', async () => {
    const selectedItems = document.querySelectorAll('.batch-item.selected');
    
    if (selectedItems.length === 0) {
        alert('Selecione pelo menos uma imagem para rotacionar');
        return;
    }
    
    selectedItems.forEach(async (item) => {
        const currentRotation = parseInt(item.dataset.rotation) || 0;
        const newRotation = (currentRotation + 90) % 360;
        item.dataset.rotation = newRotation;
        
        const rotationLabel = item.querySelector('.batch-item-rotation');
        rotationLabel.textContent = `${newRotation}°`;
        rotationLabel.style.display = newRotation > 0 ? 'block' : 'none';
        
        const img = item.querySelector('img');
        img.style.transform = `rotate(${newRotation}deg)`;
        
        // Salva a rotação no servidor
        const index = parseInt(item.dataset.index);
        try {
            await fetch('/set_batch_rotation', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({
                    index: index,
                    rotation: newRotation
                })
            });
        } catch(e) {
            console.error('Erro ao salvar rotação:', e);
        }
    });
});

document.getElementById('batchProcess').addEventListener('click', async () => {
    const selected = Array.from(document.querySelectorAll('.batch-item.selected'))
        .map(item => parseInt(item.dataset.index));
    
    if (selected.length === 0) {
        alert('Selecione pelo menos uma imagem');
        return;
    }
    
    if (!confirm(`Processar ${selected.length} imagens?`)) {
        return;
    }
    
    document.getElementById('batchGrid').classList.remove('active');
    document.getElementById('progressContainer').classList.add('active');
    
    const progressFill = document.getElementById('progressFill');
    const progressText = document.getElementById('progressText');
    
    try {
        // Simulação de progresso inicial
        for (let i = 0; i <= 10; i += 1) {
            progressFill.style.width = i * 10 + '%';
            progressFill.textContent = i * 10 + '%';
            progressText.textContent = `Preparando para processar ${selected.length} imagens...`;
            await new Promise(resolve => setTimeout(resolve, 50));
        }
        
        const resp = await fetch('/batch_process', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({selected_images: selected})
        });
        
        const result = await resp.json();
        
        // Finaliza progresso
        progressFill.style.width = '100%';
        progressFill.textContent = '100%';
        progressText.textContent = 'Concluído!';
        
        setTimeout(() => {
            document.getElementById('progressContainer').classList.remove('active');
            
            if (result.status === 'ok') {
                document.getElementById('successPopup').classList.add('active');
                setTimeout(() => {
                    document.getElementById('successPopup').classList.remove('active');
                    loadNext();
                }, 2000);
            } else {
                alert(`Erro: ${result.msg}`);
            }
        }, 500);
    } catch(e) {
        console.error('Erro ao processar lote:', e);
        document.getElementById('progressContainer').classList.remove('active');
        alert('Erro ao processar imagens em lote');
    }
});

// Inicialização
loadConfig().then(() => {
    loadNext();
});
</script>
</body>
</html>
"""

# ---------- Main ----------
def main():
    parser = argparse.ArgumentParser(description="Editor PNG com overlay de data/hora")
    parser.add_argument("input_dir", help="Diretório de entrada com imagens")
    parser.add_argument("-o", "--output", help="Diretório de saída (padrão: mesmo do input)")
    args = parser.parse_args()
    
    input_dir = os.path.abspath(args.input_dir)
    if not os.path.isdir(input_dir):
        print(f"Erro: '{input_dir}' não é um diretório válido")
        return
    
    output_dir = os.path.abspath(args.output) if args.output else input_dir
    os.makedirs(output_dir, exist_ok=True)
    
    STATE['input_dir'] = input_dir
    STATE['output_dir'] = output_dir
    
    print(f"📂 Pasta de entrada: {input_dir}")
    print(f"📂 Pasta de saída: {output_dir}")
    print("🔍 Procurando imagens...")
    
    imgs_raw = find_images(input_dir)
    if not imgs_raw:
        print("❌ Nenhuma imagem encontrada")
        return
    
    STATE['images'] = []
    for full, rel, fname in imgs_raw:
        dt = extrair_datetime_de_nome(fname)
        STATE['images'].append({
            "path": full,
            "relpath": rel,
            "filename": fname,
            "datetime": dt
        })
    
    print(f"✅ {len(STATE['images'])} imagens encontradas")
    
    global HTML_PAGE
    HTML_PAGE = build_html()
    
    server = ThreadedHTTPServer((HOST, PORT), Handler)
    url = f"http://{HOST}:{PORT}"
    
    print(f"\n🚀 Servidor rodando em {url}")
    print("📱 Abrindo navegador...")
    
    threading.Timer(1.0, lambda: abrir_navegador(url)).start()
    
    try:
        server.serve_forever()
    except KeyboardInterrupt:
        print("\n\n👋 Servidor encerrado")
        server.shutdown()

if __name__ == "__main__":
    main()
