#date: 2026-01-20T17:04:57Z
#url: https://api.github.com/gists/e3690646825b79a17447085299b78f11
#owner: https://api.github.com/users/ShanksTaicho

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
ProTrade V34 - SMART MARKET ANALYSIS
====================================
Akƒ±llƒ± Piyasa Analizi + Multi-Timeframe Onay

V33 Sorunu:
- BTC 95K‚Üí92K d√º≈üerken 16 LONG a√ßtƒ± ‚Üí 14 KAYIP
- Bot piyasa y√∂n√ºn√º anlamƒ±yor
- Teknik g√∂sterge > Trend = YANLI≈û!

V34 √á√∂z√ºm√º:
1. BTC/ETH trend analizi (1h, 4h, 1d)
2. Multi-timeframe onay (5m + 1h + 4h)
3. Piyasa rejimi belirleme (Risk-on/Risk-off)
4. Trend y√∂n√ºne g√∂re sinyal filtresi

MANTIK:
- BTC D√ú≈û√úYOR ‚Üí LONG YASAK, sadece SHORT
- BTC YUKARI ‚Üí SHORT YASAK, sadece LONG  
- BTC YATAY ‚Üí Her iki y√∂n serbest (dikkatli)
"""

import ccxt
import pandas as pd
import pandas_ta as ta
import time
import threading
import logging
import json
import os
import statistics
import signal
import sys
import copy
from datetime import datetime
from flask import Flask, render_template_string, jsonify

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s', datefmt='%H:%M:%S')
logger = logging.getLogger("ProTradeV34")
logging.getLogger('ccxt').setLevel(logging.WARNING)

# ============================================================================
# V34 CONFIG - SMART MARKET ANALYSIS
# ============================================================================
CONFIG = {
    'EXCHANGE_ID': 'binance',
    'TIMEFRAME': '5m',
    'CHECK_LIMIT': 60,
    'MIN_VOLUME_USDT': 3_000_000,
    
    # === MULTI-TIMEFRAME ===
    'HTF_1H': '1h',
    'HTF_4H': '4h',
    'HTF_1D': '1d',
    
    # === TREND EMA ===
    'EMA_FAST': 20,
    'EMA_SLOW': 50,
    'EMA_TREND': 100,
    
    # === INDICATORS ===
    'ATR_LENGTH': 14,
    'RSI_LENGTH': 14,
    'VOLUME_MA_LENGTH': 20,
    
    # === BTC TREND THRESHOLDs ===
    'BTC_TREND_STRONG': 1.5,      # %1.5 √ºzerinde = g√º√ßl√º trend
    'BTC_TREND_WEAK': 0.5,        # %0.5 altƒ±nda = yatay
    
    # === LONG FILTERS ===
    'LONG_RSI_MIN': 25,
    'LONG_RSI_MAX': 35,           # Daha sƒ±kƒ± (38‚Üí35)
    'LONG_EMA_MIN': 1.5,          # Daha sƒ±kƒ± (1.0‚Üí1.5)
    'LONG_EMA_MAX': 5.0,
    'LONG_VOLUME_MIN': 0.6,
    
    # === SHORT FILTERS ===
    'SHORT_RSI_MIN': 70,
    'SHORT_RSI_MAX': 85,
    'SHORT_EMA_MIN': 1.5,
    'SHORT_EMA_MAX': 7.0,
    'SHORT_VOLUME_MIN': 0.5,
    
    # === MULTI-TF CONFIRMATION ===
    'REQUIRE_1H_CONFIRM': True,
    'REQUIRE_4H_CONFIRM': True,
    
    # === RISK CONTROL ===
    'MAX_ALLOWED_LOSS_PER_TRADE': 5.0,  # %5 (daha sƒ±kƒ±)
    'MIN_PRICE_USDT': 0.05,
    'MIN_RR_RATIO': 1.8,
    
    # === TP/SL ===
    'SL_ATR_MULT': 1.8,
    'TP_ATR_MULT': 3.5,
    
    # === TRAILING ===
    'ENABLE_TRAILING': True,
    'BE_ACTIVATION': 0.015,
    'TRAILING_ACTIVATION': 0.025,
    'TRAILING_DISTANCE': 0.010,
    
    # === FEES ===
    'TRADING_FEE': 0.0004,
    'SPREAD_BUFFER': 0.0003,
    'SLIPPAGE_BUFFER': 0.0003,
    
    # === LEVERAGE ===
    'LEVERAGE_TREND_ALIGNED': 3,      # Trend ile aynƒ± y√∂nde
    'LEVERAGE_COUNTER_TREND': 2,      # Trend tersine (dikkatli)
    
    # === POSITION ===
    'MAX_OPEN_TRADES': 4,
    'MAX_SAME_DIRECTION': 2,
    'SIGNAL_COOLDOWN': 300,           # 5 dakika (daha uzun)
    
    # === SPEED ===
    'SLEEP_BETWEEN_COINS': 0.1,
    'LOOP_SLEEP': 5,
    'MARKET_UPDATE_INTERVAL': 60,     # Her 60 saniyede piyasa g√ºncelle
}

IGNORED_COINS = {'USDC','FDUSD','TUSD','DAI','USDP','BUSD','EUR','AEUR','USTC','USDD','USDJ','UST','USDN','TRIBE','PAXG','BTTC','LUNC','LUNA'}
DB_FILE = "trade_history_v34.json"

# ============================================================================
# GLOBAL STATE
# ============================================================================
data_lock = threading.RLock()
data_store = {
    "active_trades": {},
    "history": [],
    "stats": {"win":0,"loss":0,"total_pnl":0.0,"long_win":0,"short_win":0,"long_count":0,"short_count":0,"long_pnl":0.0,"short_pnl":0.0,"tp_count":0,"stop_count":0,"be_count":0,"trail_count":0,"blocked_by_trend":0},
    "market": {
        "btc_trend_1h": "YATAY",
        "btc_trend_4h": "YATAY", 
        "btc_trend_1d": "YATAY",
        "btc_price": 0,
        "btc_change_1h": 0,
        "btc_change_4h": 0,
        "btc_change_24h": 0,
        "eth_trend_1h": "YATAY",
        "market_regime": "NEUTRAL",
        "allowed_direction": "BOTH",
        "last_update": "-"
    },
    "total_scans": 0,
    "signals_generated": 0,
    "signals_rejected": 0,
    "rejection_reasons": {},
    "last_update": "-",
}
last_signal_time = {}
last_market_update = 0
app = Flask(__name__)
should_exit = False

# ============================================================================
# HTML DASHBOARD - V34 SMART
# ============================================================================
HTML_TEMPLATE = """
<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <title>ProTrade V34</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #0a0a12; color: #fff; font-family: -apple-system, sans-serif; padding: 15px; }
        .container { max-width: 1700px; margin: 0 auto; }
        .header { background: linear-gradient(135deg, #1a1a2e, #16213e); border: 2px solid #3498db; padding: 15px 20px; border-radius: 16px; margin-bottom: 15px; display: flex; justify-content: space-between; align-items: center; }
        .logo { font-size: 1.8rem; font-weight: 900; background: linear-gradient(135deg, #3498db, #2ecc71); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        .version { background: linear-gradient(135deg, #3498db, #2ecc71); color: #fff; padding: 4px 12px; border-radius: 8px; font-weight: 700; margin-left: 10px; font-size: 0.65rem; }
        
        /* Market Panel */
        .market-panel { background: linear-gradient(135deg, #1e3c72, #2a5298); border-radius: 12px; padding: 15px; margin-bottom: 15px; }
        .market-title { font-size: 1rem; font-weight: 700; margin-bottom: 12px; color: #fff; }
        .market-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 10px; }
        .market-item { background: rgba(0,0,0,0.3); border-radius: 8px; padding: 10px; text-align: center; }
        .market-label { font-size: 0.55rem; color: rgba(255,255,255,0.6); margin-bottom: 4px; }
        .market-value { font-size: 1.1rem; font-weight: 700; }
        .trend-up { color: #2ecc71; }
        .trend-down { color: #e74c3c; }
        .trend-neutral { color: #f39c12; }
        .regime-box { background: rgba(0,0,0,0.4); border-radius: 8px; padding: 12px; text-align: center; }
        .regime-label { font-size: 0.6rem; color: rgba(255,255,255,0.5); }
        .regime-value { font-size: 1.3rem; font-weight: 900; margin: 5px 0; }
        .direction-allowed { font-size: 0.7rem; padding: 4px 10px; border-radius: 6px; display: inline-block; margin-top: 5px; }
        .dir-long { background: rgba(46,204,113,0.3); color: #2ecc71; }
        .dir-short { background: rgba(231,76,60,0.3); color: #e74c3c; }
        .dir-both { background: rgba(243,156,18,0.3); color: #f39c12; }
        
        .kpi-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 8px; margin-bottom: 15px; }
        .kpi { background: #14141f; border: 1px solid rgba(255,255,255,0.05); border-radius: 10px; padding: 10px; text-align: center; }
        .kpi-label { font-size: 0.5rem; color: #666; text-transform: uppercase; margin-bottom: 3px; }
        .kpi-value { font-size: 1.3rem; font-weight: 900; font-family: 'Courier New', monospace; }
        .kpi-sub { font-size: 0.5rem; color: #555; margin-top: 2px; }
        .win { color: #2ecc71; }
        .loss { color: #e74c3c; }
        
        .section { background: #12121a; border: 1px solid rgba(255,255,255,0.05); border-radius: 10px; padding: 12px; margin-bottom: 12px; }
        .section-title { font-size: 0.9rem; font-weight: 700; margin-bottom: 10px; color: #3498db; }
        table { width: 100%; border-collapse: collapse; font-size: 0.7rem; }
        th { text-align: left; padding: 6px 5px; font-size: 0.5rem; color: #666; border-bottom: 1px solid rgba(255,255,255,0.05); }
        td { padding: 6px 5px; border-bottom: 1px solid rgba(255,255,255,0.02); }
        .badge { padding: 2px 6px; border-radius: 6px; font-size: 0.5rem; font-weight: 600; }
        .badge-long { background: rgba(46,204,113,0.2); color: #2ecc71; }
        .badge-short { background: rgba(231,76,60,0.2); color: #e74c3c; }
        .two-col { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
        @media (max-width: 900px) { .two-col { grid-template-columns: 1fr; } }
        .empty { text-align: center; padding: 15px; opacity: 0.4; font-size: 0.7rem; }
    </style>
</head>
<body>
<div class="container">
    <div class="header">
        <div><span class="logo">üß† ProTrade V34</span><span class="version">SMART ANALYSIS</span></div>
        <div style="text-align:right;font-size:0.55rem;opacity:0.6" id="scan-info">-</div>
    </div>
    
    <!-- Market Analysis Panel -->
    <div class="market-panel">
        <div class="market-title">üìä Piyasa Analizi (Multi-Timeframe)</div>
        <div class="market-grid">
            <div class="market-item">
                <div class="market-label">BTC Fiyat</div>
                <div class="market-value" id="btc-price">$--</div>
            </div>
            <div class="market-item">
                <div class="market-label">BTC 1H Trend</div>
                <div class="market-value" id="btc-1h">--</div>
            </div>
            <div class="market-item">
                <div class="market-label">BTC 4H Trend</div>
                <div class="market-value" id="btc-4h">--</div>
            </div>
            <div class="market-item">
                <div class="market-label">BTC 1D Trend</div>
                <div class="market-value" id="btc-1d">--</div>
            </div>
            <div class="market-item">
                <div class="market-label">1H Deƒüi≈üim</div>
                <div class="market-value" id="btc-ch1h">--%</div>
            </div>
            <div class="market-item">
                <div class="market-label">24H Deƒüi≈üim</div>
                <div class="market-value" id="btc-ch24h">--%</div>
            </div>
            <div class="regime-box">
                <div class="regime-label">Pƒ∞YASA REJƒ∞Mƒ∞</div>
                <div class="regime-value" id="regime">--</div>
                <div class="direction-allowed" id="allowed-dir">--</div>
            </div>
            <div class="market-item">
                <div class="market-label">üö´ Trend Blok</div>
                <div class="market-value" id="trend-blocked">0</div>
            </div>
        </div>
    </div>
    
    <div class="kpi-grid">
        <div class="kpi"><div class="kpi-label">üí∞ Toplam</div><div class="kpi-value" id="pnl">%0.00</div><div class="kpi-sub" id="trades">0 i≈ülem</div></div>
        <div class="kpi"><div class="kpi-label">üéØ Win Rate</div><div class="kpi-value" id="wr">--%</div><div class="kpi-sub" id="wr-d">0K/0Z</div></div>
        <div class="kpi"><div class="kpi-label">üìà PF</div><div class="kpi-value" id="pf">--</div></div>
        <div class="kpi"><div class="kpi-label" style="color:#2ecc71">LONG</div><div class="kpi-value" style="color:#2ecc71" id="long-c">0</div><div class="kpi-sub" id="long-d">-</div></div>
        <div class="kpi"><div class="kpi-label" style="color:#e74c3c">SHORT</div><div class="kpi-value" style="color:#e74c3c" id="short-c">0</div><div class="kpi-sub" id="short-d">-</div></div>
        <div class="kpi"><div class="kpi-label">‚ö° Aktif</div><div class="kpi-value" style="color:#f39c12" id="active">0</div></div>
        <div class="kpi"><div class="kpi-label">üö™ √áƒ±kƒ±≈ü</div><div class="kpi-value" id="exit">--</div></div>
    </div>
    
    <div class="section">
        <div class="section-title">‚öîÔ∏è Aktif Pozisyonlar</div>
        <table><thead><tr><th>Coin</th><th>Y√∂n</th><th>Giri≈ü</th><th>≈ûuanki</th><th>SL/TP</th><th>K/Z</th><th>1H Trend</th><th>Durum</th></tr></thead><tbody id="active-tb"></tbody></table>
    </div>
    
    <div class="two-col">
        <div class="section"><div class="section-title">üìú Son ƒ∞≈ülemler</div><table><thead><tr><th>Coin</th><th>Y√∂n</th><th>Sonu√ß</th><th>K/Z</th><th>√áƒ±kƒ±≈ü</th></tr></thead><tbody id="hist-tb"></tbody></table></div>
        <div class="section"><div class="section-title">üö´ Red Sebepleri</div><div id="rej" style="display:grid;grid-template-columns:repeat(auto-fit,minmax(80px,1fr));gap:4px"></div></div>
    </div>
</div>
<script>
function fmt(n){return n>1?n.toFixed(4):n.toFixed(6)}
function trendClass(t){return t.includes('YUKARI')?'trend-up':t.includes('A≈ûAƒûI')?'trend-down':'trend-neutral';}
async function upd(){
try{
const r=await fetch('/api/data');const d=await r.json();
document.getElementById('scan-info').innerText=(d.total_scans||0)+' tarama ‚Ä¢ '+(d.signals_generated||0)+' sinyal';

// Market data
const m=d.market||{};
document.getElementById('btc-price').innerText='$'+(m.btc_price||0).toLocaleString();
document.getElementById('btc-1h').innerText=m.btc_trend_1h||'--';document.getElementById('btc-1h').className='market-value '+trendClass(m.btc_trend_1h||'');
document.getElementById('btc-4h').innerText=m.btc_trend_4h||'--';document.getElementById('btc-4h').className='market-value '+trendClass(m.btc_trend_4h||'');
document.getElementById('btc-1d').innerText=m.btc_trend_1d||'--';document.getElementById('btc-1d').className='market-value '+trendClass(m.btc_trend_1d||'');
const ch1h=m.btc_change_1h||0;document.getElementById('btc-ch1h').innerText=(ch1h>=0?'+':'')+ch1h.toFixed(2)+'%';document.getElementById('btc-ch1h').className='market-value '+(ch1h>=0?'trend-up':'trend-down');
const ch24h=m.btc_change_24h||0;document.getElementById('btc-ch24h').innerText=(ch24h>=0?'+':'')+ch24h.toFixed(2)+'%';document.getElementById('btc-ch24h').className='market-value '+(ch24h>=0?'trend-up':'trend-down');
document.getElementById('regime').innerText=m.market_regime||'--';document.getElementById('regime').className='regime-value '+trendClass(m.market_regime||'');
const ad=m.allowed_direction||'BOTH';
let adClass='dir-both',adText='‚ÜïÔ∏è LONG & SHORT';
if(ad==='LONG_ONLY'){adClass='dir-long';adText='‚Üë SADECE LONG';}
else if(ad==='SHORT_ONLY'){adClass='dir-short';adText='‚Üì SADECE SHORT';}
document.getElementById('allowed-dir').innerText=adText;document.getElementById('allowed-dir').className='direction-allowed '+adClass;
document.getElementById('trend-blocked').innerText=d.stats?.blocked_by_trend||0;

const s=d.stats||{};const t=(s.win||0)+(s.loss||0);const wr=t>0?((s.win/t)*100):0;
document.getElementById('pnl').innerText='%'+(s.total_pnl||0).toFixed(2);document.getElementById('pnl').className='kpi-value '+((s.total_pnl||0)>=0?'win':'loss');
document.getElementById('trades').innerText=t+' i≈ülem';document.getElementById('wr').innerText=(t>0?wr.toFixed(1):'--')+'%';document.getElementById('wr-d').innerText=(s.win||0)+'K/'+(s.loss||0)+'Z';
const wins=d.history?.filter(x=>x.result==='WIN').map(x=>x.pnl)||[];const losses=d.history?.filter(x=>x.result==='LOSS').map(x=>x.pnl)||[];
const tw=wins.reduce((a,b)=>a+b,0);const tl=Math.abs(losses.reduce((a,b)=>a+b,0));
document.getElementById('pf').innerText=tl>0?(tw/tl).toFixed(2):'--';
const lwr=s.long_count>0?((s.long_win/s.long_count)*100).toFixed(0):0;document.getElementById('long-c').innerText=(s.long_count||0);document.getElementById('long-d').innerText=(s.long_win||0)+'K|%'+lwr;
const swr=s.short_count>0?((s.short_win/s.short_count)*100).toFixed(0):0;document.getElementById('short-c').innerText=(s.short_count||0);document.getElementById('short-d').innerText=(s.short_win||0)+'K|%'+swr;
document.getElementById('exit').innerText='TP:'+(s.tp_count||0)+' T:'+(s.trail_count||0);

const at=d.active_trades||{};const ak=Object.keys(at);document.getElementById('active').innerText=ak.length;
const atb=document.getElementById('active-tb');
if(ak.length===0){atb.innerHTML='<tr><td colspan="8" class="empty">Sinyal bekleniyor...</td></tr>';}
else{let h='';for(const sym of ak){const p=at[sym];const pnl=p.direction==='LONG'?((p.current_price-p.entry_price)/p.entry_price)*100*p.leverage:((p.entry_price-p.current_price)/p.entry_price)*100*p.leverage;
const db=p.direction==='LONG'?'<span class="badge badge-long">LONG</span>':'<span class="badge badge-short">SHORT</span>';
let st='üî¥';if(p.is_trailing)st='üü¢T';else if(p.is_breakeven)st='üü°BE';
const tr1h=p.trend_1h||'-';
h+='<tr><td><b>'+sym+'</b> '+p.leverage+'x</td><td>'+db+'</td><td>'+fmt(p.entry_price)+'</td><td>'+fmt(p.current_price)+'</td><td><span class="loss">'+fmt(p.stop_loss)+'</span>/<span class="win">'+fmt(p.take_profit)+'</span></td><td class="'+(pnl>=0?'win':'loss')+'"><b>%'+pnl.toFixed(2)+'</b></td><td class="'+trendClass(tr1h)+'">'+tr1h+'</td><td>'+st+'</td></tr>';}atb.innerHTML=h;}

const hi=d.history||[];const htb=document.getElementById('hist-tb');
if(hi.length===0){htb.innerHTML='<tr><td colspan="5" class="empty">Hen√ºz i≈ülem yok</td></tr>';}
else{let h='';hi.slice().reverse().slice(0,10).forEach(x=>{h+='<tr><td><b>'+x.symbol+'</b></td><td>'+(x.direction==='LONG'?'<span class="badge badge-long">L</span>':'<span class="badge badge-short">S</span>')+'</td><td>'+(x.result==='WIN'?'<span class="badge" style="background:rgba(46,204,113,0.2);color:#2ecc71">K</span>':'<span class="badge" style="background:rgba(231,76,60,0.2);color:#e74c3c">Z</span>')+'</td><td class="'+(x.pnl>=0?'win':'loss')+'">%'+x.pnl.toFixed(2)+'</td><td style="opacity:0.5">'+(x.exit_reason||'-')+'</td></tr>';});htb.innerHTML=h;}

const rr=d.rejection_reasons||{};const rd=document.getElementById('rej');const rk=Object.keys(rr);
if(rk.length===0){rd.innerHTML='<div class="empty">-</div>';}
else{let h='';rk.sort((a,b)=>rr[b]-rr[a]).slice(0,12).forEach(k=>{h+='<div style="background:rgba(255,255,255,0.02);padding:5px;border-radius:4px;text-align:center"><div style="font-size:0.4rem;opacity:0.5">'+k+'</div><div style="font-size:0.8rem;font-weight:700">'+rr[k]+'</div></div>';});rd.innerHTML=h;}
}catch(e){console.error(e);}}
upd();setInterval(upd,2000);
</script>
</body>
</html>
"""

# ============================================================================
# DATABASE & HELPERS
# ============================================================================
def load_db():
    if os.path.exists(DB_FILE):
        try:
            with open(DB_FILE,'r') as f:
                d=json.load(f)
                return d if isinstance(d,list) else []
        except:return []
    return []

def save_to_db(rec):
    try:
        h=load_db();h.append(rec)
        if len(h)>1000:h=h[-1000:]
        with open(DB_FILE,'w') as f:json.dump(h,f,indent=2)
    except:pass

def get_exchange():
    try:
        ex=ccxt.binance({'enableRateLimit':True,'options':{'defaultType':'future'},'timeout':25000})
        ex.fetch_time()
        return ex
    except Exception as e:
        logger.error(f"Borsa:{e}")
        return None

def reject(sym,dir,reason):
    with data_lock:
        data_store['signals_rejected']+=1
        if reason not in data_store['rejection_reasons']:data_store['rejection_reasons'][reason]=0
        data_store['rejection_reasons'][reason]+=1

# ============================================================================
# MARKET ANALYSIS - BTC/ETH TREND
# ============================================================================
def analyze_market(ex):
    """
    BTC ve ETH'nin 1h, 4h, 1d trendlerini analiz et
    Piyasa rejimini belirle
    ƒ∞zin verilen y√∂n√º belirle
    """
    global last_market_update
    
    try:
        # BTC analizi
        btc_1h = ex.fetch_ohlcv('BTC/USDT', '1h', limit=100)
        btc_4h = ex.fetch_ohlcv('BTC/USDT', '4h', limit=50)
        btc_1d = ex.fetch_ohlcv('BTC/USDT', '1d', limit=30)
        
        df_1h = pd.DataFrame(btc_1h, columns=['ts','o','h','l','c','v'])
        df_4h = pd.DataFrame(btc_4h, columns=['ts','o','h','l','c','v'])
        df_1d = pd.DataFrame(btc_1d, columns=['ts','o','h','l','c','v'])
        
        # EMA hesapla
        df_1h['ema20'] = df_1h['c'].ewm(span=20).mean()
        df_1h['ema50'] = df_1h['c'].ewm(span=50).mean()
        df_4h['ema20'] = df_4h['c'].ewm(span=20).mean()
        df_4h['ema50'] = df_4h['c'].ewm(span=50).mean()
        df_1d['ema20'] = df_1d['c'].ewm(span=20).mean()
        df_1d['ema50'] = df_1d['c'].ewm(span=50).mean()
        
        btc_price = df_1h['c'].iloc[-1]
        
        # Trend belirleme fonksiyonu
        def get_trend(df):
            c = df['c'].iloc[-1]
            ema20 = df['ema20'].iloc[-1]
            ema50 = df['ema50'].iloc[-1]
            
            # Son 5 mumun deƒüi≈üimi
            change = ((c - df['c'].iloc[-6]) / df['c'].iloc[-6]) * 100
            
            if c > ema20 > ema50 and change > CONFIG['BTC_TREND_STRONG']:
                return "G√ú√áL√ú YUKARI", change
            elif c > ema20 and change > CONFIG['BTC_TREND_WEAK']:
                return "YUKARI", change
            elif c < ema20 < ema50 and change < -CONFIG['BTC_TREND_STRONG']:
                return "G√ú√áL√ú A≈ûAƒûI", change
            elif c < ema20 and change < -CONFIG['BTC_TREND_WEAK']:
                return "A≈ûAƒûI", change
            else:
                return "YATAY", change
        
        trend_1h, change_1h = get_trend(df_1h)
        trend_4h, change_4h = get_trend(df_4h)
        trend_1d, change_1d = get_trend(df_1d)
        
        # 24h deƒüi≈üim
        change_24h = ((btc_price - df_1d['c'].iloc[-2]) / df_1d['c'].iloc[-2]) * 100
        
        # Piyasa rejimi belirleme
        down_count = sum(1 for t in [trend_1h, trend_4h, trend_1d] if 'A≈ûAƒûI' in t)
        up_count = sum(1 for t in [trend_1h, trend_4h, trend_1d] if 'YUKARI' in t)
        
        if down_count >= 2:
            regime = "D√ú≈û√ú≈û TRENDƒ∞"
            allowed = "SHORT_ONLY"
        elif up_count >= 2:
            regime = "Y√úKSELI≈û TRENDƒ∞"
            allowed = "LONG_ONLY"
        else:
            regime = "KARASIZ"
            allowed = "BOTH"
        
        # G√ºncelle
        with data_lock:
            m = data_store['market']
            m['btc_price'] = btc_price
            m['btc_trend_1h'] = trend_1h
            m['btc_trend_4h'] = trend_4h
            m['btc_trend_1d'] = trend_1d
            m['btc_change_1h'] = round(change_1h, 2)
            m['btc_change_4h'] = round(change_4h, 2)
            m['btc_change_24h'] = round(change_24h, 2)
            m['market_regime'] = regime
            m['allowed_direction'] = allowed
            m['last_update'] = datetime.now().strftime('%H:%M:%S')
        
        last_market_update = time.time()
        
        logger.info(f"üìä Pƒ∞YASA: BTC ${btc_price:,.0f} | 1h:{trend_1h} | 4h:{trend_4h} | 1d:{trend_1d} | ‚Üí {allowed}")
        
        return allowed
        
    except Exception as e:
        logger.error(f"Market analiz hatasƒ±: {e}")
        return "BOTH"

def get_coin_trend_1h(ex, sym):
    """Coin'in 1h trendini al"""
    try:
        ohlcv = ex.fetch_ohlcv(f"{sym}/USDT", '1h', limit=30)
        df = pd.DataFrame(ohlcv, columns=['ts','o','h','l','c','v'])
        df['ema20'] = df['c'].ewm(span=20).mean()
        df['ema50'] = df['c'].ewm(span=50).mean()
        
        c = df['c'].iloc[-1]
        ema20 = df['ema20'].iloc[-1]
        ema50 = df['ema50'].iloc[-1]
        change = ((c - df['c'].iloc[-6]) / df['c'].iloc[-6]) * 100
        
        if c > ema20 > ema50:
            return "YUKARI", change
        elif c < ema20 < ema50:
            return "A≈ûAƒûI", change
        else:
            return "YATAY", change
    except:
        return "?", 0

# ============================================================================
# INDICATORS & HELPERS
# ============================================================================
def calc_indicators(df):
    try:
        df['ema_fast'] = df.ta.ema(length=CONFIG['EMA_FAST'])
        df['ema_slow'] = df.ta.ema(length=CONFIG['EMA_SLOW'])
        df['ema_trend'] = df.ta.ema(length=CONFIG['EMA_TREND'])
        df['rsi'] = df.ta.rsi(length=CONFIG['RSI_LENGTH'])
        df['atr'] = df.ta.atr(length=CONFIG['ATR_LENGTH'])
        df['atr_pct'] = (df['atr'] / df['close']) * 100
        df['vol_ma'] = df['volume'].rolling(CONFIG['VOLUME_MA_LENGTH']).mean()
        df['vol_ratio'] = df['volume'] / df['vol_ma']
        return df
    except:
        return df

def calc_tp_sl(entry, dir, atr):
    fees = (CONFIG['TRADING_FEE']*2) + CONFIG['SPREAD_BUFFER'] + CONFIG['SLIPPAGE_BUFFER']
    sl_d = atr * CONFIG['SL_ATR_MULT']
    tp_d = atr * CONFIG['TP_ATR_MULT']
    sl_adj = sl_d + (entry * fees)
    if dir == "LONG":
        sl = entry - sl_adj
        tp = entry + tp_d
    else:
        sl = entry + sl_adj
        tp = entry - tp_d
    rr = tp_d / sl_adj if sl_adj > 0 else 0
    return tp, sl, rr

def update_trail(t, curr):
    if not CONFIG['ENABLE_TRAILING']:
        return t['stop_loss'], t['is_breakeven'], t['is_trailing']
    
    entry = t['entry_price']
    dir = t['direction']
    sl = t['stop_loss']
    is_be = t['is_breakeven']
    is_tr = t['is_trailing']
    fee = entry * (CONFIG['TRADING_FEE']*2 + CONFIG['SPREAD_BUFFER'])
    
    if dir == "LONG":
        pr = (curr - entry) / entry
        if pr >= CONFIG['BE_ACTIVATION'] and not is_be:
            ns = entry + fee
            if ns > sl:
                logger.info(f"üü° {t['symbol']} BE +{pr*100:.2f}%")
                return ns, True, is_tr
        if pr >= CONFIG['TRAILING_ACTIVATION']:
            tr = curr * CONFIG['TRAILING_DISTANCE']
            ns = curr - tr
            if ns > sl:
                if not is_tr:
                    logger.info(f"üü¢ {t['symbol']} TRAIL +{pr*100:.2f}%")
                return ns, is_be, True
    else:
        pr = (entry - curr) / entry
        if pr >= CONFIG['BE_ACTIVATION'] and not is_be:
            ns = entry - fee
            if ns < sl:
                logger.info(f"üü° {t['symbol']} BE +{pr*100:.2f}%")
                return ns, True, is_tr
        if pr >= CONFIG['TRAILING_ACTIVATION']:
            tr = curr * CONFIG['TRAILING_DISTANCE']
            ns = curr + tr
            if ns < sl:
                if not is_tr:
                    logger.info(f"üü¢ {t['symbol']} TRAIL +{pr*100:.2f}%")
                return ns, is_be, True
    
    return sl, is_be, is_tr

# ============================================================================
# V34 ANALYSIS - SMART MARKET AWARE
# ============================================================================
def analyze(ex, sym, allowed_direction):
    now = time.time()
    if sym in last_signal_time and now - last_signal_time[sym] < CONFIG['SIGNAL_COOLDOWN']:
        return
    
    try:
        pair = f"{sym}/USDT"
        
        # Min price kontrol√º
        tk = ex.fetch_ticker(pair)
        current_price = tk['last']
        if current_price < CONFIG['MIN_PRICE_USDT']:
            reject(sym, "?", "DUSUK_FIYAT")
            return
        
        # 5m veri
        ohlcv = ex.fetch_ohlcv(pair, CONFIG['TIMEFRAME'], limit=150)
        if not ohlcv or len(ohlcv) < 100:
            return
        
        df = pd.DataFrame(ohlcv, columns=['timestamp','open','high','low','close','volume'])
        df = calc_indicators(df)
        
        close = df['close'].iloc[-1]
        ema_trend = df['ema_trend'].iloc[-1]
        rsi = df['rsi'].iloc[-1]
        vol_r = df['vol_ratio'].iloc[-1]
        atr = df['atr'].iloc[-1]
        
        if pd.isna(ema_trend) or pd.isna(rsi) or pd.isna(atr) or atr <= 0:
            return
        
        ema_d = ((close - ema_trend) / ema_trend) * 100
        
        # Coin'in 1h trendi
        coin_trend_1h, coin_change_1h = get_coin_trend_1h(ex, sym)
        
        signal = None
        
        # ============================================================
        # LONG Sƒ∞NYALƒ∞
        # ============================================================
        if ema_d < 0:
            ad = abs(ema_d)
            
            # TREND KONTROL√ú - EN √ñNEMLƒ∞!
            if allowed_direction == "SHORT_ONLY":
                with data_lock:
                    data_store['stats']['blocked_by_trend'] += 1
                reject(sym, "LONG", "TREND_A≈ûAƒûI_LONG_YASAK")
                return
            
            # Coin 1h trendi a≈üaƒüƒ±ysa LONG a√ßma
            if coin_trend_1h == "A≈ûAƒûI":
                reject(sym, "LONG", "COIN_1H_A≈ûAƒûI")
                return
            
            # EMA kontrol√º
            if ad < CONFIG['LONG_EMA_MIN']:
                reject(sym, "LONG", "L_EMA_YAKIN")
                return
            if ad > CONFIG['LONG_EMA_MAX']:
                reject(sym, "LONG", "L_EMA_UZAK")
                return
            
            # RSI kontrol√º
            if rsi > CONFIG['LONG_RSI_MAX']:
                reject(sym, "LONG", "L_RSI_YUKSEK")
                return
            if rsi < CONFIG['LONG_RSI_MIN']:
                reject(sym, "LONG", "L_RSI_DUSUK")
                return
            
            # Hacim kontrol√º
            if pd.notna(vol_r) and vol_r < CONFIG['LONG_VOLUME_MIN']:
                reject(sym, "LONG", "L_HACIM")
                return
            
            signal = "LONG"
        
        # ============================================================
        # SHORT Sƒ∞NYALƒ∞
        # ============================================================
        elif ema_d > 0:
            ad = abs(ema_d)
            
            # TREND KONTROL√ú - EN √ñNEMLƒ∞!
            if allowed_direction == "LONG_ONLY":
                with data_lock:
                    data_store['stats']['blocked_by_trend'] += 1
                reject(sym, "SHORT", "TREND_YUKARI_SHORT_YASAK")
                return
            
            # Coin 1h trendi yukarƒ±ysa SHORT a√ßma
            if coin_trend_1h == "YUKARI":
                reject(sym, "SHORT", "COIN_1H_YUKARI")
                return
            
            # EMA kontrol√º
            if ad < CONFIG['SHORT_EMA_MIN']:
                reject(sym, "SHORT", "S_EMA_YAKIN")
                return
            if ad > CONFIG['SHORT_EMA_MAX']:
                reject(sym, "SHORT", "S_EMA_UZAK")
                return
            
            # RSI kontrol√º
            if rsi < CONFIG['SHORT_RSI_MIN']:
                reject(sym, "SHORT", "S_RSI_DUSUK")
                return
            if rsi > CONFIG['SHORT_RSI_MAX']:
                reject(sym, "SHORT", "S_RSI_ASIRI")
                return
            
            # Hacim kontrol√º
            if pd.notna(vol_r) and vol_r < CONFIG['SHORT_VOLUME_MIN']:
                reject(sym, "SHORT", "S_HACIM")
                return
            
            signal = "SHORT"
        
        if signal is None:
            return
        
        # TP/SL hesapla
        tp, sl, rr = calc_tp_sl(close, signal, atr)
        
        # R:R kontrol√º
        if rr < CONFIG['MIN_RR_RATIO']:
            reject(sym, signal, "RR_DUSUK")
            return
        
        # Expected loss kontrol√º
        if signal == "LONG":
            sl_dist_frac = (close - sl) / close
        else:
            sl_dist_frac = (sl - close) / close
        
        # Leverage belirleme - trend ile uyumlu mu?
        if allowed_direction == "BOTH":
            lev = CONFIG['LEVERAGE_COUNTER_TREND']
        else:
            lev = CONFIG['LEVERAGE_TREND_ALIGNED']
        
        expected_loss = sl_dist_frac * lev * 100
        
        if expected_loss > CONFIG['MAX_ALLOWED_LOSS_PER_TRADE']:
            max_lev = int(CONFIG['MAX_ALLOWED_LOSS_PER_TRADE'] / (sl_dist_frac * 100))
            if max_lev < 1:
                reject(sym, signal, "EXPECTED_LOSS_BUYUK")
                return
            lev = max_lev
            expected_loss = sl_dist_frac * lev * 100
        
        expected_pnl = ((tp - close) / close if signal == "LONG" else (close - tp) / close) * 100 * lev
        
        # Pozisyon limitleri
        with data_lock:
            act = data_store['active_trades']
            if len(act) >= CONFIG['MAX_OPEN_TRADES']:
                reject(sym, signal, "MAX_POZ")
                return
            sd = sum(1 for t in act.values() if t['direction'] == signal)
            if sd >= CONFIG['MAX_SAME_DIRECTION']:
                reject(sym, signal, "MAX_YON")
                return
            if sym in act:
                reject(sym, signal, "ACIK")
                return
        
        # Sƒ∞NYAL KABUL!
        ed = {
            "rsi": round(rsi, 1),
            "ema_dist_pct": round(ema_d, 2),
            "volume_ratio": round(vol_r, 2) if pd.notna(vol_r) else 0,
            "coin_trend_1h": coin_trend_1h,
            "coin_change_1h": round(coin_change_1h, 2),
            "market_regime": data_store['market']['market_regime']
        }
        
        with data_lock:
            data_store['active_trades'][sym] = {
                'symbol': sym,
                'direction': signal,
                'entry_price': close,
                'current_price': close,
                'stop_loss': sl,
                'take_profit': tp,
                'leverage': lev,
                'rr_ratio': rr,
                'expected_pnl': round(expected_pnl, 2),
                'expected_loss': round(expected_loss, 2),
                'trend_1h': coin_trend_1h,
                'best_price': close,
                'worst_price': close,
                'is_breakeven': False,
                'is_trailing': False,
                'entry_data': ed,
                'entry_time': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                'entry_timestamp': time.time()
            }
            data_store['signals_generated'] += 1
        
        last_signal_time[sym] = now
        
        yon = "üü¢ ALI≈û" if signal == "LONG" else "üî¥ SATI≈û"
        regime = data_store['market']['market_regime']
        logger.info("="*70)
        logger.info(f"{yon}: {sym} | RSI:{rsi:.1f} | EMA:{ema_d:.2f}% | 1H:{coin_trend_1h}")
        logger.info(f"   Piyasa: {regime} | Lev:{lev}x | R:R=1:{rr:.2f}")
        logger.info(f"   G:{close:.6f} TP:{tp:.6f} SL:{sl:.6f}")
        logger.info("="*70)
        
    except Exception as e:
        logger.warning(f"{sym}: {e}")

# ============================================================================
# TRADE MANAGEMENT
# ============================================================================
def update_trades(ex):
    with data_lock:
        syms = list(data_store['active_trades'].keys())
    
    for sym in syms:
        try:
            tk = ex.fetch_ticker(f"{sym}/USDT")
            curr = tk['last']
            
            with data_lock:
                if sym not in data_store['active_trades']:
                    continue
                t = data_store['active_trades'][sym]
                t['current_price'] = curr
                
                if t['direction'] == 'LONG':
                    if curr > t['best_price']:
                        t['best_price'] = curr
                    if curr < t['worst_price']:
                        t['worst_price'] = curr
                else:
                    if curr < t['best_price']:
                        t['best_price'] = curr
                    if curr > t['worst_price']:
                        t['worst_price'] = curr
                
                ns, ib, it = update_trail(t, curr)
                t['stop_loss'] = ns
                t['is_breakeven'] = ib
                t['is_trailing'] = it
                
                er = None
                if t['direction'] == 'LONG':
                    if curr <= t['stop_loss']:
                        er = 'TRAIL' if t['is_trailing'] else ('BE' if t['is_breakeven'] else 'SL')
                    elif curr >= t['take_profit']:
                        er = 'TP'
                else:
                    if curr >= t['stop_loss']:
                        er = 'TRAIL' if t['is_trailing'] else ('BE' if t['is_breakeven'] else 'SL')
                    elif curr <= t['take_profit']:
                        er = 'TP'
                
                if er:
                    close_trade(sym, curr, er)
        except:
            pass

def close_trade(sym, exit_p, er):
    with data_lock:
        if sym not in data_store['active_trades']:
            return
        t = data_store['active_trades'].pop(sym)
        
        entry = t['entry_price']
        dir = t['direction']
        lev = t['leverage']
        
        if dir == 'LONG':
            raw = ((exit_p - entry) / entry) * 100
        else:
            raw = ((entry - exit_p) / entry) * 100
        
        pnl = raw * lev
        res = 'WIN' if pnl > 0 else 'LOSS'
        if er == 'TP':
            res = 'WIN'
        
        rec = {
            'symbol': sym,
            'direction': dir,
            'result': res,
            'pnl': round(pnl, 2),
            'entry_price': entry,
            'exit_price': exit_p,
            'exit_reason': er,
            'leverage': lev,
            'entry_data': t['entry_data'],
            'duration_seconds': int(time.time() - t['entry_timestamp']),
            'timestamp': datetime.now().strftime('%H:%M:%S')
        }
        
        save_to_db(rec)
        data_store['history'].append(rec)
        if len(data_store['history']) > 500:
            data_store['history'] = data_store['history'][-500:]
        
        s = data_store['stats']
        if dir == 'LONG':
            s['long_count'] += 1
            s['long_pnl'] += pnl
            if res == 'WIN':
                s['long_win'] += 1
        else:
            s['short_count'] += 1
            s['short_pnl'] += pnl
            if res == 'WIN':
                s['short_win'] += 1
        
        if res == 'WIN':
            s['win'] += 1
        else:
            s['loss'] += 1
        
        s['total_pnl'] += pnl
        
        if er == 'TP':
            s['tp_count'] += 1
        elif er == 'BE':
            s['be_count'] += 1
        elif er == 'TRAIL':
            s['trail_count'] += 1
        else:
            s['stop_count'] += 1
        
        ic = "‚úÖ" if res == 'WIN' else "‚ùå"
        regime = t['entry_data'].get('market_regime', '-')
        logger.info(f"{ic} {sym} {dir} {er} %{pnl:+.2f} | Piyasa: {regime}")

# ============================================================================
# MAIN LOOP
# ============================================================================
def main_loop():
    global should_exit, last_market_update
    
    ex = get_exchange()
    if not ex:
        logger.error("‚ùå Borsa baƒülantƒ±sƒ± yok")
        return
    
    # Load history
    db = load_db()
    with data_lock:
        data_store['history'] = db[-500:]
        for t in db:
            s = data_store['stats']
            d = t.get('direction', 'LONG')
            if d == 'LONG':
                s['long_count'] += 1
                s['long_pnl'] += t['pnl']
                if t['result'] == 'WIN':
                    s['long_win'] += 1
            else:
                s['short_count'] += 1
                s['short_pnl'] += t['pnl']
                if t['result'] == 'WIN':
                    s['short_win'] += 1
            if t['result'] == 'WIN':
                s['win'] += 1
            else:
                s['loss'] += 1
            s['total_pnl'] += t['pnl']
            er = t.get('exit_reason', 'SL')
            if er == 'TP':
                s['tp_count'] += 1
            elif er == 'BE':
                s['be_count'] += 1
            elif er == 'TRAIL':
                s['trail_count'] += 1
            else:
                s['stop_count'] += 1
    
    logger.info(f"‚úÖ V34 ba≈ülatƒ±ldƒ±! {len(db)} ge√ßmi≈ü i≈ülem")
    
    # ƒ∞lk piyasa analizi
    allowed_direction = analyze_market(ex)
    
    while not should_exit:
        try:
            # Piyasa g√ºncellemesi (her 60 saniye)
            if time.time() - last_market_update > CONFIG['MARKET_UPDATE_INTERVAL']:
                allowed_direction = analyze_market(ex)
            
            # Aktif i≈ülemleri g√ºncelle
            update_trades(ex)
            
            # Coin listesi
            tks = ex.fetch_tickers()
            coins = []
            for sym, tk in tks.items():
                if '/USDT' not in sym:
                    continue
                vol = tk.get('quoteVolume', 0)
                if vol < CONFIG['MIN_VOLUME_USDT']:
                    continue
                coin = sym.split('/')[0]
                if any(x in coin for x in IGNORED_COINS):
                    continue
                if any(d.isdigit() for d in coin):
                    continue
                coins.append((coin, vol))
            
            coins.sort(key=lambda x: x[1], reverse=True)
            top = [c[0] for c in coins[:CONFIG['CHECK_LIMIT']]]
            
            with data_lock:
                data_store['total_scans'] += 1
                data_store['last_update'] = datetime.now().strftime('%H:%M:%S')
            
            for sym in top:
                if should_exit:
                    break
                analyze(ex, sym, allowed_direction)
                time.sleep(CONFIG['SLEEP_BETWEEN_COINS'])
            
            time.sleep(CONFIG['LOOP_SLEEP'])
            
        except Exception as e:
            logger.error(f"Loop hatasƒ±: {e}")
            time.sleep(10)

def shutdown(sig, frame):
    global should_exit
    should_exit = True
    logger.info("\nüõë Kapatƒ±lƒ±yor...")
    with data_lock:
        s = data_store['stats']
        tot = s['win'] + s['loss']
        wr = (s['win'] / tot * 100) if tot > 0 else 0
        logger.info(f"üìä Toplam: %{s['total_pnl']:+.2f} | {tot} i≈ülem | %{wr:.1f} WR")
        logger.info(f"üö´ Trend ile engellenen: {s['blocked_by_trend']} sinyal")
    sys.exit(0)

# ============================================================================
# FLASK
# ============================================================================
@app.route('/')
def index():
    return render_template_string(HTML_TEMPLATE)

@app.route('/api/data')
def api_data():
    with data_lock:
        return jsonify({
            "active_trades": copy.deepcopy(data_store['active_trades']),
            "history": list(data_store['history'][-50:]),
            "stats": copy.deepcopy(data_store['stats']),
            "market": copy.deepcopy(data_store['market']),
            "total_scans": data_store['total_scans'],
            "signals_generated": data_store['signals_generated'],
            "signals_rejected": data_store['signals_rejected'],
            "rejection_reasons": dict(data_store['rejection_reasons']),
            "last_update": data_store['last_update']
        })

@app.route('/health')
def health():
    with data_lock:
        s = data_store['stats']
        m = data_store['market']
        t = s['win'] + s['loss']
        return jsonify({
            "status": "ok",
            "version": "V34-SMART",
            "market_regime": m['market_regime'],
            "allowed_direction": m['allowed_direction'],
            "btc_price": m['btc_price'],
            "trades": t,
            "wr": round((s['win']/t*100), 1) if t > 0 else 0,
            "pnl": round(s['total_pnl'], 2)
        })

# ============================================================================
# MAIN
# ============================================================================
if __name__ == "__main__":
    signal.signal(signal.SIGINT, shutdown)
    signal.signal(signal.SIGTERM, shutdown)
    
    print("\n" + "="*75)
    print("üß† PROTRADE V34 - SMART MARKET ANALYSIS")
    print("="*75)
    print("\nüìä YENƒ∞: Akƒ±llƒ± Piyasa Analizi")
    print("")
    print("   üîç MULTI-TIMEFRAME ANALƒ∞Z:")
    print("   ‚îú‚îÄ BTC 1H trend takibi")
    print("   ‚îú‚îÄ BTC 4H trend takibi")
    print("   ‚îú‚îÄ BTC 1D trend takibi")
    print("   ‚îî‚îÄ Coin 1H trend onayƒ±")
    print("")
    print("   üéØ AKILLI KARAR:")
    print("   ‚îú‚îÄ BTC D√ú≈û√úYOR ‚Üí LONG YASAK, sadece SHORT")
    print("   ‚îú‚îÄ BTC YUKARI  ‚Üí SHORT YASAK, sadece LONG")
    print("   ‚îî‚îÄ BTC YATAY   ‚Üí Her iki y√∂n (dikkatli)")
    print("")
    print("   üõ°Ô∏è G√úVENLƒ∞K:")
    print("   ‚îú‚îÄ Trend ile uyumsuz sinyaller ENGELLENƒ∞R")
    print("   ‚îú‚îÄ Coin 1H trendi de kontrol edilir")
    print("   ‚îú‚îÄ Max kayƒ±p: %5")
    print("   ‚îî‚îÄ Daha sƒ±kƒ± RSI/EMA filtreleri")
    print("")
    print("="*75)
    print("üåê Dashboard: http://localhost:5005")
    print("="*75 + "\n")
    
    t = threading.Thread(target=main_loop, daemon=True)
    t.start()
    
    app.run(debug=False, port=5005, host='0.0.0.0', threaded=True)