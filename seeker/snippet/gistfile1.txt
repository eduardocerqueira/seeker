#date: 2025-05-22T17:13:21Z
#url: https://api.github.com/gists/88e02e641ddd99bd1c49dcbd4f71c30a
#owner: https://api.github.com/users/nullenc0de

#!/usr/bin/env python3
"""
Authentication Bypass Automation Tool
Combines URLfinder with automated authentication bypass testing
"""

import subprocess
import requests
import json
import re
import time
import argparse
from urllib.parse import urlparse, urljoin
from concurrent.futures import ThreadPoolExecutor, as_completed
import logging
from typing import List, Dict, Set
import urllib3

# Disable SSL warnings and certificate verification warnings
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
requests.packages.urllib3.disable_warnings()

# Configure logging to suppress certificate warnings
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# Suppress specific certificate warnings
logging.getLogger("urllib3.connectionpool").setLevel(logging.ERROR)
logging.getLogger("requests.packages.urllib3").setLevel(logging.ERROR)

class AuthBypassTester:
    def __init__(self, domain: str, threads: int = 10, timeout: int = 10):
        self.domain = domain
        self.threads = threads
        self.timeout = timeout
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        })
        # Disable SSL verification to avoid certificate warnings
        self.session.verify = False
        
        # Expanded response indicators for any API data that might control access
        self.bypass_indicators = [
            # Authentication status
            'authenticated', 'logged_in', 'isAuthenticated', 'user_authenticated', 
            'auth_status', 'login_status', 'authorized', 'session_valid', 'loggedIn',
            
            # Access control
            'access_granted', 'has_access', 'allowed', 'permitted', 'can_access',
            'is_authorized', 'access_level', 'permission_granted',
            
            # User status
            'active', 'enabled', 'valid', 'verified', 'approved', 'confirmed',
            'is_active', 'is_enabled', 'is_valid', 'is_verified',
            
            # Subscription/License status
            'subscribed', 'premium', 'licensed', 'paid', 'trial_expired',
            'subscription_active', 'license_valid', 'account_active',
            
            # Feature flags
            'feature_enabled', 'beta_access', 'admin_access', 'demo_mode',
            'maintenance_mode', 'read_only', 'restricted'
        ]
        
        self.found_urls = set()
        self.vulnerable_endpoints = []

    def run_urlfinder(self) -> List[str]:
        """Run URLfinder to discover URLs for the target domain"""
        logger.info(f"Running URLfinder for domain: {self.domain}")
        
        try:
            # Run urlfinder with JSON output
            cmd = ['urlfinder', '-d', self.domain, '-j', '-silent']
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=600)
            
            if result.returncode != 0:
                logger.error(f"URLfinder failed: {result.stderr}")
                return []
            
            urls = []
            for line in result.stdout.strip().split('\n'):
                if line.strip():
                    try:
                        data = json.loads(line)
                        urls.append(data['url'])
                    except json.JSONDecodeError:
                        # Handle non-JSON lines (might be regular output)
                        if line.startswith('http'):
                            urls.append(line.strip())
            
            logger.info(f"Found {len(urls)} URLs from URLfinder")
            return urls
            
        except subprocess.TimeoutExpired:
            logger.error("URLfinder timed out after 10 minutes")
            return []
        except FileNotFoundError:
            logger.error("URLfinder not found. Make sure it's installed and in PATH")
            return []

    def filter_api_endpoints(self, urls: List[str]) -> List[str]:
        """Filter URLs that are API endpoints (prioritized and filtered)"""
        api_urls = []
        
        # Skip common false positive patterns
        skip_patterns = [
            r'/wp-json/wp/v2/',
            r'/job/\d+/',
            r'\.js$',
            r'\.css$',
            r'/404\?',
            r'/gtm\.js',
            r'/gtm\.start',
            r'noticeError/called',
            r'\.(jpg|jpeg|png|gif|svg|ico|webp)(\?.*)?$',
            r'\.(ttf|eot|woff|woff2|otf)(\?.*)?$',
            r'\.(css|scss|less)(\?.*)?$',
            r'\.pdf(\?.*)?$',
            r'/images?/',
            r'/fonts?/',
            r'/static/',
            r'/assets/',
            r'/css/',
            r'\.min\.(js|css)(\?.*)?$',
            r'/demandware\.static/',
            r'\.gif(\?.*)?$',
        ]
        
        # High priority patterns (test these first)
        priority_patterns = [
            r'/api/(?!.*/(gtm|noticeError))',
            r'/v\d+/(?!.*wp)',
            r'developers\.',
            r'/apispecs/',
            r'\.json$',
            r'/graphql',
            r'/rest/(?!.*wp)',
            r'/jwks\.json',
        ]
        
        # Regular API patterns
        regular_patterns = [
            r'/ajax/',
            r'/services/',
            r'/internal/',
            r'/private/',
            r'/admin/api/',
            r'/configuration/',
            r'/manifest\.json$',
        ]
        
        # First, collect high priority endpoints
        priority_urls = []
        regular_urls = []
        
        for url in urls:
            # Skip known false positive patterns
            if any(re.search(pattern, url, re.IGNORECASE) for pattern in skip_patterns):
                continue
                
            # Additional filter: Skip if it looks like a static asset with parameters
            if re.search(r'\.(jpg|png|gif|svg|ttf|woff|css)\?sw=|sh=|v=', url, re.IGNORECASE):
                continue
                
            # Check for high priority patterns
            is_priority = any(re.search(pattern, url, re.IGNORECASE) for pattern in priority_patterns)
            is_regular = any(re.search(pattern, url, re.IGNORECASE) for pattern in regular_patterns)
            
            # Special handling for .well-known URLs
            if '.well-known/' in url:
                # Quick test to see if this returns HTML (indicating 404/error page)
                try:
                    test_response = requests.get(url, timeout=5, verify=False)
                    if (test_response.status_code == 200 and 
                        not (test_response.text.lower().startswith('<!doctype html>') or 
                             '<html' in test_response.text.lower()[:100])):
                        is_priority = True  # Only include if it returns actual content, not HTML
                    else:
                        continue  # Skip - this is returning HTML error page or non-200 status
                except:
                    continue  # Skip if we can't test it
            
            # Special handling for JSON files - only include if they're actually config files
            elif url.endswith('.json'):
                # Include if it's in config or API directories (well-known already handled above)
                if any(keyword in url.lower() for keyword in ['config', 'api', 'manifest', 'jwks']):
                    # But exclude if it's clearly in a static directory
                    if not any(static_dir in url.lower() for static_dir in ['static', 'assets', 'images', 'css']):
                        is_priority = True
                else:
                    continue  # Skip other JSON files
            
            if is_priority:
                priority_urls.append(url)
            elif is_regular:
                regular_urls.append(url)
        
        # Combine with priority first, test all relevant endpoints
        api_urls = priority_urls + regular_urls
        
        # Remove duplicates while preserving order
        seen = set()
        filtered_api_urls = []
        for url in api_urls:
            if url not in seen:
                seen.add(url)
                filtered_api_urls.append(url)
        
        logger.info(f"Found {len(filtered_api_urls)} potential API endpoints (Priority: {len(priority_urls)}, Regular: {len(regular_urls)})")
        logger.info(f"Filtered out static assets and non-API endpoints")
        return filtered_api_urls

    def test_endpoint_bypass(self, url: str) -> Dict:
        """Test a single endpoint for multiple authentication bypass techniques"""
        results = []
        
        try:
            # Test 1: Response Manipulation (original technique)
            response_manip = self.test_response_manipulation(url)
            if response_manip['vulnerable']:
                results.append(response_manip)
            
            # Test 2: Missing Authentication
            missing_auth = self.test_missing_authentication(url)
            if missing_auth['vulnerable']:
                results.append(missing_auth)
            
            # Test 3: IDOR (parameter manipulation)
            idor_test = self.test_idor_vulnerability(url)
            if idor_test['vulnerable']:
                results.append(idor_test)
            
            # Test 4: "**********"
            weak_token = "**********"
 "**********"  "**********"  "**********"  "**********"  "**********"  "**********"  "**********"  "**********"  "**********"  "**********"  "**********"  "**********"  "**********"i "**********"f "**********"  "**********"w "**********"e "**********"a "**********"k "**********"_ "**********"t "**********"o "**********"k "**********"e "**********"n "**********"[ "**********"' "**********"v "**********"u "**********"l "**********"n "**********"e "**********"r "**********"a "**********"b "**********"l "**********"e "**********"' "**********"] "**********": "**********"
                results.append(weak_token)
            
            # Test 5: Privilege Escalation
            priv_esc = self.test_privilege_escalation(url)
            if priv_esc['vulnerable']:
                results.append(priv_esc)
            
            # Test 6: HTTP Method Access Control
            method_bypass = self.test_http_method_bypass(url)
            if method_bypass['vulnerable']:
                results.append(method_bypass)
            
            # Test 7: Information Disclosure
            info_disclosure = self.test_information_disclosure(url)
            if info_disclosure['vulnerable']:
                results.append(info_disclosure)
            
            # Test 8: CORS Misconfiguration
            cors_test = self.test_cors_misconfiguration(url)
            if cors_test['vulnerable']:
                results.append(cors_test)
            
            # Test 9: Error Message Analysis
            error_analysis = self.test_error_message_disclosure(url)
            if error_analysis['vulnerable']:
                results.append(error_analysis)
            
            if results:
                return {'vulnerable': True, 'url': url, 'vulnerabilities': results}
            else:
                return {'vulnerable': False, 'url': url}
                
        except Exception as e:
            logger.debug(f"Error testing {url}: {e}")
            return {'vulnerable': False, 'url': url, 'error': str(e)}

    def test_response_manipulation(self, url: str) -> Dict:
        """Test 1: Response Manipulation Bypass"""
        try:
            response = self.session.get(url, timeout=self.timeout, allow_redirects=False)
            
            # Check if it's a JSON API endpoint
            if 'application/json' in response.headers.get('content-type', ''):
                return self.test_json_manipulation(url, response)
            
            # Check for redirect to SSO/login
            if response.status_code in [301, 302, 303, 307, 308]:
                location = response.headers.get('location', '')
                if any(keyword in location.lower() for keyword in ['login', 'auth', 'sso']):
                    return {
                        'vulnerable': True,
                        'method': 'Response Manipulation - Redirect Bypass',
                        'details': f'Redirects to: {location}',
                        'exploitation': 'Intercept response and remove Location header'
                    }
            
            return {'vulnerable': False}
            
        except Exception as e:
            return {'vulnerable': False, 'error': str(e)}

    def test_missing_authentication(self, url: str) -> Dict:
        """Test 2: Missing Authentication on Sensitive Endpoint"""
        try:
            # Skip common false positives
            if any(pattern in url.lower() for pattern in [
                'wp-json/wp/v2/tags', 'wp-json/wp/v2/pages', 'wp-json/wp/v2/comments',
                'wp-json/wp/v2/users', 'wp-json/wp/v2/media', '/job/', '/events/'
            ]):
                return {'vulnerable': False}
            
            # Test completely unauthenticated request
            clean_session = requests.Session()
            clean_session.verify = False
            response = clean_session.get(url, timeout=self.timeout)
            
            if response.status_code == 200:
                content = response.text.lower()
                content_length = len(response.text)
                
                # Check if this is actually an HTML error page or redirect page
                if content.startswith('<!doctype html>') or '<html' in content[:100]:
                    # This is an HTML page, not a configuration file
                    return {'vulnerable': False}
                
                # High-value sensitive patterns
                critical_patterns = [
                    'api_key', 'secret_key', 'access_token', 'private_key', 'password',
                    'connection_string', 'database_url', 'jwt', 'bearer', 'oauth'
                ]
                
                # API specification patterns
                spec_patterns = [
                    'swagger', 'openapi', 'api-spec', 'endpoints', 'schemas'
                ]
                
                # Configuration patterns
                config_patterns = [
                    'config', 'settings', 'environment', 'credentials'
                ]
                
                has_critical_data = any(pattern in content for pattern in critical_patterns)
                has_spec_data = any(pattern in content for pattern in spec_patterns)
                has_config_data = any(pattern in content for pattern in config_patterns)
                
                # Check for structured sensitive data (must be actual JSON/config, not HTML)
                is_json_config = (url.endswith('.json') and content_length > 100 and 
                                content.strip().startswith('{') and content.strip().endswith('}'))
                is_api_spec = ('spec' in url or 'swagger' in url or 'openapi' in url)
                
                # Only flag truly sensitive exposures
                if (content_length > 200 and 
                    (has_critical_data or 
                     (is_api_spec and has_spec_data) or 
                     (is_json_config and has_config_data))):
                    
                    return {
                        'vulnerable': True,
                        'method': 'Missing Authentication - Sensitive Data Exposure',
                        'details': f'Critical endpoint accessible without authentication (Status: {response.status_code}, {content_length} chars)',
                        'exploitation': 'Direct access to sensitive configuration/API data',
                        'poc': f'curl -X GET "{url}"',
                        'response_sample': response.text[:300] + '...' if len(response.text) > 300 else response.text
                    }
            
            return {'vulnerable': False}
            
        except Exception as e:
            return {'vulnerable': False, 'error': str(e)}

    def test_idor_vulnerability(self, url: str) -> Dict:
        """Test 3: Insecure Direct Object Reference (IDOR)"""
        try:
            # Look for numeric IDs in URL
            id_patterns = [r'/(\d+)/?$', r'/(\d+)/', r'id=(\d+)', r'user=(\d+)']
            
            for pattern in id_patterns:
                match = re.search(pattern, url)
                if match:
                    original_id = match.group(1)
                    # Try different IDs
                    test_ids = [str(int(original_id) + 1), str(int(original_id) - 1), '1', '999', '0']
                    
                    for test_id in test_ids:
                        test_url = re.sub(pattern, f'/{test_id}/', url) if '/' in pattern else url.replace(f'={original_id}', f'={test_id}')
                        
                        response = self.session.get(test_url, timeout=self.timeout)
                        if response.status_code == 200 and len(response.text) > 100:
                            return {
                                'vulnerable': True,
                                'method': 'IDOR (Insecure Direct Object Reference)',
                                'details': f'ID {original_id} → {test_id} accessible',
                                'exploitation': f'Change ID parameter to access other users data'
                            }
            
            return {'vulnerable': False}
            
        except Exception as e:
            return {'vulnerable': False, 'error': str(e)}

    def test_weak_token_validation(self, url: "**********":
        """Test 4: "**********"
        try:
            # Skip static assets - they don't validate tokens by design
            static_extensions = r'\.(jpg|jpeg|png|gif|svg|ico|webp|ttf|eot|woff|woff2|css|js)(\?.*)?$'
            if re.search(static_extensions, url, re.IGNORECASE):
                return {'vulnerable': False}
                
            # First test normal request to establish baseline
            normal_response = self.session.get(url, timeout=self.timeout)
            
            # Skip if baseline response is HTML error page
            if normal_response.text.lower().startswith('<!doctype html>') or '<html' in normal_response.text.lower()[:100]:
                return {'vulnerable': False}
            
            # Test with invalid/tampered tokens
            invalid_tokens = "**********"
                'Bearer invalid_token',
                'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.invalid',
                'Bearer admin_token',
                'Bearer 123456'
            ]
            
 "**********"  "**********"  "**********"  "**********"  "**********"  "**********"  "**********"  "**********"  "**********"  "**********"  "**********"  "**********"  "**********"f "**********"o "**********"r "**********"  "**********"t "**********"o "**********"k "**********"e "**********"n "**********"  "**********"i "**********"n "**********"  "**********"i "**********"n "**********"v "**********"a "**********"l "**********"i "**********"d "**********"_ "**********"t "**********"o "**********"k "**********"e "**********"n "**********"s "**********": "**********"
                headers = {'Authorization': "**********"
                response = self.session.get(url, headers=headers, timeout=self.timeout)
                
                # Skip if response is HTML error page
                if response.text.lower().startswith('<!doctype html>') or '<html' in response.text.lower()[:100]:
                    continue
                
                # Only flag as vulnerable if it returns 200 AND different/substantial content
                if response.status_code == 200 and len(response.text) > 50:
                    # Check if the response is different from normal request (indicating it processed the token)
                    if response.text != normal_response.text or 'error' not in response.text.lower():
                        # Additional check: make sure this isn't just a static file
                        content_type = response.headers.get('content-type', '').lower()
                        if not any(static_type in content_type for static_type in ['image/', 'font/', 'text/css', 'text/html']):
                            return {
                                'vulnerable': True,
                                'method': "**********"
                                'details': "**********": "{token[:30]}..." (Status: {response.status_code})',
                                'exploitation': "**********"
                                'poc': "**********": {token}"',
                                'response_sample': response.text[:200] + '...' if len(response.text) > 200 else response.text
                            }
            
            return {'vulnerable': False}
            
        except Exception as e:
            return {'vulnerable': False, 'error': str(e)}

    def test_privilege_escalation(self, url: str) -> Dict:
        """Test 5: Privilege Escalation via Parameter Tampering"""
        try:
            # First get baseline response
            baseline_response = self.session.get(url, timeout=self.timeout)
            baseline_content = baseline_response.text.lower()
            
            # Test with privilege escalation parameters
            priv_params = [
                {'role': 'admin'},
                {'isAdmin': 'true'},
                {'user_id': '1'},
                {'admin': '1'},
                {'privilege': 'admin'},
                {'level': '999'}
            ]
            
            for params in priv_params:
                response = self.session.get(url, params=params, timeout=self.timeout)
                
                if response.status_code == 200:
                    content = response.text.lower()
                    
                    # Check if response suggests elevated privileges or is significantly different
                    admin_indicators = ['admin', 'administrator', 'root', 'superuser', 'privilege']
                    has_admin_content = any(indicator in content for indicator in admin_indicators)
                    content_changed = len(content) != len(baseline_content) or content != baseline_content
                    
                    if has_admin_content and content_changed:
                        return {
                            'vulnerable': True,
                            'method': 'Privilege Escalation via Parameter Tampering',
                            'details': f'Parameter manipulation successful: {params} (Status: {response.status_code})',
                            'exploitation': 'Add privilege parameters to requests',
                            'poc': f'curl -X GET "{url}?" + "&".join([f"{k}={v}" for k,v in params.items()])',
                            'response_sample': response.text[:200] + '...' if len(response.text) > 200 else response.text
                        }
            
            return {'vulnerable': False}
            
        except Exception as e:
            return {'vulnerable': False, 'error': str(e)}

    def test_http_method_bypass(self, url: str) -> Dict:
        """Test 6: Broken Access Control on HTTP Methods"""
        try:
            # Skip static assets - DELETE on images/fonts/CSS isn't a vulnerability
            static_extensions = r'\.(jpg|jpeg|png|gif|svg|ico|webp|ttf|eot|woff|woff2|css|js)(\?.*)?$'
            if re.search(static_extensions, url, re.IGNORECASE):
                return {'vulnerable': False}
                
            # Skip static asset directories
            if any(static_dir in url.lower() for static_dir in ['/images/', '/fonts/', '/css/', '/static/', '/assets/']):
                return {'vulnerable': False}
                
            # Get baseline with GET request
            get_response = self.session.get(url, timeout=self.timeout)
            get_status = get_response.status_code
            get_content_length = len(get_response.text)
            
            methods = ['POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS']
            
            for method in methods:
                response = self.session.request(method, url, timeout=self.timeout)
                
                # Only flag as vulnerable if method returns success AND doesn't contain error messages
                if response.status_code in [200, 201, 202, 204]:
                    content = response.text.lower()
                    content_length = len(response.text)
                    
                    # Check for common error indicators that suggest the request was rejected
                    error_indicators = [
                        'request rejected', 'access denied', 'method not allowed', 
                        'forbidden', 'unauthorized', 'error', 'blocked', 'rejected'
                    ]
                    
                    has_errors = any(indicator in content for indicator in error_indicators)
                    
                    # Additional check: make sure response isn't just a static file
                    content_type = response.headers.get('content-type', '').lower()
                    is_static_content = any(static_type in content_type for static_type in ['image/', 'font/', 'text/css'])
                    
                    # Consider it vulnerable if:
                    # 1. No error messages in response, AND
                    # 2. Not static content, AND
                    # 3. Method should not be allowed (DELETE, PUT, PATCH), OR
                    # 4. Substantially different content that suggests actual processing
                    if (not has_errors and not is_static_content and
                        (method in ['DELETE', 'PUT', 'PATCH'] or 
                         (abs(content_length - get_content_length) > 100 and content_length > 50))):
                        
                        return {
                            'vulnerable': True,
                            'method': f'HTTP Method Bypass - {method}',
                            'details': f'{method} method accessible (Status: {response.status_code}, Content: {content_length} chars vs GET: {get_content_length} chars)',
                            'exploitation': f'Use {method} method to bypass access controls',
                            'poc': f'curl -X {method} "{url}"',
                            'response_sample': response.text[:200] + '...' if len(response.text) > 200 else response.text
                        }
            
            return {'vulnerable': False}
            
        except Exception as e:
            return {'vulnerable': False, 'error': str(e)}

    def test_information_disclosure(self, url: str) -> Dict:
        """Test 7: "**********"
        try:
            response = self.session.get(url, timeout=self.timeout)
            
            # Look for exposed secrets
            secret_patterns = "**********"
                r'api[_-]?key["\']?\s*[:=]\s*["\']?([a-zA-Z0-9]{20,})',
                r'secret[_-]?key["\']?\s*[: "**********"
                r'access[_-]?token["\']?\s*[: "**********"
                r'bearer["\']?\s*[:=]\s*["\']?([a-zA-Z0-9]{20,})',
                r'jwt["\']?\s*[:=]\s*["\']?(eyJ[a-zA-Z0-9\-_=]+\.[a-zA-Z0-9\-_=]+\.[a-zA-Z0-9\-_=]*)'
            ]
            
 "**********"  "**********"  "**********"  "**********"  "**********"  "**********"  "**********"  "**********"  "**********"  "**********"  "**********"  "**********"  "**********"f "**********"o "**********"r "**********"  "**********"p "**********"a "**********"t "**********"t "**********"e "**********"r "**********"n "**********"  "**********"i "**********"n "**********"  "**********"s "**********"e "**********"c "**********"r "**********"e "**********"t "**********"_ "**********"p "**********"a "**********"t "**********"t "**********"e "**********"r "**********"n "**********"s "**********": "**********"
                matches = re.findall(pattern, response.text, re.IGNORECASE)
                if matches:
                    return {
                        'vulnerable': True,
                        'method': "**********"
                        'details': "**********"
                        'exploitation': "**********"
                        'poc': f'curl -X GET "{url}"',
                        'secrets_found': "**********":3],
                        'response_sample': response.text[:200] + '...' if len(response.text) > 200 else response.text
                    }
            
            return {'vulnerable': False}
            
        except Exception as e:
            return {'vulnerable': False, 'error': str(e)}

    def test_cors_misconfiguration(self, url: str) -> Dict:
        """Test 8: CORS Misconfiguration"""
        try:
            # Skip 404 pages and other error pages
            if '404?' in url or 'ItemNotFound' in url:
                return {'vulnerable': False}
                
            headers = {'Origin': 'https://evil.com'}
            response = self.session.get(url, headers=headers, timeout=self.timeout)
            
            # Only check successful responses, not error pages
            if response.status_code != 200:
                return {'vulnerable': False}
                
            cors_header = response.headers.get('Access-Control-Allow-Origin', '')
            
            # Check for overly permissive CORS
            if cors_header == '*' or 'evil.com' in cors_header:
                # Make sure this isn't just an error page
                content = response.text.lower()
                if not any(error in content for error in ['error', 'not found', 'rejected']):
                    return {
                        'vulnerable': True,
                        'method': 'CORS Misconfiguration',
                        'details': f'CORS allows unauthorized origin: {cors_header}',
                        'exploitation': 'Cross-origin requests from malicious sites possible',
                        'poc': f'curl -X GET "{url}" -H "Origin: https://evil.com"',
                        'cors_header': cors_header
                    }
            
            return {'vulnerable': False}
            
        except Exception as e:
            return {'vulnerable': False, 'error': str(e)}

    def test_error_message_disclosure(self, url: str) -> Dict:
        """Test 9: Information Disclosure in Error Messages"""
        try:
            # Trigger errors with malformed requests
            error_triggers = [
                {'params': {'id': 'invalid'}},
                {'headers': {'Content-Type': 'application/xml'}},
                {'data': 'invalid json'},
                {'params': {'q': "' OR 1=1 --"}}
            ]
            
            for trigger in error_triggers:
                response = self.session.post(url, timeout=self.timeout, **trigger)
                
                # Look for information disclosure in errors
                disclosure_patterns = [
                    r'stack trace',
                    r'sql.*error',
                    r'database.*error',
                    r'/var/www/',
                    r'/home/',
                    r'c:\\',
                    r'exception',
                    r'traceback'
                ]
                
                content = response.text.lower()
                for pattern in disclosure_patterns:
                    if re.search(pattern, content):
                        return {
                            'vulnerable': True,
                            'method': 'Information Disclosure in Error Messages',
                            'details': f'Error message contains sensitive information',
                            'exploitation': 'Craft malformed requests to extract system info',
                            'poc': f'curl -X POST "{url}" -d "invalid json" -H "Content-Type: application/json"',
                            'error_sample': response.text[:200] + '...' if len(response.text) > 200 else response.text
                        }
            
            return {'vulnerable': False}
            
        except Exception as e:
            return {'vulnerable': False, 'error': str(e)}

    def test_json_manipulation(self, url: str, original_response: requests.Response) -> Dict:
        """Test JSON response manipulation bypass"""
        try:
            if original_response.status_code != 200:
                return {'vulnerable': False}
            
            try:
                data = original_response.json()
            except:
                return {'vulnerable': False}
            
            # Look for any access control indicators in response
            bypass_found = False
            potential_bypasses = []
            
            for key, value in self.flatten_dict(data).items():
                if any(indicator in key.lower() for indicator in self.bypass_indicators):
                    if value is False or str(value).lower() in ['false', '0', 'no', 'disabled', 'expired']:
                        bypass_found = True
                        potential_bypasses.append({
                            'field': key,
                            'current_value': value,
                            'suggested_value': self.get_bypass_value(key, value)
                        })
            
            if bypass_found:
                return {
                    'vulnerable': True,
                    'method': 'JSON Response Manipulation',
                    'details': f'Found {len(potential_bypasses)} bypass opportunities',
                    'bypass_opportunities': potential_bypasses,
                    'exploitation': 'Intercept response and modify boolean values',
                    'poc': f'curl -X GET "{url}" # Then use Burp Suite to intercept and modify response',
                    'response_sample': json.dumps(data, indent=2)[:300] + '...' if len(json.dumps(data)) > 300 else json.dumps(data, indent=2)
                }
            
            # Also check for common API error patterns that might indicate auth issues
            if self.check_for_auth_errors(data):
                return {
                    'vulnerable': True,
                    'method': 'API Error Response Manipulation',
                    'details': 'API returns auth errors - try manipulating error responses',
                    'exploitation': 'Modify error responses to bypass checks'
                }
            
            return {'vulnerable': False}
            
        except Exception as e:
            return {'vulnerable': False, 'error': str(e)}

    def get_bypass_value(self, key: str, current_value) -> str:
        """Suggest appropriate bypass value based on the field name and current value"""
        key_lower = key.lower()
        
        if any(word in key_lower for word in ['expired', 'disabled', 'restricted']):
            return 'false' if current_value else 'true'
        elif 'level' in key_lower or 'role' in key_lower:
            return 'admin' if isinstance(current_value, str) else '999'
        else:
            return 'true' if current_value is False else 'false'
    
    def check_for_auth_errors(self, data: dict) -> bool:
        """Check if response contains authentication/authorization errors"""
        error_indicators = [
            'unauthorized', 'forbidden', 'access_denied', 'insufficient_privileges',
            'login_required', 'authentication_required', 'invalid_token',
            'permission_denied', 'not_authorized', 'access_forbidden'
        ]
        
        # Convert entire response to lowercase string for searching
        response_str = json.dumps(data).lower()
        return any(indicator in response_str for indicator in error_indicators)

    def flatten_dict(self, d: dict, parent_key: str = '', sep: str = '.') -> dict:
        """Flatten nested dictionary for easier searching"""
        items = []
        for k, v in d.items():
            new_key = f"{parent_key}{sep}{k}" if parent_key else k
            if isinstance(v, dict):
                items.extend(self.flatten_dict(v, new_key, sep=sep).items())
            else:
                items.append((new_key, v))
        return dict(items)

    def test_all_endpoints(self, urls: List[str]) -> List[Dict]:
        """Test all API endpoints concurrently for multiple bypass techniques"""
        logger.info(f"Testing {len(urls)} endpoints for authentication bypasses using 9 different techniques")
        
        results = []
        with ThreadPoolExecutor(max_workers=self.threads) as executor:
            future_to_url = {executor.submit(self.test_endpoint_bypass, url): url for url in urls}
            
            for future in as_completed(future_to_url):
                result = future.result()
                if result['vulnerable']:
                    # Handle multiple vulnerabilities per endpoint
                    if 'vulnerabilities' in result:
                        for vuln in result['vulnerabilities']:
                            vuln_result = {
                                'url': result['url'],
                                'vulnerable': True,
                                **vuln
                            }
                            self.vulnerable_endpoints.append(vuln_result)
                            logger.info(f"🚨 VULNERABLE: {result['url']} - {vuln.get('method', 'Unknown')}")
                    else:
                        self.vulnerable_endpoints.append(result)
                        logger.info(f"🚨 VULNERABLE: {result['url']} - {result.get('method', 'Unknown')}")
                results.append(result)
        
        return results

    def generate_report(self, results: List[Dict]) -> str:
        """Generate a detailed report of findings"""
        total_tested = len(results)
        vulnerable = len(self.vulnerable_endpoints)
        
        report = f"""
=== Comprehensive API Security Test Results ===
Domain: {self.domain}
Total URLs discovered: {len(self.found_urls)}
API endpoints tested: {total_tested}
Vulnerable endpoints found: {vulnerable}

TESTS PERFORMED:
1. Response Manipulation (Boolean/Redirect Bypass)
2. Missing Authentication on Sensitive Endpoints  
3. Insecure Direct Object Reference (IDOR)
4. Weak Session Token/Cookie Validation
5. Privilege Escalation via Parameter Tampering
6. HTTP Method Access Control Bypass
7. Information Disclosure (Exposed Secrets)
8. CORS Misconfiguration
9. Error Message Information Disclosure

"""
        
        if vulnerable > 0:
            report += "=== VULNERABLE API ENDPOINTS ===\n"
            for vuln in self.vulnerable_endpoints:
                report += f"""
URL: {vuln['url']}
Vulnerability: {vuln.get('method', 'Unknown')}
Details: {vuln.get('details', 'No additional details')}
Exploitation: {vuln.get('exploitation', 'Manual testing required')}

🔍 PROOF OF CONCEPT (POC):
{vuln.get('poc', 'Manual verification required')}
"""
                if 'response_sample' in vuln:
                    report += f"""
📄 Response Sample:
{vuln['response_sample']}
"""
                
                if 'bypass_opportunities' in vuln:
                    report += "\n🎯 Specific Bypass Opportunities:\n"
                    for bypass in vuln['bypass_opportunities']:
                        report += f"  - Change '{bypass['field']}' from '{bypass['current_value']}' to '{bypass['suggested_value']}'\n"
                
 "**********"  "**********"  "**********"  "**********"  "**********"  "**********"  "**********"  "**********"  "**********"  "**********"  "**********"  "**********"  "**********"  "**********"  "**********"  "**********"  "**********"i "**********"f "**********"  "**********"' "**********"s "**********"e "**********"c "**********"r "**********"e "**********"t "**********"s "**********"_ "**********"f "**********"o "**********"u "**********"n "**********"d "**********"' "**********"  "**********"i "**********"n "**********"  "**********"v "**********"u "**********"l "**********"n "**********": "**********"
                    report += f"\n🔑 Secrets Found: "**********"
                
                if 'cors_header' in vuln:
                    report += f"\n🌐 CORS Header: {vuln['cors_header']}\n"
                
                if 'error_sample' in vuln:
                    report += f"\n⚠️  Error Sample: {vuln['error_sample']}\n"
                
                report += "\n" + "="*60 + "\n"
            
            report += f"""
=== SUMMARY BY VULNERABILITY TYPE ===
"""
            # Count vulnerabilities by type
            vuln_types = {}
            for vuln in self.vulnerable_endpoints:
                vuln_type = vuln.get('method', 'Unknown')
                vuln_types[vuln_type] = vuln_types.get(vuln_type, 0) + 1
            
            for vuln_type, count in sorted(vuln_types.items()):
                report += f"{vuln_type}: {count} endpoints\n"
        
        return report

    def run_full_scan(self) -> str:
        """Run the complete authentication bypass scan"""
        logger.info(f"Starting comprehensive API security scan for {self.domain}")
        
        # Step 1: Discover URLs
        all_urls = self.run_urlfinder()
        if not all_urls:
            return "No URLs discovered. Check URLfinder installation and domain validity."
        
        self.found_urls = set(all_urls)
        
        # Step 2: Filter API endpoints
        api_urls = self.filter_api_endpoints(all_urls)
        if not api_urls:
            return "No API endpoints found in discovered URLs."
        
        # Step 3: Test for bypasses
        results = self.test_all_endpoints(api_urls)
        
        # Step 4: Generate report
        return self.generate_report(results)

def main():
    parser = argparse.ArgumentParser(description='Automated Authentication Bypass Tester')
    parser.add_argument('domain', help='Target domain to test')
    parser.add_argument('-t', '--threads', type=int, default=10, help='Number of threads (default: 10)')
    parser.add_argument('-o', '--output', help='Output file for results')
    parser.add_argument('--timeout', type=int, default=10, help='Request timeout in seconds (default: 10)')
    
    args = parser.parse_args()
    
    # Validate domain
    if not args.domain or '.' not in args.domain:
        logger.error("Please provide a valid domain")
        return
    
    # Warning message
    print("⚠️  WARNING: Only use this tool on domains you own or have explicit permission to test!")
    print("Unauthorized testing may be illegal and could result in serious consequences.")
    
    # Run the scan
    tester = AuthBypassTester(args.domain, threads=args.threads, timeout=args.timeout)
    report = tester.run_full_scan()
    
    # Output results
    print(report)
    
    if args.output:
        with open(args.output, 'w') as f:
            f.write(report)
        logger.info(f"Results saved to {args.output}")

if __name__ == "__main__":
    main()