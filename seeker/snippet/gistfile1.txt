#date: 2026-01-01T17:01:12Z
#url: https://api.github.com/gists/1b8672b8478bccf8ca53b481d07c6215
#owner: https://api.github.com/users/pishguy

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import json
import logging
import mimetypes
import os
import re
import requests
import sqlite3
import threading
import time
import urllib.parse
from collections import deque
from contextlib import contextmanager
from datetime import datetime, timedelta
from http.server import HTTPServer, BaseHTTPRequestHandler
import webbrowser
from typing import Dict, List, Optional, Any, Set
import asyncio
import socket
import struct
import hashlib
import base64
import select

import pandas as pd
import pandas_ta as ta
import websocket

from parameter_optimizer import ParameterOptimizer
from smart_filters import SmartFilter
from trade_journal import TradeJournal

try:
    from playwright.async_api import async_playwright, Page, BrowserContext
except ImportError:
    print("âš ï¸ Ù„Ø·ÙØ§Ù‹ playwright Ø±Ø§ Ù†ØµØ¨ Ú©Ù†ÛŒØ¯: pip install playwright")
    print("   Ø³Ù¾Ø³: playwright install chromium")
    raise

# logging.basicConfig(
#     level=logging.INFO,
#     format='%(asctime)s - %(levelname)s - %(message)s',
#     handlers=[
#         logging.FileHandler('trading_bot.log'),
#         logging.StreamHandler()
#     ]
# )
logger = logging.getLogger(__name__)


# noinspection PyPep8Naming
class HivaGoldManager:
    def __init__(self):
        """
        Ù…Ù‚Ø¯Ø§Ø±Ø¯Ù‡ÛŒ Ø§ÙˆÙ„ÛŒÙ‡ Ø±Ø¨Ø§Øª Ø³ÛŒÚ¯Ù†Ø§Ù„â€ŒØ¯Ù‡ÛŒ Ù…Ø¸Ù†Ù‡
        Ù†Ø³Ø®Ù‡ Ø³Ø§Ø¯Ù‡â€ŒØ´Ø¯Ù‡ - ÙÙ‚Ø· Ø³ÛŒÚ¯Ù†Ø§Ù„â€ŒØ¯Ù‡ÛŒ
        """

        # â•â•â•â•â•â•â•â•â•â•â•â• Ø¯Ø±ÛŒØ§ÙØª Ø¯Ø§Ø¯Ù‡ Ù‡Ø§ÛŒ ØªØ§Ø±ÛŒØ®ÛŒ Ø§Ø² Ø³Ø§ÛŒØª ÙØ±Ø§Ø² Ø¨Ø±Ø§ÛŒ Ù‡ÛŒÙˆØ§Ú¯Ù„Ø¯ â•â•â•â•â•â•â•â•â•â•â•
        # ğŸ“¥ ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø¯Ø§Ù†Ù„ÙˆØ¯ Ø¯Ø§Ø¯Ù‡ Ø§Ø² ÙØ±Ø§Ø²Ú¯Ù„Ø¯
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        self.FARAZ_API_URL = "https://farazgold.com/room/api/get-bars/"
        self.FARAZ_COOKIES = {
            "csrftoken": "**********"
            "sessionid": "axei1d3aelm4s7dp3lu2sni2buyhaeht"
        }
        self.FARAZ_HEADERS = {
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
            "Referer": "https://farazgold.com/"
        }
        self.HISTORY_DAYS = 365  # ØªØ¹Ø¯Ø§Ø¯ Ø±ÙˆØ² Ø¯Ø§Ø¯Ù‡ ØªØ§Ø±ÛŒØ®ÛŒ

        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # ğŸ—„ï¸ ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø¯ÛŒØªØ§Ø¨ÛŒØ³
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        self.DB_PATH = 'mazaneh_data.db'
        self.market = 'mazaneh'

        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # ğŸ“ Ø´Ù†Ø§Ø³Ù‡ Ù…Ø¹Ø§Ù…Ù„Ù‡ ÙØ¹Ù„ÛŒ (Ø¨Ø±Ø§ÛŒ Ø±Ø¯ÛŒØ§Ø¨ÛŒ)
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        self.current_internal_trade_id = None

        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # âŒ Ø®Ø·Ø§Ù‡Ø§
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        self.errors: List[Dict] = []

        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # ğŸ’° ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ù…Ø§Ù„ÛŒ Ùˆ Ù¾ÙˆØ±ØªÙÙˆÙ„ÛŒÙˆ
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        self.REQUIRED_MINUTES = 1
        self.PORTFOLIO_SIZE = 5_000_000
        self.TOTAL_BALANCE = 100_000_000
        self.LINE_VALUE_TOMAN = 23_000
        self.DOLLAR_VALUE_TOMAN = 80_000
        self.POSITION_SIZE = 1

        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # ğŸ¯ ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø§Ø³ØªØ±Ø§ØªÚ˜ÛŒ
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        self.STRATEGY_MODE = 'auto'
        self.current_trade_strategy = None
        self.ENABLE_COUNTER_TREND = True

        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # ğŸ“Š Ù¾Ø§Ø±Ø§Ù…ØªØ±Ù‡Ø§ÛŒ Ø§Ø³Ú©Ø§Ù„Ù¾
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        self.SCALP_ADX_THRESHOLD = 18
        self.SCALP_MIN_PROFIT_LINES = 12
        self.SCALP_MAX_TRADE_MINUTES = 15
        self.SCALP_RISK_PERCENTAGE = 0.8
        self.SCALP_ATR_MULTIPLIER = 0.8
        self.SCALP_RR_RATIO = 1.5
        self.SCALP_STOP_LOSS_LINES = 8

        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # ğŸ“ˆ Ù¾Ø§Ø±Ø§Ù…ØªØ±Ù‡Ø§ÛŒ Ø³ÙˆØ¦ÛŒÙ†Ú¯
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        self.SWING_ADX_THRESHOLD = 25
        self.SWING_MIN_PROFIT_LINES = 5
        self.SWING_MAX_TRADE_HOURS = 8
        self.SWING_RISK_PERCENTAGE = 0.5
        self.SWING_ATR_MULTIPLIER = 0.3
        self.SWING_RR_RATIO = 2.0
        self.SWING_STOP_LOSS_LINES = 8

        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # ğŸ›¡ï¸ Ù¾Ø§Ø±Ø§Ù…ØªØ±Ù‡Ø§ÛŒ Ù…Ø¯ÛŒØ±ÛŒØª Ø±ÛŒØ³Ú©
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        self.ADX_THRESHOLD = 15
        self.TRAILING_STOP_LINES = 3
        self.TRAILING_STEP_LINES = 2
        self.MIN_PROFIT_LINES = 5
        self.RISK_PERCENTAGE = 0.5
        self.MIN_CANDLES_BETWEEN_TRADES = 1
        self.ATR_MULTIPLIER = 0.5
        self.DEFAULT_STOP_LOSS_LINES = 8
        self.BREAKEVEN_LINES = 3

        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # ğŸ”§ Ù…Ø­Ø¯ÙˆØ¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø­Ø¯ Ø¶Ø±Ø±
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        self.SCALP_MIN_STOP = 3
        self.SCALP_MAX_STOP = 8
        self.SWING_MIN_STOP = 5
        self.SWING_MAX_STOP = 10

        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # â±ï¸ ØªÙ†Ø¸ÛŒÙ…Ø§Øª ØªØ§ÛŒÙ…â€ŒÙØ±ÛŒÙ…
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        self.M2_TIMEFRAME = '2min'
        self.DAILY_TIMEFRAME = 'D'
        self.STATUS_DISPLAY_INTERVAL = 60

        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # ğŸŒ ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø§ØªØµØ§Ù„ Ø¨Ù‡ Ø³Ø±ÙˆØ± Ù‚ÛŒÙ…Øª (WebSocket)
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        self.MARKET_WSS_URL = "wss://hivagold.com/mazaneh/ws/mazaneh/price/"
        self.CONNECTION_STATUS = "disconnected"
        self.MARKET_PRICE = None
        self.LAST_CANDLE_TIME = None
        self.LAST_KNOWN_PRICE = None

        self.COOKIES = {
            "csrftoken": "**********"
            "sessionid": "5ro2sgb4a3xwxefkur81i5smnsinzk3b"
        }

        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # ğŸ“¡ ØªÙ†Ø¸ÛŒÙ…Ø§Øª WebSocket Server Ø¯Ø§Ø®Ù„ÛŒ (Ø¬Ø§ÛŒÚ¯Ø²ÛŒÙ† Ø§ØªØµØ§Ù„ Ø¨Ù‡ Ø³Ø±ÙˆØ± Ø®Ø§Ø±Ø¬ÛŒ)
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        self.WS_SERVER_HOST = "0.0.0.0"
        self.WS_SERVER_PORT = 8765
        self.ws_server_socket = None
        self.ws_server_thread = None
        self.ws_server_running = False
        self.connected_clients: Set[socket.socket] = set()
        self.clients_lock = threading.Lock()
        self.COMMAND_SERVER_STATUS = "stopped"

        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # ğŸ’¼ Ù…ØªØºÛŒØ±Ù‡Ø§ÛŒ ÙˆØ¶Ø¹ÛŒØª Ù…Ø§Ù„ÛŒ (Ø¨Ø±Ø§ÛŒ Ø¢Ù…Ø§Ø±)
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        self.balance = self.TOTAL_BALANCE
        self.portfolio = self.PORTFOLIO_SIZE
        self.trades = 0
        self.winning_trades = 0
        self.losing_trades = 0
        self.total_profit = 0
        self.total_loss = 0
        self.max_drawdown = 0
        self.peak_balance = self.TOTAL_BALANCE

        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # ğŸ“Š Ù…ØªØºÛŒØ±Ù‡Ø§ÛŒ Ù…Ø¹Ø§Ù…Ù„Ù‡ ÙØ¹Ù„ÛŒ (Ø¨Ø±Ø§ÛŒ trailing stop)
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        self.in_trade = False
        self.trade_direction = None
        self.entry_price = 0
        self.stop_loss_price = 0
        self.take_profit_price = 0
        self.last_trade_exit_time = None
        self.trade_start_time = None
        self.trade_history = []
        self.open_trades = []

        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # ğŸ“ˆ Ù…ØªØºÛŒØ±Ù‡Ø§ÛŒ Ø±Ø¯ÛŒØ§Ø¨ÛŒ Ù‚ÛŒÙ…Øª Ø¯Ø± Ù…Ø¹Ø§Ù…Ù„Ù‡ (Ø¶Ø±ÙˆØ±ÛŒ Ø¨Ø±Ø§ÛŒ trailing)
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        self.highest_price_in_trade = 0
        self.lowest_price_in_trade = float('inf')

        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # ğŸ“Š Ø°Ø®ÛŒØ±Ù‡â€ŒØ³Ø§Ø²ÛŒ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ú©Ù†Ø¯Ù„
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        self.m3_data = deque(maxlen=500)
        self.daily_data = deque(maxlen=400)
        self.m3 = pd.DataFrame()
        self.daily = pd.DataFrame()

        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # ğŸ¯ ØªÙ†Ø¸ÛŒÙ…Ø§Øª Trailing Stop
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        self.TRAILING_ENABLED = True
        self.BREAKEVEN_ENABLED = True

        self.init_database()

        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # ØªÙ†Ø¸Ù…ÛŒØ§Øª Ù…Ø±Ø¨ÙˆØ· Ø¨Ù‡ Ø§ÙˆØ±Ø¯Ø±Ø¨Ù„Ø§Ú©
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        self.order_blocks = []
        self.active_order_blocks = []
        self.order_block_expiry_hours = 24
        self.ob_lookback_period = 100
        self.min_body_ratio = 1.5
        self.max_ob_distance = 2

        self.pin_bar_min_ratio = 0.7
        self.engulfing_min_ratio = 1.1

        self.ORDER_BLOCK_SETTINGS = {
            'enabled': True,
            'lookback_period': 100,
            'min_body_ratio': 1.5,
            'max_ob_distance': 2,
            'expiry_hours': 24,
            'max_entry_attempts': 3,
            'require_confirmation': True,
            'confirmation_patterns': ['pin_bar', 'engulfing', 'strong_candle'],
            'min_adx': 20,
            'rsi_min': 30,
            'rsi_max': 70
        }

        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # ğŸ¯ Ø³ÛŒØ³ØªÙ… Ø§ÙˆÙ„ÙˆÛŒØªâ€ŒØ¨Ù†Ø¯ÛŒ Ø§Ø³ØªØ±Ø§ØªÚ˜ÛŒâ€ŒÙ‡Ø§
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        self.STRATEGY_PRIORITY = {
            'order_block': {
                'priority': 1,
                'conditions': [
                    'valid_order_block_exists',
                    'candle_confirmation',
                    'price_in_ob_zone'
                ]
            },
            'scalp': {
                'priority': 2,
                'conditions': [
                    'low_volatility',
                    'weak_trend',
                    'short_term_signal'
                ]
            },
            'swing': {
                'priority': 3,
                'conditions': [
                    'high_volatility',
                    'strong_trend',
                    'confirmed_signal'
                ]
            }
        }

        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # ğŸ”¥ ØªÙ†Ø¸ÛŒÙ…Ø§Øª Warm-up (Ú¯Ø±Ù… Ø´Ø¯Ù† Ø±Ø¨Ø§Øª)
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        self.WARMUP_ENABLED = True
        self.WARMUP_CANDLES = 2
        self.WARMUP_MINUTES = 1

        self.warmup_complete = False
        self.warmup_start_time = None
        self.warmup_candles_seen = 0
        self.first_realtime_candle_time = None

        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # ğŸ“Š Ø³ÛŒØ³ØªÙ… Ú˜ÙˆØ±Ù†Ø§Ù„â€ŒÙ†ÙˆÛŒØ³ÛŒ Ù¾ÛŒØ´Ø±ÙØªÙ‡
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        try:
            self.journal = TradeJournal(self)
            self.smart_filter = SmartFilter(self.journal)
            self.param_optimizer = ParameterOptimizer(self.journal, self)
            print("âœ… Ø³ÛŒØ³ØªÙ… Ú˜ÙˆØ±Ù†Ø§Ù„â€ŒÙ†ÙˆÛŒØ³ÛŒ Ù¾ÛŒØ´Ø±ÙØªÙ‡ ÙØ¹Ø§Ù„ Ø´Ø¯")
        except Exception as e:
            print(f"âš ï¸ Ø®Ø·Ø§ Ø¯Ø± Ø±Ø§Ù‡â€ŒØ§Ù†Ø¯Ø§Ø²ÛŒ Ø³ÛŒØ³ØªÙ… Ú˜ÙˆØ±Ù†Ø§Ù„: {e}")
            self.journal = None
            self.smart_filter = None
            self.param_optimizer = None

        self.market_regime = "unknown"
        self.regime_confidence = 0
        self.regime_history = deque(maxlen=20)

        # ØªÙ†Ø¸ÛŒÙ…Ø§Øª ØªØ´Ø®ÛŒØµ Ø¨Ø§Ø²Ø§Ø±
        self.REGIME_SETTINGS = {
            'lookback_candles': 30,
            'min_confidence': 60,
            'update_interval': 5  # Ù‡Ø± 5 Ú©Ù†Ø¯Ù„ Ø¢Ù¾Ø¯ÛŒØª Ø´ÙˆØ¯
        }

        print("âœ… Ø¯Ø± Ø­Ø§Ù„ Ø¢Ù…Ø§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ Ù‡Ø³ØªÙ‡ Ø³ÛŒÚ¯Ù†Ø§Ù„â€ŒØ¯Ù‡ÛŒ Ù…Ø¸Ù†Ù‡...")
        print(f"   ğŸ“Š Ø­Ø§Ù„Øª Ø§Ø³ØªØ±Ø§ØªÚ˜ÛŒ: {self.STRATEGY_MODE}")
        print(f"   ğŸ’° Ù¾ÙˆØ±ØªÙÙˆ: {self.PORTFOLIO_SIZE:,} ØªÙˆÙ…Ø§Ù†")
        print(f"   ğŸ’µ Ø§Ø±Ø²Ø´ Ù‡Ø± Ø®Ø·: {self.LINE_VALUE_TOMAN:,} ØªÙˆÙ…Ø§Ù†")
        print(f"   ğŸ”„ Ù…Ø¹Ø§Ù…Ù„Ø§Øª Ø®Ù„Ø§Ù Ø±ÙˆÙ†Ø¯: {'ÙØ¹Ø§Ù„' if self.ENABLE_COUNTER_TREND else 'ØºÛŒØ±ÙØ¹Ø§Ù„'}")
        print(f"   ğŸ›¡ï¸ ØªØ±ÛŒÙ„ÛŒÙ†Ú¯ Ø§Ø³ØªØ§Ù¾: ÙØ¹Ø§Ù„â€ŒØ³Ø§Ø²ÛŒ Ø¨Ø¹Ø¯ Ø§Ø² {self.TRAILING_STOP_LINES} Ø®Ø· Ø³ÙˆØ¯")
        print(f"   ğŸ“ Ú¯Ø§Ù… ØªØ±ÛŒÙ„ÛŒÙ†Ú¯: {self.TRAILING_STEP_LINES} Ø®Ø·")
        print(f"   ğŸ“¡ WebSocket Server Ø¯Ø§Ø®Ù„ÛŒ: ws://{self.WS_SERVER_HOST}:{self.WS_SERVER_PORT}")

    def start_websocket_server(self):
        """
        Ø±Ø§Ù‡â€ŒØ§Ù†Ø¯Ø§Ø²ÛŒ WebSocket Server Ø¯Ø§Ø®Ù„ÛŒ
        Ú©Ù„Ø§ÛŒÙ†Øªâ€ŒÙ‡Ø§ Ù…Ø³ØªÙ‚ÛŒÙ…Ø§Ù‹ Ø¨Ù‡ Ø§ÛŒÙ† Ø³Ø±ÙˆØ± ÙˆØµÙ„ Ù…ÛŒâ€ŒØ´ÙˆÙ†Ø¯
        """
        try:
            self.ws_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.ws_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            self.ws_server_socket.bind((self.WS_SERVER_HOST, self.WS_SERVER_PORT))
            self.ws_server_socket.listen(10)
            self.ws_server_socket.setblocking(False)

            self.ws_server_running = True
            self.COMMAND_SERVER_STATUS = "running"

            self.ws_server_thread = threading.Thread(target=self._ws_server_loop, daemon=True)
            self.ws_server_thread.start()

            print(f"\n{'â•' * 60}")
            print(f"ğŸ“¡ WebSocket Server Ø¯Ø§Ø®Ù„ÛŒ Ø±Ø§Ù‡â€ŒØ§Ù†Ø¯Ø§Ø²ÛŒ Ø´Ø¯!")
            print(f"{'â•' * 60}")
            print(f"   ğŸŒ Ø¢Ø¯Ø±Ø³: ws://{self.WS_SERVER_HOST}:{self.WS_SERVER_PORT}")
            print(f"   ğŸ“± Ú©Ù„Ø§ÛŒÙ†Øªâ€ŒÙ‡Ø§ Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ù†Ø¯ Ø¨Ù‡ Ø§ÛŒÙ† Ø¢Ø¯Ø±Ø³ Ù…ØªØµÙ„ Ø´ÙˆÙ†Ø¯")
            print(f"{'â•' * 60}\n")

            return True

        except Exception as e:
            print(f"âŒ Ø®Ø·Ø§ Ø¯Ø± Ø±Ø§Ù‡â€ŒØ§Ù†Ø¯Ø§Ø²ÛŒ WebSocket Server: {e}")
            import traceback
            traceback.print_exc()
            return False

    def stop_websocket_server(self):
        """
        ØªÙˆÙ‚Ù WebSocket Server
        """
        self.ws_server_running = False
        self.COMMAND_SERVER_STATUS = "stopped"

        with self.clients_lock:
            for client in list(self.connected_clients):
                try:
                    client.close()
                except:
                    pass
            self.connected_clients.clear()

        if self.ws_server_socket:
            try:
                self.ws_server_socket.close()
            except:
                pass

        print("ğŸ›‘ WebSocket Server Ù…ØªÙˆÙ‚Ù Ø´Ø¯")

    def download_historical_from_faraz(self):
        """
        Ø¯Ø§Ù†Ù„ÙˆØ¯ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ ØªØ§Ø±ÛŒØ®ÛŒ Ø§Ø² ÙØ±Ø§Ø²Ú¯Ù„Ø¯

        Ø§ÛŒÙ† Ù…ØªØ¯:
        1. Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ ÛŒÚ© Ø³Ø§Ù„ Ø§Ø®ÛŒØ± Ø±Ø§ Ø§Ø² API ÙØ±Ø§Ø²Ú¯Ù„Ø¯ Ø¯Ø±ÛŒØ§ÙØª Ù…ÛŒâ€ŒÚ©Ù†Ø¯
        2. Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ Ø±Ø§ Ù¾Ø§Ú©â€ŒØ³Ø§Ø²ÛŒ Ù…ÛŒâ€ŒÚ©Ù†Ø¯
        3. Ø¯Ø± Ø¯ÛŒØªØ§Ø¨ÛŒØ³ Ø°Ø®ÛŒØ±Ù‡ Ù…ÛŒâ€ŒÚ©Ù†Ø¯

        Returns:
            bool: Ø¢ÛŒØ§ Ø¯Ø§Ù†Ù„ÙˆØ¯ Ù…ÙˆÙÙ‚ Ø¨ÙˆØ¯
        """

        print(f"\n{'â•' * 60}")
        print(f"ğŸ“¥ Ø¯Ø§Ù†Ù„ÙˆØ¯ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ ØªØ§Ø±ÛŒØ®ÛŒ Ø§Ø² ÙØ±Ø§Ø²Ú¯Ù„Ø¯")
        print(f"{'â•' * 60}")

        try:
            # Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø¨Ø§Ø²Ù‡ Ø²Ù…Ø§Ù†ÛŒ
            to_ts = int(time.time())
            from_ts = to_ts - (self.HISTORY_DAYS * 24 * 60 * 60)

            from_date = datetime.fromtimestamp(from_ts).strftime('%Y-%m-%d %H:%M')
            to_date = datetime.fromtimestamp(to_ts).strftime('%Y-%m-%d %H:%M')

            print(f"   ğŸ“… Ø¨Ø§Ø²Ù‡ Ø²Ù…Ø§Ù†ÛŒ: {from_date} ØªØ§ {to_date}")
            print(f"   ğŸ“Š ØªØ¹Ø¯Ø§Ø¯ Ø±ÙˆØ²: {self.HISTORY_DAYS}")

            # ØªÙ†Ø¸ÛŒÙ… Ù¾Ø§Ø±Ø§Ù…ØªØ±Ù‡Ø§
            params = {
                "symbol": "mazane",
                "from": from_ts,
                "to": to_ts,
                "resolution": "1"
            }

            print(f"   ğŸŒ Ø§Ø±Ø³Ø§Ù„ Ø¯Ø±Ø®ÙˆØ§Ø³Øª Ø¨Ù‡ ÙØ±Ø§Ø²Ú¯Ù„Ø¯...")

            # Ø§Ø±Ø³Ø§Ù„ Ø¯Ø±Ø®ÙˆØ§Ø³Øª
            response = requests.get(
                self.FARAZ_API_URL,
                params=params,
                cookies=self.FARAZ_COOKIES,
                headers=self.FARAZ_HEADERS,
                timeout=120
            )

            if response.status_code == 200:
                data = response.json()
                count = len(data)
                print(f"   âœ… Ø¯Ø±ÛŒØ§ÙØª Ù…ÙˆÙÙ‚! ØªØ¹Ø¯Ø§Ø¯ Ø±Ú©ÙˆØ±Ø¯: {count:,}")

                if count > 0:
                    # Ø°Ø®ÛŒØ±Ù‡ Ùˆ Ù¾Ø§Ú©â€ŒØ³Ø§Ø²ÛŒ
                    success = self.save_and_clean_faraz_data(data)
                    if success:
                        print(f"{'â•' * 60}")
                        print(f"âœ… Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ ØªØ§Ø±ÛŒØ®ÛŒ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø°Ø®ÛŒØ±Ù‡ Ø´Ø¯")
                        print(f"{'â•' * 60}\n")
                        return True
                    else:
                        print(f"âŒ Ø®Ø·Ø§ Ø¯Ø± Ø°Ø®ÛŒØ±Ù‡ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§")
                        return False
                else:
                    print(f"   âš ï¸ Ø¯Ø§Ø¯Ù‡â€ŒØ§ÛŒ Ø¯Ø±ÛŒØ§ÙØª Ù†Ø´Ø¯")
                    return False

            elif response.status_code == 403:
                print(f"   âŒ Ø®Ø·Ø§ÛŒ 403: Ú©ÙˆÚ©ÛŒâ€ŒÙ‡Ø§ Ù…Ù†Ù‚Ø¶ÛŒ Ø´Ø¯Ù‡â€ŒØ§Ù†Ø¯")
                print(f"   ğŸ’¡ Ù„Ø·ÙØ§Ù‹ Ú©ÙˆÚ©ÛŒâ€ŒÙ‡Ø§ÛŒ Ø¬Ø¯ÛŒØ¯ Ø±Ø§ Ø§Ø² ÙØ±Ø§Ø²Ú¯Ù„Ø¯ Ø¯Ø±ÛŒØ§ÙØª Ú©Ù†ÛŒØ¯")
                return False

            else:
                print(f"   âŒ Ø®Ø·Ø§: Ú©Ø¯ ÙˆØ¶Ø¹ÛŒØª {response.status_code}")
                print(f"   ğŸ“„ Ù¾Ø§Ø³Ø®: {response.text[:200]}")
                return False

        except requests.exceptions.Timeout:
            print(f"   âŒ Ø®Ø·Ø§ÛŒ Timeout: Ø³Ø±ÙˆØ± Ù¾Ø§Ø³Ø® Ù†Ø¯Ø§Ø¯")
            return False

        except requests.exceptions.ConnectionError:
            print(f"   âŒ Ø®Ø·Ø§ÛŒ Ø§ØªØµØ§Ù„: Ø¹Ø¯Ù… Ø¯Ø³ØªØ±Ø³ÛŒ Ø¨Ù‡ Ø³Ø±ÙˆØ±")
            return False

        except requests.exceptions.RequestException as e:
            print(f"   âŒ Ø®Ø·Ø§ÛŒ Ø´Ø¨Ú©Ù‡: {e}")
            return False

        except json.JSONDecodeError as e:
            print(f"   âŒ Ø®Ø·Ø§ÛŒ JSON: Ù¾Ø§Ø³Ø® Ø³Ø±ÙˆØ± Ù‚Ø§Ø¨Ù„ ØªÙØ³ÛŒØ± Ù†ÛŒØ³Øª")
            return False

        except Exception as e:
            print(f"   âŒ Ø®Ø·Ø§ÛŒ ØºÛŒØ±Ù…Ù†ØªØ¸Ø±Ù‡: {e}")
            import traceback
            traceback.print_exc()
            return False

    def _prepare_signal_data(self, direction: str, strategy: str, current_price: float) -> Dict:
        """Ø¢Ù…Ø§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø³ÛŒÚ¯Ù†Ø§Ù„ Ø¨Ø±Ø§ÛŒ Ø«Ø¨Øª Ø¯Ø± Ú˜ÙˆØ±Ù†Ø§Ù„"""
        try:
            signal_data = {
                'direction': direction,
                'strategy': strategy,
                'current_price': current_price,
                'adx_entry': self.m3['adx'].iloc[-1] if 'adx' in self.m3.columns else 0,
                'rsi_entry': self.m3['rsi14'].iloc[-1] if 'rsi14' in self.m3.columns else 50,
                'atr_entry': self.m3['atr'].iloc[-1] if 'atr' in self.m3.columns else 0,
                'ema9_entry': self.m3['ema9'].iloc[-1] if 'ema9' in self.m3.columns else current_price,
                'ema21_entry': self.m3['ema21'].iloc[-1] if 'ema21' in self.m3.columns else current_price,
                'daily_trend_score': self.calculate_daily_trend_score(),
                'stoch_k': self.m3['stoch_k'].iloc[-1] if 'stoch_k' in self.m3.columns else 50,
                'stoch_d': self.m3['stoch_d'].iloc[-1] if 'stoch_d' in self.m3.columns else 50,
                'bb_position': self._calculate_bb_position(),
                'market_volatility': self.m3['atr'].iloc[-1] if 'atr' in self.m3.columns else 0,
                'session_hour': datetime.now().hour
            }
            return signal_data
        except Exception as e:
            print(f"âš ï¸ Ø®Ø·Ø§ Ø¯Ø± Ø¢Ù…Ø§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ Ø¯Ø§Ø¯Ù‡ Ø³ÛŒÚ¯Ù†Ø§Ù„: {e}")
            return {}

    def _calculate_bb_position(self) -> float:
        """Ù…Ø­Ø§Ø³Ø¨Ù‡ Ù…ÙˆÙ‚Ø¹ÛŒØª Ù‚ÛŒÙ…Øª Ø¯Ø± Ø¨ÙˆÙ„ÛŒÙ†Ú¯Ø± Ø¨Ø§Ù†Ø¯"""
        try:
            if 'bb_lower' in self.m3.columns and 'bb_upper' in self.m3.columns:
                current = self.m3['close'].iloc[-1]
                bb_lower = self.m3['bb_lower'].iloc[-1]
                bb_upper = self.m3['bb_upper'].iloc[-1]
                if bb_upper > bb_lower:
                    position = ((current - bb_lower) / (bb_upper - bb_lower)) * 100
                    return max(0, min(100, position))
            return 50.0
        except Exception:
            return 50.0

    def clear_database(self):
        """
        Ù¾Ø§Ú©â€ŒØ³Ø§Ø²ÛŒ Ú©Ø§Ù…Ù„ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø¯ÛŒØªØ§Ø¨ÛŒØ³

        Ø§ÛŒÙ† Ù…ØªØ¯ ØªÙ…Ø§Ù… Ú©Ù†Ø¯Ù„â€ŒÙ‡Ø§ÛŒ Ù…ÙˆØ¬ÙˆØ¯ Ø±Ø§ Ø­Ø°Ù Ù…ÛŒâ€ŒÚ©Ù†Ø¯
        ØªØ§ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø¬Ø¯ÛŒØ¯ Ø§Ø² ÙØ±Ø§Ø²Ú¯Ù„Ø¯ Ø°Ø®ÛŒØ±Ù‡ Ø´ÙˆÙ†Ø¯
        """

        print(f"\nğŸ§¹ Ù¾Ø§Ú©â€ŒØ³Ø§Ø²ÛŒ Ø¯ÛŒØªØ§Ø¨ÛŒØ³...")

        try:
            with self._get_db_connection() as conn:
                cursor = conn.cursor()

                # Ø­Ø°Ù Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø¬Ø¯ÙˆÙ„ M5
                cursor.execute('DELETE FROM candles_m5')
                m5_deleted = cursor.rowcount

                # Ø­Ø°Ù Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø¬Ø¯ÙˆÙ„ Ø±ÙˆØ²Ø§Ù†Ù‡
                cursor.execute('DELETE FROM candles')
                daily_deleted = cursor.rowcount

                # Ø­Ø°Ù Ø¬Ø¯ÙˆÙ„ Ù…ÙˆÙ‚Øª Ø§Ú¯Ø± ÙˆØ¬ÙˆØ¯ Ø¯Ø§Ø´ØªÙ‡ Ø¨Ø§Ø´Ø¯
                cursor.execute('DROP TABLE IF EXISTS candles_raw')

                conn.commit()

                # ÙØ´Ø±Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ Ø¯ÛŒØªØ§Ø¨ÛŒØ³
                conn.execute("VACUUM")

                print(f"   âœ… {m5_deleted} Ú©Ù†Ø¯Ù„ M5 Ø­Ø°Ù Ø´Ø¯")
                print(f"   âœ… {daily_deleted} Ú©Ù†Ø¯Ù„ Ø±ÙˆØ²Ø§Ù†Ù‡ Ø­Ø°Ù Ø´Ø¯")
                print(f"   âœ… Ø¯ÛŒØªØ§Ø¨ÛŒØ³ ÙØ´Ø±Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ Ø´Ø¯")

                return True

        except Exception as e:
            print(f"   âŒ Ø®Ø·Ø§ Ø¯Ø± Ù¾Ø§Ú©â€ŒØ³Ø§Ø²ÛŒ: {e}")
            return False

    def save_and_clean_faraz_data(self, data):
        """
        Ø°Ø®ÛŒØ±Ù‡ Ùˆ Ù¾Ø§Ú©â€ŒØ³Ø§Ø²ÛŒ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø¯Ø±ÛŒØ§ÙØªÛŒ Ø§Ø² ÙØ±Ø§Ø²Ú¯Ù„Ø¯
        Ù‡Ø± Ø¨Ø§Ø± Ú©Ù„ Ø¬Ø¯Ø§ÙˆÙ„ Ø±Ùˆ Ø§Ø² Ù†Ùˆ Ù…ÛŒâ€ŒØ³Ø§Ø²Ù‡ â†’ Ù‡ÛŒÚ† Ø®Ø·Ø§ÛŒ datatype mismatch Ù†Ù…ÛŒâ€ŒØ¯Ù‡
        """
        print(f"\n   ğŸ’¾ Ø°Ø®ÛŒØ±Ù‡ Ùˆ Ù¾Ø§Ú©â€ŒØ³Ø§Ø²ÛŒ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ ÙØ±Ø§Ø²Ú¯Ù„Ø¯...")

        try:
            with self._get_db_connection() as conn:
                cursor = conn.cursor()

                # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                # 1ï¸âƒ£ Ø­Ø°Ù Ú©Ø§Ù…Ù„ Ø¬Ø¯Ø§ÙˆÙ„ Ù‚Ø¯ÛŒÙ…ÛŒ (ØªØ¶Ù…ÛŒÙ† Ù¾Ø§Ú© Ø´Ø¯Ù† Ø³Ø§Ø®ØªØ§Ø± Ù‚Ø¨Ù„ÛŒ)
                # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                cursor.execute('DROP TABLE IF EXISTS candles_raw')
                cursor.execute('DROP TABLE IF EXISTS candles_m5')
                cursor.execute('DROP TABLE IF EXISTS candles')

                # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                # 2ï¸âƒ£ Ø³Ø§Ø®Øª Ø¯ÙˆØ¨Ø§Ø±Ù‡ Ø¬Ø¯Ø§ÙˆÙ„ Ø¨Ø§ Ø³Ø§Ø®ØªØ§Ø± Û±Û°Û°Ùª Ø¯Ø±Ø³Øª (time = TEXT)
                # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                cursor.execute('''
                    CREATE TABLE candles_m5 (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        time TEXT UNIQUE NOT NULL,
                        open REAL NOT NULL,
                        high REAL NOT NULL,
                        low REAL NOT NULL,
                        close REAL NOT NULL,
                        created_at TEXT DEFAULT CURRENT_TIMESTAMP
                    )
                ''')

                cursor.execute('''
                    CREATE TABLE candles (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        time TEXT UNIQUE NOT NULL,
                        open REAL NOT NULL,
                        high REAL NOT NULL,
                        low REAL NOT NULL,
                        close REAL NOT NULL,
                        created_at TEXT DEFAULT CURRENT_TIMESTAMP
                    )
                ''')

                cursor.execute('''
                    CREATE TABLE candles_raw (
                        time INTEGER PRIMARY KEY,
                        open REAL,
                        high REAL,
                        low REAL,
                        close REAL
                    )
                ''')

                # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                # 3ï¸âƒ£ Ø°Ø®ÛŒØ±Ù‡ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø®Ø§Ù…
                # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                records = []
                for item in data:
                    records.append((
                        item['time'],
                        item['open'],
                        item['high'],
                        item['low'],
                        item['close']
                    ))

                cursor.executemany('''
                    INSERT OR REPLACE INTO candles_raw (time, open, high, low, close)
                    VALUES (?, ?, ?, ?, ?)
                ''', records)

                print(f"      ğŸ“Š {len(records):,} Ø±Ú©ÙˆØ±Ø¯ Ø®Ø§Ù… Ø°Ø®ÛŒØ±Ù‡ Ø´Ø¯")

                # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                # 4ï¸âƒ£ Ù¾Ø§Ú©â€ŒØ³Ø§Ø²ÛŒ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§
                # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                print(f"\n   ğŸ§¹ Ù¾Ø§Ú©â€ŒØ³Ø§Ø²ÛŒ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§...")

                cursor.execute('''
                    DELETE FROM candles_raw 
                    WHERE open <= 0 OR high <= 0 OR low <= 0 OR close <= 0
                ''')
                deleted_zeros = cursor.rowcount
                if deleted_zeros > 0:
                    print(f"      âŒ Ø­Ø°Ù {deleted_zeros} Ú©Ù†Ø¯Ù„ Ø¨Ø§ Ù…Ù‚Ø§Ø¯ÛŒØ± ØµÙØ±/Ù…Ù†ÙÛŒ")

                cursor.execute('DELETE FROM candles_raw WHERE high < low')
                deleted_logic = cursor.rowcount
                if deleted_logic > 0:
                    print(f"      âŒ Ø­Ø°Ù {deleted_logic} Ú©Ù†Ø¯Ù„ ØºÛŒØ±Ù…Ù†Ø·Ù‚ÛŒ (High < Low)")

                cursor.execute('''
                    DELETE FROM candles_raw 
                    WHERE open = high AND high = low AND low = close
                ''')
                deleted_flat = cursor.rowcount
                if deleted_flat > 0:
                    print(f"      âŒ Ø­Ø°Ù {deleted_flat} Ú©Ù†Ø¯Ù„ ÙÙ„Øª (Ø¨Ø¯ÙˆÙ† Ù†ÙˆØ³Ø§Ù†)")

                total_deleted = deleted_zeros + deleted_logic + deleted_flat
                print(f"      ğŸ“Š Ù…Ø¬Ù…ÙˆØ¹ Ø­Ø°Ù Ø´Ø¯Ù‡: {total_deleted}")

                # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                # 5ï¸âƒ£ Ø³Ø§Ø®Øª DataFrame Ùˆ Ú©Ù†Ø¯Ù„â€ŒÙ‡Ø§ÛŒ 3 Ø¯Ù‚ÛŒÙ‚Ù‡â€ŒØ§ÛŒ
                # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                print(f"\n   ğŸ“Š Ø§ÛŒØ¬Ø§Ø¯ Ú©Ù†Ø¯Ù„â€ŒÙ‡Ø§ÛŒ 3 Ø¯Ù‚ÛŒÙ‚Ù‡â€ŒØ§ÛŒ...")

                cursor.execute("SELECT time, open, high, low, close FROM candles_raw ORDER BY time ASC")
                rows = cursor.fetchall()

                if not rows:
                    print(f"      âš ï¸ Ø¯Ø§Ø¯Ù‡â€ŒØ§ÛŒ Ø¨Ø±Ø§ÛŒ Ù¾Ø±Ø¯Ø§Ø²Ø´ ÙˆØ¬ÙˆØ¯ Ù†Ø¯Ø§Ø±Ø¯")
                    return False

                import pandas as pd

                df_data = []
                for row in rows:
                    df_data.append({
                        'time': pd.Timestamp.fromtimestamp(row[0]),
                        'open': row[1],
                        'high': row[2],
                        'low': row[3],
                        'close': row[4]
                    })

                df = pd.DataFrame(df_data)
                df.set_index('time', inplace=True)

                m3_data = df.resample(self.M2_TIMEFRAME).agg({
                    'open': 'first',
                    'high': 'max',
                    'low': 'min',
                    'close': 'last'
                }).dropna()

                print(f"      ğŸ“Š {len(m3_data)} Ú©Ù†Ø¯Ù„ 3 Ø¯Ù‚ÛŒÙ‚Ù‡â€ŒØ§ÛŒ Ø§ÛŒØ¬Ø§Ø¯ Ø´Ø¯")

                # Ø°Ø®ÛŒØ±Ù‡ Ú©Ù†Ø¯Ù„â€ŒÙ‡Ø§ÛŒ 3 Ø¯Ù‚ÛŒÙ‚Ù‡â€ŒØ§ÛŒ
                for index, row in m3_data.iterrows():
                    cursor.execute('''
                        INSERT OR REPLACE INTO candles_m5 (time, open, high, low, close)
                        VALUES (?, ?, ?, ?, ?)
                    ''', (index.isoformat(), row['open'], row['high'], row['low'], row['close']))

                # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                # 6ï¸âƒ£ Ø§ÛŒØ¬Ø§Ø¯ Ùˆ Ø°Ø®ÛŒØ±Ù‡ Ú©Ù†Ø¯Ù„â€ŒÙ‡Ø§ÛŒ Ø±ÙˆØ²Ø§Ù†Ù‡
                # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                print(f"\n   ğŸ“Š Ø§ÛŒØ¬Ø§Ø¯ Ú©Ù†Ø¯Ù„â€ŒÙ‡Ø§ÛŒ Ø±ÙˆØ²Ø§Ù†Ù‡...")

                daily_data = df.resample(self.DAILY_TIMEFRAME).agg({
                    'open': 'first',
                    'high': 'max',
                    'low': 'min',
                    'close': 'last'
                }).dropna()

                print(f"      ğŸ“Š {len(daily_data)} Ú©Ù†Ø¯Ù„ Ø±ÙˆØ²Ø§Ù†Ù‡ Ø§ÛŒØ¬Ø§Ø¯ Ø´Ø¯")

                for index, row in daily_data.iterrows():
                    cursor.execute('''
                        INSERT OR REPLACE INTO candles (time, open, high, low, close)
                        VALUES (?, ?, ?, ?, ?)
                    ''', (index.isoformat(), row['open'], row['high'], row['low'], row['close']))

                # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                # 7ï¸âƒ£ Ù¾Ø§Ú©â€ŒØ³Ø§Ø²ÛŒ Ù†Ù‡Ø§ÛŒÛŒ Ùˆ Ø¨Ù‡ÛŒÙ†Ù‡â€ŒØ³Ø§Ø²ÛŒ
                # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                cursor.execute('DROP TABLE IF EXISTS candles_raw')
                conn.commit()
                conn.execute("VACUUM")

                # Ø¢Ù…Ø§Ø± Ù†Ù‡Ø§ÛŒÛŒ
                cursor.execute("SELECT COUNT(*) FROM candles_m5")
                m5_count = cursor.fetchone()[0]

                cursor.execute("SELECT COUNT(*) FROM candles")
                daily_count = cursor.fetchone()[0]

                print(f"\n   âœ… Ø°Ø®ÛŒØ±Ù‡â€ŒØ³Ø§Ø²ÛŒ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ ÙØ±Ø§Ø²Ú¯Ù„Ø¯ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§Ù†Ø¬Ø§Ù… Ø´Ø¯:")
                print(f"      ğŸ“Š Ú©Ù†Ø¯Ù„â€ŒÙ‡Ø§ÛŒ 3 Ø¯Ù‚ÛŒÙ‚Ù‡â€ŒØ§ÛŒ: {m5_count:,}")
                print(f"      ğŸ“Š Ú©Ù†Ø¯Ù„â€ŒÙ‡Ø§ÛŒ Ø±ÙˆØ²Ø§Ù†Ù‡: {daily_count:,}")

                return True

        except sqlite3.Error as e:
            print(f"   âŒ Ø®Ø·Ø§ÛŒ Ø¯ÛŒØªØ§Ø¨ÛŒØ³: {e}")
            import traceback
            traceback.print_exc()
            return False

        except Exception as e:
            print(f"   âŒ Ø®Ø·Ø§ÛŒ ØºÛŒØ±Ù…Ù†ØªØ¸Ø±Ù‡: {e}")
            import traceback
            traceback.print_exc()
            return False

    def _ws_server_loop(self):
        """
        Ø­Ù„Ù‚Ù‡ Ø§ØµÙ„ÛŒ Ø³Ø±ÙˆØ± Ø¨Ø±Ø§ÛŒ Ù¾Ø°ÛŒØ±Ø´ Ø§ØªØµØ§Ù„Ø§Øª Ø¬Ø¯ÛŒØ¯
        """
        print("ğŸ”„ Ø­Ù„Ù‚Ù‡ Ø³Ø±ÙˆØ± WebSocket Ø´Ø±ÙˆØ¹ Ø´Ø¯...")

        while self.ws_server_running:
            try:
                readable, _, _ = select.select([self.ws_server_socket], [], [], 0.5)

                if readable:
                    client_socket, client_address = self.ws_server_socket.accept()
                    print(f"ğŸ“¥ Ø§ØªØµØ§Ù„ Ø¬Ø¯ÛŒØ¯ Ø§Ø²: {client_address}")

                    client_thread = threading.Thread(
                        target=self._handle_client,
                        args=(client_socket, client_address),
                        daemon=True
                    )
                    client_thread.start()

            except Exception as e:
                if self.ws_server_running:
                    print(f"âš ï¸ Ø®Ø·Ø§ Ø¯Ø± Ø­Ù„Ù‚Ù‡ Ø³Ø±ÙˆØ±: {e}")
                time.sleep(0.1)

    def _handle_client(self, client_socket: socket.socket, client_address):
        """
        Ù…Ø¯ÛŒØ±ÛŒØª Ù‡Ø± Ú©Ù„Ø§ÛŒÙ†Øª Ø¨Ù‡ ØµÙˆØ±Øª Ø¬Ø¯Ø§Ú¯Ø§Ù†Ù‡ - Ù†Ø³Ø®Ù‡ Ù¾Ø§ÛŒØ¯Ø§Ø±
        """
        import time

        try:
            if not self._perform_websocket_handshake(client_socket):
                print(f"âŒ Handshake Ù†Ø§Ù…ÙˆÙÙ‚ Ø¨Ø§ {client_address}")
                client_socket.close()
                return

            with self.clients_lock:
                self.connected_clients.add(client_socket)

            client_count = len(self.connected_clients)
            print(f"âœ… Ú©Ù„Ø§ÛŒÙ†Øª {client_address} Ù…ØªØµÙ„ Ø´Ø¯ (ØªØ¹Ø¯Ø§Ø¯ Ú©Ù„: {client_count})")

            # Ø§Ø±Ø³Ø§Ù„ Ù¾ÛŒØ§Ù… Ø®ÙˆØ´â€ŒØ¢Ù…Ø¯
            welcome_message = {
                "type": "welcome",
                "message": "Ø¨Ù‡ Ø³Ø±ÙˆØ± Ø³ÛŒÚ¯Ù†Ø§Ù„ Ù…Ø¸Ù†Ù‡ Ø®ÙˆØ´ Ø¢Ù…Ø¯ÛŒØ¯",
                "timestamp": datetime.now().isoformat(),
                "server_status": {
                    "in_trade": self.in_trade,
                    "trade_direction": self.trade_direction,
                    "market_price": self.MARKET_PRICE,
                    "warmup_complete": self.warmup_complete
                }
            }
            self._send_to_client(client_socket, welcome_message)
            self._send_candles_to_client(client_socket)

            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            # âœ… ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø³ÙˆÚ©Øª Ø¨Ø±Ø§ÛŒ Ù¾Ø§ÛŒØ¯Ø§Ø±ÛŒ
            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            client_socket.setblocking(False)

            # ÙØ¹Ø§Ù„ Ú©Ø±Ø¯Ù† TCP keepalive
            client_socket.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)

            # ØªÙ†Ø¸ÛŒÙ…Ø§Øª keepalive (Ø§Ú¯Ø± Ø³ÛŒØ³ØªÙ…â€ŒØ¹Ø§Ù…Ù„ Ù¾Ø´ØªÛŒØ¨Ø§Ù†ÛŒ Ú©Ù†Ø¯)
            try:
                # Ø´Ø±ÙˆØ¹ keepalive Ø¨Ø¹Ø¯ Ø§Ø² 60 Ø«Ø§Ù†ÛŒÙ‡ Ø¨ÛŒâ€ŒÙØ¹Ø§Ù„ÛŒØª
                client_socket.setsockopt(socket.IPPROTO_TCP, socket.TCP_KEEPIDLE, 60)
                # Ø§Ø±Ø³Ø§Ù„ keepalive Ù‡Ø± 30 Ø«Ø§Ù†ÛŒÙ‡
                client_socket.setsockopt(socket.IPPROTO_TCP, socket.TCP_KEEPINTVL, 30)
                # ØªØ¹Ø¯Ø§Ø¯ ØªÙ„Ø§Ø´â€ŒÙ‡Ø§ÛŒ keepalive Ù‚Ø¨Ù„ Ø§Ø² Ù‚Ø·Ø¹
                client_socket.setsockopt(socket.IPPROTO_TCP, socket.TCP_KEEPCNT, 5)
            except (AttributeError, OSError):
                pass  # Ø¨Ø¹Ø¶ÛŒ Ø³ÛŒØ³ØªÙ…â€ŒÙ‡Ø§ Ø§ÛŒÙ† Ú¯Ø²ÛŒÙ†Ù‡â€ŒÙ‡Ø§ Ø±Ø§ Ù†Ø¯Ø§Ø±Ù†Ø¯

            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            # âœ… Ù…ØªØºÛŒØ±Ù‡Ø§ÛŒ Ù…Ø¯ÛŒØ±ÛŒØª Ø§ØªØµØ§Ù„
            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            last_ping_time = time.time()
            last_activity_time = time.time()
            PING_INTERVAL = 1  # Ø§Ø±Ø³Ø§Ù„ ping Ù‡Ø± 25 Ø«Ø§Ù†ÛŒÙ‡
            ACTIVITY_TIMEOUT = 3600 * 24
            consecutive_errors = 0
            MAX_CONSECUTIVE_ERRORS = 10

            while self.ws_server_running:
                try:
                    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    # select Ø¨Ø§ timeout Ú©ÙˆØªØ§Ù‡
                    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    readable, _, exceptional = select.select(
                        [client_socket], [], [client_socket], 0.5
                    )

                    current_time = time.time()

                    # Ú†Ú© exceptional
                    if exceptional:
                        print(f"âš ï¸ Ø®Ø·Ø§ÛŒ Ø³ÙˆÚ©Øª Ø¨Ø±Ø§ÛŒ {client_address}")
                        break

                    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    # âœ… Ø§Ø±Ø³Ø§Ù„ ping Ø¨Ø±Ø§ÛŒ Ù†Ú¯Ù‡ Ø¯Ø§Ø´ØªÙ† Ú©Ø§Ù†Ú©Ø´Ù†
                    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    if current_time - last_ping_time >= PING_INTERVAL:
                        try:
                            # Ø§Ø±Ø³Ø§Ù„ WebSocket ping frame
                            ping_frame = bytes([0x89, 0x00])
                            client_socket.send(ping_frame)
                            last_ping_time = current_time
                            consecutive_errors = 0  # Ø±ÛŒØ³Øª Ø´Ù…Ø§Ø±Ù†Ø¯Ù‡ Ø®Ø·Ø§
                        except (BrokenPipeError, ConnectionResetError, OSError):
                            print(f"ğŸ”Œ Ø®Ø·Ø§ Ø¯Ø± Ø§Ø±Ø³Ø§Ù„ ping Ø¨Ù‡ {client_address}")
                            break

                    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    # âœ… Ú†Ú© timeout Ø¨ÛŒâ€ŒÙØ¹Ø§Ù„ÛŒØª
                    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    if current_time - last_activity_time >= ACTIVITY_TIMEOUT:
                        print(f"â° Timeout Ø¨ÛŒâ€ŒÙØ¹Ø§Ù„ÛŒØª Ø¨Ø±Ø§ÛŒ {client_address}")
                        break

                    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    # Ù¾Ø±Ø¯Ø§Ø²Ø´ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø¯Ø±ÛŒØ§ÙØªÛŒ
                    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    if readable:
                        data = self._receive_websocket_frame(client_socket)

                        if data is None:
                            # âœ… Ú©Ø§Ù†Ú©Ø´Ù† ÙˆØ§Ù‚Ø¹Ø§Ù‹ Ù‚Ø·Ø¹ Ø´Ø¯Ù‡
                            print(f"ğŸ”Œ Ú©Ø§Ù†Ú©Ø´Ù† {client_address} Ø¨Ø³ØªÙ‡ Ø´Ø¯")
                            break

                        if data == "":
                            # âœ… Ø¯Ø§Ø¯Ù‡ Ø®Ø§Ù„ÛŒ ÛŒØ§ ÙØ±ÛŒÙ… Ú©Ù†ØªØ±Ù„ÛŒ - Ø§Ø¯Ø§Ù…Ù‡ Ø¨Ø¯Ù‡
                            consecutive_errors = 0
                            continue

                        if data:
                            # âœ… Ø¯Ø§Ø¯Ù‡ Ù…Ø¹ØªØ¨Ø± Ø¯Ø±ÛŒØ§ÙØª Ø´Ø¯
                            last_activity_time = current_time
                            consecutive_errors = 0
                            self._process_client_message(client_socket, data, client_address)

                except BlockingIOError:
                    # âœ… Ø¹Ø§Ø¯ÛŒÙ‡ Ø¯Ø± Ø­Ø§Ù„Øª non-blocking
                    continue

                except (ConnectionResetError, BrokenPipeError, ConnectionAbortedError):
                    print(f"ğŸ”Œ Ú©Ø§Ù†Ú©Ø´Ù† {client_address} Ø±ÛŒØ³Øª Ø´Ø¯")
                    break

                except OSError as e:
                    if e.errno == 9:  # Bad file descriptor
                        break
                    consecutive_errors += 1
                    if consecutive_errors >= MAX_CONSECUTIVE_ERRORS:
                        print(f"âš ï¸ ØªØ¹Ø¯Ø§Ø¯ Ø®Ø·Ø§Ù‡Ø§ÛŒ Ù…ØªÙˆØ§Ù„ÛŒ Ø²ÛŒØ§Ø¯ Ø¨Ø±Ø§ÛŒ {client_address}")
                        break

                except Exception as e:
                    consecutive_errors += 1
                    if consecutive_errors >= MAX_CONSECUTIVE_ERRORS:
                        print(f"âš ï¸ Ø®Ø·Ø§Ù‡Ø§ÛŒ Ù…ØªÙˆØ§Ù„ÛŒ Ø²ÛŒØ§Ø¯: {e}")
                        break
                    if self.ws_server_running:
                        time.sleep(0.1)  # Ú©Ù…ÛŒ ØµØ¨Ø± Ú©Ù†

        except Exception as e:
            print(f"âš ï¸ Ø®Ø·Ø§ Ø¯Ø± Ù…Ø¯ÛŒØ±ÛŒØª Ú©Ù„Ø§ÛŒÙ†Øª {client_address}: {e}")

        finally:
            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            # âœ… Ù¾Ø§Ú©Ø³Ø§Ø²ÛŒ Ø§Ù…Ù†
            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            with self.clients_lock:
                self.connected_clients.discard(client_socket)

            try:
                # Ø§Ø±Ø³Ø§Ù„ close frame Ù‚Ø¨Ù„ Ø§Ø² Ø¨Ø³ØªÙ†
                close_frame = bytes([0x88, 0x00])
                client_socket.send(close_frame)
            except:
                pass

            try:
                client_socket.shutdown(socket.SHUT_RDWR)
            except:
                pass

            try:
                client_socket.close()
            except:
                pass

            client_count = len(self.connected_clients)
            print(f"ğŸ“¤ Ú©Ù„Ø§ÛŒÙ†Øª {client_address} Ù‚Ø·Ø¹ Ø´Ø¯ (ØªØ¹Ø¯Ø§Ø¯ Ø¨Ø§Ù‚ÛŒâ€ŒÙ…Ø§Ù†Ø¯Ù‡: {client_count})")

    def _perform_websocket_handshake(self, client_socket: socket.socket) -> bool:
        """
        Ø§Ù†Ø¬Ø§Ù… WebSocket Handshake (RFC 6455)
        """
        try:
            client_socket.setblocking(True)
            client_socket.settimeout(10)

            request = client_socket.recv(4096).decode('utf-8')

            if 'Upgrade: websocket' not in request and 'upgrade: websocket' not in request.lower():
                print("âš ï¸ Ø¯Ø±Ø®ÙˆØ§Ø³Øª WebSocket Ù†ÛŒØ³Øª")
                return False

            key = None
            for line in request.split('\r\n'):
                if line.lower().startswith('sec-websocket-key:'):
                    key = line.split(':', 1)[1].strip()
                    break

            if not key:
                print("âš ï¸ Ú©Ù„ÛŒØ¯ WebSocket ÛŒØ§ÙØª Ù†Ø´Ø¯")
                return False

            magic_string = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11"
            accept_key = base64.b64encode(
                hashlib.sha1((key + magic_string).encode()).digest()
            ).decode()

            response = (
                "HTTP/1.1 101 Switching Protocols\r\n"
                "Upgrade: websocket\r\n"
                "Connection: Upgrade\r\n"
                f"Sec-WebSocket-Accept: {accept_key}\r\n"
                "\r\n"
            )

            client_socket.send(response.encode())
            return True

        except Exception as e:
            print(f"âš ï¸ Ø®Ø·Ø§ Ø¯Ø± handshake: {e}")
            return False

    def _receive_websocket_frame(self, client_socket: socket.socket) -> Optional[str]:
        """
        Ø¯Ø±ÛŒØ§ÙØª Ùˆ decode Ú©Ø±Ø¯Ù† ÙØ±ÛŒÙ… WebSocket

        Returns:
            str: Ø¯Ø§Ø¯Ù‡ Ø¯Ø±ÛŒØ§ÙØªÛŒ
            "": Ø¯Ø§Ø¯Ù‡ Ø®Ø§Ù„ÛŒ ÛŒØ§ Ù¾ÛŒØ§Ù…ÛŒ Ù†Ø¨ÙˆØ¯ (Ø§Ø¯Ø§Ù…Ù‡ Ø¨Ø¯Ù‡)
            None: Ú©Ø§Ù†Ú©Ø´Ù† ÙˆØ§Ù‚Ø¹Ø§Ù‹ Ù‚Ø·Ø¹ Ø´Ø¯Ù‡ (break Ú©Ù†)
        """
        try:
            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            # âœ… Ø§ØµÙ„Ø§Ø­: Ù…Ø¯ÛŒØ±ÛŒØª Ø¨Ù‡ØªØ± Ø®ÙˆØ§Ù†Ø¯Ù† header
            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            try:
                header = client_socket.recv(2, socket.MSG_PEEK)  # Ø§ÙˆÙ„ peek Ú©Ù†
            except BlockingIOError:
                return ""  # Ø¯Ø§Ø¯Ù‡â€ŒØ§ÛŒ Ù†ÛŒØ³ØªØŒ Ø§Ø¯Ø§Ù…Ù‡ Ø¨Ø¯Ù‡
            except (ConnectionResetError, BrokenPipeError, ConnectionAbortedError):
                return None  # ÙˆØ§Ù‚Ø¹Ø§Ù‹ Ù‚Ø·Ø¹ Ø´Ø¯Ù‡

            if not header:
                return None  # Ú©Ø§Ù†Ú©Ø´Ù† Ø¨Ø³ØªÙ‡ Ø´Ø¯Ù‡

            if len(header) < 2:
                return ""  # Ù‡Ù†ÙˆØ² Ú©Ø§Ù…Ù„ Ù†Ø±Ø³ÛŒØ¯Ù‡

            # Ø­Ø§Ù„Ø§ ÙˆØ§Ù‚Ø¹ÛŒ Ø¨Ø®ÙˆØ§Ù†
            header = client_socket.recv(2)
            if len(header) < 2:
                return None

            opcode = header[0] & 0x0F
            fin = (header[0] & 0x80) != 0

            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            # âœ… Ù…Ø¯ÛŒØ±ÛŒØª ÙØ±ÛŒÙ…â€ŒÙ‡Ø§ÛŒ Ú©Ù†ØªØ±Ù„ÛŒ
            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

            # Close frame
            if opcode == 0x8:
                # Ø§Ø±Ø³Ø§Ù„ Close frame Ø¯Ø± Ù¾Ø§Ø³Ø®
                try:
                    close_frame = bytes([0x88, 0x00])
                    client_socket.send(close_frame)
                except:
                    pass
                return None

            # Ping frame
            if opcode == 0x9:
                # Ø®ÙˆØ§Ù†Ø¯Ù† payload Ù¾ÛŒÙ†Ú¯ Ùˆ Ø§Ø±Ø³Ø§Ù„ pong
                masked = (header[1] & 0x80) != 0
                payload_length = header[1] & 0x7F

                ping_payload = b""
                if payload_length > 0:
                    if masked:
                        mask_key = client_socket.recv(4)
                    ping_payload = client_socket.recv(payload_length)
                    if masked and mask_key:
                        ping_payload = bytes([ping_payload[i] ^ mask_key[i % 4] for i in range(len(ping_payload))])

                # Ø§Ø±Ø³Ø§Ù„ Pong Ø¨Ø§ Ù‡Ù…Ø§Ù† payload
                pong_header = bytes([0x8A, len(ping_payload)])
                try:
                    client_socket.send(pong_header + ping_payload)
                except:
                    pass
                return ""

            # Pong frame
            if opcode == 0xA:
                # Ø®ÙˆØ§Ù†Ø¯Ù† Ùˆ Ù†Ø§Ø¯ÛŒØ¯Ù‡ Ú¯Ø±ÙØªÙ†
                masked = (header[1] & 0x80) != 0
                payload_length = header[1] & 0x7F
                if masked:
                    client_socket.recv(4)
                if payload_length > 0:
                    client_socket.recv(payload_length)
                return ""

            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            # Ù¾Ø±Ø¯Ø§Ø²Ø´ ÙØ±ÛŒÙ… Ø¯Ø§Ø¯Ù‡
            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            masked = (header[1] & 0x80) != 0
            payload_length = header[1] & 0x7F

            if payload_length == 126:
                extended = client_socket.recv(2)
                if len(extended) < 2:
                    return ""
                payload_length = struct.unpack(">H", extended)[0]
            elif payload_length == 127:
                extended = client_socket.recv(8)
                if len(extended) < 8:
                    return ""
                payload_length = struct.unpack(">Q", extended)[0]

            mask_key = None
            if masked:
                mask_key = client_socket.recv(4)
                if len(mask_key) < 4:
                    return ""

            if payload_length == 0:
                return ""

            # Ø®ÙˆØ§Ù†Ø¯Ù† payload Ø¨Ø§ timeout
            payload = b""
            while len(payload) < payload_length:
                try:
                    remaining = payload_length - len(payload)
                    chunk = client_socket.recv(min(remaining, 4096))
                    if not chunk:
                        return None
                    payload += chunk
                except BlockingIOError:
                    # ØµØ¨Ø± Ú©Ù† ØªØ§ Ø¨Ù‚ÛŒÙ‡ Ø¨Ø±Ø³Ù‡
                    import time
                    time.sleep(0.01)
                    continue

            if masked and mask_key:
                decoded = bytearray(payload_length)
                for i in range(payload_length):
                    decoded[i] = payload[i] ^ mask_key[i % 4]
                payload = bytes(decoded)

            try:
                return payload.decode('utf-8')
            except UnicodeDecodeError:
                return ""

        except BlockingIOError:
            return ""  # âœ… Ø¯Ø§Ø¯Ù‡â€ŒØ§ÛŒ Ù†ÛŒØ³ØªØŒ Ø§Ø¯Ø§Ù…Ù‡ Ø¨Ø¯Ù‡
        except socket.timeout:
            return ""  # âœ… timeoutØŒ Ø§Ø¯Ø§Ù…Ù‡ Ø¨Ø¯Ù‡
        except (ConnectionResetError, BrokenPipeError, ConnectionAbortedError, OSError):
            return None  # âœ… ÙˆØ§Ù‚Ø¹Ø§Ù‹ Ù‚Ø·Ø¹ Ø´Ø¯Ù‡
        except Exception as e:
            # Ù„Ø§Ú¯ Ø®Ø·Ø§ ÙˆÙ„ÛŒ break Ù†Ú©Ù†
            print(f"âš ï¸ Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª ÙØ±ÛŒÙ…: {type(e).__name__}: {e}")
            return None

    def _send_websocket_frame(self, client_socket: socket.socket, message: str) -> bool:
        """
        Ø§Ø±Ø³Ø§Ù„ Ù¾ÛŒØ§Ù… Ø¨Ù‡ ØµÙˆØ±Øª ÙØ±ÛŒÙ… WebSocket
        """
        try:
            payload = message.encode('utf-8')
            length = len(payload)

            if length <= 125:
                header = bytes([0x81, length])
            elif length <= 65535:
                header = bytes([0x81, 126]) + struct.pack(">H", length)
            else:
                header = bytes([0x81, 127]) + struct.pack(">Q", length)

            client_socket.send(header + payload)
            return True

        except Exception as e:
            return False

    def _send_to_client(self, client_socket: socket.socket, data: dict) -> bool:
        """
        Ø§Ø±Ø³Ø§Ù„ Ø¯Ø§Ø¯Ù‡ Ø¨Ù‡ ÛŒÚ© Ú©Ù„Ø§ÛŒÙ†Øª Ø®Ø§Øµ
        """
        try:
            message = json.dumps(data, ensure_ascii=False)
            return self._send_websocket_frame(client_socket, message)
        except Exception as e:
            return False

    def _send_candles_to_client(self, client_socket: socket.socket):
        """
        Ø§Ø±Ø³Ø§Ù„ Ú©Ù†Ø¯Ù„â€ŒÙ‡Ø§ÛŒ ØªØ§Ø±ÛŒØ®ÛŒ Ø¨Ù‡ Ú©Ù„Ø§ÛŒÙ†Øª Ø¬Ø¯ÛŒØ¯
        """
        try:
            candles_data = self.load_candles_from_db('candles')

            data = []
            for candle in candles_data:
                data.append({
                    'time': candle['time'] if isinstance(candle, dict) else candle[0],
                    'open': float(candle['open']) if isinstance(candle, dict) else float(candle[1]),
                    'high': float(candle['high']) if isinstance(candle, dict) else float(candle[2]),
                    'low': float(candle['low']) if isinstance(candle, dict) else float(candle[3]),
                    'close': float(candle['close']) if isinstance(candle, dict) else float(candle[4])
                })

            command = {
                "type": "last_candles",
                "data": data,
                "timestamp": datetime.now().isoformat()
            }

            self._send_to_client(client_socket, command)

        except Exception as e:
            print(f"âš ï¸ Ø®Ø·Ø§ Ø¯Ø± Ø§Ø±Ø³Ø§Ù„ Ú©Ù†Ø¯Ù„â€ŒÙ‡Ø§ Ø¨Ù‡ Ú©Ù„Ø§ÛŒÙ†Øª: {e}")

    def _process_client_message(self, client_socket: socket.socket, message: str, client_address):
        """
        Ù¾Ø±Ø¯Ø§Ø²Ø´ Ù¾ÛŒØ§Ù… Ø¯Ø±ÛŒØ§ÙØªÛŒ Ø§Ø² Ú©Ù„Ø§ÛŒÙ†Øª
        """
        try:
            if not message:
                return

            data = json.loads(message)
            msg_type = data.get("type", "unknown")

            if msg_type == "ping":
                response = {
                    "type": "pong",
                    "timestamp": datetime.now().isoformat()
                }
                self._send_to_client(client_socket, response)

            elif msg_type == "get_status":
                response = {
                    "type": "status",
                    "data": {
                        "in_trade": self.in_trade,
                        "trade_direction": self.trade_direction,
                        "entry_price": self.entry_price,
                        "stop_loss": self.stop_loss_price,
                        "take_profit": self.take_profit_price,
                        "market_price": self.MARKET_PRICE,
                        "balance": self.balance,
                        "trades_count": self.trades,
                        "warmup_complete": self.warmup_complete
                    },
                    "timestamp": datetime.now().isoformat()
                }
                self._send_to_client(client_socket, response)

            elif msg_type == "get_candles":
                self._send_candles_to_client(client_socket)

            else:
                print(f"ğŸ“© Ù¾ÛŒØ§Ù… Ø§Ø² {client_address}: {data}")

        except json.JSONDecodeError:
            print(f"âš ï¸ Ù¾ÛŒØ§Ù… Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø² {client_address}: {message[:100]}")
        except Exception as e:
            print(f"âš ï¸ Ø®Ø·Ø§ Ø¯Ø± Ù¾Ø±Ø¯Ø§Ø²Ø´ Ù¾ÛŒØ§Ù…: {e}")

    def broadcast_to_clients(self, data: dict) -> int:
        """
        Ø§Ø±Ø³Ø§Ù„ Ù¾ÛŒØ§Ù… Ø¨Ù‡ Ù‡Ù…Ù‡ Ú©Ù„Ø§ÛŒÙ†Øªâ€ŒÙ‡Ø§ÛŒ Ù…ØªØµÙ„

        Returns:
            ØªØ¹Ø¯Ø§Ø¯ Ú©Ù„Ø§ÛŒÙ†Øªâ€ŒÙ‡Ø§ÛŒÛŒ Ú©Ù‡ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ù¾ÛŒØ§Ù… Ø¯Ø±ÛŒØ§ÙØª Ú©Ø±Ø¯Ù†Ø¯
        """
        if not self.connected_clients:
            return 0

        message = json.dumps(data, ensure_ascii=False)
        success_count = 0
        failed_clients = []

        with self.clients_lock:
            for client in list(self.connected_clients):
                try:
                    if self._send_websocket_frame(client, message):
                        success_count += 1
                    else:
                        failed_clients.append(client)
                except:
                    failed_clients.append(client)

            for client in failed_clients:
                self.connected_clients.discard(client)
                try:
                    client.close()
                except:
                    pass

        return success_count

    def get_connected_clients_count(self) -> int:
        """
        ØªØ¹Ø¯Ø§Ø¯ Ú©Ù„Ø§ÛŒÙ†Øªâ€ŒÙ‡Ø§ÛŒ Ù…ØªØµÙ„
        """
        return len(self.connected_clients)

    @contextmanager
    def _get_db_connection(self):
        """Context manager Ø¨Ø±Ø§ÛŒ Ø§ØªØµØ§Ù„ Ø¨Ù‡ Ø¯ÛŒØªØ§Ø¨ÛŒØ³"""
        conn = sqlite3.connect(self.DB_PATH)
        conn.row_factory = sqlite3.Row  # Ø¨Ø±Ø§ÛŒ Ø¯Ø³ØªØ±Ø³ÛŒ Ø¨Ø§ Ù†Ø§Ù… Ø³ØªÙˆÙ†
        try:
            yield conn
        finally:
            conn.close()

    def init_database(self):
        """Ø§ÛŒØ¬Ø§Ø¯ Ø¬Ø¯Ø§ÙˆÙ„ Ø¯ÛŒØªØ§Ø¨ÛŒØ³"""
        with self._get_db_connection() as conn:
            cursor = conn.cursor()

            # Ø¬Ø¯ÙˆÙ„ Ú©Ù†Ø¯Ù„â€ŒÙ‡Ø§ÛŒ M5 (3 Ø¯Ù‚ÛŒÙ‚Ù‡â€ŒØ§ÛŒ)
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS candles_m5 (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    time TEXT UNIQUE NOT NULL,
                    open REAL NOT NULL,
                    high REAL NOT NULL,
                    low REAL NOT NULL,
                    close REAL NOT NULL,
                    created_at TEXT DEFAULT CURRENT_TIMESTAMP
                )
            ''')

            # Ø¬Ø¯ÙˆÙ„ Ú©Ù†Ø¯Ù„â€ŒÙ‡Ø§ÛŒ Ø±ÙˆØ²Ø§Ù†Ù‡
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS candles (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    time TEXT UNIQUE NOT NULL,
                    open REAL NOT NULL,
                    high REAL NOT NULL,
                    low REAL NOT NULL,
                    close REAL NOT NULL,
                    created_at TEXT DEFAULT CURRENT_TIMESTAMP
                )
            ''')

            # Ø§ÛŒÙ†Ø¯Ú©Ø³ Ø¨Ø±Ø§ÛŒ Ø³Ø±Ø¹Øª Ø¨ÛŒØ´ØªØ±
            cursor.execute('''
                CREATE INDEX IF NOT EXISTS idx_m5_time
                ON candles_m5(time)
            ''')

            cursor.execute('''
                CREATE INDEX IF NOT EXISTS idx_daily_time 
                ON candles(time)
            ''')

            conn.commit()
            print("âœ… Ø¬Ø¯Ø§ÙˆÙ„ Ø¯ÛŒØªØ§Ø¨ÛŒØ³ Ø§ÛŒØ¬Ø§Ø¯/Ø¨Ø±Ø±Ø³ÛŒ Ø´Ø¯")

    def check_warmup_status(self):
        """
        Ø¨Ø±Ø±Ø³ÛŒ ÙˆØ¶Ø¹ÛŒØª Ú¯Ø±Ù… Ø´Ø¯Ù† Ø±Ø¨Ø§Øª

        Ø±Ø¨Ø§Øª Ø¨Ø§ÛŒØ¯:
        1. Ø­Ø¯Ø§Ù‚Ù„ WARMUP_CANDLES Ú©Ù†Ø¯Ù„ real-time Ø¨Ø¨ÛŒÙ†Ø¯
        2. ÛŒØ§ Ø­Ø¯Ø§Ù‚Ù„ WARMUP_MINUTES Ø¯Ù‚ÛŒÙ‚Ù‡ Ø§Ø² Ø´Ø±ÙˆØ¹ Ú¯Ø°Ø´ØªÙ‡ Ø¨Ø§Ø´Ø¯

        Returns:
            bool: Ø¢ÛŒØ§ warm-up ØªÙ…Ø§Ù… Ø´Ø¯Ù‡ Ùˆ Ù…ÛŒâ€ŒØªÙˆØ§Ù† Ù…Ø¹Ø§Ù…Ù„Ù‡ Ú©Ø±Ø¯
        """

        # Ø§Ú¯Ø± warm-up ØºÛŒØ±ÙØ¹Ø§Ù„ Ø§Ø³Øª
        if not self.WARMUP_ENABLED:
            return True

        # Ø§Ú¯Ø± Ù‚Ø¨Ù„Ø§Ù‹ ØªØ§ÛŒÛŒØ¯ Ø´Ø¯Ù‡
        if self.warmup_complete:
            return True

        # Ø¨Ø±Ø±Ø³ÛŒ ØªØ¹Ø¯Ø§Ø¯ Ú©Ù†Ø¯Ù„â€ŒÙ‡Ø§
        candles_ok = self.warmup_candles_seen >= self.WARMUP_CANDLES

        # Ø¨Ø±Ø±Ø³ÛŒ Ø²Ù…Ø§Ù†
        time_ok = False
        if self.warmup_start_time:
            elapsed_minutes = (datetime.now() - self.warmup_start_time).total_seconds() / 60
            time_ok = elapsed_minutes >= self.WARMUP_MINUTES

        # Ù‡Ø± Ø¯Ùˆ Ø´Ø±Ø· ÛŒØ§ ÛŒÚ©ÛŒ Ø§Ø² Ø¢Ù†â€ŒÙ‡Ø§
        if candles_ok or time_ok:
            self.warmup_complete = True
            print(f"\n{'â•' * 50}")
            print(f"ğŸ”¥ Ø¯ÙˆØ±Ù‡ Ú¯Ø±Ù… Ø´Ø¯Ù† Ø±Ø¨Ø§Øª ØªÙ…Ø§Ù… Ø´Ø¯!")
            print(f"{'â•' * 50}")
            print(f"   ğŸ“Š Ú©Ù†Ø¯Ù„â€ŒÙ‡Ø§ÛŒ Ù…Ø´Ø§Ù‡Ø¯Ù‡ Ø´Ø¯Ù‡: {self.warmup_candles_seen}")
            if self.warmup_start_time:
                elapsed = (datetime.now() - self.warmup_start_time).total_seconds() / 60
                print(f"   â±ï¸ Ø²Ù…Ø§Ù† Ø³Ù¾Ø±ÛŒ Ø´Ø¯Ù‡: {elapsed:.1f} Ø¯Ù‚ÛŒÙ‚Ù‡")
            print(f"   âœ… Ø±Ø¨Ø§Øª Ø¢Ù…Ø§Ø¯Ù‡ ØµØ¯ÙˆØ± Ø³ÛŒÚ¯Ù†Ø§Ù„ Ø§Ø³Øª!")
            print(f"{'â•' * 50}\n")
            return True

        # Ù‡Ù†ÙˆØ² Ø¯Ø± Ø­Ø§Ù„ Ú¯Ø±Ù… Ø´Ø¯Ù†
        return False

    def start_warmup(self):
        """Ø´Ø±ÙˆØ¹ Ø¯ÙˆØ±Ù‡ warm-up"""
        if self.WARMUP_ENABLED and not self.warmup_start_time:
            self.warmup_start_time = datetime.now()
            self.warmup_candles_seen = 0
            self.warmup_complete = False

            print(f"\n{'â•' * 50}")
            print(f"ğŸ”¥ Ø´Ø±ÙˆØ¹ Ø¯ÙˆØ±Ù‡ Ú¯Ø±Ù… Ø´Ø¯Ù† Ø±Ø¨Ø§Øª")
            print(f"{'â•' * 50}")
            print(f"   ğŸ“Š ØªØ¹Ø¯Ø§Ø¯ Ú©Ù†Ø¯Ù„ Ù…ÙˆØ±Ø¯ Ù†ÛŒØ§Ø²: {self.WARMUP_CANDLES}")
            print(f"   â±ï¸ ÛŒØ§ Ø­Ø¯Ø§Ù‚Ù„: {self.WARMUP_MINUTES} Ø¯Ù‚ÛŒÙ‚Ù‡")
            print(f"   âš ï¸ Ø¯Ø± Ø§ÛŒÙ† Ù…Ø¯Øª Ø³ÛŒÚ¯Ù†Ø§Ù„ÛŒ ØµØ§Ø¯Ø± Ù†Ù…ÛŒâ€ŒØ´ÙˆØ¯")
            print(f"{'â•' * 50}\n")

    def save_candle_to_db(self, table, datetime_str, open_price, high, low, close):
        """Ø°Ø®ÛŒØ±Ù‡ ÛŒÚ© Ú©Ù†Ø¯Ù„ Ø¯Ø± Ø¯ÛŒØªØ§Ø¨ÛŒØ³"""
        with self._get_db_connection() as conn:
            cursor = conn.cursor()

            # INSERT OR REPLACE: Ø§Ú¯Ø± ÙˆØ¬ÙˆØ¯ Ø¯Ø§Ø´Øª Ø¢Ù¾Ø¯ÛŒØª Ú©Ù†ØŒ Ù†Ø¯Ø§Ø´Øª Ø§Ø¶Ø§ÙÙ‡ Ú©Ù†
            cursor.execute(f'''
                INSERT OR REPLACE INTO {table} 
                (time, open, high, low, close)
                VALUES (?, ?, ?, ?, ?)
            ''', (datetime_str, open_price, high, low, close))

            conn.commit()

    def load_candles_from_db(self, table, limit=500):
        """Ø®ÙˆØ§Ù†Ø¯Ù† Ú©Ù†Ø¯Ù„â€ŒÙ‡Ø§ Ø§Ø² Ø¯ÛŒØªØ§Ø¨ÛŒØ³"""
        with self._get_db_connection() as conn:
            cursor = conn.cursor()

            cursor.execute(f'''
                SELECT time, open, high, low, close 
                FROM {table} 
                ORDER BY time DESC 
                LIMIT ?
            ''', (limit,))

            rows = cursor.fetchall()

            # Ø¨Ø±Ú¯Ø±Ø¯Ø§Ù†Ø¯Ù† Ø¨Ù‡ ØªØ±ØªÛŒØ¨ ØµØ­ÛŒØ­ (Ù‚Ø¯ÛŒÙ…ÛŒ Ø¨Ù‡ Ø¬Ø¯ÛŒØ¯)
            return list(reversed(rows))

    def send_last_candles(self) -> bool:
        """
        Ø§Ø±Ø³Ø§Ù„ Ú©Ù†Ø¯Ù„â€ŒÙ‡Ø§ÛŒ ØªØ§Ø±ÛŒØ®ÛŒ Ø¨Ù‡ Ù‡Ù…Ù‡ Ú©Ù„Ø§ÛŒÙ†Øªâ€ŒÙ‡Ø§
        """
        try:
            candles_data = self.load_candles_from_db('candles')

            data = []
            for candle in candles_data:
                data.append({
                    'time': candle['time'] if isinstance(candle, dict) else candle[0],
                    'open': float(candle['open']) if isinstance(candle, dict) else float(candle[1]),
                    'high': float(candle['high']) if isinstance(candle, dict) else float(candle[2]),
                    'low': float(candle['low']) if isinstance(candle, dict) else float(candle[3]),
                    'close': float(candle['close']) if isinstance(candle, dict) else float(candle[4])
                })

            command = {
                "type": "last_candles",
                "data": data,
                "timestamp": datetime.now().isoformat()
            }

            return self.send_command(command)

        except Exception as e:
            print(f"âš ï¸ Ø®Ø·Ø§ Ø¯Ø± Ø§Ø±Ø³Ø§Ù„ Ú©Ù†Ø¯Ù„â€ŒÙ‡Ø§: {e}")
            import traceback
            traceback.print_exc()
            return False

    def log_error(self, username: Optional[str], operation: str, error: str, details: Dict = None) -> None:
        """Ø°Ø®ÛŒØ±Ù‡ Ø®Ø·Ø§ Ø¯Ø± Ù„ÛŒØ³Øª Ø®Ø·Ø§Ù‡Ø§"""
        error_info = {
            'username': username,
            'operation': operation,
            'error': error,
            'details': details or {},
            'timestamp': datetime.now().isoformat()
        }
        self.errors.append(error_info)
        print(f"âŒ Ø®Ø·Ø§ {'Ø¨Ø±Ø§ÛŒ ' + username if username else ''}: [{operation}] {error}")

    def get_errors(self) -> List[Dict]:
        """Ø¯Ø±ÛŒØ§ÙØª Ù„ÛŒØ³Øª Ø®Ø·Ø§Ù‡Ø§"""
        return self.errors.copy()

    def get_errors_for_user(self, username: str) -> List[Dict]:
        """Ø¯Ø±ÛŒØ§ÙØª Ø®Ø·Ø§Ù‡Ø§ÛŒ ÛŒÚ© Ú©Ø§Ø±Ø¨Ø± Ø®Ø§Øµ"""
        return [e for e in self.errors if e.get('username') == username]

    def clear_errors(self) -> None:
        """Ù¾Ø§Ú© Ú©Ø±Ø¯Ù† Ù„ÛŒØ³Øª Ø®Ø·Ø§Ù‡Ø§"""
        self.errors = []
        print("ğŸ—‘ï¸ Ù„ÛŒØ³Øª Ø®Ø·Ø§Ù‡Ø§ Ù¾Ø§Ú© Ø´Ø¯")

    def get_candle_count(self, table):
        """ØªØ¹Ø¯Ø§Ø¯ Ú©Ù†Ø¯Ù„â€ŒÙ‡Ø§ÛŒ Ù…ÙˆØ¬ÙˆØ¯ Ø¯Ø± Ø¯ÛŒØªØ§Ø¨ÛŒØ³"""
        with self._get_db_connection() as conn:
            cursor = conn.cursor()
            cursor.execute(f'SELECT COUNT(*) FROM {table}')
            return cursor.fetchone()[0]

    def load_historical_data(self, filepath='mazaneh_data.json'):
        """
        Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ ØªØ§Ø±ÛŒØ®ÛŒ

        ØªØ±ØªÛŒØ¨ Ø¹Ù…Ù„ÛŒØ§Øª:
        1. Ù¾Ø§Ú©â€ŒØ³Ø§Ø²ÛŒ Ø¯ÛŒØªØ§Ø¨ÛŒØ³
        2. Ø¯Ø§Ù†Ù„ÙˆØ¯ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø¬Ø¯ÛŒØ¯ Ø§Ø² ÙØ±Ø§Ø²Ú¯Ù„Ø¯
        3. Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ø§Ø² Ø¯ÛŒØªØ§Ø¨ÛŒØ³ Ø¨Ù‡ Ø­Ø§ÙØ¸Ù‡
        4. Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø§Ù†Ø¯ÛŒÚ©Ø§ØªÙˆØ±Ù‡Ø§

        Returns:
            bool: Ø¢ÛŒØ§ Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ù…ÙˆÙÙ‚ Ø¨ÙˆØ¯
        """

        print(f"\n{'â•' * 60}")
        print(f"ğŸ“‚ Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ ØªØ§Ø±ÛŒØ®ÛŒ")
        print(f"{'â•' * 60}")

        try:
            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            # 1ï¸âƒ£ Ù¾Ø§Ú©â€ŒØ³Ø§Ø²ÛŒ Ø¯ÛŒØªØ§Ø¨ÛŒØ³
            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            self.clear_database()

            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            # 2ï¸âƒ£ Ø¯Ø§Ù†Ù„ÙˆØ¯ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø¬Ø¯ÛŒØ¯ Ø§Ø² ÙØ±Ø§Ø²Ú¯Ù„Ø¯
            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            if not self.download_historical_from_faraz():
                print(f"\nâŒ Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø§Ù†Ù„ÙˆØ¯ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ Ø§Ø² ÙØ±Ø§Ø²Ú¯Ù„Ø¯")
                return False

            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            # 3ï¸âƒ£ Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ø§Ø² Ø¯ÛŒØªØ§Ø¨ÛŒØ³
            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            m5_count = self.get_candle_count('candles_m5')
            daily_count = self.get_candle_count('candles')

            print(f"\nğŸ“Š Ú©Ù†Ø¯Ù„â€ŒÙ‡Ø§ÛŒ Ø°Ø®ÛŒØ±Ù‡ Ø´Ø¯Ù‡: M5={m5_count}, Daily={daily_count}")

            if m5_count < 21 or daily_count < 3:
                print(f"âŒ Ø¯Ø§Ø¯Ù‡ Ú©Ø§ÙÛŒ Ø¯Ø§Ù†Ù„ÙˆØ¯ Ù†Ø´Ø¯")
                return False

            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            # 4ï¸âƒ£ Ø®ÙˆØ§Ù†Ø¯Ù† Ú©Ù†Ø¯Ù„â€ŒÙ‡Ø§ÛŒ M5
            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            print(f"\nğŸ“¥ Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ú©Ù†Ø¯Ù„â€ŒÙ‡Ø§ÛŒ M5...")

            m5_rows = self.load_candles_from_db('candles_m5', limit=500)

            self.m3_data.clear()
            for row in m5_rows:
                time_value = row['time'] if isinstance(row, dict) else row[0]
                open_value = row['open'] if isinstance(row, dict) else row[1]
                high_value = row['high'] if isinstance(row, dict) else row[2]
                low_value = row['low'] if isinstance(row, dict) else row[3]
                close_value = row['close'] if isinstance(row, dict) else row[4]

                self.m3_data.append({
                    'time': pd.Timestamp(time_value),
                    'open': float(open_value),
                    'high': float(high_value),
                    'low': float(low_value),
                    'close': float(close_value)
                })

            print(f"   âœ… {len(self.m3_data)} Ú©Ù†Ø¯Ù„ M5 Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ø´Ø¯")

            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            # 5ï¸âƒ£ Ø®ÙˆØ§Ù†Ø¯Ù† Ú©Ù†Ø¯Ù„â€ŒÙ‡Ø§ÛŒ Ø±ÙˆØ²Ø§Ù†Ù‡
            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            print(f"\nğŸ“¥ Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ú©Ù†Ø¯Ù„â€ŒÙ‡Ø§ÛŒ Ø±ÙˆØ²Ø§Ù†Ù‡...")

            daily_rows = self.load_candles_from_db('candles', limit=400)

            self.daily_data.clear()
            for row in daily_rows:
                time_value = row['time'] if isinstance(row, dict) else row[0]
                open_value = row['open'] if isinstance(row, dict) else row[1]
                high_value = row['high'] if isinstance(row, dict) else row[2]
                low_value = row['low'] if isinstance(row, dict) else row[3]
                close_value = row['close'] if isinstance(row, dict) else row[4]

                self.daily_data.append({
                    'time': pd.Timestamp(time_value),
                    'open': float(open_value),
                    'high': float(high_value),
                    'low': float(low_value),
                    'close': float(close_value)
                })

            print(f"   âœ… {len(self.daily_data)} Ú©Ù†Ø¯Ù„ Ø±ÙˆØ²Ø§Ù†Ù‡ Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ø´Ø¯")

            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            # 6ï¸âƒ£ ØªØ¨Ø¯ÛŒÙ„ Ø¨Ù‡ DataFrame
            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            self.m3 = pd.DataFrame(list(self.m3_data))
            if not self.m3.empty:
                self.m3.set_index('time', inplace=True)

            self.daily = pd.DataFrame(list(self.daily_data))
            if not self.daily.empty:
                self.daily.set_index('time', inplace=True)

            print(f"\nğŸ“Š DataFrame Ø§ÛŒØ¬Ø§Ø¯ Ø´Ø¯:")
            print(f"   M5: {len(self.m3)} Ø±Ø¯ÛŒÙ")
            print(f"   Daily: {len(self.daily)} Ø±Ø¯ÛŒÙ")

            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            # 7ï¸âƒ£ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø§Ù†Ø¯ÛŒÚ©Ø§ØªÙˆØ±Ù‡Ø§
            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            print(f"\nğŸ“ˆ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø§Ù†Ø¯ÛŒÚ©Ø§ØªÙˆØ±Ù‡Ø§...")
            self.calculate_initial_indicators()

            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            # 8ï¸âƒ£ Ø§Ø±Ø³Ø§Ù„ Ú©Ù†Ø¯Ù„â€ŒÙ‡Ø§ Ø¨Ù‡ Ú©Ù„Ø§ÛŒÙ†Øªâ€ŒÙ‡Ø§ÛŒ Ù…ØªØµÙ„
            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            if self.COMMAND_SERVER_STATUS == "running" and self.get_connected_clients_count() > 0:
                print(f"\nğŸ“¤ Ø§Ø±Ø³Ø§Ù„ Ú©Ù†Ø¯Ù„â€ŒÙ‡Ø§ Ø¨Ù‡ Ú©Ù„Ø§ÛŒÙ†Øªâ€ŒÙ‡Ø§ÛŒ Ù…ØªØµÙ„...")
                self.send_last_candles()

            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            # 9ï¸âƒ£ Ø±ÛŒØ³Øª Warm-up
            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            self.warmup_complete = False
            self.warmup_start_time = None
            self.warmup_candles_seen = 0

            print(f"\n{'â•' * 60}")
            print(f"âœ… Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ ØªØ§Ø±ÛŒØ®ÛŒ Ú©Ø§Ù…Ù„ Ø´Ø¯")
            print(f"{'â•' * 60}")
            print(f"   ğŸ“Š M5: {len(self.m3)} Ú©Ù†Ø¯Ù„")
            print(f"   ğŸ“Š Daily: {len(self.daily)} Ú©Ù†Ø¯Ù„")
            print(f"   ğŸ”¥ Ù…Ù†ØªØ¸Ø± Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ real-time Ø¨Ø±Ø§ÛŒ warm-up...")
            print(f"{'â•' * 60}\n")

            return True

        except Exception as e:
            print(f"\nâŒ Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§: {e}")
            import traceback
            traceback.print_exc()
            return False

    def load_from_database(self):
        """Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ Ø§Ø² Ø¯ÛŒØªØ§Ø¨ÛŒØ³"""
        try:
            # ... Ú©Ø¯ Ù…ÙˆØ¬ÙˆØ¯ Ø¨Ø±Ø§ÛŒ Ø®ÙˆØ§Ù†Ø¯Ù† Ø§Ø² Ø¯ÛŒØªØ§Ø¨ÛŒØ³ ...

            m5_rows = self.load_candles_from_db('candles_m5', limit=500)
            for row in m5_rows:
                self.m3_data.append({
                    'time': pd.Timestamp(row['time']),
                    'open': row['open'],
                    'high': row['high'],
                    'low': row['low'],
                    'close': row['close']
                })

            daily_rows = self.load_candles_from_db('candles', limit=400)
            for row in daily_rows:
                self.daily_data.append({
                    'time': pd.Timestamp(row['time']),
                    'open': row['open'],
                    'high': row['high'],
                    'low': row['low'],
                    'close': row['close']
                })

            self.m3 = pd.DataFrame(list(self.m3_data))
            if not self.m3.empty:
                self.m3.set_index('time', inplace=True)

            self.daily = pd.DataFrame(list(self.daily_data))
            if not self.daily.empty:
                self.daily.set_index('time', inplace=True)

            print(f"âœ… Ø§Ø² Ø¯ÛŒØªØ§Ø¨ÛŒØ³ Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ø´Ø¯: M5={len(self.m3)}, Daily={len(self.daily)}")

            self.calculate_initial_indicators()

            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            # ğŸ”¥ Ø±ÛŒØ³Øª Ú©Ø±Ø¯Ù† warm-up
            # Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ ØªØ§Ø±ÛŒØ®ÛŒ Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ø´Ø¯ØŒ Ø­Ø§Ù„Ø§ Ø¨Ø§ÛŒØ¯ Ø¨Ø§ real-time Ú¯Ø±Ù… Ø´ÙˆØ¯
            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            self.warmup_complete = False
            self.warmup_start_time = None
            self.warmup_candles_seen = 0

            print(f"\n{'â”€' * 50}")
            print(f"âœ… Ø±Ø¨Ø§Øª Ø¢Ù…Ø§Ø¯Ù‡ Ø§Ø³Øª")
            print(f"ğŸ”¥ Ù…Ù†ØªØ¸Ø± Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ real-time Ø¨Ø±Ø§ÛŒ Ø´Ø±ÙˆØ¹ warm-up...")
            print(f"{'â”€' * 50}\n")

            return True

        except Exception as e:
            print(f"âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ø§Ø² Ø¯ÛŒØªØ§Ø¨ÛŒØ³: {e}")
            import traceback
            traceback.print_exc()
            return False

    def determine_strategy_mode(self):
        """
        ØªØ´Ø®ÛŒØµ Ø®ÙˆØ¯Ú©Ø§Ø± Ø§Ø³ØªØ±Ø§ØªÚ˜ÛŒ Ù…Ù†Ø§Ø³Ø¨ (Ø§Ø³Ú©Ø§Ù„Ù¾ ÛŒØ§ Ø³ÙˆØ¦ÛŒÙ†Ú¯)

        ğŸ”„ ØªØºÛŒÛŒØ±: Ø­Ø°Ù Ù…Ø¹ÛŒØ§Ø± Ø¬Ù„Ø³Ù‡ Ù…Ø¹Ø§Ù…Ù„Ø§ØªÛŒ

        Ù…Ø¹ÛŒØ§Ø±Ù‡Ø§ÛŒ ØªØ´Ø®ÛŒØµ (Ø¨Ø¯ÙˆÙ† Ø²Ù…Ø§Ù†):
        1. Ù†ÙˆØ³Ø§Ù† Ø¨Ø§Ø²Ø§Ø± (ATR) - Ù†ÙˆØ³Ø§Ù† Ú©Ù… â†’ Ø§Ø³Ú©Ø§Ù„Ù¾ØŒ Ù†ÙˆØ³Ø§Ù† Ø²ÛŒØ§Ø¯ â†’ Ø³ÙˆØ¦ÛŒÙ†Ú¯
        2. Ù‚Ø¯Ø±Øª Ø±ÙˆÙ†Ø¯ (ADX) - Ø±ÙˆÙ†Ø¯ Ø¶Ø¹ÛŒÙ â†’ Ø§Ø³Ú©Ø§Ù„Ù¾ØŒ Ø±ÙˆÙ†Ø¯ Ù‚ÙˆÛŒ â†’ Ø³ÙˆØ¦ÛŒÙ†Ú¯
        3. Ù†ÙˆØ³Ø§Ù† Ù†Ø³Ø¨ÛŒ - Ù†ÙˆØ³Ø§Ù† Ú©Ù… Ù†Ø³Ø¨Øª Ø¨Ù‡ Ù…ÛŒØ§Ù†Ú¯ÛŒÙ† â†’ Ø§Ø³Ú©Ø§Ù„Ù¾

        Ø¨Ø§Ø²Ú¯Ø´Øª:
        - 'scalp' ÛŒØ§ 'swing'
        """

        # ğŸ”¹ Ø§Ú¯Ø± Ø­Ø§Ù„Øª Ø¯Ø³ØªÛŒ ØªÙ†Ø¸ÛŒÙ… Ø´Ø¯Ù‡ØŒ Ø§Ø² Ø¢Ù† Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†
        if hasattr(self, 'STRATEGY_MODE') and self.STRATEGY_MODE != 'auto':
            print(f"ğŸ¯ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ø§Ø³ØªØ±Ø§ØªÚ˜ÛŒ Ø¯Ø³ØªÛŒ: {self.STRATEGY_MODE.upper()}")
            return self.STRATEGY_MODE

        # ğŸ”¹ Ø¨Ø±Ø±Ø³ÛŒ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ù„Ø§Ø²Ù…
        if len(self.m3) < 20:
            print("âš ï¸ Ø¯Ø§Ø¯Ù‡ M5 Ú©Ø§ÙÛŒ Ù†ÛŒØ³ØªØŒ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ø³ÙˆØ¦ÛŒÙ†Ú¯ Ø¨Ù‡ Ø¹Ù†ÙˆØ§Ù† Ù¾ÛŒØ´â€ŒÙØ±Ø¶")
            return 'swing'

        try:
            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            # ğŸ“Š 1. Ù…Ø­Ø§Ø³Ø¨Ù‡ Ù†ÙˆØ³Ø§Ù† (ATR)
            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            current_atr = 5  # Ù…Ù‚Ø¯Ø§Ø± Ù¾ÛŒØ´â€ŒÙØ±Ø¶ Ø¨Ø±Ø§ÛŒ Ù…Ø¸Ù†Ù‡ (5 Ø®Ø·)
            if 'atr' in self.m3.columns:
                atr_value = self.m3['atr'].iloc[-1]
                if pd.notna(atr_value) and atr_value > 0:
                    current_atr = int(atr_value)

            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            # ğŸ“Š 2. Ù…Ø­Ø§Ø³Ø¨Ù‡ Ù‚Ø¯Ø±Øª Ø±ÙˆÙ†Ø¯ (ADX)
            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            current_adx = 25  # Ù…Ù‚Ø¯Ø§Ø± Ù¾ÛŒØ´â€ŒÙØ±Ø¶
            if 'adx' in self.m3.columns:
                adx_value = self.m3['adx'].iloc[-1]
                if pd.notna(adx_value):
                    current_adx = adx_value

            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            # ğŸ“Š 3. Ù…Ø­Ø§Ø³Ø¨Ù‡ Ù†ÙˆØ³Ø§Ù† Ù†Ø³Ø¨ÛŒ
            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            recent_candles = self.m3.iloc[-20:]
            candle_ranges = recent_candles['high'] - recent_candles['low']
            avg_range = candle_ranges.mean()
            current_range = candle_ranges.iloc[-1]

            if avg_range == 0 or pd.isna(avg_range):
                range_ratio = 1.0
            else:
                range_ratio = current_range / avg_range

            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            # ğŸ¯ 4. Ø³ÛŒØ³ØªÙ… Ø§Ù…ØªÛŒØ§Ø²Ø¯Ù‡ÛŒ Ø¨Ø±Ø§ÛŒ ØªØ´Ø®ÛŒØµ Ø§Ø³ØªØ±Ø§ØªÚ˜ÛŒ
            # ğŸ”„ Ø¨Ø¯ÙˆÙ† Ù…Ø¹ÛŒØ§Ø± Ø²Ù…Ø§Ù†/Ø¬Ù„Ø³Ù‡
            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            score = 0

            # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            # Ù…Ø¹ÛŒØ§Ø± 1: Ù†ÙˆØ³Ø§Ù† (ATR) - ÙˆØ²Ù†: 40 Ø§Ù…ØªÛŒØ§Ø²
            # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            if current_atr < 4:  # Ù†ÙˆØ³Ø§Ù† Ú©Ù… (Ú©Ù…ØªØ± Ø§Ø² 4 Ø®Ø·)
                score += 40
                atr_status = "Ú©Ù… (Ù…Ù†Ø§Ø³Ø¨ Ø§Ø³Ú©Ø§Ù„Ù¾)"
            elif current_atr < 8:  # Ù†ÙˆØ³Ø§Ù† Ù…ØªÙˆØ³Ø·
                score += 15
                atr_status = "Ù…ØªÙˆØ³Ø·"
            else:  # Ù†ÙˆØ³Ø§Ù† Ø²ÛŒØ§Ø¯ (Ø¨ÛŒØ´ØªØ± Ø§Ø² 8 Ø®Ø·)
                score -= 25
                atr_status = "Ø²ÛŒØ§Ø¯ (Ù…Ù†Ø§Ø³Ø¨ Ø³ÙˆØ¦ÛŒÙ†Ú¯)"

            # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            # Ù…Ø¹ÛŒØ§Ø± 2: Ù‚Ø¯Ø±Øª Ø±ÙˆÙ†Ø¯ (ADX) - ÙˆØ²Ù†: 35 Ø§Ù…ØªÛŒØ§Ø²
            # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            if current_adx < 18:  # Ø±ÙˆÙ†Ø¯ Ø¶Ø¹ÛŒÙ
                score += 35
                adx_status = "Ø¶Ø¹ÛŒÙ (Ù…Ù†Ø§Ø³Ø¨ Ø§Ø³Ú©Ø§Ù„Ù¾)"
            elif current_adx < 25:  # Ø±ÙˆÙ†Ø¯ Ù…ØªÙˆØ³Ø·
                score += 10
                adx_status = "Ù…ØªÙˆØ³Ø·"
            else:  # Ø±ÙˆÙ†Ø¯ Ù‚ÙˆÛŒ
                score -= 20
                adx_status = "Ù‚ÙˆÛŒ (Ù…Ù†Ø§Ø³Ø¨ Ø³ÙˆØ¦ÛŒÙ†Ú¯)"

            # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            # Ù…Ø¹ÛŒØ§Ø± 3: Ù†ÙˆØ³Ø§Ù† Ù†Ø³Ø¨ÛŒ - ÙˆØ²Ù†: 25 Ø§Ù…ØªÛŒØ§Ø²
            # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            if range_ratio < 0.7:
                score += 25
                range_status = "Ú©Ù… Ù†Ø³Ø¨Øª Ø¨Ù‡ Ù…ÛŒØ§Ù†Ú¯ÛŒÙ†"
            elif range_ratio > 1.3:
                score -= 25
                range_status = "Ø²ÛŒØ§Ø¯ Ù†Ø³Ø¨Øª Ø¨Ù‡ Ù…ÛŒØ§Ù†Ú¯ÛŒÙ†"
            else:
                range_status = "Ù†Ø±Ù…Ø§Ù„"

            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            # ğŸ¯ 5. ØªØµÙ…ÛŒÙ…â€ŒÚ¯ÛŒØ±ÛŒ Ù†Ù‡Ø§ÛŒÛŒ
            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            if score >= 50:
                strategy = 'scalp'
                confidence = "Ø¨Ø§Ù„Ø§"
            elif score >= 25:
                strategy = 'scalp'
                confidence = "Ù…ØªÙˆØ³Ø·"
            elif score >= 0:
                strategy = 'swing'
                confidence = "Ù…ØªÙˆØ³Ø·"
            else:
                strategy = 'swing'
                confidence = "Ø¨Ø§Ù„Ø§"

            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            # ğŸ“Š Ù†Ù…Ø§ÛŒØ´ Ù†ØªØ§ÛŒØ¬ ØªØ´Ø®ÛŒØµ
            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            print(f"\n{'â”€' * 50}")
            print(f"ğŸ¯ ØªØ´Ø®ÛŒØµ Ø§Ø³ØªØ±Ø§ØªÚ˜ÛŒ Ø®ÙˆØ¯Ú©Ø§Ø±")
            print(f"{'â”€' * 50}")
            print(f"   ğŸ“Š ATR: {current_atr} Ø®Ø· - {atr_status}")
            print(f"   ğŸ“ˆ ADX: {current_adx:.1f} - {adx_status}")
            print(f"   ğŸ“‰ Ù†ÙˆØ³Ø§Ù† Ù†Ø³Ø¨ÛŒ: {range_ratio:.2f}x - {range_status}")
            print(f"   ğŸ”¢ Ø§Ù…ØªÛŒØ§Ø² Ù†Ù‡Ø§ÛŒÛŒ: {score:+d}")
            print(f"   âœ… Ø§Ø³ØªØ±Ø§ØªÚ˜ÛŒ: {strategy.upper()} (Ø§Ø·Ù…ÛŒÙ†Ø§Ù†: {confidence})")
            print(f"{'â”€' * 50}")

            return strategy

        except Exception as e:
            print(f"âš ï¸ Ø®Ø·Ø§ Ø¯Ø± ØªØ´Ø®ÛŒØµ Ø§Ø³ØªØ±Ø§ØªÚ˜ÛŒ: {e}")
            import traceback
            traceback.print_exc()
            return 'swing'

    def calculate_daily_trend_score(self):
        """
        Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø§Ù…ØªÛŒØ§Ø² Ø±ÙˆÙ†Ø¯ Ø±ÙˆØ²Ø§Ù†Ù‡ (100- ØªØ§ 100+)

        Ø§ÛŒÙ† ØªØ§Ø¨Ø¹ Ø±ÙˆÙ†Ø¯ Ø±ÙˆØ²Ø§Ù†Ù‡ Ø±Ø§ Ø¨Ø§ Ø³ÛŒØ³ØªÙ… Ø§Ù…ØªÛŒØ§Ø²Ø¯Ù‡ÛŒ ØªØ­Ù„ÛŒÙ„ Ù…ÛŒâ€ŒÚ©Ù†Ø¯
        Ø¨Ù‡ Ø¬Ø§ÛŒ Ø´Ø±Ø· Ø¨Ø§ÛŒÙ†Ø±ÛŒ (Ø¢Ø±ÛŒ/Ø®ÛŒØ±) Ú©Ù‡ Ø¯Ø± Ú©Ø¯ Ù‚Ø¨Ù„ÛŒ Ø¨ÙˆØ¯.

        Ø§Ù…ØªÛŒØ§Ø² Ù…Ø«Ø¨Øª â†’ Ø±ÙˆÙ†Ø¯ ØµØ¹ÙˆØ¯ÛŒ (Ù…Ù†Ø§Ø³Ø¨ LONG)
        Ø§Ù…ØªÛŒØ§Ø² Ù…Ù†ÙÛŒ â†’ Ø±ÙˆÙ†Ø¯ Ù†Ø²ÙˆÙ„ÛŒ (Ù…Ù†Ø§Ø³Ø¨ SHORT)
        Ø§Ù…ØªÛŒØ§Ø² Ù†Ø²Ø¯ÛŒÚ© Ø¨Ù‡ ØµÙØ± â†’ Ø¨Ø§Ø²Ø§Ø± Ø®Ù†Ø«ÛŒ

        Ù…Ø¹ÛŒØ§Ø±Ù‡Ø§ Ùˆ ÙˆØ²Ù†â€ŒÙ‡Ø§:
        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        Ù…Ø¹ÛŒØ§Ø±                      | ÙˆØ²Ù†
        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        1. Ù‚ÛŒÙ…Øª Ù†Ø³Ø¨Øª Ø¨Ù‡ EMA55      | Â±40 Ø§Ù…ØªÛŒØ§Ø²
        2. ÙØ§ØµÙ„Ù‡ EMA55 Ø§Ø² EMA200   | Â±30 Ø§Ù…ØªÛŒØ§Ø²
        3. RSI Ø±ÙˆØ²Ø§Ù†Ù‡              | Â±30 Ø§Ù…ØªÛŒØ§Ø²
        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

        Ø¨Ø§Ø²Ú¯Ø´Øª:
        - Ø§Ù…ØªÛŒØ§Ø² Ø¨ÛŒÙ† 100- ØªØ§ 100+
        """

        # Ø¨Ø±Ø±Ø³ÛŒ Ø¯Ø§Ø¯Ù‡ Ú©Ø§ÙÛŒ
        if len(self.daily) < 3:
            print("âš ï¸ Ø¯Ø§Ø¯Ù‡ Ø±ÙˆØ²Ø§Ù†Ù‡ Ú©Ø§ÙÛŒ Ù†ÛŒØ³Øª Ø¨Ø±Ø§ÛŒ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø§Ù…ØªÛŒØ§Ø² Ø±ÙˆÙ†Ø¯")
            return 0

        try:
            last = self.daily.iloc[-1]
            score = 0

            # Ø¯Ø±ÛŒØ§ÙØª Ù…Ù‚Ø§Ø¯ÛŒØ± Ù¾Ø§ÛŒÙ‡
            daily_close = last['close']

            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            # ğŸ“Š 1. Ù…ÙˆÙ‚Ø¹ÛŒØª Ù‚ÛŒÙ…Øª Ù†Ø³Ø¨Øª Ø¨Ù‡ EMA55 (Â±40 Ø§Ù…ØªÛŒØ§Ø²)
            # Ø§ÛŒÙ† Ù…Ù‡Ù…â€ŒØªØ±ÛŒÙ† Ù…Ø¹ÛŒØ§Ø± Ø§Ø³Øª
            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            daily_ema55 = last.get('ema55', daily_close)
            if pd.isna(daily_ema55):
                daily_ema55 = daily_close

            price_vs_ema55 = daily_close - daily_ema55

            if price_vs_ema55 > 15:  # Ù‚ÛŒÙ…Øª Ø¨Ø³ÛŒØ§Ø± Ø¨Ø§Ù„Ø§ØªØ± Ø§Ø² EMA55
                score += 40
                ema55_status = f"Ø¨Ø³ÛŒØ§Ø± Ø¨Ø§Ù„Ø§ØªØ± (+{price_vs_ema55:.1f}$)"
            elif price_vs_ema55 > 8:  # 8-15 Ø¯Ù„Ø§Ø± Ø¨Ø§Ù„Ø§ØªØ±
                score += 30
                ema55_status = f"Ø¨Ø§Ù„Ø§ØªØ± (+{price_vs_ema55:.1f}$)"
            elif price_vs_ema55 > 0:  # 0-8 Ø¯Ù„Ø§Ø± Ø¨Ø§Ù„Ø§ØªØ±
                score += 20
                ema55_status = f"Ú©Ù…ÛŒ Ø¨Ø§Ù„Ø§ØªØ± (+{price_vs_ema55:.1f}$)"
            elif price_vs_ema55 > -8:  # 0 ØªØ§ 8- Ø¯Ù„Ø§Ø± Ù¾Ø§ÛŒÛŒÙ†â€ŒØªØ±
                score += 0
                ema55_status = f"Ù†Ø²Ø¯ÛŒÚ© ({price_vs_ema55:+.1f}$)"
            elif price_vs_ema55 > -15:  # 8-15 Ø¯Ù„Ø§Ø± Ù¾Ø§ÛŒÛŒÙ†â€ŒØªØ±
                score -= 20
                ema55_status = f"Ù¾Ø§ÛŒÛŒÙ†â€ŒØªØ± ({price_vs_ema55:+.1f}$)"
            else:  # Ø¨ÛŒØ´ØªØ± Ø§Ø² 15 Ø¯Ù„Ø§Ø± Ù¾Ø§ÛŒÛŒÙ†â€ŒØªØ±
                score -= 40
                ema55_status = f"Ø¨Ø³ÛŒØ§Ø± Ù¾Ø§ÛŒÛŒÙ†â€ŒØªØ± ({price_vs_ema55:+.1f}$)"

            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            # ğŸ“Š 2. ÙØ§ØµÙ„Ù‡ EMA55 Ø§Ø² EMA200 (Â±30 Ø§Ù…ØªÛŒØ§Ø²)
            # Ù†Ø´Ø§Ù†â€ŒØ¯Ù‡Ù†Ø¯Ù‡ Ù‚Ø¯Ø±Øª Ø±ÙˆÙ†Ø¯ Ø¨Ù„Ù†Ø¯Ù…Ø¯Øª
            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            daily_ema200 = last.get('ema200', daily_close)
            if pd.isna(daily_ema200):
                daily_ema200 = daily_close

            ema55_vs_ema200 = daily_ema55 - daily_ema200

            if ema55_vs_ema200 > 25:  # ÙØ§ØµÙ„Ù‡ Ø²ÛŒØ§Ø¯ = Ø±ÙˆÙ†Ø¯ ØµØ¹ÙˆØ¯ÛŒ Ù‚ÙˆÛŒ
                score += 30
                ema_cross_status = f"ØµØ¹ÙˆØ¯ÛŒ Ù‚ÙˆÛŒ (+{ema55_vs_ema200:.1f}$)"
            elif ema55_vs_ema200 > 12:  # ÙØ§ØµÙ„Ù‡ Ù…ØªÙˆØ³Ø·
                score += 20
                ema_cross_status = f"ØµØ¹ÙˆØ¯ÛŒ (+{ema55_vs_ema200:.1f}$)"
            elif ema55_vs_ema200 > 0:  # ÙØ§ØµÙ„Ù‡ Ú©Ù… Ø§Ù…Ø§ Ù…Ø«Ø¨Øª
                score += 10
                ema_cross_status = f"ØµØ¹ÙˆØ¯ÛŒ Ø¶Ø¹ÛŒÙ (+{ema55_vs_ema200:.1f}$)"
            elif ema55_vs_ema200 > -12:  # ÙØ§ØµÙ„Ù‡ Ú©Ù… Ø§Ù…Ø§ Ù…Ù†ÙÛŒ
                score -= 10
                ema_cross_status = f"Ù†Ø²ÙˆÙ„ÛŒ Ø¶Ø¹ÛŒÙ ({ema55_vs_ema200:+.1f}$)"
            elif ema55_vs_ema200 > -25:  # ÙØ§ØµÙ„Ù‡ Ù…ØªÙˆØ³Ø· Ù…Ù†ÙÛŒ
                score -= 20
                ema_cross_status = f"Ù†Ø²ÙˆÙ„ÛŒ ({ema55_vs_ema200:+.1f}$)"
            else:  # ÙØ§ØµÙ„Ù‡ Ø²ÛŒØ§Ø¯ Ù…Ù†ÙÛŒ = Ø±ÙˆÙ†Ø¯ Ù†Ø²ÙˆÙ„ÛŒ Ù‚ÙˆÛŒ
                score -= 30
                ema_cross_status = f"Ù†Ø²ÙˆÙ„ÛŒ Ù‚ÙˆÛŒ ({ema55_vs_ema200:+.1f}$)"

            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            # ğŸ“Š 3. RSI Ø±ÙˆØ²Ø§Ù†Ù‡ (Â±30 Ø§Ù…ØªÛŒØ§Ø²)
            # Ø¨Ù‡ Ø¹Ù†ÙˆØ§Ù† ØªØ£ÛŒÛŒØ¯ØŒ Ù†Ù‡ ÙÛŒÙ„ØªØ± Ø³Ø®Øª
            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            daily_rsi = last.get('rsi14', 50)
            if pd.isna(daily_rsi):
                daily_rsi = 50

            if daily_rsi > 75:  # Ø§Ø´Ø¨Ø§Ø¹ Ø®Ø±ÛŒØ¯ Ø´Ø¯ÛŒØ¯
                score -= 15  # Ù‡Ø´Ø¯Ø§Ø± Ø¨Ø±Ø§ÛŒ LONG Ø¬Ø¯ÛŒØ¯
                rsi_status = f"Ø§Ø´Ø¨Ø§Ø¹ Ø®Ø±ÛŒØ¯ ({daily_rsi:.1f})"
            elif daily_rsi > 65:  # Ù†Ø²Ø¯ÛŒÚ© Ø¨Ù‡ Ø§Ø´Ø¨Ø§Ø¹ Ø®Ø±ÛŒØ¯
                score += 5
                rsi_status = f"Ù†Ø²Ø¯ÛŒÚ© Ø§Ø´Ø¨Ø§Ø¹ Ø®Ø±ÛŒØ¯ ({daily_rsi:.1f})"
            elif daily_rsi > 45:  # Ù…Ù†Ø·Ù‚Ù‡ Ø·Ø¨ÛŒØ¹ÛŒ ØµØ¹ÙˆØ¯ÛŒ
                score += 15  # Ø¨Ù‡ØªØ±ÛŒÙ† Ù…Ù†Ø·Ù‚Ù‡ Ø¨Ø±Ø§ÛŒ LONG
                rsi_status = f"Ø·Ø¨ÛŒØ¹ÛŒ ØµØ¹ÙˆØ¯ÛŒ ({daily_rsi:.1f})"
            elif daily_rsi > 35:  # Ù…Ù†Ø·Ù‚Ù‡ Ø·Ø¨ÛŒØ¹ÛŒ Ù†Ø²ÙˆÙ„ÛŒ
                score += 10
                rsi_status = f"Ø·Ø¨ÛŒØ¹ÛŒ Ù†Ø²ÙˆÙ„ÛŒ ({daily_rsi:.1f})"
            elif daily_rsi > 25:  # Ù†Ø²Ø¯ÛŒÚ© Ø¨Ù‡ Ø§Ø´Ø¨Ø§Ø¹ ÙØ±ÙˆØ´
                score += 5
                rsi_status = f"Ù†Ø²Ø¯ÛŒÚ© Ø§Ø´Ø¨Ø§Ø¹ ÙØ±ÙˆØ´ ({daily_rsi:.1f})"
            else:  # Ø§Ø´Ø¨Ø§Ø¹ ÙØ±ÙˆØ´ Ø´Ø¯ÛŒØ¯
                score -= 15  # Ù‡Ø´Ø¯Ø§Ø± Ø¨Ø±Ø§ÛŒ SHORT Ø¬Ø¯ÛŒØ¯
                rsi_status = f"Ø§Ø´Ø¨Ø§Ø¹ ÙØ±ÙˆØ´ ({daily_rsi:.1f})"

            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            # ğŸ“Š ØªÙØ³ÛŒØ± Ø§Ù…ØªÛŒØ§Ø² Ù†Ù‡Ø§ÛŒÛŒ
            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            if score >= 60:
                trend_interpretation = "Ø±ÙˆÙ†Ø¯ ØµØ¹ÙˆØ¯ÛŒ Ù‚ÙˆÛŒ ğŸ“ˆğŸ“ˆ"
            elif score >= 30:
                trend_interpretation = "Ø±ÙˆÙ†Ø¯ ØµØ¹ÙˆØ¯ÛŒ Ù…ØªÙˆØ³Ø· ğŸ“ˆ"
            elif score >= 10:
                trend_interpretation = "Ø±ÙˆÙ†Ø¯ ØµØ¹ÙˆØ¯ÛŒ Ø¶Ø¹ÛŒÙ ğŸ“Š"
            elif score <= -60:
                trend_interpretation = "Ø±ÙˆÙ†Ø¯ Ù†Ø²ÙˆÙ„ÛŒ Ù‚ÙˆÛŒ ğŸ“‰ğŸ“‰"
            elif score <= -30:
                trend_interpretation = "Ø±ÙˆÙ†Ø¯ Ù†Ø²ÙˆÙ„ÛŒ Ù…ØªÙˆØ³Ø· ğŸ“‰"
            elif score <= -10:
                trend_interpretation = "Ø±ÙˆÙ†Ø¯ Ù†Ø²ÙˆÙ„ÛŒ Ø¶Ø¹ÛŒÙ ğŸ“Š"
            else:
                trend_interpretation = "Ø¨Ø§Ø²Ø§Ø± Ø®Ù†Ø«ÛŒ â¡ï¸"

            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            # ğŸ“Š Ù†Ù…Ø§ÛŒØ´ Ù†ØªØ§ÛŒØ¬
            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            print(f"\n{'â”€' * 50}")
            print(f"ğŸ“Š ØªØ­Ù„ÛŒÙ„ Ø±ÙˆÙ†Ø¯ Ø±ÙˆØ²Ø§Ù†Ù‡")
            print(f"{'â”€' * 50}")
            print(f"   ğŸ’° Ù‚ÛŒÙ…Øª: {daily_close:.2f}")
            print(f"   ğŸ“ˆ Ù‚ÛŒÙ…Øª vs EMA55: {ema55_status}")
            print(f"   ğŸ“Š EMA55 vs EMA200: {ema_cross_status}")
            print(f"   ğŸ“‰ RSI Ø±ÙˆØ²Ø§Ù†Ù‡: {rsi_status}")
            print(f"   ğŸ”¢ Ø§Ù…ØªÛŒØ§Ø² Ù†Ù‡Ø§ÛŒÛŒ: {score:+d}")
            print(f"   ğŸ¯ ØªÙØ³ÛŒØ±: {trend_interpretation}")
            print(f"{'â”€' * 50}")

            return score

        except Exception as e:
            print(f"âš ï¸ Ø®Ø·Ø§ Ø¯Ø± Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø§Ù…ØªÛŒØ§Ø² Ø±ÙˆÙ†Ø¯ Ø±ÙˆØ²Ø§Ù†Ù‡: {e}")
            import traceback
            traceback.print_exc()
            return 0

    def calculate_current_profit_lines(self, current_price):
        """
        Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø³ÙˆØ¯/Ø¶Ø±Ø± ÙØ¹Ù„ÛŒ Ø¨Ø± Ø­Ø³Ø¨ Ø®Ø·

        Ø¨Ø§Ø²Ú¯Ø´Øª:
        - ØªØ¹Ø¯Ø§Ø¯ Ø®Ø·ÙˆØ· Ø³ÙˆØ¯ (Ù…Ø«Ø¨Øª) ÛŒØ§ Ø¶Ø±Ø± (Ù…Ù†ÙÛŒ)
        """
        if not self.in_trade or not self.entry_price:
            return 0

        current_price = int(current_price)
        entry_price = int(self.entry_price)

        if self.trade_direction == 'long':
            return current_price - entry_price
        elif self.trade_direction == 'short':
            return entry_price - current_price
        else:
            return 0

    def is_market_ranging_simple(self):
        """ÛŒÚ© ØªØ´Ø®ÛŒØµ Ø³Ø§Ø¯Ù‡ Ø¨Ø§Ø²Ø§Ø± Ø±Ù†Ø¬"""
        if len(self.m3) < 20:
            return False

        # 1. ADX Ù¾Ø§ÛŒÛŒÙ† Ø¨Ø§Ø´Ø¯
        current_adx = self.m3['adx'].iloc[-1] if 'adx' in self.m3.columns else 25
        if current_adx > 25:
            return False  # Ø±ÙˆÙ†Ø¯ Ù‚ÙˆÛŒ Ø§Ø³Øª

        # 2. Ù‚ÛŒÙ…Øª Ø¨ÛŒÙ† Ø¨Ø§Ù†Ø¯Ù‡Ø§ÛŒ Ø¨ÙˆÙ„ÛŒÙ†Ú¯Ø± Ø¨Ø§Ø´Ø¯
        if 'bb_upper' in self.m3.columns and 'bb_lower' in self.m3.columns:
            current_price = self.m3['close'].iloc[-1]
            bb_upper = self.m3['bb_upper'].iloc[-1]
            bb_lower = self.m3['bb_lower'].iloc[-1]

            if not (bb_lower < current_price < bb_upper):
                return False  # Ø®Ø§Ø±Ø¬ Ø§Ø² Ø¨Ø§Ù†Ø¯ Ø§Ø³Øª

        # 3. Ø¹Ø±Ø¶ Ø¨Ø§Ù†Ø¯ Ú©Ù… Ø¨Ø§Ø´Ø¯
        bb_width = bb_upper - bb_lower
        bb_middle = (bb_upper + bb_lower) / 2
        if (bb_width / bb_middle) > 0.03:  # Ø¹Ø±Ø¶ Ø¨ÛŒØ´ØªØ± Ø§Ø² 3%
            return False

        return True  # Ø¨Ø§Ø²Ø§Ø± Ø§Ø­ØªÙ…Ø§Ù„Ø§Ù‹ Ø±Ù†Ø¬ Ø§Ø³Øª

    def send_realtime_price(self, current_price) -> bool:
        """
        Ø§Ø±Ø³Ø§Ù„ Ù‚ÛŒÙ…Øª Ù„Ø­Ø¸Ù‡â€ŒØ§ÛŒ Ø¨Ù‡ Ù‡Ù…Ù‡ Ú©Ù„Ø§ÛŒÙ†Øªâ€ŒÙ‡Ø§
        """
        current_price = int(current_price)

        unrealized_pnl = None
        if self.in_trade:
            unrealized_pnl = self.calculate_unrealized_pnl(current_price)

        command = {
            "type": "realtime_price",
            "price": current_price,
            "unrealized_pnl": unrealized_pnl,
            "timestamp": datetime.now().isoformat()
        }

        clients_count = self.get_connected_clients_count()
        if clients_count > 0:
            self.broadcast_to_clients(command)
            return True

        return False

    def send_heartbeat(self) -> bool:
        """
        Ø§Ø±Ø³Ø§Ù„ Ù¾ÛŒØ§Ù… heartbeat Ø¨Ù‡ Ù‡Ù…Ù‡ Ú©Ù„Ø§ÛŒÙ†Øªâ€ŒÙ‡Ø§
        """
        command = {
            "type": "heartbeat",
            "timestamp": datetime.now().isoformat(),
            "status": {
                "connected": self.CONNECTION_STATUS == "connected",
                "in_trade": self.in_trade,
                "trade_direction": self.trade_direction,
                "balance": round(self.balance, 0),
                "trades_count": self.trades,
                "market_price": round(self.MARKET_PRICE, 2) if self.MARKET_PRICE else None,
                "connected_clients": self.get_connected_clients_count(),
                "warmup_complete": self.warmup_complete
            }
        }

        clients_count = self.get_connected_clients_count()
        if clients_count > 0:
            self.broadcast_to_clients(command)
            return True

        return False

    def send_command(self, command_data: dict) -> bool:
        """
        Ø§Ø±Ø³Ø§Ù„ Ø¯Ø³ØªÙˆØ± Ø¨Ù‡ Ù‡Ù…Ù‡ Ú©Ù„Ø§ÛŒÙ†Øªâ€ŒÙ‡Ø§ÛŒ Ù…ØªØµÙ„

        Ø§ÛŒÙ† Ù…ØªØ¯ Ø¬Ø§ÛŒÚ¯Ø²ÛŒÙ† Ù…ØªØ¯ Ù‚Ø¨Ù„ÛŒ Ø§Ø³Øª Ú©Ù‡ Ø¨Ù‡ Ø³Ø±ÙˆØ± Ø®Ø§Ø±Ø¬ÛŒ ÙˆØµÙ„ Ù…ÛŒâ€ŒØ´Ø¯
        Ø­Ø§Ù„Ø§ Ù…Ø³ØªÙ‚ÛŒÙ…Ø§Ù‹ Ø¨Ù‡ Ú©Ù„Ø§ÛŒÙ†Øªâ€ŒÙ‡Ø§ÛŒ Ù…ØªØµÙ„ broadcast Ù…ÛŒâ€ŒÚ©Ù†Ø¯
        """
        try:
            if "command_id" not in command_data:
                command_data["command_id"] = f"cmd_{datetime.now().strftime('%Y%m%d%H%M%S%f')}"

            if "timestamp" not in command_data:
                command_data["timestamp"] = datetime.now().isoformat()

            clients_count = self.get_connected_clients_count()

            if clients_count == 0:
                print(f"âš ï¸ Ù‡ÛŒÚ† Ú©Ù„Ø§ÛŒÙ†ØªÛŒ Ù…ØªØµÙ„ Ù†ÛŒØ³Øª. Ø¯Ø³ØªÙˆØ±: {command_data.get('type')}")
                return False

            success_count = self.broadcast_to_clients(command_data)

            if success_count > 0:
                print(f"ğŸ“¤ Ø¯Ø³ØªÙˆØ± Ø¨Ù‡ {success_count}/{clients_count} Ú©Ù„Ø§ÛŒÙ†Øª Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯: {command_data.get('type')}")
                return True
            else:
                print(f"âŒ Ø§Ø±Ø³Ø§Ù„ Ø¯Ø³ØªÙˆØ± Ù†Ø§Ù…ÙˆÙÙ‚: {command_data.get('type')}")
                return False

        except Exception as e:
            print(f"âŒ Ø®Ø·Ø§ Ø¯Ø± Ø§Ø±Ø³Ø§Ù„ Ø¯Ø³ØªÙˆØ±: {e}")
            import traceback
            traceback.print_exc()
            return False

    def send_enter_trade_command(self, direction, entry_price, stop_loss, take_profit):
        """
        Ø§Ø±Ø³Ø§Ù„ Ø³ÛŒÚ¯Ù†Ø§Ù„ ÙˆØ±ÙˆØ¯ Ø¨Ù‡ Ù…Ø¹Ø§Ù…Ù„Ù‡ Ø¨Ù‡ Ú©Ù„Ø§ÛŒÙ†Øªâ€ŒÙ‡Ø§

        Args:
            direction: Ø¬Ù‡Øª Ù…Ø¹Ø§Ù…Ù„Ù‡ - 'long' ÛŒØ§ 'short'
            entry_price: Ù‚ÛŒÙ…Øª ÙˆØ±ÙˆØ¯
            stop_loss: Ù‚ÛŒÙ…Øª Ø­Ø¯ Ø¶Ø±Ø±
            take_profit: Ù‚ÛŒÙ…Øª Ø­Ø¯ Ø³ÙˆØ¯
            position_size: Ø­Ø¬Ù… Ù…Ø¹Ø§Ù…Ù„Ù‡ (Ù¾ÛŒØ´â€ŒÙØ±Ø¶ 1)

        Returns:
            bool: Ø¢ÛŒØ§ Ø§Ø±Ø³Ø§Ù„ Ø³ÛŒÚ¯Ù†Ø§Ù„ Ù…ÙˆÙÙ‚ Ø¨ÙˆØ¯
        """

        hiva_direction = ''
        if direction == 'long':
            hiva_direction = 'buy'
        else:
            hiva_direction = 'sell'

        print(f"Hiva Direction: {hiva_direction}")

        strategy = self.current_trade_strategy if self.current_trade_strategy else 'unknown'

        entry_price = int(entry_price)
        stop_loss = int(stop_loss)
        take_profit = int(take_profit)

        stop_distance_lines = abs(entry_price - stop_loss)
        profit_distance_lines = abs(take_profit - entry_price)

        risk_toman = stop_distance_lines * self.LINE_VALUE_TOMAN
        potential_profit_toman = profit_distance_lines * self.LINE_VALUE_TOMAN

        trade_id = f"trade_{datetime.now().strftime('%Y%m%d%H%M%S%f')}"
        self.current_internal_trade_id = trade_id

        command = {
            "type": "enter_trade",
            "direction": hiva_direction,
            "symbol": "MAZANEH",
            "entry_price": entry_price,
            "stop_loss": stop_loss,
            "take_profit": take_profit,
            "strategy": strategy,
            "stop_distance_lines": stop_distance_lines,
            "profit_distance_lines": profit_distance_lines,
            "risk_toman": round(risk_toman, 0),
            "potential_profit_toman": round(potential_profit_toman, 0),
            "risk_reward_ratio": round(profit_distance_lines / stop_distance_lines, 2) if stop_distance_lines > 0 else 0,
            "line_value_toman": self.LINE_VALUE_TOMAN,
            "risk_percent": self.RISK_PERCENTAGE * 100,
            "trade_id": trade_id,
            "timestamp": datetime.now().isoformat()
        }

        print(f"\n{'â•' * 60}")
        print(f"ğŸ“¤ Ø³ÛŒÚ¯Ù†Ø§Ù„ ÙˆØ±ÙˆØ¯ Ø¨Ù‡ Ù…Ø¹Ø§Ù…Ù„Ù‡ {direction.upper()} ({strategy.upper()})")
        print(f"{'â•' * 60}")
        print(f"   ğŸ’° Ù‚ÛŒÙ…Øª ÙˆØ±ÙˆØ¯: {entry_price}")
        print(f"   ğŸ›¡ï¸ Ø­Ø¯ Ø¶Ø±Ø±: {stop_loss} ({stop_distance_lines} Ø®Ø·)")
        print(f"   ğŸ¯ Ø­Ø¯ Ø³ÙˆØ¯: {take_profit} ({profit_distance_lines} Ø®Ø·)")
        print(f"   ğŸ’¸ Ø±ÛŒØ³Ú©: {risk_toman:,.0f} ØªÙˆÙ…Ø§Ù†")
        print(f"   ğŸ’° Ø³ÙˆØ¯ Ø¨Ø§Ù„Ù‚ÙˆÙ‡: {potential_profit_toman:,.0f} ØªÙˆÙ…Ø§Ù†")
        print(f"   ğŸ”‘ Ø´Ù†Ø§Ø³Ù‡: {trade_id}")
        print(f"{'â•' * 60}")

        return self.send_command(command)

    def send_exit_trade_command(self, exit_price, reason, pnl_toman, pnl_percent):
        """
        Ø§Ø±Ø³Ø§Ù„ Ø³ÛŒÚ¯Ù†Ø§Ù„ Ø®Ø±ÙˆØ¬ Ø§Ø² Ù…Ø¹Ø§Ù…Ù„Ù‡ Ø¨Ù‡ Ú©Ù„Ø§ÛŒÙ†Øªâ€ŒÙ‡Ø§

        Args:
            exit_price: Ù‚ÛŒÙ…Øª Ø®Ø±ÙˆØ¬
            reason: Ø¯Ù„ÛŒÙ„ Ø®Ø±ÙˆØ¬
            pnl_toman: Ø³ÙˆØ¯/Ø¶Ø±Ø± Ø¨Ù‡ ØªÙˆÙ…Ø§Ù†
            pnl_percent: Ø³ÙˆØ¯/Ø¶Ø±Ø± Ø¨Ù‡ Ø¯Ø±ØµØ¯

        Returns:
            bool: Ø¢ÛŒØ§ Ø§Ø±Ø³Ø§Ù„ Ø³ÛŒÚ¯Ù†Ø§Ù„ Ù…ÙˆÙÙ‚ Ø¨ÙˆØ¯
        """

        exit_price = int(exit_price)
        entry_price = int(self.entry_price)

        if self.trade_direction == 'long':
            pnl_lines = exit_price - entry_price
        else:
            pnl_lines = entry_price - exit_price

        hiva_direction = ''
        if self.trade_direction == 'long':
            hiva_direction = 'buy'
        else:
            hiva_direction = 'sell'

        command = {
            "type": "exit_trade",
            "symbol": "MAZANEH",
            "exit_price": exit_price,
            "reason": reason,
            "direction": hiva_direction,
            "entry_price": entry_price,
            "pnl_lines": pnl_lines,
            "pnl_toman": round(pnl_toman, 0),
            "pnl_percent": round(pnl_percent, 2),
            "line_value_toman": self.LINE_VALUE_TOMAN,
            "trade_duration": str(datetime.now() - self.trade_start_time) if self.trade_start_time else "0:00:00",
            "strategy": self.current_trade_strategy,
            "trade_id": self.current_internal_trade_id
        }

        emoji = "ğŸ’°" if pnl_toman >= 0 else "ğŸ’¸"

        print(f"\n{'â•' * 60}")
        print(f"ğŸ“¤ Ø³ÛŒÚ¯Ù†Ø§Ù„ Ø®Ø±ÙˆØ¬ Ø§Ø² Ù…Ø¹Ø§Ù…Ù„Ù‡")
        print(f"{'â•' * 60}")
        print(f"   {emoji} Ø³ÙˆØ¯/Ø¶Ø±Ø±: {pnl_lines:+} Ø®Ø· ({pnl_toman:+,.0f} ØªÙˆÙ…Ø§Ù†) ({pnl_percent:+.1f}%)")
        print(f"   ğŸ“ Ù‚ÛŒÙ…Øª Ø®Ø±ÙˆØ¬: {exit_price}")
        print(f"   ğŸ“‹ Ø¯Ù„ÛŒÙ„: {reason}")
        print(f"   ğŸ”‘ Ø´Ù†Ø§Ø³Ù‡: {self.current_internal_trade_id}")
        print(f"{'â•' * 60}")

        return self.send_command(command)

    def send_update_stop_loss_command(self, new_stop_loss, reason):
        """
        Ø§Ø±Ø³Ø§Ù„ Ø³ÛŒÚ¯Ù†Ø§Ù„ ØªØºÛŒÛŒØ± Ø­Ø¯ Ø¶Ø±Ø± Ø¨Ù‡ Ú©Ù„Ø§ÛŒÙ†Øªâ€ŒÙ‡Ø§

        Args:
            new_stop_loss: Ù‚ÛŒÙ…Øª Ø­Ø¯ Ø¶Ø±Ø± Ø¬Ø¯ÛŒØ¯
            reason: Ø¯Ù„ÛŒÙ„ ØªØºÛŒÛŒØ±

        Returns:
            bool: Ø¢ÛŒØ§ Ø§Ø±Ø³Ø§Ù„ Ø³ÛŒÚ¯Ù†Ø§Ù„ Ù…ÙˆÙÙ‚ Ø¨ÙˆØ¯
        """

        new_stop_loss = int(new_stop_loss)
        old_stop_loss = int(self.stop_loss_price)
        entry_price = int(self.entry_price)
        current_price = int(self.MARKET_PRICE) if self.MARKET_PRICE else 0
        take_profit = int(self.take_profit_price)

        if self.trade_direction == 'long':
            locked_profit_lines = new_stop_loss - entry_price
        else:
            locked_profit_lines = entry_price - new_stop_loss

        locked_profit_toman = locked_profit_lines * self.LINE_VALUE_TOMAN

        command = {
            "type": "update_stop_loss",
            "symbol": "MAZANEH",
            "direction": self.trade_direction,
            "old_stop_loss": old_stop_loss,
            "new_stop_loss": new_stop_loss,
            "entry_price": entry_price,
            "current_price": current_price,
            "take_profit": take_profit,
            "reason": reason,
            "locked_profit_lines": locked_profit_lines,
            "locked_profit_toman": locked_profit_toman,
            "line_value_toman": self.LINE_VALUE_TOMAN,
            "trade_id": self.current_internal_trade_id
        }

        print(f"\n{'â•' * 60}")
        print(f"ğŸ“¤ Ø³ÛŒÚ¯Ù†Ø§Ù„ ØªØºÛŒÛŒØ± Ø­Ø¯ Ø¶Ø±Ø±")
        print(f"{'â•' * 60}")
        print(f"   ğŸ›¡ï¸ Ø­Ø¯ Ø¶Ø±Ø±: {old_stop_loss} â†’ {new_stop_loss}")
        print(f"   ğŸ’° Ø³ÙˆØ¯ Ù‚ÙÙ„ Ø´Ø¯Ù‡: {locked_profit_lines} Ø®Ø· ({locked_profit_toman:,.0f} ØªÙˆÙ…Ø§Ù†)")
        print(f"   ğŸ“‹ Ø¯Ù„ÛŒÙ„: {reason}")
        print(f"   ğŸ”‘ Ø´Ù†Ø§Ø³Ù‡: {self.current_internal_trade_id}")
        print(f"{'â•' * 60}")

        return self.send_command(command)

    def send_update_take_profit_command(self, new_take_profit, reason):
        """
        Ø§Ø±Ø³Ø§Ù„ Ø³ÛŒÚ¯Ù†Ø§Ù„ ØªØºÛŒÛŒØ± Ø­Ø¯ Ø³ÙˆØ¯ Ø¨Ù‡ Ú©Ù„Ø§ÛŒÙ†Øªâ€ŒÙ‡Ø§

        Args:
            new_take_profit: Ù‚ÛŒÙ…Øª Ø­Ø¯ Ø³ÙˆØ¯ Ø¬Ø¯ÛŒØ¯
            reason: Ø¯Ù„ÛŒÙ„ ØªØºÛŒÛŒØ±

        Returns:
            bool: Ø¢ÛŒØ§ Ø§Ø±Ø³Ø§Ù„ Ø³ÛŒÚ¯Ù†Ø§Ù„ Ù…ÙˆÙÙ‚ Ø¨ÙˆØ¯
        """

        new_take_profit = int(new_take_profit)
        old_take_profit = int(self.take_profit_price)
        entry_price = int(self.entry_price)
        current_price = int(self.MARKET_PRICE) if self.MARKET_PRICE else 0
        stop_loss = int(self.stop_loss_price)

        if self.trade_direction == 'long':
            tp_distance_lines = new_take_profit - entry_price
        else:
            tp_distance_lines = entry_price - new_take_profit

        potential_profit_toman = tp_distance_lines * self.LINE_VALUE_TOMAN

        command = {
            "type": "update_take_profit",
            "symbol": "MAZANEH",
            "direction": self.trade_direction,
            "old_take_profit": old_take_profit,
            "new_take_profit": new_take_profit,
            "entry_price": entry_price,
            "current_price": current_price,
            "stop_loss": stop_loss,
            "reason": reason,
            "tp_distance_lines": tp_distance_lines,
            "potential_profit_toman": potential_profit_toman,
            "line_value_toman": self.LINE_VALUE_TOMAN,
            "trade_id": self.current_internal_trade_id
        }

        print(f"\n{'â•' * 60}")
        print(f"ğŸ“¤ Ø³ÛŒÚ¯Ù†Ø§Ù„ ØªØºÛŒÛŒØ± Ø­Ø¯ Ø³ÙˆØ¯")
        print(f"{'â•' * 60}")
        print(f"   ğŸ¯ Ø­Ø¯ Ø³ÙˆØ¯: {old_take_profit} â†’ {new_take_profit}")
        print(f"   ğŸ“ ÙØ§ØµÙ„Ù‡ Ø§Ø² ÙˆØ±ÙˆØ¯: {tp_distance_lines} Ø®Ø· ({potential_profit_toman:,.0f} ØªÙˆÙ…Ø§Ù†)")
        print(f"   ğŸ“‹ Ø¯Ù„ÛŒÙ„: {reason}")
        print(f"   ğŸ”‘ Ø´Ù†Ø§Ø³Ù‡: {self.current_internal_trade_id}")
        print(f"{'â•' * 60}")

        return self.send_command(command)

    def calculate_unrealized_pnl(self, current_price):
        """
        Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø³ÙˆØ¯/Ø¶Ø±Ø± Ø´Ù†Ø§ÙˆØ± (Ø¨Ø±Ø§ÛŒ Ù…Ø¹Ø§Ù…Ù„Ù‡ Ø¨Ø§Ø²)

        ğŸ”„ ØªØºÛŒÛŒØ± Ø§Ø² ØªÛŒÚ© Ø¨Ù‡ Ø®Ø·

        Ø¨Ø§Ø²Ú¯Ø´Øª:
        - dict Ø¨Ø§ Ú©Ù„ÛŒØ¯Ù‡Ø§ÛŒ: toman, percent, lines
        """

        if not self.in_trade or not self.entry_price:
            return {"toman": 0, "percent": 0, "lines": 0}

        try:
            # ğŸ”„ ØªØ¨Ø¯ÛŒÙ„ Ø¨Ù‡ Ø¹Ø¯Ø¯ ØµØ­ÛŒØ­
            current_price = int(current_price)
            entry_price = int(self.entry_price)

            # Ù…Ø­Ø§Ø³Ø¨Ù‡ ØªØ¹Ø¯Ø§Ø¯ Ø®Ø·ÙˆØ·
            if self.trade_direction == 'long':
                lines = current_price - entry_price
            elif self.trade_direction == 'short':
                lines = entry_price - current_price
            else:
                return {"toman": 0, "percent": 0, "lines": 0}

            # ğŸ”„ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø¨Ù‡ ØªÙˆÙ…Ø§Ù†
            pnl_toman = lines * self.LINE_VALUE_TOMAN
            pnl_percent = (pnl_toman / self.PORTFOLIO_SIZE) * 100

            return {
                "toman": round(pnl_toman, 0),
                "percent": round(pnl_percent, 2),
                "lines": int(lines)
            }

        except Exception as e:
            print(f"âš ï¸ Ø®Ø·Ø§ Ø¯Ø± Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø³ÙˆØ¯ Ø´Ù†Ø§ÙˆØ±: {e}")
            return {"toman": 0, "percent": 0, "lines": 0}

    def calculate_initial_indicators(self):
        try:
            if len(self.daily) >= 200:
                ema55_series = ta.ema(self.daily['close'], length=55)
                if ema55_series is not None:
                    self.daily['ema55'] = ema55_series

                ema200_series = ta.ema(self.daily['close'], length=200)
                if ema200_series is not None:
                    self.daily['ema200'] = ema200_series

                rsi_series = ta.rsi(self.daily['close'], length=14)
                if rsi_series is not None:
                    self.daily['rsi14'] = rsi_series

                print("âœ… Ø§Ù†Ø¯ÛŒÚ©Ø§ØªÙˆØ±Ù‡Ø§ÛŒ Ø±ÙˆØ²Ø§Ù†Ù‡ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø´Ø¯Ù†Ø¯")
            else:
                print(f"âš ï¸ Ø¯Ø§Ø¯Ù‡ Ø±ÙˆØ²Ø§Ù†Ù‡ Ú©Ø§ÙÛŒ Ù†ÛŒØ³Øª Ø¨Ø±Ø§ÛŒ EMA200 (Ù†ÛŒØ§Ø²: 200ØŒ Ù…ÙˆØ¬ÙˆØ¯: {len(self.daily)})")

            if len(self.m3) >= 21:
                self.update_m5_indicators()
                print("âœ… Ø§Ù†Ø¯ÛŒÚ©Ø§ØªÙˆØ±Ù‡Ø§ÛŒ 5 Ø¯Ù‚ÛŒÙ‚Ù‡â€ŒØ§ÛŒ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø´Ø¯Ù†Ø¯")
            else:
                print(f"âš ï¸ Ø¯Ø§Ø¯Ù‡ M5 Ú©Ø§ÙÛŒ Ù†ÛŒØ³Øª Ø¨Ø±Ø§ÛŒ Ø§Ù†Ø¯ÛŒÚ©Ø§ØªÙˆØ±Ù‡Ø§ (Ù†ÛŒØ§Ø²: 21ØŒ Ù…ÙˆØ¬ÙˆØ¯: {len(self.m3)})")

        except Exception as e:
            print(f"Ø®Ø·Ø§ Ø¯Ø± Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø§Ù†Ø¯ÛŒÚ©Ø§ØªÙˆØ±Ù‡Ø§: {e}")
            import traceback
            traceback.print_exc()

    def update_m5_indicators(self):
        """Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø§Ù†Ø¯ÛŒÚ©Ø§ØªÙˆØ±Ù‡Ø§ÛŒ 5 Ø¯Ù‚ÛŒÙ‚Ù‡â€ŒØ§ÛŒ - Ù†Ø³Ø®Ù‡ Ù†Ù‡Ø§ÛŒÛŒ"""
        try:
            if len(self.m3) < 50:
                return

            df = self.m3.copy()

            # 1. Ù…ÛŒØ§Ù†Ú¯ÛŒÙ†â€ŒÙ‡Ø§ÛŒ Ù…ØªØ­Ø±Ú©
            df['ema9'] = ta.ema(df['close'], length=9)
            df['ema21'] = ta.ema(df['close'], length=21)
            df['ema50'] = ta.ema(df['close'], length=50)

            # 2. RSI
            df['rsi14'] = ta.rsi(df['close'], length=14)

            # 3. ADX
            try:
                # Ø­Ø°Ù import Ø§Ø¶Ø§ÙÛŒ - Ø§Ø² ta Ú©Ù‡ Ø¯Ø± Ø¨Ø§Ù„Ø§ÛŒ ÙØ§ÛŒÙ„ import Ø´Ø¯Ù‡ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†ÛŒØ¯
                adx_result = ta.adx(df['high'], df['low'], df['close'], length=14)

                # Ù¾ÛŒØ¯Ø§ Ú©Ø±Ø¯Ù† Ø³ØªÙˆÙ† ADX Ø¨Ù‡ ØµÙˆØ±Øª Ù¾ÙˆÛŒØ§
                adx_col = None
                for col in adx_result.columns:
                    if 'ADX' in str(col).upper():
                        adx_col = col
                        break

                if adx_col:
                    df['adx'] = adx_result[adx_col]
                else:
                    df['adx'] = 25.0
                    print("âš ï¸ Ø³ØªÙˆÙ† ADX ÛŒØ§ÙØª Ù†Ø´Ø¯ØŒ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ù…Ù‚Ø¯Ø§Ø± Ù¾ÛŒØ´â€ŒÙØ±Ø¶")

            except Exception as e:
                print(f"âš ï¸ Ø®Ø·Ø§ Ø¯Ø± Ù…Ø­Ø§Ø³Ø¨Ù‡ ADX: {e}")
                df['adx'] = 25.0

            # 4. MACD
            try:
                macd_result = ta.macd(df['close'])

                # Ù¾ÛŒØ¯Ø§ Ú©Ø±Ø¯Ù† Ø³ØªÙˆÙ†â€ŒÙ‡Ø§ÛŒ MACD Ø¨Ù‡ ØµÙˆØ±Øª Ù¾ÙˆÛŒØ§
                if not macd_result.empty:
                    macd_cols = macd_result.columns.tolist()

                    # Ø³ØªÙˆÙ† Ø§ÙˆÙ„ Ù…Ø¹Ù…ÙˆÙ„Ø§Ù‹ MACD Ø§ØµÙ„ÛŒ Ø§Ø³Øª
                    if len(macd_cols) > 0:
                        df['macd'] = macd_result.iloc[:, 0]
                    if len(macd_cols) > 1:
                        df['macd_signal'] = macd_result.iloc[:, 1]
                    if len(macd_cols) > 2:
                        df['macd_histogram'] = macd_result.iloc[:, 2]

            except Exception as e:
                print(f"âš ï¸ Ø®Ø·Ø§ Ø¯Ø± Ù…Ø­Ø§Ø³Ø¨Ù‡ MACD: {e}")
                df['macd'] = df['macd_signal'] = df['macd_histogram'] = 0

            # 5. ATR
            try:
                df['atr'] = ta.atr(df['high'], df['low'], df['close'], length=14)
            except Exception as e:
                print(f"âš ï¸ Ø®Ø·Ø§ Ø¯Ø± Ù…Ø­Ø§Ø³Ø¨Ù‡ ATR: {e}")
                df['atr'] = 20

            # 6. Bollinger Bands - **Ø§ØµÙ„Ø§Ø­ Ù†Ù‡Ø§ÛŒÛŒ**
            try:
                # Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø¨ÙˆÙ„ÛŒÙ†Ú¯Ø± Ø¨Ø§Ù†Ø¯
                bb = ta.bbands(df['close'], length=20, std=2)

                if hasattr(bb, 'columns') and len(bb.columns) > 0:
                    # Ù¾ÛŒØ¯Ø§ Ú©Ø±Ø¯Ù† Ø³ØªÙˆÙ†â€ŒÙ‡Ø§ Ø¨Ù‡ ØµÙˆØ±Øª Ù¾ÙˆÛŒØ§ - Ù…Ù‡Ù…!
                    upper_col = None
                    middle_col = None
                    lower_col = None

                    for col in bb.columns:
                        col_str = str(col)
                        if 'BBU' in col_str:
                            upper_col = col
                        elif 'BBM' in col_str:
                            middle_col = col
                        elif 'BBL' in col_str:
                            lower_col = col

                    print(f"ğŸ” Ø³ØªÙˆÙ†â€ŒÙ‡Ø§ÛŒ ÛŒØ§ÙØª Ø´Ø¯Ù‡: Upper={upper_col}, Middle={middle_col}, Lower={lower_col}")

                    if upper_col and middle_col and lower_col:
                        df['bb_upper'] = bb[upper_col]
                        df['bb_middle'] = bb[middle_col]
                        df['bb_lower'] = bb[lower_col]
                        print(f"âœ… Ø¨ÙˆÙ„ÛŒÙ†Ú¯Ø± Ø¨Ø§Ù†Ø¯ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ø´Ø¯")
                    else:
                        # Ø§Ú¯Ø± Ø³ØªÙˆÙ†â€ŒÙ‡Ø§ Ø±Ø§ Ù¾ÛŒØ¯Ø§ Ù†Ú©Ø±Ø¯ÛŒÙ…
                        raise ValueError(f"Ø³ØªÙˆÙ†â€ŒÙ‡Ø§ÛŒ Ø¨ÙˆÙ„ÛŒÙ†Ú¯Ø± ÛŒØ§ÙØª Ù†Ø´Ø¯. Ø³ØªÙˆÙ†â€ŒÙ‡Ø§ÛŒ Ù…ÙˆØ¬ÙˆØ¯: {bb.columns.tolist()}")
                else:
                    raise ValueError("Ø¨ÙˆÙ„ÛŒÙ†Ú¯Ø± Ø¨Ø§Ù†Ø¯ DataFrame Ù…Ø¹ØªØ¨Ø± Ù†ÛŒØ³Øª")

            except Exception as e:
                print(f"âš ï¸ Ø®Ø·Ø§ Ø¯Ø± Ø¨ÙˆÙ„ÛŒÙ†Ú¯Ø± Ø¨Ø§Ù†Ø¯: {e}")
                # Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø¯Ø³ØªÛŒ Ø¨ÙˆÙ„ÛŒÙ†Ú¯Ø± Ø¨Ø§Ù†Ø¯
                try:
                    window = 20
                    sma = df['close'].rolling(window=window).mean()
                    std = df['close'].rolling(window=window).std()
                    df['bb_upper'] = sma + (std * 2)
                    df['bb_middle'] = sma
                    df['bb_lower'] = sma - (std * 2)
                    print("âœ… Ø¨ÙˆÙ„ÛŒÙ†Ú¯Ø± Ø¨Ø§Ù†Ø¯ Ø¨Ø§ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø¯Ø³ØªÛŒ Ø§ÛŒØ¬Ø§Ø¯ Ø´Ø¯")
                except Exception as e2:
                    print(f"âš ï¸ Ø®Ø·Ø§ Ø¯Ø± Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø¯Ø³ØªÛŒ Ø¨ÙˆÙ„ÛŒÙ†Ú¯Ø±: {e2}")
                    df['bb_upper'] = df['close'] * 1.02
                    df['bb_middle'] = df['close']
                    df['bb_lower'] = df['close'] * 0.98

            # 7. Stochastic
            try:
                stoch_result = ta.stoch(df['high'], df['low'], df['close'])

                if hasattr(stoch_result, 'columns'):
                    for col in stoch_result.columns:
                        col_str = str(col).upper()
                        if 'K' in col_str:
                            df['stoch_k'] = stoch_result[col]
                        elif 'D' in col_str:
                            df['stoch_d'] = stoch_result[col]
            except Exception as e:
                print(f"âš ï¸ Ø®Ø·Ø§ Ø¯Ø± Ù…Ø­Ø§Ø³Ø¨Ù‡ Stochastic: {e}")
                df['stoch_k'] = 50
                df['stoch_d'] = 50

            # 8. Ø­Ø¬Ù… (Ø§Ú¯Ø± Ù…ÙˆØ¬ÙˆØ¯ Ø¨Ø§Ø´Ø¯)
            if 'volume' in df.columns:
                try:
                    df['volume_ema'] = ta.ema(df['volume'], length=20)
                except:
                    pass

            # 9. Ù…Ø­Ø§Ø³Ø¨Ù‡ ÙˆØ¶Ø¹ÛŒØª Ù†Ø³Ø¨ÛŒ
            if 'bb_lower' in df.columns and 'bb_upper' in df.columns:
                try:
                    # Ø¬Ù„ÙˆÚ¯ÛŒØ±ÛŒ Ø§Ø² ØªÙ‚Ø³ÛŒÙ… Ø¨Ø± ØµÙØ±
                    bb_range = df['bb_upper'] - df['bb_lower']
                    mask = bb_range != 0
                    df.loc[mask, 'price_vs_bb'] = (df.loc[mask, 'close'] - df.loc[mask, 'bb_lower']) / bb_range[mask] * 100
                    df.loc[~mask, 'price_vs_bb'] = 50
                except:
                    df['price_vs_bb'] = 50
            else:
                df['price_vs_bb'] = 50

            # Ø°Ø®ÛŒØ±Ù‡
            self.m3 = df

            print("âœ… Ø§Ù†Ø¯ÛŒÚ©Ø§ØªÙˆØ±Ù‡Ø§ÛŒ M5 Ø¨Ù‡â€ŒØ±ÙˆØ² Ø´Ø¯Ù†Ø¯")

            # Ù†Ù…Ø§ÛŒØ´ Ù…Ù‚Ø§Ø¯ÛŒØ± Ø¨Ø±Ø§ÛŒ ØªØ£ÛŒÛŒØ¯
            try:
                print(f"   ğŸ“Š Ù†Ù…ÙˆÙ†Ù‡: ADX={df['adx'].iloc[-1]:.1f}, RSI={df['rsi14'].iloc[-1]:.1f}")
                print(f"   ğŸ“ˆ EMA: 9={df['ema9'].iloc[-1]:.0f}, 21={df['ema21'].iloc[-1]:.0f}")

                if 'bb_upper' in df.columns:
                    print(f"   ğŸ“‰ Ø¨ÙˆÙ„ÛŒÙ†Ú¯Ø±: Ø¨Ø§Ù„Ø§={df['bb_upper'].iloc[-1]:.0f}, Ù…ÛŒØ§Ù†Ù‡={df['bb_middle'].iloc[-1]:.0f}, Ù¾Ø§ÛŒÛŒÙ†={df['bb_lower'].iloc[-1]:.0f}")
            except Exception as e:
                print(f"âš ï¸ Ø®Ø·Ø§ Ø¯Ø± Ù†Ù…Ø§ÛŒØ´ Ù…Ù‚Ø§Ø¯ÛŒØ±: {e}")

        except Exception as e:
            print(f"âš ï¸ Ø®Ø·Ø§ÛŒ Ú©Ù„ÛŒ Ø¯Ø± Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø§Ù†Ø¯ÛŒÚ©Ø§ØªÙˆØ±Ù‡Ø§: {e}")
            import traceback
            traceback.print_exc()

    def calculate_dynamic_stop_loss(self, current_price: float, direction: str) -> int:
        """Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø­Ø¯ Ø¶Ø±Ø± Ù¾ÙˆÛŒØ§ - Ù†Ø³Ø®Ù‡ Ø§ØµÙ„Ø§Ø­ Ø´Ø¯Ù‡ Ùˆ Ú©Ø§Ù…Ù†Øªâ€ŒÚ¯Ø°Ø§Ø±ÛŒ Ø´Ø¯Ù‡"""

        # ğŸ¯ 1. ØªØ´Ø®ÛŒØµ Ø§Ø³ØªØ±Ø§ØªÚ˜ÛŒ
        strategy = self.determine_strategy_mode()

        # âš™ï¸ 2. ØªÙ†Ø¸ÛŒÙ… Ù¾Ø§Ø±Ø§Ù…ØªØ±Ù‡Ø§ Ø¨Ø± Ø§Ø³Ø§Ø³ Ø§Ø³ØªØ±Ø§ØªÚ˜ÛŒ
        if strategy == 'scalp':
            base_stop = self.SCALP_STOP_LOSS_LINES
            min_stop = self.SCALP_MIN_STOP
            max_stop = self.SCALP_MAX_STOP
            atr_mult = self.SCALP_ATR_MULTIPLIER
            risk_percent = self.SCALP_RISK_PERCENTAGE
            strategy_name = "Ø§Ø³Ú©Ø§Ù„Ù¾"
        else:
            base_stop = self.SWING_STOP_LOSS_LINES
            min_stop = self.SWING_MIN_STOP
            max_stop = self.SWING_MAX_STOP
            atr_mult = self.SWING_ATR_MULTIPLIER
            risk_percent = self.SWING_RISK_PERCENTAGE
            strategy_name = "Ø³ÙˆØ¦ÛŒÙ†Ú¯"

        # ğŸ“ 3. Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø¨Ø± Ø§Ø³Ø§Ø³ ATR (Ø§Ù†Ø¯Ø§Ø²Ù‡ Ù†ÙˆØ³Ø§Ù†)
        atr_lines = 0
        if len(self.m3) >= 14 and 'atr' in self.m3.columns:
            atr = self.m3['atr'].iloc[-1]
            if pd.notna(atr) and atr > 0:
                atr_lines = int(atr)

        # Ø¶Ø±Ø¨ Ø¯Ø± Ø¶Ø±ÛŒØ¨ ATR
        atr_based_stop = int(atr_lines * atr_mult)

        # ğŸ“Š 4. Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø¨Ø± Ø§Ø³Ø§Ø³ Bollinger Bands (Ø¹Ø±Ø¶ Ø¨Ø§Ø²Ø§Ø±)
        bb_based_stop = 0
        if 'bb_middle' in self.m3.columns and 'bb_lower' in self.m3.columns:
            bb_width = self.m3['bb_upper'].iloc[-1] - self.m3['bb_lower'].iloc[-1]
            if bb_width > 0:
                bb_based_stop = int(bb_width * 0.3)  # 30% Ø¹Ø±Ø¶ Ø¨Ø§Ù†Ø¯

        # ğŸ¯ 5. Ø§Ù†ØªØ®Ø§Ø¨ Ø¨Ø²Ø±Ú¯ØªØ±ÛŒÙ† Ø­Ø¯ Ø¶Ø±Ø± (Ø¨Ø±Ø§ÛŒ Ù…Ø­Ø§ÙØ¸Øª Ø¨Ù‡ØªØ±)
        stop_loss = max(base_stop, atr_based_stop, bb_based_stop)

        # ğŸ”§ 6. Ù…Ø­Ø¯ÙˆØ¯ Ú©Ø±Ø¯Ù† Ø¨Ù‡ Ø¨Ø§Ø²Ù‡ Ù…Ø¬Ø§Ø²
        stop_loss = max(min_stop, min(max_stop, stop_loss))

        # ğŸ’° 7. Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø±ÛŒØ³Ú© Ù…Ø§Ù„ÛŒ Ùˆ ØªØ·Ø¨ÛŒÙ‚
        risk_amount = int(self.portfolio * risk_percent)
        risk_in_lines = risk_amount // self.LINE_VALUE_TOMAN

        # Ø§Ú¯Ø± Ø±ÛŒØ³Ú© Ù…Ø§Ù„ÛŒ Ù…Ø­Ø¯ÙˆØ¯ÛŒØª Ø§ÛŒØ¬Ø§Ø¯ Ù…ÛŒâ€ŒÚ©Ù†Ø¯ØŒ Ø¢Ù† Ø±Ø§ Ø§Ø¹Ù…Ø§Ù„ Ú©Ù†
        if risk_in_lines > 0 and risk_in_lines < stop_loss:
            stop_loss = max(min_stop, risk_in_lines)
            print(f"   âš ï¸ Ù…Ø­Ø¯ÙˆØ¯ÛŒØª Ø±ÛŒØ³Ú© Ù…Ø§Ù„ÛŒ: Ø­Ø¯ Ø¶Ø±Ø± Ø¨Ù‡ {stop_loss} Ø®Ø· Ú©Ø§Ù‡Ø´ ÛŒØ§ÙØª")

        # ğŸ“Š 8. Ù…Ø­Ø§Ø³Ø¨Ù‡ Ù‚ÛŒÙ…Øª Ø­Ø¯ Ø¶Ø±Ø±
        current_price_int = int(current_price)
        if direction == 'long':
            stop_price = current_price_int - stop_loss
        else:
            stop_price = current_price_int + stop_loss

        # ğŸ“ 9. Ù†Ù…Ø§ÛŒØ´ Ù†ØªØ§ÛŒØ¬
        print(f"\n{'â”€' * 50}")
        print(f"ğŸ›¡ï¸ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø­Ø¯ Ø¶Ø±Ø± Ù¾ÙˆÛŒØ§ - {strategy_name}")
        print(f"{'â”€' * 50}")
        print(f"   ğŸ“Š Ø§Ø³ØªØ±Ø§ØªÚ˜ÛŒ: {strategy_name}")
        print(f"   ğŸ“ Ø­Ø¯ Ø¶Ø±Ø± Ù¾Ø§ÛŒÙ‡: {base_stop} Ø®Ø·")
        print(f"   ğŸ“ˆ ATR: {atr_lines} Ø®Ø· â†’ {atr_based_stop} Ø®Ø·")
        print(f"   ğŸ“Š Bollinger: {bb_based_stop} Ø®Ø·")
        print(f"   ğŸ”¢ Ø¨Ø²Ø±Ú¯ØªØ±ÛŒÙ†: {stop_loss} Ø®Ø·")
        print(f"   ğŸ“ Ù‚ÛŒÙ…Øª ÙˆØ±ÙˆØ¯: {current_price_int}")
        print(f"   ğŸ›¡ï¸ Ù‚ÛŒÙ…Øª Ø­Ø¯ Ø¶Ø±Ø±: {stop_price}")
        print(f"   ğŸ“ ÙØ§ØµÙ„Ù‡: {stop_loss} Ø®Ø·")
        print(f"   ğŸ’° Ø±ÛŒØ³Ú© Ù…Ø§Ù„ÛŒ: {risk_amount:,.0f} ØªÙˆÙ…Ø§Ù† = {risk_in_lines} Ø®Ø·")
        print(f"{'â”€' * 50}")

        return stop_loss

    def analyze_market_momentum(self):
        """ØªØ­Ù„ÛŒÙ„ Ù…ÙˆÙ…Ù†ØªÙˆÙ… Ø¨Ø§Ø²Ø§Ø± Ø¨Ø±Ø§ÛŒ ÙÛŒÙ„ØªØ± Ø³ÛŒÚ¯Ù†Ø§Ù„â€ŒÙ‡Ø§"""

        if len(self.m3) < 50:
            return {'momentum': 'neutral', 'strength': 0}

        df = self.m3

        momentum_score = 0
        reasons = []

        # 1. Ø¨Ø±Ø±Ø³ÛŒ MACD
        if 'macd' in df.columns and 'macd_signal' in df.columns:
            macd_value = df['macd'].iloc[-1]
            macd_signal = df['macd_signal'].iloc[-1]

            if macd_value > macd_signal:
                momentum_score += 25
                reasons.append("MACD ØµØ¹ÙˆØ¯ÛŒ")
            else:
                momentum_score -= 25
                reasons.append("MACD Ù†Ø²ÙˆÙ„ÛŒ")

        # 2. Ø¨Ø±Ø±Ø³ÛŒ Stochastic
        if 'stoch_k' in df.columns and 'stoch_d' in df.columns:
            stoch_k = df['stoch_k'].iloc[-1]
            stoch_d = df['stoch_d'].iloc[-1]

            if stoch_k > 80 and stoch_d > 80:
                momentum_score -= 15  # Ø§Ø´Ø¨Ø§Ø¹ Ø®Ø±ÛŒØ¯
                reasons.append("Stochastic Ø§Ø´Ø¨Ø§Ø¹ Ø®Ø±ÛŒØ¯")
            elif stoch_k < 20 and stoch_d < 20:
                momentum_score += 15  # Ø§Ø´Ø¨Ø§Ø¹ ÙØ±ÙˆØ´
                reasons.append("Stochastic Ø§Ø´Ø¨Ø§Ø¹ ÙØ±ÙˆØ´")
            elif stoch_k > stoch_d:
                momentum_score += 10
                reasons.append("Stochastic ØµØ¹ÙˆØ¯ÛŒ")
            else:
                momentum_score -= 10
                reasons.append("Stochastic Ù†Ø²ÙˆÙ„ÛŒ")

        # 3. Ø¨Ø±Ø±Ø³ÛŒ Ù…ÙˆÙ‚Ø¹ÛŒØª Ù‚ÛŒÙ…Øª Ø¯Ø± Bollinger Bands
        if 'bb_upper' in df.columns and 'bb_lower' in df.columns:
            current_price = df['close'].iloc[-1]
            bb_upper = df['bb_upper'].iloc[-1]
            bb_lower = df['bb_lower'].iloc[-1]
            bb_middle = df['bb_middle'].iloc[-1]

            if current_price > bb_upper:
                momentum_score -= 20  # Ø®Ø§Ø±Ø¬ Ø§Ø² Ø¨Ø§Ù†Ø¯ Ø¨Ø§Ù„Ø§ - Ø§ØµÙ„Ø§Ø­ Ø§Ø­ØªÙ…Ø§Ù„ÛŒ
                reasons.append("Ø®Ø§Ø±Ø¬ Ø§Ø² Ø¨Ø§Ù†Ø¯ Ø¨Ø§Ù„Ø§")
            elif current_price < bb_lower:
                momentum_score += 20  # Ø®Ø§Ø±Ø¬ Ø§Ø² Ø¨Ø§Ù†Ø¯ Ù¾Ø§ÛŒÛŒÙ† - Ø¨Ø§Ø²Ú¯Ø´Øª Ø§Ø­ØªÙ…Ø§Ù„ÛŒ
                reasons.append("Ø®Ø§Ø±Ø¬ Ø§Ø² Ø¨Ø§Ù†Ø¯ Ù¾Ø§ÛŒÛŒÙ†")
            elif current_price > bb_middle:
                momentum_score += 10
                reasons.append("Ø¨Ø§Ù„Ø§ÛŒ ÙˆØ³Ø· Ø¨Ø§Ù†Ø¯")
            else:
                momentum_score -= 10
                reasons.append("Ø²ÛŒØ± ÙˆØ³Ø· Ø¨Ø§Ù†Ø¯")

        # ØªÙØ³ÛŒØ± Ù†ØªÛŒØ¬Ù‡
        if momentum_score >= 30:
            momentum = 'strong_bullish'
        elif momentum_score >= 10:
            momentum = 'bullish'
        elif momentum_score <= -30:
            momentum = 'strong_bearish'
        elif momentum_score <= -10:
            momentum = 'bearish'
        else:
            momentum = 'neutral'

        return {
            'momentum': momentum,
            'strength': momentum_score,
            'reasons': reasons
        }

    def smart_trailing_stop(self, current_price):
        """
        ØªØ±ÛŒÙ„ÛŒÙ†Ú¯ Ø§Ø³ØªØ§Ù¾ Ø¢ÙˆÛŒØ²Ø§Ù† - Ù†Ø³Ø®Ù‡ Ø§ØµÙ„Ø§Ø­ Ø´Ø¯Ù‡ Ù†Ù‡Ø§ÛŒÛŒ
        ÙÙ‚Ø· ÙˆÙ‚ØªÛŒ Ù‚ÛŒÙ…Øª Ø¨Ù‡ Ø³Ù…Øª Ø³ÙˆØ¯ Ø­Ø±Ú©Øª Ù…ÛŒâ€ŒÚ©Ù†Ø¯ Ø­Ø¯Ù‡Ø§ ØªØºÛŒÛŒØ± Ù…ÛŒâ€ŒÚ©Ù†Ù†Ø¯
        """

        if not self.TRAILING_ENABLED:
            return False

        if not self.in_trade:
            return False

        if self.trade_direction is None:
            return False

        current_price = int(current_price)
        entry_price = int(self.entry_price)
        stop_loss = int(self.stop_loss_price)
        take_profit = int(self.take_profit_price)

        direction = self.trade_direction
        sl_distance = self.TRAILING_STEP_LINES

        if direction == 'long':
            # âœ… Ø§ØµÙ„Ø§Ø­ Û±: Ù‡Ù…ÛŒØ´Ù‡ old_highest Ø±Ø§ Ø°Ø®ÛŒØ±Ù‡ Ú©Ù†
            old_highest = self.highest_price_in_trade

            # âœ… Ø§ØµÙ„Ø§Ø­ Û²: Ù‡Ù…ÛŒØ´Ù‡ highest Ø±Ø§ Ø¢Ù¾Ø¯ÛŒØª Ú©Ù† (Ø¨Ø§ Ù…Ø§Ú©Ø³ÛŒÙ…Ù…)
            self.highest_price_in_trade = max(self.highest_price_in_trade, current_price)

            # âœ… Ø§ØµÙ„Ø§Ø­ Û³: Ø¨Ø±Ø±Ø³ÛŒ Ú©Ù† Ø¢ÛŒØ§ Ù‚ÛŒÙ…Øª ÙˆØ§Ù‚Ø¹Ø§Ù‹ Ø¨Ø§Ù„Ø§ Ø±ÙØªÙ‡ØŸ
            price_moved_up = current_price > old_highest

            # Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø³ÙˆØ¯ Ù†Ø³Ø¨Øª Ø¨Ù‡ Ø¨Ø§Ù„Ø§ØªØ±ÛŒÙ† Ù‚ÛŒÙ…Øª
            current_profit_lines = self.highest_price_in_trade - entry_price

            # âœ… Ø§ØµÙ„Ø§Ø­ Û´: Ø´Ø±Ø· ÙØ¹Ø§Ù„â€ŒØ³Ø§Ø²ÛŒ ØªØ±ÛŒÙ„ÛŒÙ†Ú¯
            if current_profit_lines < self.TRAILING_STOP_LINES:
                if price_moved_up:
                    print(f"ğŸ“ˆ Ø¨Ø§Ù„Ø§ØªØ±ÛŒÙ† Ù‚ÛŒÙ…Øª Ø¢Ù¾Ø¯ÛŒØª Ø´Ø¯: {current_price} (Ø³ÙˆØ¯: {current_profit_lines} Ø®Ø· - Ù…Ù†ØªØ¸Ø± {self.TRAILING_STOP_LINES} Ø®Ø· Ø¨Ø±Ø§ÛŒ ØªØ±ÛŒÙ„ÛŒÙ†Ú¯)")

                current_profit = current_price - entry_price
                print(f"ğŸ“Š LONG - Ù‚ÛŒÙ…Øª: {current_price} | Ø¨Ø§Ù„Ø§ØªØ±ÛŒÙ†: {self.highest_price_in_trade} | Ø³ÙˆØ¯: {current_profit} Ø®Ø· | SL: {stop_loss} | TP: {take_profit}")
                return False

            # âœ… Ø§ØµÙ„Ø§Ø­ Ûµ: ÙÙ‚Ø· ÙˆÙ‚ØªÛŒ Ù‚ÛŒÙ…Øª Ø¨Ø§Ù„Ø§ Ø±ÙØªÙ‡ ØªØ±ÛŒÙ„ÛŒÙ†Ú¯ ÙØ¹Ø§Ù„ Ú©Ù†
            if price_moved_up:
                move_amount = current_price - old_highest

                # Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø­Ø¯ Ø¶Ø±Ø± Ø¬Ø¯ÛŒØ¯
                new_stop_loss = current_price - sl_distance

                # âœ… Ø§ØµÙ„Ø§Ø­ Û¶: Ø´Ø±Ø· Ø¨Ø§ÛŒØ¯ new_stop_loss > stop_loss Ø¨Ø§Ø´Ø¯
                if new_stop_loss > stop_loss:
                    old_sl = stop_loss
                    self.stop_loss_price = new_stop_loss

                    # Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø­Ø¯ Ø³ÙˆØ¯ Ø¬Ø¯ÛŒØ¯ (Ø¨Ø§ Ù†Ø³Ø¨Øª Ø±ÛŒØ³Ú© Ø¨Ù‡ Ø±ÛŒÙˆØ§Ø±Ø¯)
                    new_take_profit = take_profit + move_amount

                    # âœ… Ø§ØµÙ„Ø§Ø­ Û·: Ø­Ø¯ Ø³ÙˆØ¯ Ø¬Ø¯ÛŒØ¯ Ø¨Ø§ÛŒØ¯ Ø­Ø¯Ø§Ù‚Ù„ Û±.Ûµ Ø¨Ø±Ø§Ø¨Ø± Ø­Ø¯ Ø¶Ø±Ø± Ø¨Ø§Ø´Ø¯
                    min_profit = entry_price + int((new_stop_loss - entry_price) * 1.5)
                    new_take_profit = max(new_take_profit, min_profit)

                    old_tp = take_profit
                    self.take_profit_price = new_take_profit

                    locked_profit = self.stop_loss_price - entry_price
                    locked_profit_toman = locked_profit * self.LINE_VALUE_TOMAN

                    print(f"\nğŸ¯ ØªØ±ÛŒÙ„ÛŒÙ†Ú¯ Ø¢ÙˆÛŒØ²Ø§Ù† LONG Ø¢Ù¾Ø¯ÛŒØª Ø´Ø¯!")
                    print(f"   ğŸ“ˆ Ù‚ÛŒÙ…Øª: {old_highest} â†’ {current_price} (+{move_amount} Ø®Ø·)")
                    print(f"   ğŸ›¡ï¸ SL: {old_sl} â†’ {self.stop_loss_price}")
                    print(f"   ğŸ¯ TP: {old_tp} â†’ {self.take_profit_price}")
                    print(f"   ğŸ’° Ø³ÙˆØ¯ Ù‚ÙÙ„ Ø´Ø¯Ù‡: {locked_profit} Ø®Ø· ({locked_profit_toman:,.0f} ØªÙˆÙ…Ø§Ù†)")

                    self.send_update_stop_loss_command(
                        new_stop_loss=self.stop_loss_price,
                        reason=f"ØªØ±ÛŒÙ„ÛŒÙ†Ú¯ Ø¢ÙˆÛŒØ²Ø§Ù† - Ø³ÙˆØ¯ Ù‚ÙÙ„: {locked_profit} Ø®Ø·"
                    )

                    self.send_update_take_profit_command(
                        new_take_profit=self.take_profit_price,
                        reason=f"ØªØ±ÛŒÙ„ÛŒÙ†Ú¯ Ø¢ÙˆÛŒØ²Ø§Ù† - TP Ø¬Ø¯ÛŒØ¯"
                    )

                    return True

            # Ù†Ù…Ø§ÛŒØ´ ÙˆØ¶Ø¹ÛŒØª ÙØ¹Ù„ÛŒ
            current_profit = current_price - entry_price
            print(f"ğŸ“Š LONG - Ù‚ÛŒÙ…Øª: {current_price} | Ø¨Ø§Ù„Ø§ØªØ±ÛŒÙ†: {self.highest_price_in_trade} | Ø³ÙˆØ¯: {current_profit} Ø®Ø· | SL: {stop_loss} | TP: {take_profit}")

        elif direction == 'short':
            # âœ… Ø§ØµÙ„Ø§Ø­ Û±: Ù‡Ù…ÛŒØ´Ù‡ old_lowest Ø±Ø§ Ø°Ø®ÛŒØ±Ù‡ Ú©Ù†
            if self.lowest_price_in_trade == float('inf'):
                self.lowest_price_in_trade = current_price
                old_lowest = current_price
            else:
                old_lowest = self.lowest_price_in_trade

            # âœ… Ø§ØµÙ„Ø§Ø­ Û²: Ù‡Ù…ÛŒØ´Ù‡ lowest Ø±Ø§ Ø¢Ù¾Ø¯ÛŒØª Ú©Ù† (Ø¨Ø§ Ù…ÛŒÙ†ÛŒÙ…Ù…)
            self.lowest_price_in_trade = min(self.lowest_price_in_trade, current_price)

            # âœ… Ø§ØµÙ„Ø§Ø­ Û³: Ø¨Ø±Ø±Ø³ÛŒ Ú©Ù† Ø¢ÛŒØ§ Ù‚ÛŒÙ…Øª ÙˆØ§Ù‚Ø¹Ø§Ù‹ Ù¾Ø§ÛŒÛŒÙ† Ø±ÙØªÙ‡ØŸ
            price_moved_down = current_price < old_lowest

            # Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø³ÙˆØ¯ Ù†Ø³Ø¨Øª Ø¨Ù‡ Ù¾Ø§ÛŒÛŒÙ†â€ŒØªØ±ÛŒÙ† Ù‚ÛŒÙ…Øª
            if self.lowest_price_in_trade != float('inf'):
                current_profit_lines = entry_price - self.lowest_price_in_trade
            else:
                current_profit_lines = 0

            # âœ… Ø§ØµÙ„Ø§Ø­ Û´: Ø´Ø±Ø· ÙØ¹Ø§Ù„â€ŒØ³Ø§Ø²ÛŒ ØªØ±ÛŒÙ„ÛŒÙ†Ú¯
            if current_profit_lines < self.TRAILING_STOP_LINES:
                if price_moved_down:
                    print(f"ğŸ“‰ Ù¾Ø§ÛŒÛŒÙ†â€ŒØªØ±ÛŒÙ† Ù‚ÛŒÙ…Øª Ø¢Ù¾Ø¯ÛŒØª Ø´Ø¯: {current_price} (Ø³ÙˆØ¯: {current_profit_lines} Ø®Ø· - Ù…Ù†ØªØ¸Ø± {self.TRAILING_STOP_LINES} Ø®Ø· Ø¨Ø±Ø§ÛŒ ØªØ±ÛŒÙ„ÛŒÙ†Ú¯)")

                current_profit = entry_price - current_price
                lowest_display = self.lowest_price_in_trade if self.lowest_price_in_trade != float('inf') else entry_price
                print(f"ğŸ“Š SHORT - Ù‚ÛŒÙ…Øª: {current_price} | Ù¾Ø§ÛŒÛŒÙ†â€ŒØªØ±ÛŒÙ†: {lowest_display} | Ø³ÙˆØ¯: {current_profit} Ø®Ø· | SL: {stop_loss} | TP: {take_profit}")
                return False

            # âœ… Ø§ØµÙ„Ø§Ø­ Ûµ: ÙÙ‚Ø· ÙˆÙ‚ØªÛŒ Ù‚ÛŒÙ…Øª Ù¾Ø§ÛŒÛŒÙ† Ø±ÙØªÙ‡ ØªØ±ÛŒÙ„ÛŒÙ†Ú¯ ÙØ¹Ø§Ù„ Ú©Ù†
            if price_moved_down:
                move_amount = old_lowest - current_price

                # Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø­Ø¯ Ø¶Ø±Ø± Ø¬Ø¯ÛŒØ¯
                new_stop_loss = current_price + sl_distance

                # âœ… Ø§ØµÙ„Ø§Ø­ Û¶: Ø´Ø±Ø· Ø¨Ø§ÛŒØ¯ new_stop_loss < stop_loss Ø¨Ø§Ø´Ø¯
                if new_stop_loss < stop_loss:
                    old_sl = stop_loss
                    self.stop_loss_price = new_stop_loss

                    # Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø­Ø¯ Ø³ÙˆØ¯ Ø¬Ø¯ÛŒØ¯ (Ø¨Ø§ Ù†Ø³Ø¨Øª Ø±ÛŒØ³Ú© Ø¨Ù‡ Ø±ÛŒÙˆØ§Ø±Ø¯)
                    new_take_profit = take_profit - move_amount

                    # âœ… Ø§ØµÙ„Ø§Ø­ Û·: Ø­Ø¯ Ø³ÙˆØ¯ Ø¬Ø¯ÛŒØ¯ Ø¨Ø§ÛŒØ¯ Ø­Ø¯Ø§Ù‚Ù„ Û±.Ûµ Ø¨Ø±Ø§Ø¨Ø± Ø­Ø¯ Ø¶Ø±Ø± Ø¨Ø§Ø´Ø¯
                    min_profit = entry_price - int((entry_price - new_stop_loss) * 1.5)
                    new_take_profit = min(new_take_profit, min_profit)

                    old_tp = take_profit
                    self.take_profit_price = new_take_profit

                    locked_profit = entry_price - self.stop_loss_price
                    locked_profit_toman = locked_profit * self.LINE_VALUE_TOMAN

                    print(f"\nğŸ¯ ØªØ±ÛŒÙ„ÛŒÙ†Ú¯ Ø¢ÙˆÛŒØ²Ø§Ù† SHORT Ø¢Ù¾Ø¯ÛŒØª Ø´Ø¯!")
                    print(f"   ğŸ“‰ Ù‚ÛŒÙ…Øª: {old_lowest} â†’ {current_price} (+{move_amount} Ø®Ø· Ø³ÙˆØ¯)")
                    print(f"   ğŸ›¡ï¸ SL: {old_sl} â†’ {self.stop_loss_price}")
                    print(f"   ğŸ¯ TP: {old_tp} â†’ {self.take_profit_price}")
                    print(f"   ğŸ’° Ø³ÙˆØ¯ Ù‚ÙÙ„ Ø´Ø¯Ù‡: {locked_profit} Ø®Ø· ({locked_profit_toman:,.0f} ØªÙˆÙ…Ø§Ù†)")

                    self.send_update_stop_loss_command(
                        new_stop_loss=self.stop_loss_price,
                        reason=f"ØªØ±ÛŒÙ„ÛŒÙ†Ú¯ Ø¢ÙˆÛŒØ²Ø§Ù† - Ø³ÙˆØ¯ Ù‚ÙÙ„: {locked_profit} Ø®Ø·"
                    )

                    self.send_update_take_profit_command(
                        new_take_profit=self.take_profit_price,
                        reason=f"ØªØ±ÛŒÙ„ÛŒÙ†Ú¯ Ø¢ÙˆÛŒØ²Ø§Ù† - TP Ø¬Ø¯ÛŒØ¯"
                    )

                    return True

            # Ù†Ù…Ø§ÛŒØ´ ÙˆØ¶Ø¹ÛŒØª ÙØ¹Ù„ÛŒ
            current_profit = entry_price - current_price
            lowest_display = self.lowest_price_in_trade if self.lowest_price_in_trade != float('inf') else entry_price
            print(f"ğŸ“Š SHORT - Ù‚ÛŒÙ…Øª: {current_price} | Ù¾Ø§ÛŒÛŒÙ†â€ŒØªØ±ÛŒÙ†: {lowest_display} | Ø³ÙˆØ¯: {current_profit} Ø®Ø· | SL: {stop_loss} | TP: {take_profit}")

        return False

    def calculate_pnl(self, entry_price, exit_price, direction):
        """
        Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø³ÙˆØ¯/Ø¶Ø±Ø± Ù†Ù‡Ø§ÛŒÛŒ Ù…Ø¹Ø§Ù…Ù„Ù‡ Ø¨Ø± Ø­Ø³Ø¨ ØªÙˆÙ…Ø§Ù†

        ğŸ”„ ØªØºÛŒÛŒØ± Ø§Ø² ØªÛŒÚ© Ø¨Ù‡ Ø®Ø·:
        - Ù‚Ø¨Ù„Ø§Ù‹: ØªÛŒÚ© Ã— Ø­Ø¬Ù… Ã— Ø§Ø±Ø²Ø´_ØªÛŒÚ©
        - Ø§Ù„Ø§Ù†: Ø®Ø· Ã— Ø§Ø±Ø²Ø´_Ø®Ø· (Ø­Ø¬Ù… Ù‡Ù…ÛŒØ´Ù‡ 1)

        Ù¾Ø§Ø±Ø§Ù…ØªØ±Ù‡Ø§:
        - entry_price: Ù‚ÛŒÙ…Øª ÙˆØ±ÙˆØ¯ (Ø¹Ø¯Ø¯ ØµØ­ÛŒØ­)
        - exit_price: Ù‚ÛŒÙ…Øª Ø®Ø±ÙˆØ¬ (Ø¹Ø¯Ø¯ ØµØ­ÛŒØ­)
        - direction: Ø¬Ù‡Øª Ù…Ø¹Ø§Ù…Ù„Ù‡ ('long' ÛŒØ§ 'short')

        Ø¨Ø§Ø²Ú¯Ø´Øª:
        - Ø³ÙˆØ¯/Ø¶Ø±Ø± Ø¨Ù‡ ØªÙˆÙ…Ø§Ù†

        Ù…Ø«Ø§Ù„:
        - LONG: ÙˆØ±ÙˆØ¯ 53200ØŒ Ø®Ø±ÙˆØ¬ 53220 â†’ 20 Ø®Ø· Ã— 23000 = 460,000 ØªÙˆÙ…Ø§Ù† Ø³ÙˆØ¯
        - SHORT: ÙˆØ±ÙˆØ¯ 53200ØŒ Ø®Ø±ÙˆØ¬ 53180 â†’ 20 Ø®Ø· Ã— 23000 = 460,000 ØªÙˆÙ…Ø§Ù† Ø³ÙˆØ¯
        """

        if entry_price <= 0:
            print(f"âš ï¸ Ù‚ÛŒÙ…Øª ÙˆØ±ÙˆØ¯ Ù†Ø§Ù…Ø¹ØªØ¨Ø±: {entry_price}")
            return 0

        if exit_price <= 0:
            print(f"âš ï¸ Ù‚ÛŒÙ…Øª Ø®Ø±ÙˆØ¬ Ù†Ø§Ù…Ø¹ØªØ¨Ø±: {exit_price}")
            return 0

        if direction is None:
            print(f"âš ï¸ Ø¬Ù‡Øª Ù…Ø¹Ø§Ù…Ù„Ù‡ Ù†Ø§Ù…Ø¹ØªØ¨Ø±: {direction}")
            return 0

        try:
            # ğŸ”„ ØªØ¨Ø¯ÛŒÙ„ Ø¨Ù‡ Ø¹Ø¯Ø¯ ØµØ­ÛŒØ­
            entry_price = int(entry_price)
            exit_price = int(exit_price)

            # Ù…Ø­Ø§Ø³Ø¨Ù‡ ØªØ¹Ø¯Ø§Ø¯ Ø®Ø·ÙˆØ· Ø³ÙˆØ¯/Ø¶Ø±Ø±
            if direction == 'long':
                lines = exit_price - entry_price
                print(f"ğŸ” PnL LONG: Ø®Ø±ÙˆØ¬({exit_price}) - ÙˆØ±ÙˆØ¯({entry_price}) = {lines} Ø®Ø·")
            elif direction == 'short':
                lines = entry_price - exit_price
                print(f"ğŸ” PnL SHORT: ÙˆØ±ÙˆØ¯({entry_price}) - Ø®Ø±ÙˆØ¬({exit_price}) = {lines} Ø®Ø·")
            else:
                print(f"âš ï¸ Ø¬Ù‡Øª Ù…Ø¹Ø§Ù…Ù„Ù‡ Ù†Ø§Ù…Ø¹ØªØ¨Ø±: {direction}")
                return 0

            # ğŸ”„ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø³ÙˆØ¯/Ø¶Ø±Ø± Ø¨Ù‡ ØªÙˆÙ…Ø§Ù†
            # ÙØ±Ù…ÙˆÙ„ Ø¬Ø¯ÛŒØ¯: Ø®Ø· Ã— Ø§Ø±Ø²Ø´_Ù‡Ø±_Ø®Ø·
            pnl_toman = lines * self.LINE_VALUE_TOMAN

            # Ø¨Ø±Ø±Ø³ÛŒ Ù…Ù†Ø·Ù‚ÛŒ Ø¨ÙˆØ¯Ù†
            max_reasonable_lines = 1000  # Ø­Ø¯Ø§Ú©Ø«Ø± 1000 Ø®Ø· ØªØºÛŒÛŒØ± Ù…Ù†Ø·Ù‚ÛŒ
            if abs(lines) > max_reasonable_lines:
                print(f"âš ï¸ ØªØºÛŒÛŒØ± Ù‚ÛŒÙ…Øª ØºÛŒØ±Ù…Ù†Ø·Ù‚ÛŒ: {lines} Ø®Ø·ØŒ Ù…Ø­Ø¯ÙˆØ¯ Ø´Ø¯ Ø¨Ù‡ {max_reasonable_lines}")
                if lines > 0:
                    lines = max_reasonable_lines
                else:
                    lines = -max_reasonable_lines
                pnl_toman = lines * self.LINE_VALUE_TOMAN

            # Ù…Ø­Ø¯ÙˆØ¯ÛŒØª Ø³ÙˆØ¯/Ø¶Ø±Ø±
            max_reasonable_pnl = self.PORTFOLIO_SIZE * 2
            if abs(pnl_toman) > max_reasonable_pnl:
                print(f"âš ï¸ Ø³ÙˆØ¯/Ø¶Ø±Ø± ØºÛŒØ±Ù…Ù†Ø·Ù‚ÛŒ: {pnl_toman:,.0f} ØªÙˆÙ…Ø§Ù†ØŒ Ù…Ø­Ø¯ÙˆØ¯ Ø´Ø¯")
                if pnl_toman > 0:
                    pnl_toman = max_reasonable_pnl
                else:
                    pnl_toman = -max_reasonable_pnl

            print(f"ğŸ“Š PnL Ù†Ù‡Ø§ÛŒÛŒ: {pnl_toman:+,.0f} ØªÙˆÙ…Ø§Ù† ({lines:+} Ø®Ø· Ã— {self.LINE_VALUE_TOMAN:,} ØªÙˆÙ…Ø§Ù†)")
            return pnl_toman

        except Exception as e:
            print(f"âš ï¸ Ø®Ø·Ø§ Ø¯Ø± Ù…Ø­Ø§Ø³Ø¨Ù‡ PnL: {e}")
            return 0

    def get_valid_exit_price(self, preferred_price):
        if preferred_price is not None and preferred_price > 0:
            if self.entry_price > 0:
                lower_bound = self.entry_price * 0.5
                upper_bound = self.entry_price * 2
                if preferred_price >= lower_bound and preferred_price <= upper_bound:
                    return preferred_price
                else:
                    print(f"âš ï¸ Ù‚ÛŒÙ…Øª ØªØ±Ø¬ÛŒØ­ÛŒ ØºÛŒØ±Ù…Ù†Ø·Ù‚ÛŒ: {preferred_price:.2f} (Ù…Ø­Ø¯ÙˆØ¯Ù‡ Ù…Ø¬Ø§Ø²: {lower_bound:.2f} - {upper_bound:.2f})")
            else:
                return preferred_price

        if self.MARKET_PRICE is not None and self.MARKET_PRICE > 0:
            print(f"ğŸ“Š Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ù‚ÛŒÙ…Øª Ø¨Ø§Ø²Ø§Ø±: {self.MARKET_PRICE:.2f}")
            return self.MARKET_PRICE

        if self.LAST_KNOWN_PRICE is not None and self.LAST_KNOWN_PRICE > 0:
            print(f"âš ï¸ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ø¢Ø®Ø±ÛŒÙ† Ù‚ÛŒÙ…Øª Ø´Ù†Ø§Ø®ØªÙ‡ Ø´Ø¯Ù‡: {self.LAST_KNOWN_PRICE:.2f}")
            return self.LAST_KNOWN_PRICE

        if self.entry_price > 0:
            print(f"âš ï¸ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ù‚ÛŒÙ…Øª ÙˆØ±ÙˆØ¯ Ø¨Ù‡ Ø¹Ù†ÙˆØ§Ù† Ù‚ÛŒÙ…Øª Ø®Ø±ÙˆØ¬: {self.entry_price:.2f}")
            return self.entry_price

        print("âŒ Ù‡ÛŒÚ† Ù‚ÛŒÙ…Øª Ù…Ø¹ØªØ¨Ø±ÛŒ Ù…ÙˆØ¬ÙˆØ¯ Ù†ÛŒØ³Øª!")
        return None

    def exit_trade(self, exit_price, reason="Ø¯Ø³ØªÛŒ"):
        try:
            if not self.in_trade:
                print("âš ï¸ Ù…Ø¹Ø§Ù…Ù„Ù‡â€ŒØ§ÛŒ Ø¨Ø§Ø² Ù†ÛŒØ³Øª")
                return False

            exit_price = int(exit_price)
            entry_price = int(self.entry_price)

            if self.trade_direction == 'long':
                pnl_lines = exit_price - entry_price
            else:
                pnl_lines = entry_price - exit_price

            pnl_toman = pnl_lines * self.LINE_VALUE_TOMAN
            pnl_percent = (pnl_toman / self.portfolio) * 100

            # Ø«Ø¨Øª Ø®Ø±ÙˆØ¬ Ø¯Ø± Ú˜ÙˆØ±Ù†Ø§Ù„
            if hasattr(self, 'journal') and self.journal:
                exit_data = {
                    'trade_id': self.current_internal_trade_id,
                    'exit_price': exit_price,
                    'reason': reason,
                    'pnl_lines': pnl_lines,
                    'pnl_toman': pnl_toman,
                    'pnl_percent': pnl_percent
                }
                self.journal.log_trade_exit(exit_data)

            # ÛŒØ§Ø¯Ú¯ÛŒØ±ÛŒ Ø¯Ø± SmartFilter
            if hasattr(self, 'smart_filter') and self.smart_filter:
                trade_record = {
                    'trade_id': self.current_internal_trade_id,
                    'pnl_lines': pnl_lines,
                    'direction': self.trade_direction,
                    'strategy': self.current_trade_strategy,
                    'entry_price': entry_price,
                    'exit_price': exit_price,
                    'reason': reason
                }
                self.smart_filter.learn_from_trade(trade_record)

            self.send_exit_trade_command(exit_price, reason, pnl_toman, pnl_percent)

            self.trades += 1
            if pnl_toman >= 0:
                self.winning_trades += 1
                self.total_profit += pnl_toman
            else:
                self.losing_trades += 1
                self.total_loss += abs(pnl_toman)

            self.balance += pnl_toman

            if self.balance > self.peak_balance:
                self.peak_balance = self.balance

            current_drawdown = ((self.peak_balance - self.balance) / self.peak_balance) * 100
            if current_drawdown > self.max_drawdown:
                self.max_drawdown = current_drawdown

            trade_record = {
                'entry_time': self.trade_start_time.isoformat() if self.trade_start_time else None,
                'exit_time': datetime.now().isoformat(),
                'direction': self.trade_direction,
                'entry_price': entry_price,
                'exit_price': exit_price,
                'stop_loss': int(self.stop_loss_price),
                'take_profit': int(self.take_profit_price),
                'pnl_lines': pnl_lines,
                'pnl_toman': pnl_toman,
                'pnl_percent': round(pnl_percent, 2),
                'duration': str(datetime.now() - self.trade_start_time) if self.trade_start_time else "N/A",
                'reason': reason,
                'balance_after': self.balance,
                'highest_price': self.highest_price_in_trade,
                'lowest_price': self.lowest_price_in_trade if self.lowest_price_in_trade != float('inf') else 0,
                'strategy': self.current_trade_strategy,
                'trade_id': self.current_internal_trade_id
            }
            self.trade_history.append(trade_record)

            print(f"\n{'â•' * 50}")
            if pnl_toman >= 0:
                print(f"âœ… Ù…Ø¹Ø§Ù…Ù„Ù‡ Ø¨Ø§ Ø³ÙˆØ¯ Ø¨Ø³ØªÙ‡ Ø´Ø¯!")
            else:
                print(f"âŒ Ù…Ø¹Ø§Ù…Ù„Ù‡ Ø¨Ø§ Ø¶Ø±Ø± Ø¨Ø³ØªÙ‡ Ø´Ø¯!")
            print(f"{'â•' * 50}")
            print(f"   ğŸ“ˆ Ø¬Ù‡Øª: {self.trade_direction.upper()}")
            print(f"   ğŸ“ ÙˆØ±ÙˆØ¯: {entry_price} â†’ Ø®Ø±ÙˆØ¬: {exit_price}")
            print(f"   {'ğŸ’°' if pnl_toman >= 0 else 'ğŸ’¸'} Ø³ÙˆØ¯/Ø¶Ø±Ø±: {pnl_toman:+,.0f} ØªÙˆÙ…Ø§Ù† ({pnl_lines:+} Ø®Ø·)")
            print(f"   ğŸ“Š Ø¯Ø±ØµØ¯: {pnl_percent:+.2f}%")
            print(f"   ğŸ’¼ Ù…ÙˆØ¬ÙˆØ¯ÛŒ: {self.balance:,.0f} ØªÙˆÙ…Ø§Ù†")
            print(f"   ğŸ“‹ Ø¯Ù„ÛŒÙ„: {reason}")
            print(f"{'â•' * 50}")

            self.last_trade_exit_time = datetime.now()
            self.reset_trade_variables()

            return True

        except Exception as e:
            print(f"âŒ Ø®Ø·Ø§ Ø¯Ø± Ø®Ø±ÙˆØ¬ Ø§Ø² Ù…Ø¹Ø§Ù…Ù„Ù‡: {e}")
            import traceback
            traceback.print_exc()
            return False

    def clear_open_trades(self):
        """
        Ù¾Ø§Ú© Ú©Ø±Ø¯Ù† Ù„ÛŒØ³Øª Ù…Ø¹Ø§Ù…Ù„Ø§Øª Ø¨Ø§Ø²
        Ø§ÛŒÙ† ØªØ§Ø¨Ø¹ Ø¬Ø¯Ø§Ú¯Ø§Ù†Ù‡ Ø¨Ø±Ø§ÛŒ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø¯Ø± Ø¬Ø§Ù‡Ø§ÛŒ Ù…Ø®ØªÙ„Ù
        """
        if hasattr(self, 'open_trades') and self.open_trades:
            trade_count = len(self.open_trades)
            self.open_trades.clear()
            print(f"ğŸ§¹ {trade_count} Ù…Ø¹Ø§Ù…Ù„Ù‡ Ø§Ø² Ù„ÛŒØ³Øª Ø¨Ø§Ø² Ù¾Ø§Ú© Ø´Ø¯")
            return True
        else:
            print("ğŸ“­ Ù„ÛŒØ³Øª Ù…Ø¹Ø§Ù…Ù„Ø§Øª Ø¨Ø§Ø² Ø®Ø§Ù„ÛŒ Ø§Ø³Øª")
            return False

    def update_m5_data(self, current_time, current_price):
        """Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ M5 Ø¨Ø§ Ú©Ù†Ø¯Ù„ Ø¬Ø¯ÛŒØ¯"""
        try:
            current_time_floor = pd.Timestamp(current_time).floor(self.M2_TIMEFRAME)

            if len(self.m3) == 0:
                # Ø§ÙˆÙ„ÛŒÙ† Ú©Ù†Ø¯Ù„
                new_row = pd.DataFrame([{
                    'open': current_price,
                    'high': current_price,
                    'low': current_price,
                    'close': current_price
                }], index=[current_time_floor])
                self.m3 = new_row
                return True

            last_index = self.m3.index[-1]

            if current_time_floor > last_index:
                # Ú©Ù†Ø¯Ù„ Ø¬Ø¯ÛŒØ¯
                new_row = pd.DataFrame([{
                    'open': current_price,
                    'high': current_price,
                    'low': current_price,
                    'close': current_price
                }], index=[current_time_floor])

                self.m3 = pd.concat([self.m3, new_row])

                # Ø­Ø°Ù Ú©Ù†Ø¯Ù„â€ŒÙ‡Ø§ÛŒ Ù‚Ø¯ÛŒÙ…ÛŒ Ø¨Ø±Ø§ÛŒ ØµØ±ÙÙ‡â€ŒØ¬ÙˆÛŒÛŒ Ø¯Ø± Ø­Ø§ÙØ¸Ù‡
                if len(self.m3) > 500:
                    self.m3 = self.m3.iloc[-500:]

                return True
            else:
                # Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ú©Ù†Ø¯Ù„ ÙØ¹Ù„ÛŒ
                self.m3.loc[last_index, 'high'] = max(self.m3.loc[last_index, 'high'], current_price)
                self.m3.loc[last_index, 'low'] = min(self.m3.loc[last_index, 'low'], current_price)
                self.m3.loc[last_index, 'close'] = current_price
                return False

        except Exception as e:
            print(f"âš ï¸ Ø®Ø·Ø§ Ø¯Ø± Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø¯Ø§Ø¯Ù‡ M5: {e}")
            return False

    def check_trade_management(self, current_price):
        """Ù…Ø¯ÛŒØ±ÛŒØª Ù…Ø¹Ø§Ù…Ù„Ù‡ Ø¨Ø§Ø² - Ù†Ø³Ø®Ù‡ Ø§ØµÙ„Ø§Ø­ Ø´Ø¯Ù‡"""

        if not self.in_trade:
            return

        if self.trade_direction is None:
            return

        current_price = int(current_price)
        entry_price = int(self.entry_price)
        stop_loss = int(self.stop_loss_price)
        take_profit = int(self.take_profit_price)

        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # ğŸ›¡ï¸ Ø§ÙˆÙ„ ØªØ±ÛŒÙ„ÛŒÙ†Ú¯ Ø§Ø³ØªØ§Ù¾ Ø±Ø§ Ø§Ø¬Ø±Ø§ Ú©Ù† (Ø§ÛŒÙ† Ø®ÙˆØ¯Ø´ highest/lowest Ø±Ø§ Ø¢Ù¾Ø¯ÛŒØª Ù…ÛŒâ€ŒÚ©Ù†Ø¯)
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        try:
            self.smart_trailing_stop(current_price)
        except Exception as e:
            print(f"âš ï¸ Ø®Ø·Ø§ Ø¯Ø± trailing stop: {e}")
            import traceback
            traceback.print_exc()

        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # ğŸ”´ Ø¨Ø¹Ø¯ Ú†Ú© Ú©Ù† Ø¢ÛŒØ§ Ø¨Ù‡ Ø­Ø¯ Ø¶Ø±Ø± Ø±Ø³ÛŒØ¯Ù‡
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # Ù…Ù‚Ø§Ø¯ÛŒØ± Ø¬Ø¯ÛŒØ¯ Ø±Ø§ Ø¨Ú¯ÛŒØ± (Ù…Ù…Ú©Ù† Ø§Ø³Øª trailing stop ØªØºÛŒÛŒØ±Ø´Ø§Ù† Ø¯Ø§Ø¯Ù‡ Ø¨Ø§Ø´Ø¯)
        stop_loss = int(self.stop_loss_price)
        take_profit = int(self.take_profit_price)

        stop_loss_hit = False
        if self.trade_direction == 'long' and current_price <= stop_loss:
            stop_loss_hit = True
            print(f"ğŸ›¡ï¸ Ø­Ø¯ Ø¶Ø±Ø± LONG ÙØ¹Ø§Ù„ Ø´Ø¯! Ù‚ÛŒÙ…Øª: {current_price} <= SL: {stop_loss}")
        elif self.trade_direction == 'short' and current_price >= stop_loss:
            stop_loss_hit = True
            print(f"ğŸ›¡ï¸ Ø­Ø¯ Ø¶Ø±Ø± SHORT ÙØ¹Ø§Ù„ Ø´Ø¯! Ù‚ÛŒÙ…Øª: {current_price} >= SL: {stop_loss}")

        if stop_loss_hit:
            self.exit_trade(stop_loss, "Ø­Ø¯ Ø¶Ø±Ø±")
            return

        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # ğŸ¯ Ú†Ú© Ú©Ù† Ø¢ÛŒØ§ Ø¨Ù‡ Ø­Ø¯ Ø³ÙˆØ¯ Ø±Ø³ÛŒØ¯Ù‡
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        take_profit_hit = False
        if self.trade_direction == 'long' and current_price >= take_profit:
            take_profit_hit = True
            print(f"ğŸ¯ Ø­Ø¯ Ø³ÙˆØ¯ LONG ÙØ¹Ø§Ù„ Ø´Ø¯! Ù‚ÛŒÙ…Øª: {current_price} >= TP: {take_profit}")
        elif self.trade_direction == 'short' and current_price <= take_profit:
            take_profit_hit = True
            print(f"ğŸ¯ Ø­Ø¯ Ø³ÙˆØ¯ SHORT ÙØ¹Ø§Ù„ Ø´Ø¯! Ù‚ÛŒÙ…Øª: {current_price} <= TP: {take_profit}")

        if take_profit_hit:
            self.exit_trade(take_profit, "Ø­Ø¯ Ø³ÙˆØ¯")
            return

    def check_time_based_exit(self):
        if not self.in_trade:
            return False

        if not self.trade_start_time:
            return False

        current_price = self.MARKET_PRICE if self.MARKET_PRICE else self.LAST_KNOWN_PRICE
        if not current_price:
            return False

        current_price = int(current_price)

        duration = datetime.now() - self.trade_start_time
        total_seconds = duration.total_seconds()
        minutes = total_seconds / 60
        hours = minutes / 60

        if hasattr(self, 'current_trade_strategy') and self.current_trade_strategy:
            strategy = self.current_trade_strategy
        else:
            strategy = self.determine_strategy_mode(current_price)

        current_profit_lines = self.calculate_current_profit_lines(current_price)
        current_profit_toman = current_profit_lines * self.LINE_VALUE_TOMAN

        if strategy == 'scalp':
            max_minutes = self.SCALP_MAX_TRADE_MINUTES

            if minutes >= max_minutes:
                print(f"\nâ° Ø®Ø±ÙˆØ¬ Ø²Ù…Ø§Ù†ÛŒ Ø§Ø³Ú©Ø§Ù„Ù¾ - Ø­Ø¯Ø§Ú©Ø«Ø± Ø²Ù…Ø§Ù† Ø±Ø³ÛŒØ¯")
                print(f"   â±ï¸ Ù…Ø¯Øª Ù…Ø¹Ø§Ù…Ù„Ù‡: {minutes:.0f} Ø¯Ù‚ÛŒÙ‚Ù‡")
                print(f"   ğŸ’° Ø³ÙˆØ¯/Ø¶Ø±Ø±: {current_profit_lines:+} Ø®Ø· ({current_profit_toman:+,.0f} ØªÙˆÙ…Ø§Ù†)")
                self.exit_trade(current_price, f"Ø­Ø¯Ø§Ú©Ø«Ø± Ø²Ù…Ø§Ù† Ø§Ø³Ú©Ø§Ù„Ù¾ ({max_minutes} Ø¯Ù‚ÛŒÙ‚Ù‡)")
                return True

            if minutes >= 45 and current_profit_lines < -2:
                print(f"\nâ° Ø®Ø±ÙˆØ¬ Ø²Ù…Ø§Ù†ÛŒ Ø§Ø³Ú©Ø§Ù„Ù¾ - Ø¶Ø±Ø± Ù…Ø¯Ø§ÙˆÙ…")
                print(f"   â±ï¸ Ù…Ø¯Øª Ù…Ø¹Ø§Ù…Ù„Ù‡: {minutes:.0f} Ø¯Ù‚ÛŒÙ‚Ù‡")
                print(f"   ğŸ’¸ Ø¶Ø±Ø±: {current_profit_lines} Ø®Ø· (Ø¨ÛŒØ´ Ø§Ø² 2 Ø®Ø·)")
                self.exit_trade(current_price, "Ø¶Ø±Ø± Ù…Ø¯Ø§ÙˆÙ… Ø§Ø³Ú©Ø§Ù„Ù¾ (45 Ø¯Ù‚ÛŒÙ‚Ù‡)")
                return True

            if minutes >= 60 and 0 <= current_profit_lines < 2:
                print(f"\nâ° Ø®Ø±ÙˆØ¬ Ø²Ù…Ø§Ù†ÛŒ Ø§Ø³Ú©Ø§Ù„Ù¾ - Ø³ÙˆØ¯ Ù†Ø§Ú†ÛŒØ²")
                print(f"   â±ï¸ Ù…Ø¯Øª Ù…Ø¹Ø§Ù…Ù„Ù‡: {minutes:.0f} Ø¯Ù‚ÛŒÙ‚Ù‡")
                print(f"   ğŸ’° Ø³ÙˆØ¯: {current_profit_lines} Ø®Ø· (Ú©Ù…ØªØ± Ø§Ø² 2 Ø®Ø·)")
                self.exit_trade(current_price, "Ø³ÙˆØ¯ Ù†Ø§Ú†ÛŒØ² Ø§Ø³Ú©Ø§Ù„Ù¾ (60 Ø¯Ù‚ÛŒÙ‚Ù‡)")
                return True

            if minutes >= 30 and current_profit_lines < -1:
                current_adx = 25
                if 'adx' in self.m3.columns and not self.m3['adx'].empty:
                    adx_val = self.m3['adx'].iloc[-1]
                    if pd.notna(adx_val):
                        current_adx = adx_val

                if current_adx > 30:
                    print(f"\nâ° Ø®Ø±ÙˆØ¬ Ø²Ù…Ø§Ù†ÛŒ Ø§Ø³Ú©Ø§Ù„Ù¾ - Ø¶Ø±Ø± Ø¯Ø± Ø±ÙˆÙ†Ø¯ Ù‚ÙˆÛŒ")
                    print(f"   â±ï¸ Ù…Ø¯Øª Ù…Ø¹Ø§Ù…Ù„Ù‡: {minutes:.0f} Ø¯Ù‚ÛŒÙ‚Ù‡")
                    print(f"   ğŸ’¸ Ø¶Ø±Ø±: {current_profit_lines} Ø®Ø·")
                    print(f"   ğŸ“ˆ ADX: {current_adx:.1f} (Ø±ÙˆÙ†Ø¯ Ù‚ÙˆÛŒ)")
                    self.exit_trade(current_price, "Ø¶Ø±Ø± Ø¯Ø± Ø±ÙˆÙ†Ø¯ Ù‚ÙˆÛŒ Ø§Ø³Ú©Ø§Ù„Ù¾")
                    return True

        else:
            max_hours = self.SWING_MAX_TRADE_HOURS

            if hours >= max_hours:
                print(f"\nâ° Ø®Ø±ÙˆØ¬ Ø²Ù…Ø§Ù†ÛŒ Ø³ÙˆØ¦ÛŒÙ†Ú¯ - Ø­Ø¯Ø§Ú©Ø«Ø± Ø²Ù…Ø§Ù† Ø±Ø³ÛŒØ¯")
                print(f"   â±ï¸ Ù…Ø¯Øª Ù…Ø¹Ø§Ù…Ù„Ù‡: {hours:.1f} Ø³Ø§Ø¹Øª")
                print(f"   ğŸ’° Ø³ÙˆØ¯/Ø¶Ø±Ø±: {current_profit_lines:+} Ø®Ø· ({current_profit_toman:+,.0f} ØªÙˆÙ…Ø§Ù†)")
                self.exit_trade(current_price, f"Ø­Ø¯Ø§Ú©Ø«Ø± Ø²Ù…Ø§Ù† Ø³ÙˆØ¦ÛŒÙ†Ú¯ ({max_hours} Ø³Ø§Ø¹Øª)")
                return True

            if hours >= 2 and current_profit_lines < -5:
                print(f"\nâ° Ø®Ø±ÙˆØ¬ Ø²Ù…Ø§Ù†ÛŒ Ø³ÙˆØ¦ÛŒÙ†Ú¯ - Ø¶Ø±Ø± Ù…Ø¯Ø§ÙˆÙ…")
                print(f"   â±ï¸ Ù…Ø¯Øª Ù…Ø¹Ø§Ù…Ù„Ù‡: {hours:.1f} Ø³Ø§Ø¹Øª")
                print(f"   ğŸ’¸ Ø¶Ø±Ø±: {current_profit_lines} Ø®Ø· (Ø¨ÛŒØ´ Ø§Ø² 5 Ø®Ø·)")
                self.exit_trade(current_price, "Ø¶Ø±Ø± Ù…Ø¯Ø§ÙˆÙ… Ø³ÙˆØ¦ÛŒÙ†Ú¯ (2 Ø³Ø§Ø¹Øª)")
                return True

            if hours >= 4 and 0 <= current_profit_lines < 3:
                print(f"\nâ° Ø®Ø±ÙˆØ¬ Ø²Ù…Ø§Ù†ÛŒ Ø³ÙˆØ¦ÛŒÙ†Ú¯ - Ø³ÙˆØ¯ Ù†Ø§Ú†ÛŒØ²")
                print(f"   â±ï¸ Ù…Ø¯Øª Ù…Ø¹Ø§Ù…Ù„Ù‡: {hours:.1f} Ø³Ø§Ø¹Øª")
                print(f"   ğŸ’° Ø³ÙˆØ¯: {current_profit_lines} Ø®Ø· (Ú©Ù…ØªØ± Ø§Ø² 3 Ø®Ø·)")
                self.exit_trade(current_price, "Ø³ÙˆØ¯ Ù†Ø§Ú†ÛŒØ² Ø³ÙˆØ¦ÛŒÙ†Ú¯ (4 Ø³Ø§Ø¹Øª)")
                return True

            if hours >= 6 and 3 <= current_profit_lines < 8:
                print(f"\nğŸ“Š Ø§Ø·Ù„Ø§Ø¹â€ŒØ±Ø³Ø§Ù†ÛŒ Ø³ÙˆØ¦ÛŒÙ†Ú¯ - 6 Ø³Ø§Ø¹Øª Ú¯Ø°Ø´Øª")
                print(f"   â±ï¸ Ù…Ø¯Øª Ù…Ø¹Ø§Ù…Ù„Ù‡: {hours:.1f} Ø³Ø§Ø¹Øª")
                print(f"   ğŸ’° Ø³ÙˆØ¯: {current_profit_lines} Ø®Ø·")
                print(f"   ğŸ’¡ Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯: Ù…ÛŒâ€ŒØªÙˆØ§Ù†ÛŒØ¯ Ø®Ø±ÙˆØ¬ Ø¯Ø± Ù†Ø¸Ø± Ø¨Ú¯ÛŒØ±ÛŒØ¯")

        return False

    def analyze_market_regime(self, lookback_candles=50):
        """
        ØªØ­Ù„ÛŒÙ„ Ø­Ø§Ù„Øª Ø¨Ø§Ø²Ø§Ø± Ø¨Ø§ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ Ùˆ Ø§Ù†Ø¯ÛŒÚ©Ø§ØªÙˆØ±Ù‡Ø§ÛŒ Ù…ÙˆØ¬ÙˆØ¯
        ØªØ±Ú©ÛŒØ¨ÛŒ Ø§Ø² Ø±ÙˆØ´â€ŒÙ‡Ø§ÛŒ Ù…Ø®ØªÙ„Ù Ø¨Ø±Ø§ÛŒ Ø¯Ù‚Øª Ø¨ÛŒØ´ØªØ±

        Returns:
            tuple: (regime, confidence, details)
            regime: 'trending_up', 'trending_down', 'ranging', 'volatile', 'unknown'
            confidence: 0-100
            details: Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø¬Ø²Ø¦ÛŒ
        """

        if len(self.m3) < lookback_candles:
            return "unknown", 50, {"error": "Ø¯Ø§Ø¯Ù‡ Ú©Ø§ÙÛŒ Ù†ÛŒØ³Øª"}

        try:
            # Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ù…ÙˆØ¬ÙˆØ¯
            recent = self.m3.iloc[-lookback_candles:]

            # ğŸ¯ Ø³ÛŒØ³ØªÙ… Ø§Ù…ØªÛŒØ§Ø²Ø¯Ù‡ÛŒ Ú†Ù†Ø¯Ù…Ø¹ÛŒØ§Ø±Ù‡
            scores = {
                'trending_up': 0,
                'trending_down': 0,
                'ranging': 0,
                'volatile': 0
            }

            details = {}

            # ==================== Ù…Ø¹ÛŒØ§Ø± 1: Ù‚Ø¯Ø±Øª Ø±ÙˆÙ†Ø¯ (ADX) ====================
            if 'adx' in recent.columns:
                adx_values = recent['adx'].dropna()
                if len(adx_values) > 0:
                    avg_adx = adx_values.mean()
                    adx_std = adx_values.std()

                    details['adx_avg'] = round(avg_adx, 1)
                    details['adx_std'] = round(adx_std, 1)

                    if avg_adx < 18:
                        scores['ranging'] += 35  # ADX Ù¾Ø§ÛŒÛŒÙ† = Ø§Ø­ØªÙ…Ø§Ù„ Ø±Ù†Ø¬ Ø¨Ø§Ù„Ø§
                        details['adx_signal'] = 'low_trend_strength'
                    elif avg_adx > 25:
                        # Ø¨Ø±Ø±Ø³ÛŒ Ø¬Ù‡Øª Ø±ÙˆÙ†Ø¯
                        if 'ema9' in recent.columns and 'ema21' in recent.columns:
                            ema9_current = recent['ema9'].iloc[-1]
                            ema21_current = recent['ema21'].iloc[-1]

                            if ema9_current > ema21_current:
                                scores['trending_up'] += 40
                                details['adx_signal'] = 'strong_uptrend'
                            else:
                                scores['trending_down'] += 40
                                details['adx_signal'] = 'strong_downtrend'
                    else:
                        scores['ranging'] += 20
                        details['adx_signal'] = 'medium_trend'

            # ==================== Ù…Ø¹ÛŒØ§Ø± 2: Ù…ÙˆÙ‚Ø¹ÛŒØª Ø¯Ø± Ø¨ÙˆÙ„ÛŒÙ†Ú¯Ø± Ø¨Ø§Ù†Ø¯ ====================
            if all(col in recent.columns for col in ['bb_upper', 'bb_lower', 'bb_middle']):
                # Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø¯Ø±ØµØ¯ Ø²Ù…Ø§Ù† Ø¯Ø±ÙˆÙ† Ø¨Ø§Ù†Ø¯Ù‡Ø§
                in_band_count = 0
                bb_positions = []

                for i in range(len(recent)):
                    price = recent['close'].iloc[i]
                    bb_upper = recent['bb_upper'].iloc[i]
                    bb_lower = recent['bb_lower'].iloc[i]

                    # Ù…ÙˆÙ‚Ø¹ÛŒØª Ù†Ø³Ø¨ÛŒ Ø¯Ø± Ø¨Ø§Ù†Ø¯ (0-100)
                    if bb_upper > bb_lower:
                        position = ((price - bb_lower) / (bb_upper - bb_lower)) * 100
                        position = max(0, min(100, position))
                        bb_positions.append(position)

                    # Ø¨Ø±Ø±Ø³ÛŒ Ø¯Ø§Ø®Ù„ Ø¨Ø§Ù†Ø¯ Ø¨ÙˆØ¯Ù†
                    if bb_lower <= price <= bb_upper:
                        in_band_count += 1

                time_in_bands_pct = (in_band_count / len(recent)) * 100

                # Ù…Ø­Ø§Ø³Ø¨Ù‡ ÙØ´Ø±Ø¯Ú¯ÛŒ Ø¨Ø§Ù†Ø¯
                bb_widths = recent['bb_upper'] - recent['bb_lower']
                avg_bb_width = bb_widths.mean()
                avg_price = recent['close'].mean()
                bb_width_pct = (avg_bb_width / avg_price) * 100 if avg_price > 0 else 0

                details['time_in_bands'] = round(time_in_bands_pct, 1)
                details['bb_width_pct'] = round(bb_width_pct, 2)

                # Ø§Ù…ØªÛŒØ§Ø²Ø¯Ù‡ÛŒ
                if time_in_bands_pct > 80 and bb_width_pct < 3.0:
                    scores['ranging'] += 30
                    details['bb_signal'] = 'tight_range'
                elif time_in_bands_pct > 60:
                    scores['ranging'] += 20
                    details['bb_signal'] = 'in_range'
                else:
                    # Ø§Ú¯Ø± Ø®Ø§Ø±Ø¬ Ø§Ø² Ø¨Ø§Ù†Ø¯ Ù‡Ø³ØªÛŒÙ…ØŒ Ø§Ø­ØªÙ…Ø§Ù„ Ø±ÙˆÙ†Ø¯
                    current_position = bb_positions[-1] if bb_positions else 50
                    if current_position > 80:
                        scores['trending_up'] += 15
                        details['bb_signal'] = 'above_band'
                    elif current_position < 20:
                        scores['trending_down'] += 15
                        details['bb_signal'] = 'below_band'

            # ==================== Ù…Ø¹ÛŒØ§Ø± 3: ØªØ­Ù„ÛŒÙ„ EMA Ú©Ø±Ø§Ø³â€ŒÙ‡Ø§ ====================
            if all(col in recent.columns for col in ['ema9', 'ema21']):
                # Ø´Ù…Ø§Ø±Ø´ ØªØ¹Ø¯Ø§Ø¯ Ú©Ø±Ø§Ø³â€ŒÙ‡Ø§
                crosses = 0
                trend_changes = []

                for i in range(1, len(recent)):
                    prev_ema9 = recent['ema9'].iloc[i - 1]
                    prev_ema21 = recent['ema21'].iloc[i - 1]
                    curr_ema9 = recent['ema9'].iloc[i]
                    curr_ema21 = recent['ema21'].iloc[i]

                    prev_bullish = prev_ema9 > prev_ema21
                    curr_bullish = curr_ema9 > curr_ema21

                    if prev_bullish != curr_bullish:
                        crosses += 1
                        trend_changes.append(i)

                cross_frequency = (crosses / len(recent)) * 100

                details['ema_crosses'] = crosses
                details['cross_frequency'] = round(cross_frequency, 1)

                if cross_frequency > 40:  # Ú©Ø±Ø§Ø³ Ù…Ú©Ø±Ø± = Ø¨Ø§Ø²Ø§Ø± Ø±Ù†Ø¬
                    scores['ranging'] += 25
                    details['ema_signal'] = 'frequent_crosses'
                elif cross_frequency < 15:  # Ú©Ø±Ø§Ø³ Ú©Ù… = Ø±ÙˆÙ†Ø¯ Ù¾Ø§ÛŒØ¯Ø§Ø±
                    current_bullish = recent['ema9'].iloc[-1] > recent['ema21'].iloc[-1]
                    if current_bullish:
                        scores['trending_up'] += 25
                        details['ema_signal'] = 'stable_uptrend'
                    else:
                        scores['trending_down'] += 25
                        details['ema_signal'] = 'stable_downtrend'
                else:
                    scores['ranging'] += 15
                    details['ema_signal'] = 'mixed_signals'

            # ==================== Ù…Ø¹ÛŒØ§Ø± 4: ØªØ­Ù„ÛŒÙ„ RSI Ø§Ù„Ú¯Ùˆ ====================
            if 'rsi14' in recent.columns:
                rsi_values = recent['rsi14'].dropna()
                if len(rsi_values) > 0:
                    avg_rsi = rsi_values.mean()
                    rsi_std = rsi_values.std()
                    rsi_range = rsi_values.max() - rsi_values.min()

                    details['rsi_avg'] = round(avg_rsi, 1)
                    details['rsi_std'] = round(rsi_std, 1)
                    details['rsi_range'] = round(rsi_range, 1)

                    # RSI Ø¯Ø± Ù…Ø­Ø¯ÙˆØ¯Ù‡ Ù…ÛŒØ§Ù†ÛŒ Ø¨Ø§ Ù†ÙˆØ³Ø§Ù† Ú©Ù… = Ø¨Ø§Ø²Ø§Ø± Ø±Ù†Ø¬
                    if 40 <= avg_rsi <= 60 and rsi_std < 10 and rsi_range < 25:
                        scores['ranging'] += 20
                        details['rsi_signal'] = 'neutral_range'
                    # RSI Ø¨Ø§Ù„Ø§ Ø¨Ø§ Ù†ÙˆØ³Ø§Ù† Ú©Ù… = Ø±ÙˆÙ†Ø¯ ØµØ¹ÙˆØ¯ÛŒ
                    elif avg_rsi > 60 and rsi_std < 8:
                        scores['trending_up'] += 20
                        details['rsi_signal'] = 'bullish_stable'
                    # RSI Ù¾Ø§ÛŒÛŒÙ† Ø¨Ø§ Ù†ÙˆØ³Ø§Ù† Ú©Ù… = Ø±ÙˆÙ†Ø¯ Ù†Ø²ÙˆÙ„ÛŒ
                    elif avg_rsi < 40 and rsi_std < 8:
                        scores['trending_down'] += 20
                        details['rsi_signal'] = 'bearish_stable'
                    else:
                        scores['volatile'] += 15
                        details['rsi_signal'] = 'volatile'

            # ==================== Ù…Ø¹ÛŒØ§Ø± 5: ØªØ­Ù„ÛŒÙ„ Ù†ÙˆØ³Ø§Ù† (ATR) ====================
            if 'atr' in recent.columns:
                atr_values = recent['atr'].dropna()
                if len(atr_values) > 0:
                    # â­ï¸ ØªØºÛŒÛŒØ± Ú©Ù„ÛŒØ¯ÛŒ Ø§ÛŒÙ†Ø¬Ø§Ø³Øª â­ï¸
                    # Ù‡Ù… ATR Ù†Ø³Ø¨ÛŒ (Ø¨Ø±Ø§ÛŒ Ø§Ù…ØªÛŒØ§Ø²Ø¯Ù‡ÛŒ Ø¯Ø§Ø®Ù„ÛŒ) Ùˆ Ù‡Ù… ATR Ù…Ø·Ù„Ù‚ (Ø¨Ø±Ø§ÛŒ SmartFilter) Ø±Ø§ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ú©Ù†
                    avg_atr_absolute = atr_values.mean()
                    avg_price = recent['close'].mean()
                    atr_ratio = (avg_atr_absolute / avg_price) * 100 if avg_price > 0 else 0

                    details['atr_absolute'] = round(avg_atr_absolute, 1)  # <<< Ø§ÛŒÙ† Ø®Ø· Ø±Ø§ Ø§Ø¶Ø§ÙÙ‡ Ú©Ù†
                    details['atr_ratio_pct'] = round(atr_ratio, 2)

                    # Ù…Ù†Ø·Ù‚ Ø§Ù…ØªÛŒØ§Ø²Ø¯Ù‡ÛŒ Ø¯Ø§Ø®Ù„ÛŒ Ø®ÙˆØ¯Øª Ø±Ø§ Ù†Ú¯Ù‡ Ø¯Ø§Ø± (Ú©Ù‡ Ø¯Ø±Ø³Øª Ú©Ø§Ø± Ù…ÛŒâ€ŒÚ©Ù†Ø¯)
                    if atr_ratio < 0.3:
                        scores['ranging'] += 15
                        details['atr_signal'] = 'low_volatility'
                    elif atr_ratio > 0.8:
                        scores['volatile'] += 25
                        details['atr_signal'] = 'high_volatility'
                    else:
                        scores['ranging'] += 10
                        details['atr_signal'] = 'medium_volatility'

            # ==================== Ù…Ø¹ÛŒØ§Ø± 6: ØªØ£ÛŒÛŒØ¯ Ø¨Ø§ Ø±ÙˆÙ†Ø¯ Ø±ÙˆØ²Ø§Ù†Ù‡ ====================
            daily_trend_score = self.calculate_daily_trend_score()
            details['daily_trend_score'] = daily_trend_score

            if abs(daily_trend_score) < 30:  # Ø±ÙˆÙ†Ø¯ Ø±ÙˆØ²Ø§Ù†Ù‡ Ø¶Ø¹ÛŒÙ
                scores['ranging'] += 10
                details['daily_signal'] = 'weak_daily_trend'
            elif daily_trend_score > 50:  # Ø±ÙˆÙ†Ø¯ ØµØ¹ÙˆØ¯ÛŒ Ù‚ÙˆÛŒ Ø±ÙˆØ²Ø§Ù†Ù‡
                scores['trending_up'] += 15
                details['daily_signal'] = 'strong_daily_uptrend'
            elif daily_trend_score < -50:  # Ø±ÙˆÙ†Ø¯ Ù†Ø²ÙˆÙ„ÛŒ Ù‚ÙˆÛŒ Ø±ÙˆØ²Ø§Ù†Ù‡
                scores['trending_down'] += 15
                details['daily_signal'] = 'strong_daily_downtrend'

            # ==================== ØªØ´Ø®ÛŒØµ Ù†Ù‡Ø§ÛŒÛŒ ====================
            # Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø§Ø·Ù…ÛŒÙ†Ø§Ù†
            total_scores = sum(scores.values())
            if total_scores > 0:
                confidence_scores = {k: (v / total_scores) * 100 for k, v in scores.items()}

                # Ù¾ÛŒØ¯Ø§ Ú©Ø±Ø¯Ù† Ø±Ú˜ÛŒÙ… ØºØ§Ù„Ø¨
                dominant_regime = max(confidence_scores, key=confidence_scores.get)
                confidence = confidence_scores[dominant_regime]

                # Ø§Ú¯Ø± Ø§Ø·Ù…ÛŒÙ†Ø§Ù† Ø®ÛŒÙ„ÛŒ Ù¾Ø§ÛŒÛŒÙ† Ø§Ø³Øª
                if confidence < 40:
                    dominant_regime = "transitional"
                    confidence = 100 - confidence

                # Ø§Ú¯Ø± Ù†ÙˆØ³Ø§Ù† Ø¨Ø§Ù„Ø§ Ø¯Ø§Ø±ÛŒÙ…
                if scores['volatile'] > 30:
                    dominant_regime = "volatile"
                    confidence = max(confidence, 70)

                details['final_scores'] = scores
                details['confidence_breakdown'] = confidence_scores

                return dominant_regime, round(confidence, 1), details

            return "unknown", 50, details

        except Exception as e:
            print(f"âš ï¸ Ø®Ø·Ø§ Ø¯Ø± ØªØ­Ù„ÛŒÙ„ Ø±Ú˜ÛŒÙ… Ø¨Ø§Ø²Ø§Ø±: {e}")
            import traceback
            traceback.print_exc()
            return "unknown", 0, {"error": str(e)}

    def _update_market_regime(self):
        """Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø±Ú˜ÛŒÙ… Ø¨Ø§Ø²Ø§Ø±"""
        try:
            regime, confidence, details = self.analyze_market_regime(
                lookback_candles=self.REGIME_SETTINGS['lookback_candles']
            )

            self.market_regime = regime
            self.regime_confidence = confidence
            self.last_regime_details = details
            # Ø°Ø®ÛŒØ±Ù‡ Ø¯Ø± ØªØ§Ø±ÛŒØ®Ú†Ù‡
            self.regime_history.append({
                'time': datetime.now(),
                'regime': regime,
                'confidence': confidence,
                'price': self.MARKET_PRICE if self.MARKET_PRICE else self.LAST_KNOWN_PRICE
            })

            # Ù†Ù…Ø§ÛŒØ´ Ø¯Ø± ØµÙˆØ±Øª ØªØºÛŒÛŒØ± Ù‚Ø§Ø¨Ù„ ØªÙˆØ¬Ù‡
            if len(self.regime_history) >= 2:
                last_regime = self.regime_history[-2]['regime']
                last_confidence = self.regime_history[-2]['confidence']

                if (regime != last_regime and confidence > self.REGIME_SETTINGS['min_confidence'] and
                        last_confidence > self.REGIME_SETTINGS['min_confidence']):
                    print(f"\nğŸ”„ ØªØºÛŒÛŒØ± Ø±Ú˜ÛŒÙ… Ø¨Ø§Ø²Ø§Ø±: {last_regime} â†’ {regime}")
                    print(f"   Ø§Ø·Ù…ÛŒÙ†Ø§Ù†: {last_confidence:.0f}% â†’ {confidence:.0f}%")

                    # Ø§Ø·Ù„Ø§Ø¹â€ŒØ±Ø³Ø§Ù†ÛŒ Ø¨Ù‡ Ú©Ù„Ø§ÛŒÙ†Øªâ€ŒÙ‡Ø§
                    self._broadcast_regime_change(last_regime, regime)

        except Exception as e:
            print(f"âš ï¸ Ø®Ø·Ø§ Ø¯Ø± Ø¢Ù¾Ø¯ÛŒØª Ø±Ú˜ÛŒÙ… Ø¨Ø§Ø²Ø§Ø±: {e}")

    def get_market_simple_regime(self):
        """
        Ù†Ø³Ø®Ù‡ Ø³Ø§Ø¯Ù‡â€ŒØ´Ø¯Ù‡ Ø¨Ø±Ø§ÛŒ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø¯Ø± Ù„Ø§Ú¯â€ŒÙ‡Ø§
        """
        regime, confidence, details = self.analyze_market_regime(lookback_candles=30)

        emoji = "ğŸ“Š"
        if regime == "trending_up":
            emoji = "ğŸ“ˆ"
        elif regime == "trending_down":
            emoji = "ğŸ“‰"
        elif regime == "ranging":
            emoji = "â¡ï¸"
        elif regime == "volatile":
            emoji = "ğŸŒŠ"
        elif regime == "transitional":
            emoji = "ğŸ”„"

        return f"{emoji} {regime} ({confidence}%)"

    def process_new_candle(self, current_time, current_price):
        """
        Ù¾Ø±Ø¯Ø§Ø²Ø´ Ú©Ù†Ø¯Ù„ Ø¬Ø¯ÛŒØ¯ Ùˆ Ø°Ø®ÛŒØ±Ù‡ Ø¯Ø± Ø¯ÛŒØªØ§Ø¨ÛŒØ³

        ğŸ”¥ Ø¨Ø§ Ø³ÛŒØ³ØªÙ… Warm-up:
        - Ø±Ø¨Ø§Øª Ø¨Ø¹Ø¯ Ø§Ø² Ø§Ø¬Ø±Ø§ Ø¨Ø§ÛŒØ¯ Ú†Ù†Ø¯ Ú©Ù†Ø¯Ù„ real-time Ø¨Ø¨ÛŒÙ†Ø¯
        - Ù‚Ø¨Ù„ Ø§Ø² Ø§ØªÙ…Ø§Ù… warm-up Ø³ÛŒÚ¯Ù†Ø§Ù„ ÙˆØ±ÙˆØ¯ ØµØ§Ø¯Ø± Ù†Ù…ÛŒâ€ŒØ´ÙˆØ¯
        - Ù…Ø¯ÛŒØ±ÛŒØª Ù…Ø¹Ø§Ù…Ù„Ø§Øª Ø¨Ø§Ø² Ù‡Ù…ÛŒØ´Ù‡ ÙØ¹Ø§Ù„ Ø§Ø³Øª
        """

        print(f"\nğŸ“Š Ù¾Ø±Ø¯Ø§Ø²Ø´ Ú©Ù†Ø¯Ù„: {current_time} - Ù‚ÛŒÙ…Øª: {current_price:.2f}")

        self.LAST_KNOWN_PRICE = current_price
        current_time_floor = pd.Timestamp(current_time).floor(self.M2_TIMEFRAME)

        is_new_candle = False
        previous_candle_to_save = None  # Ú©Ù†Ø¯Ù„ Ù‚Ø¨Ù„ÛŒ Ú©Ù‡ Ø¨Ø§ÛŒØ¯ Ø°Ø®ÛŒØ±Ù‡ Ø´ÙˆØ¯

        if len(self.m3) % self.REGIME_SETTINGS['update_interval'] == 0:
            self._update_market_regime()

        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # ğŸ“Š Ø¨Ø®Ø´ 1: Ø¢Ù¾Ø¯ÛŒØª Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ú©Ù†Ø¯Ù„
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        if len(self.m3) == 0:
            # Ø§ÙˆÙ„ÛŒÙ† Ú©Ù†Ø¯Ù„
            new_row = pd.DataFrame([{
                'open': current_price,
                'high': current_price,
                'low': current_price,
                'close': current_price
            }], index=[current_time_floor])
            self.m3 = new_row
            is_new_candle = True

        else:
            last_index = self.m3.index[-1]

            if current_time_floor > last_index:
                # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                # ğŸ’¾ Ú©Ù†Ø¯Ù„ Ù‚Ø¨Ù„ÛŒ ØªÙ…Ø§Ù… Ø´Ø¯ - Ø°Ø®ÛŒØ±Ù‡ Ø¯Ø± Ø¯ÛŒØªØ§Ø¨ÛŒØ³
                # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                previous_candle_to_save = {
                    'datetime': last_index.isoformat(),
                    'open': self.m3.loc[last_index, 'open'],
                    'high': self.m3.loc[last_index, 'high'],
                    'low': self.m3.loc[last_index, 'low'],
                    'close': self.m3.loc[last_index, 'close']
                }

                # Ø§ÛŒØ¬Ø§Ø¯ Ú©Ù†Ø¯Ù„ Ø¬Ø¯ÛŒØ¯
                new_row = pd.DataFrame([{
                    'open': current_price,
                    'high': current_price,
                    'low': current_price,
                    'close': current_price
                }], index=[current_time_floor])

                self.m3 = pd.concat([self.m3, new_row])

                # Ø­Ø°Ù Ú©Ù†Ø¯Ù„â€ŒÙ‡Ø§ÛŒ Ù‚Ø¯ÛŒÙ…ÛŒ Ø¨Ø±Ø§ÛŒ ØµØ±ÙÙ‡â€ŒØ¬ÙˆÛŒÛŒ Ø¯Ø± Ø­Ø§ÙØ¸Ù‡
                if len(self.m3) > 500:
                    self.m3 = self.m3.iloc[-500:]

                is_new_candle = True

                # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                # ğŸ”¥ Ø´Ù…Ø§Ø±Ø´ Ú©Ù†Ø¯Ù„â€ŒÙ‡Ø§ÛŒ real-time Ø¨Ø±Ø§ÛŒ warm-up
                # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                if self.WARMUP_ENABLED and not self.warmup_complete:
                    self.warmup_candles_seen += 1
                    remaining = self.WARMUP_CANDLES - self.warmup_candles_seen
                    if remaining > 0:
                        print(f"ğŸ”¥ Warm-up: Ú©Ù†Ø¯Ù„ {self.warmup_candles_seen}/{self.WARMUP_CANDLES} - {remaining} Ú©Ù†Ø¯Ù„ Ø¯ÛŒÚ¯Ø± Ù…Ø§Ù†Ø¯Ù‡")

            else:
                # Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ú©Ù†Ø¯Ù„ ÙØ¹Ù„ÛŒ (Ù‡Ù†ÙˆØ² Ø¨Ø³ØªÙ‡ Ù†Ø´Ø¯Ù‡)
                self.m3.loc[last_index, 'high'] = max(self.m3.loc[last_index, 'high'], current_price)
                self.m3.loc[last_index, 'low'] = min(self.m3.loc[last_index, 'low'], current_price)
                self.m3.loc[last_index, 'close'] = current_price

        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # ğŸ’¾ Ø¨Ø®Ø´ 2: Ø°Ø®ÛŒØ±Ù‡ Ú©Ù†Ø¯Ù„ ØªÙ…Ø§Ù… Ø´Ø¯Ù‡ Ø¯Ø± Ø¯ÛŒØªØ§Ø¨ÛŒØ³
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        if previous_candle_to_save:
            try:
                self.save_candle_to_db(
                    'candles_m5',
                    previous_candle_to_save['datetime'],
                    previous_candle_to_save['open'],
                    previous_candle_to_save['high'],
                    previous_candle_to_save['low'],
                    previous_candle_to_save['close']
                )
                print(f"ğŸ’¾ Ú©Ù†Ø¯Ù„ Ø°Ø®ÛŒØ±Ù‡ Ø´Ø¯: {previous_candle_to_save['datetime']}")
                print(f"   O={previous_candle_to_save['open']:.0f} H={previous_candle_to_save['high']:.0f} L={previous_candle_to_save['low']:.0f} C={previous_candle_to_save['close']:.0f}")

                # Ø¨Ø±Ø±Ø³ÛŒ Ùˆ Ø°Ø®ÛŒØ±Ù‡ Ú©Ù†Ø¯Ù„ Ø±ÙˆØ²Ø§Ù†Ù‡
                self.check_and_save_daily_candle(pd.Timestamp(previous_candle_to_save['datetime']))

            except Exception as e:
                print(f"âš ï¸ Ø®Ø·Ø§ Ø¯Ø± Ø°Ø®ÛŒØ±Ù‡ Ú©Ù†Ø¯Ù„: {e}")

        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # ğŸ“ˆ Ø¨Ø®Ø´ 3: Ø¢Ù¾Ø¯ÛŒØª Ø§Ù†Ø¯ÛŒÚ©Ø§ØªÙˆØ±Ù‡Ø§
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        if is_new_candle and len(self.m3) >= 21:
            self.update_m5_indicators()

        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # ğŸ”´ Ø¨Ø®Ø´ 4: Ù…Ø¯ÛŒØ±ÛŒØª Ù…Ø¹Ø§Ù…Ù„Ù‡ Ø¨Ø§Ø² (Ù‡Ù…ÛŒØ´Ù‡ Ø§Ø¬Ø±Ø§ Ù…ÛŒâ€ŒØ´ÙˆØ¯)
        # âš ï¸ Ø§ÛŒÙ† Ø¨Ø®Ø´ Ù…Ø³ØªÙ‚Ù„ Ø§Ø² warm-up Ø§Ø³Øª!
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        if self.in_trade:
            self.check_trade_management(current_price)
            self.check_time_based_exit()
            return  # Ø§Ú¯Ø± Ù…Ø¹Ø§Ù…Ù„Ù‡ Ø¨Ø§Ø² Ø¯Ø§Ø±ÛŒÙ…ØŒ Ø¯Ù†Ø¨Ø§Ù„ Ø³ÛŒÚ¯Ù†Ø§Ù„ Ø¬Ø¯ÛŒØ¯ Ù†Ù…ÛŒâ€ŒÚ¯Ø±Ø¯ÛŒÙ…

        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # ğŸ”¥ Ø¨Ø®Ø´ 5: Ø¨Ø±Ø±Ø³ÛŒ ÙˆØ¶Ø¹ÛŒØª Warm-up
        # Ø§Ú¯Ø± Ù‡Ù†ÙˆØ² Ú¯Ø±Ù… Ù†Ø´Ø¯Ù‡ØŒ Ø§Ø² ÙˆØ±ÙˆØ¯ Ø¨Ù‡ Ù…Ø¹Ø§Ù…Ù„Ù‡ Ø¬Ù„ÙˆÚ¯ÛŒØ±ÛŒ Ú©Ù†
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        if not self.check_warmup_status():
            # Ù†Ù…Ø§ÛŒØ´ ÙˆØ¶Ø¹ÛŒØª warm-up
            if self.warmup_start_time:
                elapsed = (datetime.now() - self.warmup_start_time).total_seconds() / 60
                print(f"ğŸ”¥ Ø¯Ø± Ø­Ø§Ù„ Ú¯Ø±Ù… Ø´Ø¯Ù†... ({self.warmup_candles_seen}/{self.WARMUP_CANDLES} Ú©Ù†Ø¯Ù„ | {elapsed:.1f}/{self.WARMUP_MINUTES} Ø¯Ù‚ÛŒÙ‚Ù‡)")
            else:
                print(f"ğŸ”¥ Ù…Ù†ØªØ¸Ø± Ø´Ø±ÙˆØ¹ warm-up...")
            return  # Ø®Ø±ÙˆØ¬ - Ø³ÛŒÚ¯Ù†Ø§Ù„ Ø¨Ø±Ø±Ø³ÛŒ Ù†Ø´ÙˆØ¯

        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # â³ Ø¨Ø®Ø´ 6: Ø¨Ø±Ø±Ø³ÛŒ ÙØ§ØµÙ„Ù‡ Ø§Ø² Ù…Ø¹Ø§Ù…Ù„Ù‡ Ù‚Ø¨Ù„ÛŒ
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        if self.last_trade_exit_time:
            time_since_last = datetime.now() - self.last_trade_exit_time
            minutes_since = time_since_last.total_seconds() / 60
            required_minutes = self.MIN_CANDLES_BETWEEN_TRADES * self.REQUIRED_MINUTES

            if minutes_since < required_minutes:
                remaining = required_minutes - minutes_since
                print(f"â³ Ø²Ù…Ø§Ù† Ø§Ù†ØªØ¸Ø§Ø± Ø¨ÛŒÙ† Ù…Ø¹Ø§Ù…Ù„Ø§Øª: {remaining:.0f} Ø¯Ù‚ÛŒÙ‚Ù‡ Ù…Ø§Ù†Ø¯Ù‡")
                return

        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # ğŸ’° Ø¨Ø®Ø´ 7: Ø¨Ø±Ø±Ø³ÛŒ Ù…ÙˆØ¬ÙˆØ¯ÛŒ
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        if self.balance < self.portfolio:
            print(f"âš ï¸ Ù…ÙˆØ¬ÙˆØ¯ÛŒ Ú©Ø§ÙÛŒ Ù†ÛŒØ³Øª: {self.balance:,.0f} < {self.portfolio:,.0f}")
            return

        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # ğŸ“Š Ø¨Ø®Ø´ 8: Ø¨Ø±Ø±Ø³ÛŒ Ø¯Ø§Ø¯Ù‡ Ú©Ø§ÙÛŒ
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        if len(self.m3) < 21 or len(self.daily) < 55:
            print(f"âš ï¸ Ø¯Ø§Ø¯Ù‡ Ú©Ø§ÙÛŒ Ù†ÛŒØ³Øª: M5={len(self.m3)}, Daily={len(self.daily)}")
            return

        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # ğŸ•¯ï¸ Ø¨Ø®Ø´ 9: ÙÙ‚Ø· Ø¯Ø± Ú©Ù†Ø¯Ù„ Ø¬Ø¯ÛŒØ¯ Ø³ÛŒÚ¯Ù†Ø§Ù„ Ø¨Ø±Ø±Ø³ÛŒ Ø´ÙˆØ¯
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        if not is_new_candle:
            return

        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # ğŸ¯ Ø¨Ø®Ø´ 10: Ø¨Ø±Ø±Ø³ÛŒ Ø³ÛŒÚ¯Ù†Ø§Ù„ ÙˆØ±ÙˆØ¯ Ùˆ Ø§Ø¬Ø±Ø§
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        signal = self.check_entry_signal(current_price)

        if signal:
            print(f"\nğŸ¯ Ø³ÛŒÚ¯Ù†Ø§Ù„ {signal.upper()} Ø´Ù†Ø§Ø³Ø§ÛŒÛŒ Ø´Ø¯!")
            self.execute_entry(signal, current_price)
        else:
            print(f"âšª Ø³ÛŒÚ¯Ù†Ø§Ù„ ÙˆØ±ÙˆØ¯ÛŒ ÛŒØ§ÙØª Ù†Ø´Ø¯")

    def check_and_save_daily_candle(self, candle_time):
        """
        Ø¨Ø±Ø±Ø³ÛŒ Ùˆ Ø°Ø®ÛŒØ±Ù‡ Ú©Ù†Ø¯Ù„ Ø±ÙˆØ²Ø§Ù†Ù‡
        ÙˆÙ‚ØªÛŒ Ø±ÙˆØ² Ø¹ÙˆØ¶ Ù…ÛŒâ€ŒØ´ÙˆØ¯ØŒ Ú©Ù†Ø¯Ù„ Ø±ÙˆØ²Ø§Ù†Ù‡ Ù‚Ø¨Ù„ÛŒ Ø±Ø§ Ø°Ø®ÛŒØ±Ù‡ Ù…ÛŒâ€ŒÚ©Ù†Ø¯
        """
        try:
            current_date = candle_time.floor('D')

            # Ø§Ú¯Ø± daily Ø®Ø§Ù„ÛŒ Ø§Ø³ØªØŒ Ø¨Ø±Ú¯Ø±Ø¯
            if len(self.daily) == 0:
                return

            last_daily_index = self.daily.index[-1]
            last_daily_date = last_daily_index.floor('D')

            # Ø§Ú¯Ø± Ø±ÙˆØ² Ø¹ÙˆØ¶ Ø´Ø¯Ù‡
            if current_date > last_daily_date:
                # Ø°Ø®ÛŒØ±Ù‡ Ú©Ù†Ø¯Ù„ Ø±ÙˆØ²Ø§Ù†Ù‡ Ù‚Ø¨Ù„ÛŒ
                self.save_candle_to_db(
                    'candles',
                    last_daily_index.isoformat(),
                    self.daily.loc[last_daily_index, 'open'],
                    self.daily.loc[last_daily_index, 'high'],
                    self.daily.loc[last_daily_index, 'low'],
                    self.daily.loc[last_daily_index, 'close']
                )
                print(f"ğŸ’¾ Ú©Ù†Ø¯Ù„ Ø±ÙˆØ²Ø§Ù†Ù‡ Ø°Ø®ÛŒØ±Ù‡ Ø´Ø¯: {last_daily_date.date()}")

        except Exception as e:
            print(f"âš ï¸ Ø®Ø·Ø§ Ø¯Ø± Ø°Ø®ÛŒØ±Ù‡ Ú©Ù†Ø¯Ù„ Ø±ÙˆØ²Ø§Ù†Ù‡: {e}")

    def _adjust_for_range_market(self):
        """ØªÙ†Ø¸ÛŒÙ… Ù¾Ø§Ø±Ø§Ù…ØªØ±Ù‡Ø§ Ø¨Ø±Ø§ÛŒ Ø¨Ø§Ø²Ø§Ø± Ø±Ù†Ø¬"""
        # Ú©Ø§Ù‡Ø´ Ø¢Ø³ØªØ§Ù†Ù‡ ADX
        self.SCALP_ADX_THRESHOLD = max(12, self.SCALP_ADX_THRESHOLD - 3)
        self.SWING_ADX_THRESHOLD = max(18, self.SWING_ADX_THRESHOLD - 4)

        # Ú©Ø§Ù‡Ø´ Ø­Ø¯ Ø¶Ø±Ø±
        self.SCALP_STOP_LOSS_LINES = max(3, self.SCALP_STOP_LOSS_LINES - 2)
        self.SWING_STOP_LOSS_LINES = max(5, self.SWING_STOP_LOSS_LINES - 3)

        print(f"   âš™ï¸ ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø¨Ø±Ø§ÛŒ Ø¨Ø§Ø²Ø§Ø± Ø±Ù†Ø¬: ADX={self.SCALP_ADX_THRESHOLD}, SL={self.SCALP_STOP_LOSS_LINES}")

    def _adjust_for_trend_market(self):
        """ØªÙ†Ø¸ÛŒÙ… Ù¾Ø§Ø±Ø§Ù…ØªØ±Ù‡Ø§ Ø¨Ø±Ø§ÛŒ Ø¨Ø§Ø²Ø§Ø± Ø±ÙˆÙ†Ø¯Ø¯Ø§Ø±"""
        # Ø§ÙØ²Ø§ÛŒØ´ Ø¢Ø³ØªØ§Ù†Ù‡ ADX
        self.SCALP_ADX_THRESHOLD = min(25, self.SCALP_ADX_THRESHOLD + 2)
        self.SWING_ADX_THRESHOLD = min(30, self.SWING_ADX_THRESHOLD + 3)

        # Ø§ÙØ²Ø§ÛŒØ´ Ø­Ø¯ Ø³ÙˆØ¯
        self.SCALP_RR_RATIO = min(2.5, self.SCALP_RR_RATIO + 0.3)
        self.SWING_RR_RATIO = min(3.0, self.SWING_RR_RATIO + 0.5)

        print(f"   âš™ï¸ ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø¨Ø±Ø§ÛŒ Ø¨Ø§Ø²Ø§Ø± Ø±ÙˆÙ†Ø¯Ø¯Ø§Ø±: ADX={self.SCALP_ADX_THRESHOLD}, RR={self.SCALP_RR_RATIO}")

    def check_entry_signal(self, current_price):
        try:
            # ğŸ” Ø¨Ø±Ø±Ø³ÛŒ Ø±Ú˜ÛŒÙ… Ø¨Ø§Ø²Ø§Ø±
            if self.regime_confidence > self.REGIME_SETTINGS['min_confidence']:
                print(f"\nğŸ“Š Ø±Ú˜ÛŒÙ… Ø¨Ø§Ø²Ø§Ø± ÙØ¹Ø§Ù„: {self.market_regime} (Ø§Ø·Ù…ÛŒÙ†Ø§Ù†: {self.regime_confidence}%)")

                # Ø¹Ø¯Ù… ÙˆØ±ÙˆØ¯ Ø¯Ø± Ø¨Ø§Ø²Ø§Ø± Ù¾Ø±Ù†ÙˆØ³Ø§Ù†
                if self.market_regime == "volatile":
                    print("ğŸš« Ø¨Ø§Ø²Ø§Ø± Ù¾Ø±Ù†ÙˆØ³Ø§Ù† - Ù…Ø¹Ø§Ù…Ù„Ù‡ Ù†Ù…ÛŒâ€ŒÚ©Ù†ÛŒÙ…")
                    return None

                # ØªÙ†Ø¸ÛŒÙ… Ù¾Ø§Ø±Ø§Ù…ØªØ±Ù‡Ø§ Ø¨Ø± Ø§Ø³Ø§Ø³ Ø±Ú˜ÛŒÙ…
                if self.market_regime == "ranging":
                    # Ú©Ø§Ù‡Ø´ Ø¢Ø³ØªØ§Ù†Ù‡ ADX Ø¨Ø±Ø§ÛŒ Ø±Ù†Ø¬
                    self._adjust_for_range_market()
                elif self.market_regime in ["trending_up", "trending_down"]:
                    # Ø§ÙØ²Ø§ÛŒØ´ Ø¢Ø³ØªØ§Ù†Ù‡ ADX Ø¨Ø±Ø§ÛŒ Ø±ÙˆÙ†Ø¯
                    self._adjust_for_trend_market()

            strategy = self.determine_strategy_mode()

            current_adx = 25
            if 'adx' in self.m3.columns and not self.m3['adx'].empty:
                adx_val = self.m3['adx'].iloc[-1]
                if pd.notna(adx_val):
                    current_adx = adx_val

            current_rsi = 50
            if 'rsi14' in self.m3.columns and not self.m3['rsi14'].empty:
                rsi_val = self.m3['rsi14'].iloc[-1]
                if pd.notna(rsi_val):
                    current_rsi = rsi_val

            ema9 = current_price
            if 'ema9' in self.m3.columns and not self.m3['ema9'].empty:
                ema9_val = self.m3['ema9'].iloc[-1]
                if pd.notna(ema9_val):
                    ema9 = ema9_val

            ema21 = current_price
            if 'ema21' in self.m3.columns and not self.m3['ema21'].empty:
                ema21_val = self.m3['ema21'].iloc[-1]
                if pd.notna(ema21_val):
                    ema21 = ema21_val

            daily_trend_score = self.calculate_daily_trend_score()

            print(f"\n{'â•' * 50}")
            print(f"ğŸ” Ø¨Ø±Ø±Ø³ÛŒ Ø³ÛŒÚ¯Ù†Ø§Ù„ ÙˆØ±ÙˆØ¯ - Ø§Ø³ØªØ±Ø§ØªÚ˜ÛŒ: {strategy.upper()}")
            print(f"{'â•' * 50}")
            print(f"   ğŸ“Š M5 - ADX: {current_adx:.1f} | RSI: {current_rsi:.1f}")
            print(f"   ğŸ“ˆ M5 - EMA9: {ema9:.2f} | EMA21: {ema21:.2f}")
            print(f"   ğŸ¯ Ø§Ù…ØªÛŒØ§Ø² Ø±ÙˆÙ†Ø¯ Ø±ÙˆØ²Ø§Ù†Ù‡: {daily_trend_score:+d}")
            print(f"   ğŸ”„ Ù…Ø¹Ø§Ù…Ù„Ø§Øª Ø®Ù„Ø§Ù Ø±ÙˆÙ†Ø¯: {'ÙØ¹Ø§Ù„' if self.ENABLE_COUNTER_TREND else 'ØºÛŒØ±ÙØ¹Ø§Ù„'}")

            if strategy == 'scalp':
                adx_threshold = self.SCALP_ADX_THRESHOLD
                min_daily_score_long = 20
                min_daily_score_short = -20
            else:
                adx_threshold = self.SWING_ADX_THRESHOLD
                min_daily_score_long = 40
                min_daily_score_short = -40

            long_conditions = {
                'ema_cross': ema9 > ema21,
                'rsi_ok': current_rsi > 40 if strategy == 'scalp' else current_rsi > 45,
                'adx_ok': current_adx > adx_threshold,
                'daily_ok': daily_trend_score >= min_daily_score_long
            }

            short_conditions = {
                'ema_cross': ema9 < ema21,
                'rsi_ok': current_rsi < 60 if strategy == 'scalp' else current_rsi < 55,
                'adx_ok': current_adx > adx_threshold,
                'daily_ok': daily_trend_score <= min_daily_score_short
            }

            print(f"\n   ğŸ“ˆ Ø´Ø±Ø§ÛŒØ· LONG {strategy.upper()}:")
            print(f"      EMA9>EMA21: {'âœ…' if long_conditions['ema_cross'] else 'âŒ'}")
            print(f"      RSI: {'âœ…' if long_conditions['rsi_ok'] else 'âŒ'} ({current_rsi:.1f})")
            print(f"      ADX>{adx_threshold}: {'âœ…' if long_conditions['adx_ok'] else 'âŒ'} ({current_adx:.1f})")
            print(f"      Ø±ÙˆÙ†Ø¯ Ø±ÙˆØ²Ø§Ù†Ù‡>={min_daily_score_long}: {'âœ…' if long_conditions['daily_ok'] else 'âŒ'} ({daily_trend_score:+d})")

            if all(long_conditions.values()):
                print(f"\n   âœ… Ø³ÛŒÚ¯Ù†Ø§Ù„ LONG {strategy.upper()} ØªØ§ÛŒÛŒØ¯ Ø´Ø¯!")

                # Ø§Ø¹Ù…Ø§Ù„ ÙÛŒÙ„ØªØ± Ù‡ÙˆØ´Ù…Ù†Ø¯
                if hasattr(self, 'smart_filter') and self.smart_filter:
                    # â­ï¸ ØªØºÛŒÛŒØ± Û±: Ù…Ù‚Ø¯Ø§Ø± ATR Ù…Ø·Ù„Ù‚ Ø±Ø§ Ø§Ø² Ù†ØªÛŒØ¬Ù‡ ØªØ­Ù„ÛŒÙ„ Ø±Ú˜ÛŒÙ… Ø¨Ø§Ø²Ø§Ø± Ù…ÛŒâ€ŒØ®ÙˆØ§Ù†ÛŒÙ…
                    atr_absolute_regime = self.last_regime_details.get('atr_absolute', 0)

                    signal_data = {
                        'direction': 'long',
                        'strategy': strategy,
                        'current_price': current_price,
                        'adx_entry': current_adx,
                        'rsi_entry': current_rsi,
                        # â­ï¸ ØªØºÛŒÛŒØ± Û²: Ú©Ù„ÛŒØ¯ Ø¬Ø¯ÛŒØ¯ 'atr_absolute_regime' Ø±Ø§ Ø¨Ù‡ Ø¯ÛŒÚ©Ø´Ù†Ø±ÛŒ Ø§Ø¶Ø§ÙÙ‡ Ù…ÛŒâ€ŒÚ©Ù†ÛŒÙ…
                        'atr_absolute_regime': atr_absolute_regime,
                        'ema9_entry': ema9,
                        'ema21_entry': ema21,
                        'daily_trend_score': daily_trend_score
                        # â­ï¸ ØªØºÛŒÛŒØ± Û³: 'atr_entry' Ø¯ÛŒÚ¯Ø± Ù„Ø§Ø²Ù… Ù†ÛŒØ³Øª Ú†ÙˆÙ† ÙÛŒÙ„ØªØ± Ø§Ø² Ø§ÙˆÙ† Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù†Ù…ÛŒâ€ŒÚ©Ù†Ù‡
                    }

                    allowed, reason = self.smart_filter.should_enter_trade(signal_data)
                    if not allowed:
                        print(f"ğŸš« ÙÛŒÙ„ØªØ± Ù‡ÙˆØ´Ù…Ù†Ø¯: {reason}")
                        return None

                return 'long'

            print(f"\n   ğŸ“‰ Ø´Ø±Ø§ÛŒØ· SHORT {strategy.upper()}:")
            print(f"      EMA9<EMA21: {'âœ…' if short_conditions['ema_cross'] else 'âŒ'}")
            print(f"      RSI: {'âœ…' if short_conditions['rsi_ok'] else 'âŒ'} ({current_rsi:.1f})")
            print(f"      ADX>{adx_threshold}: {'âœ…' if short_conditions['adx_ok'] else 'âŒ'} ({current_adx:.1f})")
            print(f"      Ø±ÙˆÙ†Ø¯ Ø±ÙˆØ²Ø§Ù†Ù‡<={min_daily_score_short}: {'âœ…' if short_conditions['daily_ok'] else 'âŒ'} ({daily_trend_score:+d})")

            if all(short_conditions.values()):
                print(f"\n   âœ… Ø³ÛŒÚ¯Ù†Ø§Ù„ SHORT {strategy.upper()} ØªØ§ÛŒÛŒØ¯ Ø´Ø¯!")

                # Ø§Ø¹Ù…Ø§Ù„ ÙÛŒÙ„ØªØ± Ù‡ÙˆØ´Ù…Ù†Ø¯
                if hasattr(self, 'smart_filter') and self.smart_filter:
                    # â­ï¸ ØªØºÛŒÛŒØ± Û± (Ø¨Ø±Ø§ÛŒ Short)
                    atr_absolute_regime = self.last_regime_details.get('atr_absolute', 0)

                    signal_data = {
                        'direction': 'short',
                        'strategy': strategy,
                        'current_price': current_price,
                        'adx_entry': current_adx,
                        'rsi_entry': current_rsi,
                        # â­ï¸ ØªØºÛŒÛŒØ± Û² (Ø¨Ø±Ø§ÛŒ Short)
                        'atr_absolute_regime': atr_absolute_regime,
                        'ema9_entry': ema9,
                        'ema21_entry': ema21,
                        'daily_trend_score': daily_trend_score
                    }

                    allowed, reason = self.smart_filter.should_enter_trade(signal_data)
                    if not allowed:
                        print(f"ğŸš« ÙÛŒÙ„ØªØ± Ù‡ÙˆØ´Ù…Ù†Ø¯: {reason}")
                        return None

                return 'short'

            if self.ENABLE_COUNTER_TREND:
                print(f"\n   ğŸ”„ Ø¨Ø±Ø±Ø³ÛŒ Ø³ÛŒÚ¯Ù†Ø§Ù„ Ø®Ù„Ø§Ù Ø±ÙˆÙ†Ø¯...")

                # 1. SHORT Ø®Ù„Ø§Ù Ø±ÙˆÙ†Ø¯ (ÙØ±ÙˆØ´ Ø¯Ø± Ø³Ù‚Ù Ø±ÙˆÙ†Ø¯ ØµØ¹ÙˆØ¯ÛŒ/Ø±Ù†Ø¬)
                # ØªØºÛŒÛŒØ±: Ù…Ø­Ø¯ÙˆØ¯Ù‡ Ø¨Ø§Ø²ØªØ± Ø´Ø¯ (10 ØªØ§ 70) ØªØ§ Ø±Ù†Ø¬ Ù‡Ù… Ù¾ÙˆØ´Ø´ Ø¯Ø§Ø¯Ù‡ Ø¨Ø´Ù‡
                if 10 <= daily_trend_score <= 70:
                    # Ø´Ø±Ø§ÛŒØ· Ù¾ÙˆÙ„Ø¨Ú©: Ù‚ÛŒÙ…Øª Ø²Ø¯Ù‡ Ø¨Ø§Ù„Ø§ Ùˆ Ø¯Ø§Ø±Ù‡ Ø¨Ø±Ù…ÛŒÚ¯Ø±Ø¯Ù‡
                    counter_short_conditions = {
                        'adx_ok': current_adx > 20,  # Ø­Ø±Ú©Øª Ú©Ø§ÙÛŒ
                        'rsi_overbought': current_rsi > 65,  # Ø§Ø´Ø¨Ø§Ø¹ Ø®Ø±ÛŒØ¯
                        'rsi_not_extreme': current_rsi < 80,  # Ù†Ù‡ Ø®ÛŒÙ„ÛŒ Ø´Ø¯ÛŒØ¯
                        'price_near_ema': abs(current_price - ema21) / ema21 < 0.002,  # âœ… Ø¬Ø¯ÛŒØ¯: Ù‚ÛŒÙ…Øª Ú†Ø³Ø¨ÛŒØ¯Ù‡ Ø¨Ù‡ EMA21
                        'ema_slope_down': ema9 < ema21  # Ø´ÛŒØ¨ Ù…Ù†ÙÛŒ (ØªØ§ÛŒÛŒØ¯ÛŒÙ‡ Ø¬Ù‡Øª)
                    }

                    print(f"\n   ğŸ“‰ Ø´Ø±Ø§ÛŒØ· SHORT Ø®Ù„Ø§Ù Ø±ÙˆÙ†Ø¯:")
                    print(f"      ADX>20: {'âœ…' if counter_short_conditions['adx_ok'] else 'âŒ'} ({current_adx:.1f})")
                    print(f"      RSI>65: {'âœ…' if counter_short_conditions['rsi_overbought'] else 'âŒ'} ({current_rsi:.1f})")
                    print(f"      RSI<80: {'âœ…' if counter_short_conditions['rsi_not_extreme'] else 'âŒ'} ({current_rsi:.1f})")
                    print(f"      Ù†Ø²Ø¯ÛŒÚ©ÛŒ Ø¨Ù‡ EMA21 (<0.2%): {'âœ…' if counter_short_conditions['price_near_ema'] else 'âŒ'}")
                    print(f"      Ø´ÛŒØ¨ EMA Ù…Ù†ÙÛŒ: {'âœ…' if counter_short_conditions['ema_slope_down'] else 'âŒ'}")

                    counter_short_valid = all(counter_short_conditions.values())

                    if counter_short_valid:
                        print(f"\n   âœ… Ø³ÛŒÚ¯Ù†Ø§Ù„ SHORT Ø®Ù„Ø§Ù Ø±ÙˆÙ†Ø¯ (Ù¾ÙˆÙ„Ø¨Ú©) ØªØ§ÛŒÛŒØ¯ Ø´Ø¯!")

                        # Ø§Ø¹Ù…Ø§Ù„ ÙÛŒÙ„ØªØ± Ù‡ÙˆØ´Ù…Ù†Ø¯
                        if hasattr(self, 'smart_filter') and self.smart_filter:
                            atr_absolute_regime = self.last_regime_details.get('atr_absolute', 0)
                            signal_data = {
                                'direction': 'short',
                                'strategy': 'counter_trend_pullback',
                                'current_price': current_price,
                                'adx_entry': current_adx,
                                'rsi_entry': current_rsi,
                                'atr_absolute_regime': atr_absolute_regime,
                                'ema9_entry': ema9,
                                'ema21_entry': ema21,
                                'daily_trend_score': daily_trend_score
                            }

                            allowed, reason = self.smart_filter.should_enter_trade(signal_data)
                            if not allowed:
                                print(f"ğŸš« ÙÛŒÙ„ØªØ± Ù‡ÙˆØ´Ù…Ù†Ø¯: {reason}")
                                return None

                        return 'short'
                    else:
                        print(f"   âš ï¸ Ø´Ø±Ø§ÛŒØ· SHORT Ø®Ù„Ø§Ù Ø±ÙˆÙ†Ø¯ Ú©Ø§Ù…Ù„ Ù†ÛŒØ³Øª")

                # 2. LONG Ø®Ù„Ø§Ù Ø±ÙˆÙ†Ø¯ (Ø®Ø±ÛŒØ¯ Ø¯Ø± Ú©Ù Ø±ÙˆÙ†Ø¯ Ù†Ø²ÙˆÙ„ÛŒ/Ø±Ù†Ø¬)
                elif -70 <= daily_trend_score <= -10:
                    counter_long_conditions = {
                        'adx_ok': current_adx > 20,  # Ø­Ø±Ú©Øª Ú©Ø§ÙÛŒ
                        'rsi_oversold': current_rsi < 35,  # Ø§Ø´Ø¨Ø§Ø¹ ÙØ±ÙˆØ´
                        'rsi_not_extreme': current_rsi > 20,  # Ù†Ù‡ Ø®ÛŒÙ„ÛŒ Ø´Ø¯ÛŒØ¯
                        'price_near_ema': abs(current_price - ema21) / ema21 < 0.002,  # âœ… Ø¬Ø¯ÛŒØ¯: Ù‚ÛŒÙ…Øª Ú†Ø³Ø¨ÛŒØ¯Ù‡ Ø¨Ù‡ EMA21
                        'ema_slope_up': ema9 > ema21  # Ø´ÛŒØ¨ Ù…Ø«Ø¨Øª (ØªØ§ÛŒÛŒØ¯ÛŒÙ‡ Ø¬Ù‡Øª)
                    }

                    print(f"\n   ğŸ“ˆ Ø´Ø±Ø§ÛŒØ· LONG Ø®Ù„Ø§Ù Ø±ÙˆÙ†Ø¯:")
                    print(f"      ADX>20: {'âœ…' if counter_long_conditions['adx_ok'] else 'âŒ'} ({current_adx:.1f})")
                    print(f"      RSI<35: {'âœ…' if counter_long_conditions['rsi_oversold'] else 'âŒ'} ({current_rsi:.1f})")
                    print(f"      RSI>20: {'âœ…' if counter_long_conditions['rsi_not_extreme'] else 'âŒ'} ({current_rsi:.1f})")
                    print(f"      Ù†Ø²Ø¯ÛŒÚ©ÛŒ Ø¨Ù‡ EMA21 (<0.2%): {'âœ…' if counter_long_conditions['price_near_ema'] else 'âŒ'}")
                    print(f"      Ø´ÛŒØ¨ EMA Ù…Ø«Ø¨Øª: {'âœ…' if counter_long_conditions['ema_slope_up'] else 'âŒ'}")

                    counter_long_valid = all(counter_long_conditions.values())

                    if counter_long_valid:
                        print(f"\n   âœ… Ø³ÛŒÚ¯Ù†Ø§Ù„ LONG Ø®Ù„Ø§Ù Ø±ÙˆÙ†Ø¯ (Ù¾ÙˆÙ„Ø¨Ú©) ØªØ§ÛŒÛŒØ¯ Ø´Ø¯!")

                        # Ø§Ø¹Ù…Ø§Ù„ ÙÛŒÙ„ØªØ± Ù‡ÙˆØ´Ù…Ù†Ø¯
                        if hasattr(self, 'smart_filter') and self.smart_filter:
                            atr_absolute_regime = self.last_regime_details.get('atr_absolute', 0)
                            signal_data = {
                                'direction': 'long',
                                'strategy': 'counter_trend_pullback',
                                'current_price': current_price,
                                'adx_entry': current_adx,
                                'rsi_entry': current_rsi,
                                'atr_absolute_regime': atr_absolute_regime,
                                'ema9_entry': ema9,
                                'ema21_entry': ema21,
                                'daily_trend_score': daily_trend_score
                            }

                            allowed, reason = self.smart_filter.should_enter_trade(signal_data)
                            if not allowed:
                                print(f"ğŸš« ÙÛŒÙ„ØªØ± Ù‡ÙˆØ´Ù…Ù†Ø¯: {reason}")
                                return None

                        return 'long'
                    else:
                        print(f"   âš ï¸ Ø´Ø±Ø§ÛŒØ· LONG Ø®Ù„Ø§Ù Ø±ÙˆÙ†Ø¯ Ú©Ø§Ù…Ù„ Ù†ÛŒØ³Øª")

                else:
                    # Ù¾ÛŒØ§Ù…â€ŒÙ‡Ø§ÛŒ Ø¯ÛŒØ¨Ø§Ú¯ Ø¨Ø±Ø§ÛŒ Ø­Ø§Ù„Øªâ€ŒÙ‡Ø§ÛŒÛŒ Ú©Ù‡ Ø³ÛŒÚ¯Ù†Ø§Ù„ ØµØ§Ø¯Ø± Ù†Ù…ÛŒØ´Ù‡
                    if daily_trend_score > 70:
                        print(f"   âš ï¸ Ø±ÙˆÙ†Ø¯ Ø±ÙˆØ²Ø§Ù†Ù‡ Ø¨Ø³ÛŒØ§Ø± Ù‚ÙˆÛŒ ØµØ¹ÙˆØ¯ÛŒ ({daily_trend_score:+d}) - Ù…Ø¹Ø§Ù…Ù„Ø§Øª Ø®Ù„Ø§Ù Ø±ÙˆÙ†Ø¯ Ù…Ù…Ù†ÙˆØ¹")
                    elif daily_trend_score < -70:
                        print(f"   âš ï¸ Ø±ÙˆÙ†Ø¯ Ø±ÙˆØ²Ø§Ù†Ù‡ Ø¨Ø³ÛŒØ§Ø± Ù‚ÙˆÛŒ Ù†Ø²ÙˆÙ„ÛŒ ({daily_trend_score:+d}) - Ù…Ø¹Ø§Ù…Ù„Ø§Øª Ø®Ù„Ø§Ù Ø±ÙˆÙ†Ø¯ Ù…Ù…Ù†ÙˆØ¹")
                    elif abs(daily_trend_score) < 10:
                        print(f"   âš ï¸ Ø±ÙˆÙ†Ø¯ Ø±ÙˆØ²Ø§Ù†Ù‡ Ø®ÛŒÙ„ÛŒ Ø¶Ø¹ÛŒÙ/Ø±Ù†Ø¬ Ø®Ø§Ù„Øµ ({daily_trend_score:+d}) - Ù…Ø¹Ø§Ù…Ù„Ø§Øª Ø®Ù„Ø§Ù Ø±ÙˆÙ†Ø¯ Ù†ÛŒØ§Ø² Ø¨Ù‡ Ø±ÙˆÙ†Ø¯ ÙˆØ§Ø¶Ø­â€ŒØªØ±")
                    else:
                        print(f"   âš ï¸ Ø±ÙˆÙ†Ø¯ Ø±ÙˆØ²Ø§Ù†Ù‡ Ø®Ø§Ø±Ø¬ Ø§Ø² Ù…Ø­Ø¯ÙˆØ¯Ù‡ Ù…Ø¹Ø§Ù…Ù„Ø§Øª Ø®Ù„Ø§Ù Ø±ÙˆÙ†Ø¯ ({daily_trend_score:+d})")

            print(f"\n   âšª Ù‡ÛŒÚ† Ø³ÛŒÚ¯Ù†Ø§Ù„ ÙˆØ§Ø¶Ø­ÛŒ ÛŒØ§ÙØª Ù†Ø´Ø¯")
            print(f"{'â•' * 50}")
            return None

        except Exception as e:
            print(f"âš ï¸ Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø±Ø±Ø³ÛŒ Ø³ÛŒÚ¯Ù†Ø§Ù„ ÙˆØ±ÙˆØ¯: {e}")
            import traceback
            traceback.print_exc()
            return None

    def execute_entry(self, direction, current_price):
        try:
            print(f"\n{'â•' * 60}")
            print(f"ğŸ¯ Ø´Ø±ÙˆØ¹ ÙØ±Ø¢ÛŒÙ†Ø¯ ÙˆØ±ÙˆØ¯ Ø¨Ù‡ Ù…Ø¹Ø§Ù…Ù„Ù‡ {direction.upper()}")
            print(f"{'â•' * 60}")

            current_price = int(current_price)

            if self.in_trade:
                if self.trade_direction != direction:
                    print(f"\nâš ï¸ Ù…Ø¹Ø§Ù…Ù„Ù‡ {self.trade_direction.upper()} Ø¨Ø§Ø² Ø§Ø³Øª Ùˆ Ø³ÛŒÚ¯Ù†Ø§Ù„ Ù…Ø®Ø§Ù„Ù ({direction.upper()}) Ø¯Ø±ÛŒØ§ÙØª Ø´Ø¯!")
                    print(f"ğŸ”„ Ø¨Ø³ØªÙ† Ù…Ø¹Ø§Ù…Ù„Ù‡ Ù‚Ø¨Ù„ÛŒ...")

                    self.exit_trade(current_price, f"Ø³ÛŒÚ¯Ù†Ø§Ù„ Ù…Ø®Ø§Ù„Ù - ØªØºÛŒÛŒØ± Ø¨Ù‡ {direction.upper()}")

                    import time
                    time.sleep(0.1)

                else:
                    print(f"\nâš ï¸ Ù…Ø¹Ø§Ù…Ù„Ù‡ {direction.upper()} Ù‚Ø¨Ù„Ø§Ù‹ Ø¨Ø§Ø² Ø§Ø³Øª - Ø§Ø² ÙˆØ±ÙˆØ¯ Ù…Ø¬Ø¯Ø¯ ØµØ±Ù Ù†Ø¸Ø± Ø´Ø¯")
                    return False

            self.current_trade_strategy = self.determine_strategy_mode()
            strategy = self.current_trade_strategy

            if strategy == 'scalp':
                settings = {
                    'name': 'Ø§Ø³Ú©Ø§Ù„Ù¾',
                    'name_en': 'SCALP',
                    'rr_ratio': self.SCALP_RR_RATIO,
                    'min_profit_lines': self.SCALP_MIN_PROFIT_LINES,
                    'max_time': f"{self.SCALP_MAX_TRADE_MINUTES} Ø¯Ù‚ÛŒÙ‚Ù‡",
                    'risk_percent': self.SCALP_RISK_PERCENTAGE * 100,
                    'stop_loss_lines': self.SCALP_STOP_LOSS_LINES,
                }
            else:
                settings = {
                    'name': 'Ø³ÙˆØ¦ÛŒÙ†Ú¯',
                    'name_en': 'SWING',
                    'rr_ratio': self.SWING_RR_RATIO,
                    'min_profit_lines': self.SWING_MIN_PROFIT_LINES,
                    'max_time': f"{self.SWING_MAX_TRADE_HOURS} Ø³Ø§Ø¹Øª",
                    'risk_percent': self.SWING_RISK_PERCENTAGE * 100,
                    'stop_loss_lines': self.SWING_STOP_LOSS_LINES,
                }

            print(f"\nğŸ“Š Ø§Ø³ØªØ±Ø§ØªÚ˜ÛŒ: {settings['name']} ({settings['name_en']})")
            print(f"   ğŸ¯ Ù†Ø³Ø¨Øª RR: 1:{settings['rr_ratio']}")
            print(f"   ğŸ’° Ø­Ø¯Ø§Ù‚Ù„ Ø³ÙˆØ¯ Ù‡Ø¯Ù: {settings['min_profit_lines']} Ø®Ø·")
            print(f"   ğŸ›¡ï¸ Ø­Ø¯ Ø¶Ø±Ø± Ù¾ÛŒØ´â€ŒÙØ±Ø¶: {settings['stop_loss_lines']} Ø®Ø·")
            print(f"   â±ï¸ Ø­Ø¯Ø§Ú©Ø«Ø± Ø²Ù…Ø§Ù†: {settings['max_time']}")
            print(f"   ğŸ“Š Ø±ÛŒØ³Ú©: {settings['risk_percent']:.1f}%")

            self.entry_price = current_price

            stop_distance_lines = self.calculate_dynamic_stop_loss(current_price, direction)

            if direction == 'long':
                self.stop_loss_price = current_price - stop_distance_lines
            else:
                self.stop_loss_price = current_price + stop_distance_lines

            if stop_distance_lines < 1:
                print(f"\nâŒ Ø®Ø·Ø§: ÙØ§ØµÙ„Ù‡ Ø­Ø¯ Ø¶Ø±Ø± Ø®ÛŒÙ„ÛŒ Ú©Ù… Ø§Ø³Øª!")
                print(f"   ÙØ§ØµÙ„Ù‡: {stop_distance_lines} Ø®Ø· (Ø­Ø¯Ø§Ù‚Ù„: 1 Ø®Ø·)")
                self.reset_trade_variables()
                return False

            take_profit_distance_lines = int(stop_distance_lines * settings['rr_ratio'])

            if direction == 'long':
                self.take_profit_price = current_price + take_profit_distance_lines
            elif direction == 'short':
                self.take_profit_price = current_price - take_profit_distance_lines
            else:
                print(f"âŒ Ø¬Ù‡Øª Ù…Ø¹Ø§Ù…Ù„Ù‡ Ù†Ø§Ù…Ø¹ØªØ¨Ø±: {direction}")
                self.reset_trade_variables()
                return False

            if take_profit_distance_lines < settings['min_profit_lines']:
                if strategy == 'scalp' and take_profit_distance_lines >= 3:
                    print(f"\nâš ï¸ Ø³ÙˆØ¯ Ú©Ù…ØªØ± Ø§Ø² Ù‡Ø¯Ù Ø§Ù…Ø§ Ø¨Ø±Ø§ÛŒ Ø§Ø³Ú©Ø§Ù„Ù¾ Ù‚Ø§Ø¨Ù„ Ù‚Ø¨ÙˆÙ„")
                    print(f"   Ø³ÙˆØ¯: {take_profit_distance_lines} Ø®Ø· (Ù‡Ø¯Ù: {settings['min_profit_lines']})")
                else:
                    print(f"\nâŒ Ø³ÙˆØ¯ Ø¨Ø§Ù„Ù‚ÙˆÙ‡ Ù†Ø§Ú©Ø§ÙÛŒ!")
                    print(f"   Ø³ÙˆØ¯ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø´Ø¯Ù‡: {take_profit_distance_lines} Ø®Ø·")
                    print(f"   Ø­Ø¯Ø§Ù‚Ù„ Ù…ÙˆØ±Ø¯ Ù†ÛŒØ§Ø²: {settings['min_profit_lines']} Ø®Ø·")
                    self.reset_trade_variables()
                    return False

            risk_amount = stop_distance_lines * self.LINE_VALUE_TOMAN
            risk_percent = (risk_amount / self.PORTFOLIO_SIZE) * 100

            max_allowed_risk = settings['risk_percent'] * 1.5
            if risk_percent > max_allowed_risk:
                print(f"\nâŒ Ø±ÛŒØ³Ú© ÙˆØ§Ù‚Ø¹ÛŒ Ø¨ÛŒØ´ Ø§Ø² Ø­Ø¯ Ù…Ø¬Ø§Ø²!")
                print(f"   Ø±ÛŒØ³Ú©: {risk_percent:.1f}% (Ø­Ø¯Ø§Ú©Ø«Ø±: {max_allowed_risk:.1f}%)")
                self.reset_trade_variables()
                return False

            self.current_internal_trade_id = f"{direction}_{int(datetime.now().timestamp())}"

            # Ø«Ø¨Øª ÙˆØ±ÙˆØ¯ Ø¯Ø± Ú˜ÙˆØ±Ù†Ø§Ù„
            if hasattr(self, 'journal') and self.journal:
                signal_data = self._prepare_signal_data(direction, strategy, current_price)
                signal_data.update({
                    'trade_id': self.current_internal_trade_id,
                    'entry_price': self.entry_price,
                    'stop_loss': self.stop_loss_price,
                    'take_profit': self.take_profit_price,
                    'symbol': 'MAZANEH'
                })
                self.journal.log_trade_entry(signal_data)

            self.send_enter_trade_command(
                direction=direction,
                entry_price=self.entry_price,
                stop_loss=self.stop_loss_price,
                take_profit=self.take_profit_price
            )

            self.in_trade = True
            self.trade_direction = direction
            self.trade_start_time = datetime.now()

            self.highest_price_in_trade = current_price
            self.lowest_price_in_trade = current_price

            print(f"ğŸ“Š Ù…Ù‚Ø¯Ø§Ø±Ø¯Ù‡ÛŒ Ø§ÙˆÙ„ÛŒÙ‡: highest={self.highest_price_in_trade}, lowest={self.lowest_price_in_trade}")

            self.open_trades.append({
                'trade_id': self.current_internal_trade_id,
                'direction': direction,
                'entry_price': self.entry_price,
                'stop_loss': self.stop_loss_price,
                'take_profit': self.take_profit_price,
                'entry_time': self.trade_start_time,
                'strategy': strategy
            })

            if direction == 'long':
                trade_emoji = "ğŸŸ¢"
                trade_type = "Ø®Ø±ÛŒØ¯ (LONG)"
            else:
                trade_emoji = "ğŸ”´"
                trade_type = "ÙØ±ÙˆØ´ (SHORT)"

            potential_profit_toman = take_profit_distance_lines * self.LINE_VALUE_TOMAN

            print(f"\n{'â•' * 60}")
            print(f"{trade_emoji} ÙˆØ±ÙˆØ¯ Ù…ÙˆÙÙ‚ Ø¨Ù‡ Ù…Ø¹Ø§Ù…Ù„Ù‡ {trade_type}")
            print(f"{'â•' * 60}")
            print(f"\nğŸ“Š Ø¬Ø²Ø¦ÛŒØ§Øª Ù…Ø¹Ø§Ù…Ù„Ù‡:")
            print(f"   ğŸ†” Ø´Ù†Ø§Ø³Ù‡: {self.current_internal_trade_id}")
            print(f"   ğŸ¯ Ø§Ø³ØªØ±Ø§ØªÚ˜ÛŒ: {settings['name']} ({settings['name_en']})")
            print(f"   ğŸ“ˆ Ù‚ÛŒÙ…Øª ÙˆØ±ÙˆØ¯: {self.entry_price}")
            print(f"   ğŸ›¡ï¸ Ø­Ø¯ Ø¶Ø±Ø±: {int(self.stop_loss_price)} ({stop_distance_lines} Ø®Ø·)")
            print(f"   ğŸ¯ Ø­Ø¯ Ø³ÙˆØ¯: {int(self.take_profit_price)} ({take_profit_distance_lines} Ø®Ø·)")
            print(f"   âš–ï¸ Ù†Ø³Ø¨Øª RR: 1:{settings['rr_ratio']}")

            print(f"\nğŸ’° Ù…Ø­Ø§Ø³Ø¨Ø§Øª Ù…Ø§Ù„ÛŒ:")
            print(f"   ğŸ’¸ Ø±ÛŒØ³Ú©: {risk_amount:,.0f} ØªÙˆÙ…Ø§Ù† ({risk_percent:.1f}%)")
            print(f"   ğŸ’° Ø³ÙˆØ¯ Ø¨Ø§Ù„Ù‚ÙˆÙ‡: {potential_profit_toman:,.0f} ØªÙˆÙ…Ø§Ù†")
            print(f"   ğŸ“Š Ø§Ø±Ø²Ø´ Ù‡Ø± Ø®Ø·: {self.LINE_VALUE_TOMAN:,.0f} ØªÙˆÙ…Ø§Ù†")

            print(f"\nâ±ï¸ Ø²Ù…Ø§Ù†â€ŒØ¨Ù†Ø¯ÛŒ:")
            print(f"   ğŸ• Ø´Ø±ÙˆØ¹: {self.trade_start_time.strftime('%Y-%m-%d %H:%M:%S')}")
            print(f"   â³ Ø­Ø¯Ø§Ú©Ø«Ø± Ø²Ù…Ø§Ù†: {settings['max_time']}")

            print(f"{'â•' * 60}")

            return True

        except Exception as e:
            print(f"\nâŒ Ø®Ø·Ø§ Ø¯Ø± ÙˆØ±ÙˆØ¯ Ø¨Ù‡ Ù…Ø¹Ø§Ù…Ù„Ù‡: {e}")
            import traceback
            traceback.print_exc()
            self.reset_trade_variables()
            return False

    def reset_trade_variables(self):
        self.in_trade = False
        self.trade_direction = None
        self.entry_price = 0
        self.stop_loss_price = 0
        self.take_profit_price = 0
        self.current_trade_strategy = None
        self.trade_start_time = None
        self.highest_price_in_trade = 0
        self.lowest_price_in_trade = float('inf')
        self.current_internal_trade_id = None

        # âœ… Ø§Ø¶Ø§ÙÙ‡ Ø´Ø¯: Ù¾Ø§Ú© Ú©Ø±Ø¯Ù† Ù„ÛŒØ³Øª Ù…Ø¹Ø§Ù…Ù„Ø§Øª Ø¨Ø§Ø²
        if hasattr(self, 'open_trades') and self.open_trades:
            self.open_trades.clear()

    def on_market_message(self, ws, message):
        """Ù¾Ø±Ø¯Ø§Ø²Ø´ Ù¾ÛŒØ§Ù…â€ŒÙ‡Ø§ÛŒ Ø¯Ø±ÛŒØ§ÙØªÛŒ Ø§Ø² WebSocket Ù‚ÛŒÙ…Øª"""
        try:
            data = json.loads(message)

            if "price" in data:
                self.MARKET_PRICE = float(data["price"])
                self.LAST_KNOWN_PRICE = self.MARKET_PRICE
                current_time = pd.Timestamp.now()

                # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                # ğŸ”¥ Ø´Ø±ÙˆØ¹ warm-up Ø¨Ø§ Ø§ÙˆÙ„ÛŒÙ† Ù‚ÛŒÙ…Øª real-time
                # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                if self.WARMUP_ENABLED and self.warmup_start_time is None:
                    self.start_warmup()
                    self.first_realtime_candle_time = current_time

                # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                # ğŸ“¤ Ø§Ø±Ø³Ø§Ù„ Ù‚ÛŒÙ…Øª Ù„Ø­Ø¸Ù‡â€ŒØ§ÛŒ Ø¨Ù‡ Ú©Ù„Ø§ÛŒÙ†Øªâ€ŒÙ‡Ø§
                # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                if not hasattr(self, '_last_price_send_time'):
                    self._last_price_send_time = datetime.now()

                time_since_last_send = (datetime.now() - self._last_price_send_time).total_seconds()
                PRICE_SEND_INTERVAL = 1

                if time_since_last_send >= PRICE_SEND_INTERVAL:
                    self.send_realtime_price(self.MARKET_PRICE)
                    self._last_price_send_time = datetime.now()

                # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                # ğŸ“Š Ù¾Ø±Ø¯Ø§Ø²Ø´ Ú©Ù†Ø¯Ù„
                # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                if self.LAST_CANDLE_TIME is None:
                    self.LAST_CANDLE_TIME = current_time.floor(self.M2_TIMEFRAME)
                    print(f"\nğŸ“Š Ø§ÙˆÙ„ÛŒÙ† Ú©Ù†Ø¯Ù„: {self.LAST_CANDLE_TIME}")
                    print(f"ğŸ’° Ù‚ÛŒÙ…Øª: {self.MARKET_PRICE}")
                    self.process_new_candle(self.LAST_CANDLE_TIME, self.MARKET_PRICE)
                else:
                    current_candle_time = current_time.floor(self.M2_TIMEFRAME)

                    if current_candle_time > self.LAST_CANDLE_TIME:
                        self.LAST_CANDLE_TIME = current_candle_time
                        print(f"\nğŸ“Š Ú©Ù†Ø¯Ù„ Ø¬Ø¯ÛŒØ¯ Ø´Ø±ÙˆØ¹ Ø´Ø¯: {self.LAST_CANDLE_TIME}")
                        print(f"ğŸ’° Ù‚ÛŒÙ…Øª: {self.MARKET_PRICE}")
                        self.process_new_candle(self.LAST_CANDLE_TIME, self.MARKET_PRICE)
                    else:
                        # Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ú©Ù†Ø¯Ù„ ÙØ¹Ù„ÛŒ Ùˆ Ù…Ø¯ÛŒØ±ÛŒØª Ù…Ø¹Ø§Ù…Ù„Ù‡
                        if self.in_trade and self.MARKET_PRICE:
                            self.check_trade_management(self.MARKET_PRICE)

        except json.JSONDecodeError as e:
            print(f"âš ï¸ Ø®Ø·Ø§ Ø¯Ø± Ù¾Ø§Ø±Ø³ JSON: {e}")
        except Exception as e:
            print(f"âš ï¸ Ø®Ø·Ø§ Ø¯Ø± Ù¾Ø±Ø¯Ø§Ø²Ø´ Ù¾ÛŒØ§Ù…: {e}")
            import traceback
            traceback.print_exc()

    def on_market_open(self, ws):
        self.CONNECTION_STATUS = "connected"
        print("âœ… Ø§ØªØµØ§Ù„ Ø¨Ù‡ WebSocket Ù‚ÛŒÙ…Øª Ø²Ù†Ø¯Ù‡ MAZANEH Ø¨Ø±Ù‚Ø±Ø§Ø± Ø´Ø¯.")

    def on_market_close(self, ws, close_status_code, close_msg):
        self.CONNECTION_STATUS = "disconnected"
        print(f"âŒ Ø§ØªØµØ§Ù„ WebSocket Ø¨Ø³ØªÙ‡ Ø´Ø¯. Ú©Ø¯: {close_status_code}, Ù¾ÛŒØ§Ù…: {close_msg}")

    def on_market_error(self, ws, error):
        print(f"âš ï¸ Ø®Ø·Ø§ÛŒ WebSocket: {error}")

    def connect_to_price_socket(self):
        """
        Ø§ØªØµØ§Ù„ Ø¨Ù‡ WebSocket Ù‚ÛŒÙ…Øª Ø¨Ø§ Ø§Ø±Ø³Ø§Ù„ Ú©ÙˆÚ©ÛŒâ€ŒÙ‡Ø§ÛŒ Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª
        """

        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # ğŸª Ø³Ø§Ø®Øª Ø±Ø´ØªÙ‡ Ú©ÙˆÚ©ÛŒ Ø¨Ø±Ø§ÛŒ Ø§Ø±Ø³Ø§Ù„ Ø¯Ø± Ù‡Ø¯Ø±
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        cookie_string = "; ".join([f"{key}={value}" for key, value in self.COOKIES.items()])

        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # ğŸ“‹ ØªÙ†Ø¸ÛŒÙ… Ù‡Ø¯Ø±Ù‡Ø§ Ø¨Ù‡ ØµÙˆØ±Øª Ù„ÛŒØ³Øª (ÙØ±Ù…Øª ØµØ­ÛŒØ­ Ø¨Ø±Ø§ÛŒ websocket-client)
        # âš ï¸ Ù†Ú©ØªÙ‡: Origin Ø±Ø§ Ø­Ø°Ù Ú©Ø±Ø¯ÛŒÙ… Ú†ÙˆÙ† Ú©ØªØ§Ø¨Ø®Ø§Ù†Ù‡ Ø®ÙˆØ¯Ø´ Ø§Ø¶Ø§ÙÙ‡ Ù…ÛŒâ€ŒÚ©Ù†Ø¯
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        headers = [
            f"Cookie: {cookie_string}",
            "User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"
        ]

        print(f"ğŸ”— Ø§ØªØµØ§Ù„ Ø¨Ù‡ WebSocket: {self.MARKET_WSS_URL}")

        ws = websocket.WebSocketApp(
            self.MARKET_WSS_URL,
            on_message=self.on_market_message,
            on_open=self.on_market_open,
            on_close=self.on_market_close,
            on_error=self.on_market_error,
            header=headers  # Ù‡Ø¯Ø±Ù‡Ø§ Ø¨Ù‡ ØµÙˆØ±Øª Ù„ÛŒØ³Øª
        )

        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # ğŸ”Œ Ø§ØªØµØ§Ù„ Ø¨Ø§ ØªÙ†Ø¸ÛŒÙ… origin ØµØ­ÛŒØ­
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        ws.run_forever(
            ping_interval=30,
            ping_timeout=10,
            reconnect=5,
            origin="https://hivagold.com"  # Origin Ø±Ø§ Ø§ÛŒÙ†Ø¬Ø§ ØªÙ†Ø¸ÛŒÙ… Ù…ÛŒâ€ŒÚ©Ù†ÛŒÙ…
        )

    def wait_for_connection(self, timeout=60):
        start_time = time.time()
        elapsed = 0

        print(f"â³ Ù…Ù†ØªØ¸Ø± Ø§ØªØµØ§Ù„... (ØªØ§ {timeout} Ø«Ø§Ù†ÛŒÙ‡)")

        while self.CONNECTION_STATUS != "connected":
            elapsed = time.time() - start_time

            if elapsed > timeout:
                print(f"âŒ Ø²Ù…Ø§Ù† Ø§Ù†ØªØ¸Ø§Ø± Ø¨Ø±Ø§ÛŒ Ø§ØªØµØ§Ù„ Ø¨Ù‡ Ù¾Ø§ÛŒØ§Ù† Ø±Ø³ÛŒØ¯ ({timeout} Ø«Ø§Ù†ÛŒÙ‡)")
                return False

            if int(elapsed) % 10 == 0 and int(elapsed) > 0:
                print(f"â³ Ø¯Ø± Ø§Ù†ØªØ¸Ø§Ø± Ø§ØªØµØ§Ù„... ({int(elapsed)}/{timeout} Ø«Ø§Ù†ÛŒÙ‡)")

            time.sleep(1)

        print(f"âœ… Ø§ØªØµØ§Ù„ Ù¾Ø³ Ø§Ø² {elapsed:.1f} Ø«Ø§Ù†ÛŒÙ‡ Ø¨Ø±Ù‚Ø±Ø§Ø± Ø´Ø¯")
        return True

    def show_status(self):
        """
        Ù†Ù…Ø§ÛŒØ´ ÙˆØ¶Ø¹ÛŒØª ÙØ¹Ù„ÛŒ Ø±Ø¨Ø§Øª

        ğŸ”„ ØªØºÛŒÛŒØ±Ø§Øª:
        - Ù†Ù…Ø§ÛŒØ´ ØªØ¹Ø¯Ø§Ø¯ Ú©Ù„Ø§ÛŒÙ†Øªâ€ŒÙ‡Ø§ÛŒ Ù…ØªØµÙ„ Ø¨Ù‡ WebSocket Server Ø¯Ø§Ø®Ù„ÛŒ
        - ØªØºÛŒÛŒØ± Ø§Ø² ØªÛŒÚ© Ø¨Ù‡ Ø®Ø·
        """

        portfolio_pnl = self.balance - self.TOTAL_BALANCE
        portfolio_percent = 0
        if self.PORTFOLIO_SIZE > 0:
            portfolio_percent = (portfolio_pnl / self.PORTFOLIO_SIZE) * 100

        print("\n" + "=" * 70)
        print("ğŸ“Š ÙˆØ¶Ø¹ÛŒØª Ø±Ø¨Ø§Øª Ù…Ø¹Ø§Ù…Ù„Ù‡â€ŒÚ¯Ø± Ù…Ø¸Ù†Ù‡")
        print("=" * 70)

        if self.CONNECTION_STATUS == 'connected':
            print(f"ğŸ”— Ø§ØªØµØ§Ù„ Ø¨Ù‡ Ø³Ø±ÙˆØ± Ù‚ÛŒÙ…Øª: âœ… Ù…ØªØµÙ„")
        else:
            print(f"ğŸ”— Ø§ØªØµØ§Ù„ Ø¨Ù‡ Ø³Ø±ÙˆØ± Ù‚ÛŒÙ…Øª: âŒ Ù‚Ø·Ø¹")

        if self.COMMAND_SERVER_STATUS == 'running':
            client_count = self.get_connected_clients_count()
            print(f"ğŸ“¡ WebSocket Server: âœ… ÙØ¹Ø§Ù„ (Ù¾ÙˆØ±Øª {self.WS_SERVER_PORT})")
            print(f"ğŸ“± Ú©Ù„Ø§ÛŒÙ†Øªâ€ŒÙ‡Ø§ÛŒ Ù…ØªØµÙ„: {client_count}")
        else:
            print(f"ğŸ“¡ WebSocket Server: âŒ ØºÛŒØ±ÙØ¹Ø§Ù„")

        print(f"ğŸ’° Ú©Ù„ Ù…ÙˆØ¬ÙˆØ¯ÛŒ: {self.balance:,.0f} ØªÙˆÙ…Ø§Ù†")
        print(f"ğŸ’¼ Ø³Ø§ÛŒØ² Ù¾ÙˆØ±ØªÙÙˆ: {self.PORTFOLIO_SIZE:,.0f} ØªÙˆÙ…Ø§Ù†")
        print(f"ğŸ“ˆ Ø³ÙˆØ¯/Ø¶Ø±Ø± Ù¾ÙˆØ±ØªÙÙˆ: {portfolio_pnl:+,.0f} ØªÙˆÙ…Ø§Ù† ({portfolio_percent:+.1f}%)")
        print(f"ğŸ“Š ØªØºÛŒÛŒØ± Ø§Ø² Ø§Ø¨ØªØ¯Ø§: {(self.balance - self.TOTAL_BALANCE):+,.0f} ØªÙˆÙ…Ø§Ù†")
        print(f"ğŸ’µ Ø§Ø±Ø²Ø´ Ù‡Ø± Ø®Ø·: {self.LINE_VALUE_TOMAN:,.0f} ØªÙˆÙ…Ø§Ù†")

        print(f"ğŸ“Š Ø±Ú˜ÛŒÙ… Ø¨Ø§Ø²Ø§Ø±: {self.get_market_simple_regime()}")

        if self.market_regime == "ranging" and self.regime_confidence > 70:
            print("   ğŸ’¡ Ø¨Ø§Ø²Ø§Ø± Ø¯Ø± Ø±Ù†Ø¬ Ø¨Ø§ Ú©ÛŒÙÛŒØª - Ù…Ù†Ø§Ø³Ø¨ Ø§Ø³ØªØ±Ø§ØªÚ˜ÛŒ Ø±Ù†Ø¬")
        elif self.market_regime == "trending_up":
            print("   ğŸ’¡ Ø¨Ø§Ø²Ø§Ø± ØµØ¹ÙˆØ¯ÛŒ - Ù…Ù†Ø§Ø³Ø¨ Ø§Ø³ØªØ±Ø§ØªÚ˜ÛŒ Ø¯Ù†Ø¨Ø§Ù„â€ŒÚ©Ù†Ù†Ø¯Ù‡ Ø±ÙˆÙ†Ø¯")
        elif self.market_regime == "volatile":
            print("   âš ï¸ Ø¨Ø§Ø²Ø§Ø± Ù¾Ø±Ù†ÙˆØ³Ø§Ù† - Ø±ÛŒØ³Ú© Ø¨Ø§Ù„Ø§")

        if self.warmup_complete:
            print(f"ğŸ”¥ Warm-up: âœ… ØªÙ…Ø§Ù… Ø´Ø¯")
        else:
            if self.warmup_start_time:
                elapsed = (datetime.now() - self.warmup_start_time).total_seconds() / 60
                print(f"ğŸ”¥ Warm-up: Ø¯Ø± Ø­Ø§Ù„ Ú¯Ø±Ù… Ø´Ø¯Ù† ({self.warmup_candles_seen}/{self.WARMUP_CANDLES} Ú©Ù†Ø¯Ù„ | {elapsed:.1f}/{self.WARMUP_MINUTES} Ø¯Ù‚ÛŒÙ‚Ù‡)")
            else:
                print(f"ğŸ”¥ Warm-up: Ù…Ù†ØªØ¸Ø± Ø´Ø±ÙˆØ¹...")

        if self.trades > 0:
            win_rate = (self.winning_trades / self.trades) * 100
            avg_profit = 0
            if self.winning_trades > 0:
                avg_profit = self.total_profit / self.winning_trades
            avg_loss = 0
            if self.losing_trades > 0:
                avg_loss = self.total_loss / self.losing_trades
            profit_factor = float('inf')
            if self.total_loss > 0:
                profit_factor = self.total_profit / self.total_loss
            total_pnl = self.total_profit - self.total_loss

            print("-" * 70)
            print(f"ğŸ“Š ØªØ¹Ø¯Ø§Ø¯ Ù…Ø¹Ø§Ù…Ù„Ø§Øª: {self.trades}")
            print(f"âœ… Ù…Ø¹Ø§Ù…Ù„Ø§Øª Ø¨Ø±Ù†Ø¯Ù‡: {self.winning_trades}")
            print(f"âŒ Ù…Ø¹Ø§Ù…Ù„Ø§Øª Ø¨Ø§Ø²Ù†Ø¯Ù‡: {self.losing_trades}")
            print(f"ğŸ“ˆ Ù†Ø±Ø® Ø¨Ø±Ø¯: {win_rate:.1f}%")
            print(f"ğŸ’° Ù…ÛŒØ§Ù†Ú¯ÛŒÙ† Ø³ÙˆØ¯: {avg_profit:,.0f} ØªÙˆÙ…Ø§Ù†")
            print(f"ğŸ’¸ Ù…ÛŒØ§Ù†Ú¯ÛŒÙ† Ø¶Ø±Ø±: {avg_loss:,.0f} ØªÙˆÙ…Ø§Ù†")
            print(f"âš–ï¸ ÙØ§Ú©ØªÙˆØ± Ø³ÙˆØ¯: {profit_factor:.2f}")
            print(f"ğŸ“Š Ø³ÙˆØ¯ Ø®Ø§Ù„Øµ: {total_pnl:+,.0f} ØªÙˆÙ…Ø§Ù†")
            print(f"ğŸ“‰ Ø­Ø¯Ø§Ú©Ø«Ø± Ø§ÙØª Ø³Ø±Ù…Ø§ÛŒÙ‡: {self.max_drawdown:.2f}%")

        if self.in_trade and self.trade_direction:
            print("-" * 70)
            print(f"ğŸ”¥ Ù…Ø¹Ø§Ù…Ù„Ù‡ Ø¨Ø§Ø²: {self.trade_direction.upper()}")
            if self.current_trade_strategy:
                print(f"ğŸ¯ Ø§Ø³ØªØ±Ø§ØªÚ˜ÛŒ: {self.current_trade_strategy.upper()}")
            print(f"ğŸ“ˆ Ù‚ÛŒÙ…Øª ÙˆØ±ÙˆØ¯: {int(self.entry_price)}")

            current_display_price = "Ù†Ø§Ù…Ø´Ø®Øµ"
            if self.MARKET_PRICE:
                current_display_price = f"{int(self.MARKET_PRICE)}"
            elif self.LAST_KNOWN_PRICE:
                current_display_price = f"{int(self.LAST_KNOWN_PRICE)} (Ø¢Ø®Ø±ÛŒÙ†)"
            print(f"ğŸ“Š Ù‚ÛŒÙ…Øª ÙØ¹Ù„ÛŒ: {current_display_price}")

            print(f"ğŸ›¡ï¸ Ø­Ø¯ Ø¶Ø±Ø±: {int(self.stop_loss_price)}")
            print(f"ğŸ¯ Ø­Ø¯ Ø³ÙˆØ¯: {int(self.take_profit_price)}")

            if self.trade_direction == 'long':
                print(f"ğŸ“ˆ Ø¨Ø§Ù„Ø§ØªØ±ÛŒÙ† Ù‚ÛŒÙ…Øª: {int(self.highest_price_in_trade)}")
            else:
                lowest = self.lowest_price_in_trade if self.lowest_price_in_trade != float('inf') else 0
                print(f"ğŸ“‰ Ù¾Ø§ÛŒÛŒÙ†â€ŒØªØ±ÛŒÙ† Ù‚ÛŒÙ…Øª: {int(lowest)}")

            current_price_for_calc = self.MARKET_PRICE if self.MARKET_PRICE else self.LAST_KNOWN_PRICE
            if current_price_for_calc:
                current_price_for_calc = int(current_price_for_calc)
                entry_price = int(self.entry_price)

                if self.trade_direction == 'long':
                    unrealized_lines = current_price_for_calc - entry_price
                else:
                    unrealized_lines = entry_price - current_price_for_calc

                unrealized_pnl = unrealized_lines * self.LINE_VALUE_TOMAN
                pnl_percent = 0
                if self.portfolio > 0:
                    pnl_percent = (unrealized_pnl / self.portfolio) * 100

                print(f"ğŸ“Š Ø³ÙˆØ¯/Ø¶Ø±Ø± Ø´Ù†Ø§ÙˆØ±: {unrealized_pnl:+,.0f} ØªÙˆÙ…Ø§Ù† ({pnl_percent:+.1f}%) [{unrealized_lines:+} Ø®Ø·]")

                try:
                    take_profit = int(self.take_profit_price)
                    if self.trade_direction == 'long':
                        if take_profit > entry_price:
                            total_distance = take_profit - entry_price
                            current_progress = current_price_for_calc - entry_price
                            progress_percent = (current_progress / total_distance) * 100
                            progress_percent = max(0, min(100, progress_percent))
                            print(f"ğŸ“ˆ Ù¾ÛŒØ´Ø±ÙØª Ø¨Ù‡ Ø­Ø¯ Ø³ÙˆØ¯: {progress_percent:.1f}%")
                    else:
                        if take_profit < entry_price:
                            total_distance = entry_price - take_profit
                            current_progress = entry_price - current_price_for_calc
                            progress_percent = (current_progress / total_distance) * 100
                            progress_percent = max(0, min(100, progress_percent))
                            print(f"ğŸ“‰ Ù¾ÛŒØ´Ø±ÙØª Ø¨Ù‡ Ø­Ø¯ Ø³ÙˆØ¯: {progress_percent:.1f}%")
                except ZeroDivisionError:
                    pass

            if self.trade_start_time:
                duration = datetime.now() - self.trade_start_time
                hours = int(duration.seconds // 3600)
                minutes = int((duration.seconds % 3600) // 60)
                seconds = int(duration.seconds % 60)
                print(f"â±ï¸ Ù…Ø¯Øª Ù…Ø¹Ø§Ù…Ù„Ù‡: {hours:02d}:{minutes:02d}:{seconds:02d}")

                now = datetime.now()
                current_minute = now.minute
                next_candle_minute = ((current_minute // 5) + 1) * 5
                if next_candle_minute >= 60:
                    next_candle_time = now.replace(hour=now.hour + 1, minute=0, second=0, microsecond=0)
                else:
                    next_candle_time = now.replace(minute=next_candle_minute, second=0, microsecond=0)

                time_to_next = next_candle_time - now
                if time_to_next.total_seconds() > 0:
                    mins = int(time_to_next.total_seconds() // 60)
                    secs = int(time_to_next.total_seconds() % 60)
                    print(f"ğŸ•’ Ø²Ù…Ø§Ù† ØªØ§ Ú©Ù†Ø¯Ù„ Ø¨Ø¹Ø¯ÛŒ: {mins}:{secs:02d}")
        else:
            print("-" * 70)
            print("â³ Ø¯Ø± Ø­Ø§Ù„ Ø§Ù†ØªØ¸Ø§Ø± Ø¨Ø±Ø§ÛŒ Ø³ÛŒÚ¯Ù†Ø§Ù„ Ù…Ù†Ø§Ø³Ø¨...")

            if self.MARKET_PRICE:
                print(f"ğŸ“Š Ø¢Ø®Ø±ÛŒÙ† Ù‚ÛŒÙ…Øª: {int(self.MARKET_PRICE)}")
            elif self.LAST_KNOWN_PRICE:
                print(f"ğŸ“Š Ø¢Ø®Ø±ÛŒÙ† Ù‚ÛŒÙ…Øª Ø´Ù†Ø§Ø®ØªÙ‡ Ø´Ø¯Ù‡: {int(self.LAST_KNOWN_PRICE)}")
            else:
                print("ğŸ“Š Ø¢Ø®Ø±ÛŒÙ† Ù‚ÛŒÙ…Øª: Ø¯Ø± Ø§Ù†ØªØ¸Ø§Ø± Ø¯Ø§Ø¯Ù‡")

            try:
                if len(self.m3) >= 21:
                    if 'adx' in self.m3.columns and 'rsi14' in self.m3.columns:
                        adx_value = self.m3['adx'].iloc[-1]
                        rsi_value = self.m3['rsi14'].iloc[-1]
                        if pd.notna(adx_value) and pd.notna(rsi_value):
                            print(f"ğŸ“Š ADX: {adx_value:.1f} | RSI: {rsi_value:.1f}")

                    if 'ema9' in self.m3.columns and 'ema21' in self.m3.columns:
                        ema9_value = self.m3['ema9'].iloc[-1]
                        ema21_value = self.m3['ema21'].iloc[-1]
                        if pd.notna(ema9_value) and pd.notna(ema21_value):
                            print(f"ğŸ“ˆ EMA9: {ema9_value:.0f} | EMA21: {ema21_value:.0f}")
                            if ema9_value > ema21_value:
                                print("ğŸ¯ Ø³ÛŒÚ¯Ù†Ø§Ù„ EMA: ØµØ¹ÙˆØ¯ÛŒ (EMA9 > EMA21)")
                            else:
                                print("ğŸ¯ Ø³ÛŒÚ¯Ù†Ø§Ù„ EMA: Ù†Ø²ÙˆÙ„ÛŒ (EMA9 < EMA21)")
            except Exception as e:
                print(f"ğŸ“Š Ø§Ù†Ø¯ÛŒÚ©Ø§ØªÙˆØ±Ù‡Ø§: Ø¯Ø± Ø­Ø§Ù„ Ù…Ø­Ø§Ø³Ø¨Ù‡")

            if self.last_trade_exit_time:
                time_since_last = datetime.now() - self.last_trade_exit_time
                minutes_since = time_since_last.total_seconds() / 60
                required_minutes = self.MIN_CANDLES_BETWEEN_TRADES * self.REQUIRED_MINUTES
                remaining = required_minutes - minutes_since
                if remaining > 0:
                    print(f"â³ Ø²Ù…Ø§Ù† Ø§Ù†ØªØ¸Ø§Ø± Ø¨ÛŒÙ† Ù…Ø¹Ø§Ù…Ù„Ø§Øª: {remaining:.0f} Ø¯Ù‚ÛŒÙ‚Ù‡ Ø¨Ø§Ù‚ÛŒâ€ŒÙ…Ø§Ù†Ø¯Ù‡")

        print("=" * 70)

    def save_state(self):
        """
        Ø°Ø®ÛŒØ±Ù‡ ÙˆØ¶Ø¹ÛŒØª Ø±Ø¨Ø§Øª Ø¯Ø± ÙØ§ÛŒÙ„

        ğŸ”„ ØªØºÛŒÛŒØ±: Ø­Ø°Ù position_sizeØŒ Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† pnl_lines
        """

        try:
            trade_start_time_str = None
            if self.trade_start_time:
                trade_start_time_str = self.trade_start_time.isoformat()

            last_trade_exit_time_str = None
            if self.last_trade_exit_time:
                last_trade_exit_time_str = self.last_trade_exit_time.isoformat()

            last_candle_time_str = None
            if self.LAST_CANDLE_TIME is not None:
                if isinstance(self.LAST_CANDLE_TIME, pd.Timestamp):
                    last_candle_time_str = self.LAST_CANDLE_TIME.isoformat()

            # ØªØ¨Ø¯ÛŒÙ„ ØªØ§Ø±ÛŒØ®Ú†Ù‡ Ù…Ø¹Ø§Ù…Ù„Ø§Øª
            serializable_trade_history = []
            for trade in self.trade_history[-20:]:
                trade_copy = trade.copy()
                if 'entry_time' in trade_copy and trade_copy['entry_time'] is not None:
                    if isinstance(trade_copy['entry_time'], datetime):
                        trade_copy['entry_time'] = trade_copy['entry_time'].isoformat()
                if 'exit_time' in trade_copy and trade_copy['exit_time'] is not None:
                    if isinstance(trade_copy['exit_time'], datetime):
                        trade_copy['exit_time'] = trade_copy['exit_time'].isoformat()
                serializable_trade_history.append(trade_copy)

            state = {
                'timestamp': datetime.now().isoformat(),
                'balance': self.balance,
                'portfolio': self.portfolio,
                'warmup_complete': self.warmup_complete,
                'warmup_candles_seen': self.warmup_candles_seen,
                'ws_server_port': self.WS_SERVER_PORT,
                'trades': self.trades,
                'winning_trades': self.winning_trades,
                'losing_trades': self.losing_trades,
                'total_profit': self.total_profit,
                'total_loss': self.total_loss,
                'max_drawdown': self.max_drawdown,
                'peak_balance': self.peak_balance,
                'in_trade': self.in_trade,
                'trade_direction': self.trade_direction,
                'current_trade_strategy': self.current_trade_strategy,
                'entry_price': int(self.entry_price) if self.entry_price else 0,
                'stop_loss_price': int(self.stop_loss_price) if self.stop_loss_price else 0,
                'take_profit_price': int(self.take_profit_price) if self.take_profit_price else 0,
                'trade_start_time': trade_start_time_str,
                'last_trade_exit_time': last_trade_exit_time_str,
                'trade_history': serializable_trade_history,
                'market_price': int(self.MARKET_PRICE) if self.MARKET_PRICE else None,
                'last_known_price': int(self.LAST_KNOWN_PRICE) if self.LAST_KNOWN_PRICE else None,
                'last_candle_time': last_candle_time_str,
                'connection_status': self.CONNECTION_STATUS,
                'm5_data_length': len(self.m3),
                'daily_data_length': len(self.daily),
                'highest_price_in_trade': int(self.highest_price_in_trade) if self.highest_price_in_trade else 0,
                'lowest_price_in_trade': int(self.lowest_price_in_trade) if self.lowest_price_in_trade != float('inf') else 0,
                'line_value_toman': self.LINE_VALUE_TOMAN
            }

            # with open('bot_state.json', 'w', encoding='utf-8') as f:
            #     json.dump(state, f, indent=4, default=str, ensure_ascii=False)
            #
            # print(f"ğŸ’¾ ÙˆØ¶Ø¹ÛŒØª Ø±Ø¨Ø§Øª Ø°Ø®ÛŒØ±Ù‡ Ø´Ø¯ (Ù…Ø¹Ø§Ù…Ù„Ø§Øª: {self.trades}, Ù…ÙˆØ¬ÙˆØ¯ÛŒ: {self.balance:,.0f} ØªÙˆÙ…Ø§Ù†)")
            return True

        except Exception as e:
            print(f"âš ï¸ Ø®Ø·Ø§ Ø¯Ø± Ø°Ø®ÛŒØ±Ù‡ ÙˆØ¶Ø¹ÛŒØª: {e}")
            import traceback
            traceback.print_exc()
            return False

    def load_state(self):
        """
        Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ ÙˆØ¶Ø¹ÛŒØª Ø±Ø¨Ø§Øª Ø§Ø² ÙØ§ÛŒÙ„

        ğŸ”„ ØªØºÛŒÛŒØ±: Ø­Ø°Ù position_size
        """

        try:
            with open('bot_state.json', 'r', encoding='utf-8') as f:
                state = json.load(f)

            print(f"ğŸ“‚ Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ ÙˆØ¶Ø¹ÛŒØª Ø§Ø² {state.get('timestamp', 'Ù†Ø§Ù…Ø´Ø®Øµ')}")

            # Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ù…ÙˆØ¬ÙˆØ¯ÛŒ
            loaded_balance = state.get('balance', self.TOTAL_BALANCE)
            if loaded_balance < 0 or loaded_balance > self.TOTAL_BALANCE * 10:
                print(f"âš ï¸ Ù…ÙˆØ¬ÙˆØ¯ÛŒ Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ø´Ø¯Ù‡ ØºÛŒØ±Ù…Ù†Ø·Ù‚ÛŒ: {loaded_balance:,.0f} ØªÙˆÙ…Ø§Ù†")
                print(f"   Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ù…ÙˆØ¬ÙˆØ¯ÛŒ Ø§ÙˆÙ„ÛŒÙ‡: {self.TOTAL_BALANCE:,.0f} ØªÙˆÙ…Ø§Ù†")
                self.balance = self.TOTAL_BALANCE
            else:
                self.balance = loaded_balance

            self.warmup_complete = state.get('warmup_complete', False)
            self.warmup_candles_seen = state.get('warmup_candles_seen', 0)
            self.portfolio = state.get('portfolio', self.PORTFOLIO_SIZE)
            self.trades = state.get('trades', 0)
            self.winning_trades = state.get('winning_trades', 0)
            self.losing_trades = state.get('losing_trades', 0)
            self.total_profit = state.get('total_profit', 0)
            self.total_loss = state.get('total_loss', 0)
            self.max_drawdown = state.get('max_drawdown', 0)
            self.peak_balance = state.get('peak_balance', self.TOTAL_BALANCE)

            self.in_trade = state.get('in_trade', False)
            self.trade_direction = state.get('trade_direction')
            self.current_trade_strategy = state.get('current_trade_strategy')
            self.entry_price = state.get('entry_price', 0)
            self.stop_loss_price = state.get('stop_loss_price', 0)
            self.take_profit_price = state.get('take_profit_price', 0)

            self.highest_price_in_trade = state.get('highest_price_in_trade', 0)
            loaded_lowest = state.get('lowest_price_in_trade', 0)
            if loaded_lowest == 0:
                self.lowest_price_in_trade = float('inf')
            else:
                self.lowest_price_in_trade = loaded_lowest

            # Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ø²Ù…Ø§Ù†â€ŒÙ‡Ø§
            trade_start_time_str = state.get('trade_start_time')
            if trade_start_time_str:
                self.trade_start_time = datetime.fromisoformat(trade_start_time_str)
            else:
                self.trade_start_time = None

            last_trade_exit_time_str = state.get('last_trade_exit_time')
            if last_trade_exit_time_str:
                self.last_trade_exit_time = datetime.fromisoformat(last_trade_exit_time_str)
            else:
                self.last_trade_exit_time = None

            # Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ ØªØ§Ø±ÛŒØ®Ú†Ù‡
            self.trade_history = state.get('trade_history', [])
            for trade in self.trade_history:
                if isinstance(trade.get('entry_time'), str):
                    trade['entry_time'] = datetime.fromisoformat(trade['entry_time'])
                if isinstance(trade.get('exit_time'), str):
                    trade['exit_time'] = datetime.fromisoformat(trade['exit_time'])

            self.MARKET_PRICE = state.get('market_price')
            self.LAST_KNOWN_PRICE = state.get('last_known_price')

            last_candle_time_str = state.get('last_candle_time')
            if last_candle_time_str:
                self.LAST_CANDLE_TIME = pd.Timestamp.fromisoformat(last_candle_time_str)
            else:
                self.LAST_CANDLE_TIME = None

            self.CONNECTION_STATUS = state.get('connection_status', 'disconnected')

            print(f"âœ… ÙˆØ¶Ø¹ÛŒØª Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ø´Ø¯: {self.trades} Ù…Ø¹Ø§Ù…Ù„Ù‡ØŒ Ù…ÙˆØ¬ÙˆØ¯ÛŒ: {self.balance:,.0f} ØªÙˆÙ…Ø§Ù†")

            if self.in_trade:
                print(f"âš ï¸ Ù…Ø¹Ø§Ù…Ù„Ù‡ Ø¨Ø§Ø² ÛŒØ§ÙØª Ø´Ø¯: {self.trade_direction} Ø¯Ø± Ù‚ÛŒÙ…Øª {self.entry_price}")
                if self.entry_price <= 0:
                    print(f"âš ï¸ Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ù…Ø¹Ø§Ù…Ù„Ù‡ Ø¨Ø§Ø² ØºÛŒØ±Ù…Ù†Ø·Ù‚ÛŒ Ø§Ø³Øª. Ø¨Ø³ØªÙ† Ù…Ø¹Ø§Ù…Ù„Ù‡...")
                    self.in_trade = False
                    self.trade_direction = None
                    self.entry_price = 0
                    self.stop_loss_price = 0
                    self.take_profit_price = 0
                    self.current_trade_strategy = None

            return True

        except FileNotFoundError:
            print("â„¹ï¸ ÙØ§ÛŒÙ„ ÙˆØ¶Ø¹ÛŒØª ÛŒØ§ÙØª Ù†Ø´Ø¯. Ø´Ø±ÙˆØ¹ Ø¨Ø§ ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø§ÙˆÙ„ÛŒÙ‡")
            return False

        except Exception as e:
            print(f"âš ï¸ Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ ÙˆØ¶Ø¹ÛŒØª: {e}")
            import traceback
            traceback.print_exc()
            return False

    def reset_state(self):
        """
        Ø±ÛŒØ³Øª Ú©Ø§Ù…Ù„ ÙˆØ¶Ø¹ÛŒØª Ø±Ø¨Ø§Øª Ø¨Ù‡ Ø­Ø§Ù„Øª Ø§ÙˆÙ„ÛŒÙ‡

        ğŸ”„ ØªØºÛŒÛŒØ±: Ø­Ø°Ù position_sizeØŒ Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† warmup variables
        """

        print("\nğŸ”„ Ø±ÛŒØ³Øª Ú©Ø§Ù…Ù„ ÙˆØ¶Ø¹ÛŒØª Ø±Ø¨Ø§Øª Ø¨Ù‡ Ø­Ø§Ù„Øª Ø§ÙˆÙ„ÛŒÙ‡...")

        self.balance = self.TOTAL_BALANCE
        self.portfolio = self.PORTFOLIO_SIZE
        self.trades = 0
        self.winning_trades = 0
        self.losing_trades = 0
        self.total_profit = 0
        self.total_loss = 0
        self.max_drawdown = 0
        self.peak_balance = self.TOTAL_BALANCE

        self.in_trade = False
        self.trade_direction = None
        self.entry_price = 0
        self.stop_loss_price = 0
        self.take_profit_price = 0
        self.current_trade_strategy = None
        self.trade_start_time = None
        self.last_trade_exit_time = None
        self.trade_history = []
        self.open_trades = []
        self.current_internal_trade_id = None

        self.highest_price_in_trade = 0
        self.lowest_price_in_trade = float('inf')

        self.MARKET_PRICE = None
        self.LAST_KNOWN_PRICE = None
        self.LAST_CANDLE_TIME = None
        self.CONNECTION_STATUS = "disconnected"

        self.warmup_complete = False
        self.warmup_start_time = None
        self.warmup_candles_seen = 0
        self.first_realtime_candle_time = None

        files_to_remove = ['bot_state.json', 'performance_report.json', 'trading_bot.log']
        for filepath in files_to_remove:
            try:
                if os.path.exists(filepath):
                    os.remove(filepath)
                    print(f"âœ… ÙØ§ÛŒÙ„ {filepath} Ù¾Ø§Ú© Ø´Ø¯")
            except Exception as e:
                print(f"âš ï¸ Ø®Ø·Ø§ Ø¯Ø± Ù¾Ø§Ú© Ú©Ø±Ø¯Ù† ÙØ§ÛŒÙ„ {filepath}: {e}")

        print("âœ… ÙˆØ¶Ø¹ÛŒØª Ø±Ø¨Ø§Øª Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø±ÛŒØ³Øª Ø´Ø¯")
        print(f"ğŸ’° Ù…ÙˆØ¬ÙˆØ¯ÛŒ Ø¬Ø¯ÛŒØ¯: {self.balance:,.0f} ØªÙˆÙ…Ø§Ù†")

    def generate_performance_report(self):
        """
        ØªÙˆÙ„ÛŒØ¯ Ú¯Ø²Ø§Ø±Ø´ Ø¹Ù…Ù„Ú©Ø±Ø¯ Ø±Ø¨Ø§Øª

        ğŸ”„ ØªØºÛŒÛŒØ± Ø§Ø² ØªÛŒÚ© Ø¨Ù‡ Ø®Ø·
        """

        print("\n" + "ğŸ“Š" * 25)
        print("ğŸ“Š Ú¯Ø²Ø§Ø±Ø´ Ú©Ø§Ù…Ù„ Ø¹Ù…Ù„Ú©Ø±Ø¯ Ø±Ø¨Ø§Øª Ù…Ø¹Ø§Ù…Ù„Ù‡â€ŒÚ¯Ø± Ù…Ø¸Ù†Ù‡ ğŸ“Š")
        print("ğŸ“Š" * 25)

        total_trades = self.trades
        win_rate = 0
        if total_trades > 0:
            win_rate = (self.winning_trades / total_trades) * 100

        total_pnl = self.total_profit - self.total_loss
        total_return_percent = 0
        if self.TOTAL_BALANCE > 0:
            total_return_percent = ((self.balance - self.TOTAL_BALANCE) / self.TOTAL_BALANCE) * 100

        profit_factor = float('inf')
        if self.total_loss > 0:
            profit_factor = self.total_profit / self.total_loss

        avg_win = 0
        if self.winning_trades > 0:
            avg_win = self.total_profit / self.winning_trades

        avg_loss = 0
        if self.losing_trades > 0:
            avg_loss = self.total_loss / self.losing_trades

        avg_pnl_per_trade = 0
        if total_trades > 0:
            avg_pnl_per_trade = total_pnl / total_trades

        print(f"\nğŸ“ˆ Ø¢Ù…Ø§Ø± Ú©Ù„ÛŒ:")
        print(f"   â€¢ Ú©Ù„ Ù…ÙˆØ¬ÙˆØ¯ÛŒ: {self.balance:,.0f} ØªÙˆÙ…Ø§Ù†")
        print(f"   â€¢ ØªØºÛŒÛŒØ±Ø§Øª Ú©Ù„: {(self.balance - self.TOTAL_BALANCE):+,.0f} ØªÙˆÙ…Ø§Ù†")
        print(f"   â€¢ Ø¯Ø±ØµØ¯ ØªØºÛŒÛŒØ±: {total_return_percent:+.2f}%")
        print(f"   â€¢ Ø­Ø¯Ø§Ú©Ø«Ø± Ù…ÙˆØ¬ÙˆØ¯ÛŒ: {self.peak_balance:,.0f} ØªÙˆÙ…Ø§Ù†")
        print(f"   â€¢ Ø­Ø¯Ø§Ú©Ø«Ø± Ø§ÙØª Ø³Ø±Ù…Ø§ÛŒÙ‡: {self.max_drawdown:.2f}%")
        print(f"   â€¢ Ø§Ø±Ø²Ø´ Ù¾ÙˆØ±ØªÙÙˆ: {self.portfolio:,.0f} ØªÙˆÙ…Ø§Ù†")
        print(f"   â€¢ Ø§Ø±Ø²Ø´ Ù‡Ø± Ø®Ø·: {self.LINE_VALUE_TOMAN:,.0f} ØªÙˆÙ…Ø§Ù†")

        print(f"\nğŸ“Š Ø¢Ù…Ø§Ø± Ù…Ø¹Ø§Ù…Ù„Ø§Øª:")
        print(f"   â€¢ ØªØ¹Ø¯Ø§Ø¯ Ú©Ù„ Ù…Ø¹Ø§Ù…Ù„Ø§Øª: {total_trades}")
        print(f"   â€¢ Ù…Ø¹Ø§Ù…Ù„Ø§Øª Ø¨Ø±Ù†Ø¯Ù‡: {self.winning_trades}")
        print(f"   â€¢ Ù…Ø¹Ø§Ù…Ù„Ø§Øª Ø¨Ø§Ø²Ù†Ø¯Ù‡: {self.losing_trades}")
        print(f"   â€¢ Ù†Ø±Ø® Ø¨Ø±Ø¯: {win_rate:.1f}%")
        print(f"   â€¢ Ù…Ø¬Ù…ÙˆØ¹ Ø³ÙˆØ¯: {self.total_profit:,.0f} ØªÙˆÙ…Ø§Ù†")
        print(f"   â€¢ Ù…Ø¬Ù…ÙˆØ¹ Ø¶Ø±Ø±: {self.total_loss:,.0f} ØªÙˆÙ…Ø§Ù†")
        print(f"   â€¢ Ø³ÙˆØ¯ Ø®Ø§Ù„Øµ: {total_pnl:+,.0f} ØªÙˆÙ…Ø§Ù†")
        print(f"   â€¢ Ù…ÛŒØ§Ù†Ú¯ÛŒÙ† Ø³ÙˆØ¯ Ù‡Ø± Ù…Ø¹Ø§Ù…Ù„Ù‡ Ø¨Ø±Ù†Ø¯Ù‡: {avg_win:,.0f} ØªÙˆÙ…Ø§Ù†")
        print(f"   â€¢ Ù…ÛŒØ§Ù†Ú¯ÛŒÙ† Ø¶Ø±Ø± Ù‡Ø± Ù…Ø¹Ø§Ù…Ù„Ù‡ Ø¨Ø§Ø²Ù†Ø¯Ù‡: {avg_loss:,.0f} ØªÙˆÙ…Ø§Ù†")
        print(f"   â€¢ Ù…ÛŒØ§Ù†Ú¯ÛŒÙ† Ø³ÙˆØ¯/Ø¶Ø±Ø± Ù‡Ø± Ù…Ø¹Ø§Ù…Ù„Ù‡: {avg_pnl_per_trade:+,.0f} ØªÙˆÙ…Ø§Ù†")
        print(f"   â€¢ ÙØ§Ú©ØªÙˆØ± Ø³ÙˆØ¯: {profit_factor:.2f}")

        print(f"\nâš™ï¸ Ù¾Ø§Ø±Ø§Ù…ØªØ±Ù‡Ø§ÛŒ Ù…Ø¹Ø§Ù…Ù„Ø§ØªÛŒ:")
        print(f"   â€¢ Ø±ÛŒØ³Ú© Ù‡Ø± Ù…Ø¹Ø§Ù…Ù„Ù‡: {self.RISK_PERCENTAGE * 100}% Ø§Ø² Ù¾ÙˆØ±ØªÙÙˆ")
        print(f"   â€¢ Ø­Ø¯ Ø¶Ø±Ø± Ù…ØªØ­Ø±Ú© Ø§ÙˆÙ„ÛŒÙ‡: {self.TRAILING_STOP_LINES} Ø®Ø·")
        print(f"   â€¢ Ú¯Ø§Ù… Ø­Ø¯ Ø¶Ø±Ø±: {self.TRAILING_STEP_LINES} Ø®Ø·")
        print(f"   â€¢ Ø¢Ø³ØªØ§Ù†Ù‡ ADX: {self.ADX_THRESHOLD}")
        print(f"   â€¢ Ø­Ø¯Ø§Ù‚Ù„ ÙØ§ØµÙ„Ù‡ Ø¨ÛŒÙ† Ù…Ø¹Ø§Ù…Ù„Ø§Øª: {self.MIN_CANDLES_BETWEEN_TRADES} Ú©Ù†Ø¯Ù„")

        # Ù†Ù…Ø§ÛŒØ´ ØªØ§Ø±ÛŒØ®Ú†Ù‡ Ù…Ø¹Ø§Ù…Ù„Ø§Øª
        if self.trade_history:
            num_trades_to_show = min(5, len(self.trade_history))
            print(f"\nğŸ“‹ ØªØ§Ø±ÛŒØ®Ú†Ù‡ {num_trades_to_show} Ù…Ø¹Ø§Ù…Ù„Ù‡ Ø¢Ø®Ø±:")
            print("-" * 80)

            for i, trade in enumerate(self.trade_history[-num_trades_to_show:], 1):
                pnl = trade.get('pnl_toman', 0)
                pnl_lines = trade.get('pnl_lines', 0)
                direction = trade.get('direction', 'unknown')
                reason = trade.get('reason', 'Ù†Ø§Ù…Ø´Ø®Øµ')
                strategy = trade.get('strategy', 'Ù†Ø§Ù…Ø´Ø®Øµ')

                if pnl > 0:
                    emoji = 'ğŸŸ¢'
                else:
                    emoji = 'ğŸ”´'

                print(f"\n   {i}. {emoji} {direction.upper()} ({strategy}) | {reason}")

                entry_time = trade.get('entry_time')
                if entry_time:
                    if isinstance(entry_time, datetime):
                        print(f"      ğŸ•’ ÙˆØ±ÙˆØ¯: {entry_time.strftime('%Y-%m-%d %H:%M')}")
                    else:
                        print(f"      ğŸ•’ ÙˆØ±ÙˆØ¯: {entry_time}")

                exit_time = trade.get('exit_time')
                if exit_time:
                    if isinstance(exit_time, datetime):
                        print(f"      ğŸ•’ Ø®Ø±ÙˆØ¬: {exit_time.strftime('%Y-%m-%d %H:%M')}")
                    else:
                        print(f"      ğŸ•’ Ø®Ø±ÙˆØ¬: {exit_time}")

                print(f"      ğŸ“ˆ Ù‚ÛŒÙ…Øª ÙˆØ±ÙˆØ¯: {trade.get('entry_price', 0)}")
                print(f"      ğŸ“‰ Ù‚ÛŒÙ…Øª Ø®Ø±ÙˆØ¬: {trade.get('exit_price', 0)}")
                print(f"      ğŸ“Š ØªØºÛŒÛŒØ±: {pnl_lines:+} Ø®Ø·")
                print(f"      ğŸ’° Ø³ÙˆØ¯/Ø¶Ø±Ø±: {pnl:+,.0f} ØªÙˆÙ…Ø§Ù† ({trade.get('pnl_percent', 0):+.1f}%)")
                print(f"      â±ï¸ Ù…Ø¯Øª: {trade.get('duration', 'Ù†Ø§Ù…Ø´Ø®Øµ')}")
                print(f"      ğŸ“Š Ù…ÙˆØ¬ÙˆØ¯ÛŒ Ø¨Ø¹Ø¯: {trade.get('balance_after', 0):,.0f} ØªÙˆÙ…Ø§Ù†")

            print("-" * 80)

        # Ø°Ø®ÛŒØ±Ù‡ Ú¯Ø²Ø§Ø±Ø´
        try:
            report_data = {
                'timestamp': datetime.now().isoformat(),
                'balance': self.balance,
                'total_balance_initial': self.TOTAL_BALANCE,
                'total_trades': total_trades,
                'winning_trades': self.winning_trades,
                'losing_trades': self.losing_trades,
                'win_rate': win_rate,
                'total_profit': self.total_profit,
                'total_loss': self.total_loss,
                'total_pnl': total_pnl,
                'total_return_percent': total_return_percent,
                'max_drawdown': self.max_drawdown,
                'peak_balance': self.peak_balance,
                'profit_factor': profit_factor if profit_factor != float('inf') else 999999,
                'avg_win': avg_win,
                'avg_loss': avg_loss,
                'avg_pnl_per_trade': avg_pnl_per_trade,
                'line_value_toman': self.LINE_VALUE_TOMAN,
                'parameters': {
                    'risk_percentage': self.RISK_PERCENTAGE,
                    'trailing_stop_lines': self.TRAILING_STOP_LINES,
                    'trailing_step_lines': self.TRAILING_STEP_LINES,
                    'adx_threshold': self.ADX_THRESHOLD,
                    'min_candles_between_trades': self.MIN_CANDLES_BETWEEN_TRADES
                }
            }

            serializable_history = []
            for trade in self.trade_history[-10:]:
                trade_copy = trade.copy()
                if 'entry_time' in trade_copy and trade_copy['entry_time'] is not None:
                    if isinstance(trade_copy['entry_time'], datetime):
                        trade_copy['entry_time'] = trade_copy['entry_time'].isoformat()
                if 'exit_time' in trade_copy and trade_copy['exit_time'] is not None:
                    if isinstance(trade_copy['exit_time'], datetime):
                        trade_copy['exit_time'] = trade_copy['exit_time'].isoformat()
                serializable_history.append(trade_copy)

            report_data['trade_history'] = serializable_history

            # with open('performance_report.json', 'w', encoding='utf-8') as f:
            #     json.dump(report_data, f, indent=4, default=str, ensure_ascii=False)
            #
            # print(f"\nğŸ’¾ Ú¯Ø²Ø§Ø±Ø´ Ø¯Ø± ÙØ§ÛŒÙ„ 'performance_report.json' Ø°Ø®ÛŒØ±Ù‡ Ø´Ø¯.")

        except Exception as e:
            print(f"âš ï¸ Ø®Ø·Ø§ Ø¯Ø± Ø°Ø®ÛŒØ±Ù‡ Ú¯Ø²Ø§Ø±Ø´: {e}")

        print("ğŸ“Š" * 25)
        print("ğŸ“Š Ù¾Ø§ÛŒØ§Ù† Ú¯Ø²Ø§Ø±Ø´ ğŸ“Š")
        print("ğŸ“Š" * 25)

    def save_settings(self):
        """
        Ø°Ø®ÛŒØ±Ù‡ ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø¯Ø± ÙØ§ÛŒÙ„ Ø¬Ø¯Ø§Ú¯Ø§Ù†Ù‡
        """
        try:
            settings = {
                'trailing_enabled': self.TRAILING_ENABLED,
                'breakeven_enabled': self.BREAKEVEN_ENABLED,
                'trailing_stop_lines': self.TRAILING_STOP_LINES,
                'trailing_step_lines': self.TRAILING_STEP_LINES,
                'breakeven_lines': self.BREAKEVEN_LINES,
                'strategy_mode': self.STRATEGY_MODE,
                'scalp_risk_percentage': self.SCALP_RISK_PERCENTAGE,
                'swing_risk_percentage': self.SWING_RISK_PERCENTAGE,
                'min_profit_lines': self.MIN_PROFIT_LINES,
                'enable_counter_trend': self.ENABLE_COUNTER_TREND,
                'updated_at': datetime.now().isoformat()
            }

            with open('bot_settings.json', 'w', encoding='utf-8') as f:
                json.dump(settings, f, indent=4, ensure_ascii=False)

            print(f"ğŸ’¾ ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø°Ø®ÛŒØ±Ù‡ Ø´Ø¯")
            return True

        except Exception as e:
            print(f"âš ï¸ Ø®Ø·Ø§ Ø¯Ø± Ø°Ø®ÛŒØ±Ù‡ ØªÙ†Ø¸ÛŒÙ…Ø§Øª: {e}")
            return False

    def load_settings(self):
        """
        Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø§Ø² ÙØ§ÛŒÙ„
        """
        try:
            if os.path.exists('bot_settings.json'):
                with open('bot_settings.json', 'r', encoding='utf-8') as f:
                    settings = json.load(f)

                self.TRAILING_ENABLED = settings.get('trailing_enabled', True)
                self.BREAKEVEN_ENABLED = settings.get('breakeven_enabled', True)
                self.TRAILING_STOP_LINES = settings.get('trailing_stop_lines', self.TRAILING_STOP_LINES)
                self.TRAILING_STEP_LINES = settings.get('trailing_step_lines', self.TRAILING_STEP_LINES)
                self.BREAKEVEN_LINES = settings.get('breakeven_lines', self.BREAKEVEN_LINES)
                self.STRATEGY_MODE = settings.get('strategy_mode', 'auto')
                self.SCALP_RISK_PERCENTAGE = settings.get('scalp_risk_percentage', 0.10)
                self.SWING_RISK_PERCENTAGE = settings.get('swing_risk_percentage', 0.10)
                self.MIN_PROFIT_LINES = settings.get('min_profit_lines', 5)
                self.ENABLE_COUNTER_TREND = settings.get('enable_counter_trend', True)

                print(f"ğŸ“‚ ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ø´Ø¯")
                print(f"   ğŸ¯ Trailing: {'ÙØ¹Ø§Ù„' if self.TRAILING_ENABLED else 'ØºÛŒØ±ÙØ¹Ø§Ù„'}")
                print(f"   ğŸ›¡ï¸ Breakeven: {'ÙØ¹Ø§Ù„' if self.BREAKEVEN_ENABLED else 'ØºÛŒØ±ÙØ¹Ø§Ù„'}")
                print(f"   ğŸ“Š Strategy: {self.STRATEGY_MODE}")
                return True

        except Exception as e:
            print(f"âš ï¸ Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ ØªÙ†Ø¸ÛŒÙ…Ø§Øª: {e}")

        return False

    def run(self):
        print("\n" + "ğŸ¯" * 30)
        print("ğŸ¯ Ø±Ø¨Ø§Øª Ù…Ø¹Ø§Ù…Ù„Ù‡â€ŒÚ¯Ø± Ù…Ø¸Ù†Ù‡ Ø¢Ø¨Ø´Ø¯Ù‡ Ù‡ÛŒÙˆØ§Ú¯Ù„Ø¯ ğŸ¯")
        print("ğŸ¯" * 30)
        print(f"ğŸ’° Ú©Ù„ Ù…ÙˆØ¬ÙˆØ¯ÛŒ Ø­Ø³Ø§Ø¨: {self.TOTAL_BALANCE:,.0f} ØªÙˆÙ…Ø§Ù†")
        print(f"ğŸ’¼ Ø³Ø§ÛŒØ² Ù¾ÙˆØ±ØªÙÙˆ Ø¨Ø±Ø§ÛŒ Ù‡Ø± Ù…Ø¹Ø§Ù…Ù„Ù‡: {self.PORTFOLIO_SIZE:,.0f} ØªÙˆÙ…Ø§Ù†")
        print(f"ğŸ’µ Ø§Ø±Ø²Ø´ Ù‡Ø± Ø®Ø·: {self.LINE_VALUE_TOMAN:,.0f} ØªÙˆÙ…Ø§Ù†")
        print(f"âš–ï¸ Ø±ÛŒØ³Ú© Ù‡Ø± Ù…Ø¹Ø§Ù…Ù„Ù‡ Ø§Ø³Ú©Ø§Ù„Ù¾: {self.SCALP_RISK_PERCENTAGE * 100}% Ø§Ø² Ù¾ÙˆØ±ØªÙÙˆ")
        print(f"âš–ï¸ Ø±ÛŒØ³Ú© Ù‡Ø± Ù…Ø¹Ø§Ù…Ù„Ù‡ Ø³ÙˆØ¦ÛŒÙ†Ú¯: {self.SWING_RISK_PERCENTAGE * 100}% Ø§Ø² Ù¾ÙˆØ±ØªÙÙˆ")
        print(f"ğŸ›¡ï¸ Ø­Ø¯ Ø¶Ø±Ø± Ù…ØªØ­Ø±Ú© Ø§ÙˆÙ„ÛŒÙ‡: {self.TRAILING_STOP_LINES} Ø®Ø·")
        print(f"ğŸ“Š Ú¯Ø§Ù… Ø­Ø¯ Ø¶Ø±Ø±: {self.TRAILING_STEP_LINES} Ø®Ø·")
        print(f"ğŸ›¡ï¸ Ø­Ø¯ Ø¶Ø±Ø± Ø§Ø³Ú©Ø§Ù„Ù¾: {self.SCALP_STOP_LOSS_LINES} Ø®Ø· | Ø³ÙˆØ¦ÛŒÙ†Ú¯: {self.SWING_STOP_LOSS_LINES} Ø®Ø·")
        print(f"ğŸ¯ Ø¢Ø³ØªØ§Ù†Ù‡ ADX Ø§Ø³Ú©Ø§Ù„Ù¾: {self.SCALP_ADX_THRESHOLD} | Ø³ÙˆØ¦ÛŒÙ†Ú¯: {self.SWING_ADX_THRESHOLD}")
        print(f"â±ï¸ Ø­Ø¯Ø§Ù‚Ù„ ÙØ§ØµÙ„Ù‡ Ø¨ÛŒÙ† Ù…Ø¹Ø§Ù…Ù„Ø§Øª: {self.MIN_CANDLES_BETWEEN_TRADES} Ú©Ù†Ø¯Ù„ ({self.MIN_CANDLES_BETWEEN_TRADES * 5} Ø¯Ù‚ÛŒÙ‚Ù‡)")
        print(f"ğŸ“¡ WebSocket Server Ø¯Ø§Ø®Ù„ÛŒ: ws://{self.WS_SERVER_HOST}:{self.WS_SERVER_PORT}")
        print(f"ğŸ¯ Ø­Ø§Ù„Øª Ø§Ø³ØªØ±Ø§ØªÚ˜ÛŒ: {self.STRATEGY_MODE}")
        print("ğŸ¯" * 30)

        self.load_settings()

        if not self.start_websocket_server():
            print("âŒ Ø®Ø·Ø§ Ø¯Ø± Ø±Ø§Ù‡â€ŒØ§Ù†Ø¯Ø§Ø²ÛŒ WebSocket Server. Ø±Ø¨Ø§Øª Ù…ØªÙˆÙ‚Ù Ø´Ø¯.")
            return

        if not self.load_historical_data():
            print("âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ ØªØ§Ø±ÛŒØ®ÛŒ. Ø±Ø¨Ø§Øª Ù…ØªÙˆÙ‚Ù Ø´Ø¯.")
            self.stop_websocket_server()
            return

        if os.path.exists('bot_state.json'):
            try:
                with open('bot_state.json', 'r') as f:
                    state = json.load(f)
                    current_balance = state.get('balance', self.TOTAL_BALANCE)
                    if current_balance < 0 or current_balance > self.TOTAL_BALANCE * 10:
                        print(f"\nâš ï¸ ÙˆØ¶Ø¹ÛŒØª Ø®Ø±Ø§Ø¨ ØªØ´Ø®ÛŒØµ Ø¯Ø§Ø¯Ù‡ Ø´Ø¯!")
                        print(f"   Ù…ÙˆØ¬ÙˆØ¯ÛŒ Ø¯Ø± ÙØ§ÛŒÙ„: {current_balance:,.0f} ØªÙˆÙ…Ø§Ù†")
                        print(f"   Ù…ÙˆØ¬ÙˆØ¯ÛŒ Ù…Ù†Ø·Ù‚ÛŒ: {self.TOTAL_BALANCE:,.0f} ØªÙˆÙ…Ø§Ù†")
                        choice = input("Ø¢ÛŒØ§ Ù…ÛŒâ€ŒØ®ÙˆØ§Ù‡ÛŒØ¯ ÙˆØ¶Ø¹ÛŒØª Ø±Ø§ Ø±ÛŒØ³Øª Ú©Ù†ÛŒØ¯ØŸ (y/n): ").strip().lower()
                        if choice == 'y':
                            self.reset_state()
                        else:
                            self.load_state()
                    else:
                        self.load_state()
            except Exception as e:
                print(f"âš ï¸ Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø±Ø±Ø³ÛŒ ÙˆØ¶Ø¹ÛŒØª: {e}")
                self.reset_state()

        ws_thread = threading.Thread(target=self.connect_to_price_socket, daemon=True)
        ws_thread.start()
        print("ğŸ“¡ Ø¯Ø± Ø­Ø§Ù„ Ø§ØªØµØ§Ù„ Ø¨Ù‡ Ø³Ø±ÙˆØ± Ù‚ÛŒÙ…Øªâ€ŒÙ‡Ø§ÛŒ Ø²Ù†Ø¯Ù‡ Ù…Ø¸Ù†Ù‡...")

        if not self.wait_for_connection(timeout=60):
            print("âŒ Ø§ØªØµØ§Ù„ Ø¨Ù‡ Ø³Ø±ÙˆØ± Ù‚ÛŒÙ…Øª Ø¨Ø±Ù‚Ø±Ø§Ø± Ù†Ø´Ø¯. Ø±Ø¨Ø§Øª Ù…ØªÙˆÙ‚Ù Ù…ÛŒâ€ŒØ´ÙˆØ¯.")
            self.stop_websocket_server()
            return

        print("âœ… Ø§ØªØµØ§Ù„ Ø¨Ù‡ Ø³Ø±ÙˆØ± Ù‚ÛŒÙ…Øª Ø¨Ø±Ù‚Ø±Ø§Ø± Ø´Ø¯. Ø±Ø¨Ø§Øª ÙØ¹Ø§Ù„ Ø§Ø³Øª.")

        time.sleep(2)

        try:
            LOOP_INTERVAL = 1
            STATUS_INTERVAL = 60
            HEARTBEAT_INTERVAL = 30
            SAVE_INTERVAL = 60
            REPORT_INTERVAL = 600
            OPTIMIZATION_INTERVAL = 3600

            status_counter = 0
            heartbeat_counter = 0
            save_counter = 0
            report_counter = 0
            optimization_counter = 0

            print(f"\nâ±ï¸ ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø²Ù…Ø§Ù†ÛŒ:")
            print(f"   Ù†Ù…Ø§ÛŒØ´ ÙˆØ¶Ø¹ÛŒØª: Ù‡Ø± {STATUS_INTERVAL} Ø«Ø§Ù†ÛŒÙ‡")
            print(f"   Ø§Ø±Ø³Ø§Ù„ heartbeat: Ù‡Ø± {HEARTBEAT_INTERVAL} Ø«Ø§Ù†ÛŒÙ‡")
            print(f"   Ø°Ø®ÛŒØ±Ù‡ ÙˆØ¶Ø¹ÛŒØª: Ù‡Ø± {SAVE_INTERVAL} Ø«Ø§Ù†ÛŒÙ‡")
            print(f"   Ú¯Ø²Ø§Ø±Ø´ Ø¹Ù…Ù„Ú©Ø±Ø¯: Ù‡Ø± {REPORT_INTERVAL} Ø«Ø§Ù†ÛŒÙ‡")
            print(f"   Ø¨Ù‡ÛŒÙ†Ù‡â€ŒØ³Ø§Ø²ÛŒ Ù¾Ø§Ø±Ø§Ù…ØªØ±Ù‡Ø§: Ù‡Ø± {OPTIMIZATION_INTERVAL} Ø«Ø§Ù†ÛŒÙ‡")
            print(f"   ğŸ“¡ Ú©Ù„Ø§ÛŒÙ†Øªâ€ŒÙ‡Ø§ Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ù†Ø¯ Ø¨Ù‡ ws://localhost:{self.WS_SERVER_PORT} Ù…ØªØµÙ„ Ø´ÙˆÙ†Ø¯")

            while True:
                status_counter += LOOP_INTERVAL
                heartbeat_counter += LOOP_INTERVAL
                save_counter += LOOP_INTERVAL
                report_counter += LOOP_INTERVAL
                optimization_counter += LOOP_INTERVAL

                if status_counter >= STATUS_INTERVAL:
                    self.show_status()
                    status_counter = 0

                if heartbeat_counter >= HEARTBEAT_INTERVAL:
                    self.send_heartbeat()
                    heartbeat_counter = 0

                if save_counter >= SAVE_INTERVAL:
                    self.save_state()
                    save_counter = 0

                if report_counter >= REPORT_INTERVAL:
                    self.generate_performance_report()
                    report_counter = 0

                if optimization_counter >= OPTIMIZATION_INTERVAL:
                    if hasattr(self, 'param_optimizer') and self.param_optimizer:
                        self.param_optimizer.optimize_parameters()
                    optimization_counter = 0

                time.sleep(LOOP_INTERVAL)

        except KeyboardInterrupt:
            print("\n\nâš ï¸ Ø±Ø¨Ø§Øª ØªÙˆØ³Ø· Ú©Ø§Ø±Ø¨Ø± Ù…ØªÙˆÙ‚Ù Ø´Ø¯.")

            if self.in_trade:
                print("\nâš ï¸ Ù‡Ø´Ø¯Ø§Ø±: ÛŒÚ© Ù…Ø¹Ø§Ù…Ù„Ù‡ Ø¨Ø§Ø² ÙˆØ¬ÙˆØ¯ Ø¯Ø§Ø±Ø¯!")
                current_price = self.MARKET_PRICE if self.MARKET_PRICE else self.LAST_KNOWN_PRICE
                if current_price:
                    current_price = int(current_price)
                    print(f"   Ù‚ÛŒÙ…Øª ÙØ¹Ù„ÛŒ: {current_price}")
                    print(f"   Ù‚ÛŒÙ…Øª ÙˆØ±ÙˆØ¯: {int(self.entry_price)}")
                    print(f"   Ø¬Ù‡Øª: {self.trade_direction}")
                    print(f"   Ø§Ø³ØªØ±Ø§ØªÚ˜ÛŒ: {self.current_trade_strategy}")

                    current_pnl = self.calculate_current_profit_lines(current_price)
                    current_pnl_toman = current_pnl * self.LINE_VALUE_TOMAN
                    print(f"   Ø³ÙˆØ¯/Ø¶Ø±Ø± ÙØ¹Ù„ÛŒ: {current_pnl:+} Ø®Ø· ({current_pnl_toman:+,.0f} ØªÙˆÙ…Ø§Ù†)")

                    action = input("Ø¢ÛŒØ§ Ù…ÛŒâ€ŒØ®ÙˆØ§Ù‡ÛŒØ¯ Ù…Ø¹Ø§Ù…Ù„Ù‡ Ø±Ø§ Ø¨Ø§ Ù‚ÛŒÙ…Øª Ø¨Ø§Ø²Ø§Ø± Ø¨Ø¨Ù†Ø¯ÛŒØ¯ØŸ (y/n): ").strip().lower()
                    if action == 'y':
                        self.exit_trade(current_price, "Ø®Ø±ÙˆØ¬ Ø¯Ø³ØªÛŒ ØªÙˆØ³Ø· Ú©Ø§Ø±Ø¨Ø±")
                        print("âœ… Ù…Ø¹Ø§Ù…Ù„Ù‡ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ø³ØªÙ‡ Ø´Ø¯.")
                    else:
                        print("âš ï¸ Ù…Ø¹Ø§Ù…Ù„Ù‡ Ø¨Ø§Ø² Ø¨Ø§Ù‚ÛŒ Ù…Ø§Ù†Ø¯. ØªÙˆØ¬Ù‡: Ø±Ø¨Ø§Øª Ù…ØªÙˆÙ‚Ù Ø´Ø¯Ù‡ Ø§Ø³Øª.")
                else:
                    print("âŒ Ù‚ÛŒÙ…Øª Ø¨Ø§Ø²Ø§Ø± Ø¯Ø± Ø¯Ø³ØªØ±Ø³ Ù†ÛŒØ³Øª. Ø§Ù…Ú©Ø§Ù† Ø¨Ø³ØªÙ† Ù…Ø¹Ø§Ù…Ù„Ù‡ ÙˆØ¬ÙˆØ¯ Ù†Ø¯Ø§Ø±Ø¯.")

            self.save_state()
            self.generate_performance_report()

            shutdown_command = {
                "type": "bot_shutdown",
                "reason": "user_requested",
                "final_balance": self.balance,
                "total_trades": self.trades,
                "total_profit": self.total_profit,
                "total_loss": self.total_loss,
                "connected_clients": self.get_connected_clients_count(),
                "timestamp": datetime.now().isoformat()
            }
            self.send_command(shutdown_command)

            self.stop_websocket_server()

            print("\nâœ… Ø±Ø¨Ø§Øª Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ù…ØªÙˆÙ‚Ù Ø´Ø¯.")

# --- Ø§Ø¬Ø±Ø§ÛŒ Ø§ØµÙ„ÛŒ ---
if __name__ == "__main__":
    try:
        print("\nğŸš€ Ø±Ø§Ù‡â€ŒØ§Ù†Ø¯Ø§Ø²ÛŒ Ø±Ø¨Ø§Øª Ù…Ø¹Ø§Ù…Ù„Ù‡â€ŒÚ¯Ø±...")
        print("=" * 50)
        print("ğŸ“¡ Ø§ÛŒÙ† Ø±Ø¨Ø§Øª ÛŒÚ© WebSocket Server Ø¯Ø§Ø®Ù„ÛŒ Ø±Ø§Ù‡â€ŒØ§Ù†Ø¯Ø§Ø²ÛŒ Ù…ÛŒâ€ŒÚ©Ù†Ø¯")
        print("   Ú©Ù„Ø§ÛŒÙ†Øªâ€ŒÙ‡Ø§ Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ù†Ø¯ Ù…Ø³ØªÙ‚ÛŒÙ…Ø§Ù‹ Ø¨Ù‡ Ø¢Ù† Ù…ØªØµÙ„ Ø´ÙˆÙ†Ø¯")
        print("=" * 50)

        bot = HivaGoldManager()
        bot.run()

    except KeyboardInterrupt:
        print("\n\nğŸ‘‹ Ø±Ø¨Ø§Øª ØªÙˆØ³Ø· Ú©Ø§Ø±Ø¨Ø± Ù…ØªÙˆÙ‚Ù Ø´Ø¯.")
    except Exception as e:
        print(f"\nâŒ Ø®Ø·Ø§ÛŒ ØºÛŒØ±Ù…Ù†ØªØ¸Ø±Ù‡: {e}")
        import traceback

        traceback.print_exc()mport traceback

        traceback.print_exc()