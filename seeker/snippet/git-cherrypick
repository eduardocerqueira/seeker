#date: 2025-09-25T16:54:52Z
#url: https://api.github.com/gists/f07a1af57f7fd6149fe5038dd34d4bd6
#owner: https://api.github.com/users/ivikasavnish

#!/usr/bin/env python3
"""
Git Cherry Pick - A Git extension for tracking merges and easy cherry-picking with Jira integration

Usage:
    git cherrypick track <source-branch> <destination-branch>
    git cherrypick list [source-branch]
    git cherrypick select <source-branch> <destination-branch>
    git cherrypick status
"""

import sys
import os
import subprocess
import json
import re
from datetime import datetime
from typing import List, Dict, Optional, Tuple
import argparse

class GitCherryPick:
    def __init__(self):
        self.repo_root = self._get_repo_root()
        self.data_file = os.path.join(self.repo_root, '.git', 'cherrypick_data.json')
        self.data = self._load_data()

    def _get_repo_root(self) -> str:
        """Get the root directory of the git repository"""
        try:
            result = subprocess.run(['git', 'rev-parse', '--show-toplevel'],
                                  capture_output=True, text=True, check=True)
            return result.stdout.strip()
        except subprocess.CalledProcessError:
            print("Error: Not in a git repository")
            sys.exit(1)

    def _load_data(self) -> Dict:
        """Load tracking data from file"""
        if os.path.exists(self.data_file):
            try:
                with open(self.data_file, 'r') as f:
                    return json.load(f)
            except (json.JSONDecodeError, IOError):
                pass
        return {'tracked_branches': {}, 'last_merge_commits': {}}

    def _save_data(self):
        """Save tracking data to file"""
        try:
            with open(self.data_file, 'w') as f:
                json.dump(self.data, f, indent=2)
        except IOError as e:
            print(f"Error saving data: {e}")

    def _run_git_command(self, cmd: List[str]) -> str:
        """Run a git command and return output"""
        try:
            result = subprocess.run(['git'] + cmd, capture_output=True, text=True, check=True)
            return result.stdout.strip()
        except subprocess.CalledProcessError as e:
            print(f"Git command failed: {e}")
            return ""

    def _extract_jira_info(self, commit_message: str) -> Optional[Dict[str, str]]:
        """Extract Jira ticket information from commit message"""
        jira_patterns = [
            r'https?://[\w\.-]+\.atlassian\.net/browse/([A-Z]+-\d+)',
            r'https?://[\w\.-]+/browse/([A-Z]+-\d+)',
            r'\b([A-Z]+-\d+)\b',
        ]

        for pattern in jira_patterns:
            match = re.search(pattern, commit_message, re.IGNORECASE)
            if match:
                ticket_id = match.group(1)
                # Try to extract title from commit message
                lines = commit_message.split('\n')
                title = lines[0].strip()

                # Remove ticket ID from title if it's there
                title = re.sub(r'\b' + re.escape(ticket_id) + r'\b:?\s*', '', title, flags=re.IGNORECASE)
                title = title.strip()

                return {
                    'ticket_id': ticket_id,
                    'title': title,
                    'url': f"https://your-domain.atlassian.net/browse/{ticket_id}"
                }
        return None

    def _get_commits_since_merge(self, source_branch: str, destination_branch: str,
                                since_commit: Optional[str] = None) -> List[Dict]:
        """Get commits in source branch since last merge with destination"""
        if since_commit:
            commit_range = f"{since_commit}..{source_branch}"
        else:
            # Find merge base
            merge_base = self._run_git_command(['merge-base', source_branch, destination_branch])
            if not merge_base:
                return []
            commit_range = f"{merge_base}..{source_branch}"

        # Get commit hashes
        commits = self._run_git_command(['rev-list', '--reverse', commit_range])
        if not commits:
            return []

        commit_list = []
        for commit_hash in commits.split('\n'):
            if not commit_hash.strip():
                continue

            # Get commit info
            commit_info = self._run_git_command([
                'show', '--format=%H|%s|%an|%ad', '--no-patch', '--date=short', commit_hash
            ])

            if not commit_info:
                continue

            parts = commit_info.split('|', 3)
            if len(parts) < 4:
                continue

            full_hash, subject, author, date = parts

            # Get full commit message for Jira extraction
            full_message = self._run_git_command(['show', '--format=%B', '--no-patch', commit_hash])

            jira_info = self._extract_jira_info(full_message)

            commit_data = {
                'hash': full_hash,
                'short_hash': full_hash[:8],
                'subject': subject,
                'author': author,
                'date': date,
                'jira': jira_info
            }

            commit_list.append(commit_data)

        return commit_list

    def _find_last_merge_commit(self, source_branch: str, destination_branch: str) -> Optional[str]:
        """Find the last merge commit from source to destination"""
        # Get merge commits in destination that came from source
        merge_commits = self._run_git_command([
            'log', '--merges', '--grep', f"Merge.*{source_branch}",
            '--format=%H', destination_branch
        ])

        if merge_commits:
            return merge_commits.split('\n')[0]
        return None

    def track_branches(self, source_branch: str, destination_branch: str):
        """Start tracking merges between source and destination branches"""
        # Verify branches exist
        branches = self._run_git_command(['branch', '-a']).split('\n')
        branch_names = [b.strip().replace('* ', '').replace('remotes/', '') for b in branches]

        if not any(source_branch in b for b in branch_names):
            print(f"Error: Source branch '{source_branch}' not found")
            return

        if not any(destination_branch in b for b in branch_names):
            print(f"Error: Destination branch '{destination_branch}' not found")
            return

        # Find current merge base or last merge
        last_merge = self._find_last_merge_commit(source_branch, destination_branch)
        if not last_merge:
            last_merge = self._run_git_command(['merge-base', source_branch, destination_branch])

        tracking_key = f"{source_branch}->{destination_branch}"
        self.data['tracked_branches'][tracking_key] = {
            'source': source_branch,
            'destination': destination_branch,
            'last_merge_commit': last_merge,
            'created_at': datetime.now().isoformat()
        }

        self._save_data()
        print(f"Now tracking: {source_branch} -> {destination_branch}")
        print(f"Last merge commit: {last_merge[:8] if last_merge else 'None'}")

    def list_commits(self, source_branch: Optional[str] = None):
        """List commits available for cherry-picking"""
        if source_branch:
            # Find tracking entries for this source branch
            matching_tracks = {k: v for k, v in self.data['tracked_branches'].items()
                             if v['source'] == source_branch}
        else:
            matching_tracks = self.data['tracked_branches']

        if not matching_tracks:
            print("No tracked branches found.")
            if source_branch:
                print(f"Use 'git cherrypick track {source_branch} <destination>' to start tracking.")
            return

        for track_key, track_info in matching_tracks.items():
            print(f"\n=== {track_info['source']} -> {track_info['destination']} ===")
            commits = self._get_commits_since_merge(
                track_info['source'],
                track_info['destination'],
                track_info.get('last_merge_commit')
            )

            if not commits:
                print("No new commits to cherry-pick")
                continue

            for i, commit in enumerate(commits, 1):
                jira_str = ""
                if commit['jira']:
                    jira_str = f" [{commit['jira']['ticket_id']}]"

                print(f"{i:2d}. {commit['short_hash']} {commit['subject']}{jira_str}")
                print(f"     Author: {commit['author']} | Date: {commit['date']}")
                if commit['jira'] and commit['jira']['title']:
                    print(f"     Jira: {commit['jira']['title']}")
                print()

    def interactive_select(self, source_branch: str, destination_branch: str):
        """Interactive commit selection and cherry-picking"""
        tracking_key = f"{source_branch}->{destination_branch}"

        if tracking_key not in self.data['tracked_branches']:
            print(f"Branches not tracked. Use: git cherrypick track {source_branch} {destination_branch}")
            return

        track_info = self.data['tracked_branches'][tracking_key]
        commits = self._get_commits_since_merge(
            source_branch, destination_branch, track_info.get('last_merge_commit')
        )

        if not commits:
            print("No new commits to cherry-pick")
            return

        print(f"\nCommits available for cherry-picking from {source_branch} to {destination_branch}:\n")

        for i, commit in enumerate(commits, 1):
            jira_str = ""
            if commit['jira']:
                jira_str = f" [{commit['jira']['ticket_id']}]"

            print(f"{i:2d}. {commit['short_hash']} {commit['subject']}{jira_str}")
            print(f"     Author: {commit['author']} | Date: {commit['date']}")
            if commit['jira']:
                if commit['jira']['title']:
                    print(f"     Jira: {commit['jira']['title']}")
                if commit['jira']['url']:
                    print(f"     Link: {commit['jira']['url']}")
            print()

        # Get user selection
        while True:
            try:
                selection = input("\nEnter commit numbers to cherry-pick (e.g., 1,3,5 or 1-3): ").strip()
                if not selection:
                    print("Cancelled.")
                    return

                indices = self._parse_selection(selection, len(commits))
                if indices:
                    break
                print("Invalid selection. Try again.")
            except KeyboardInterrupt:
                print("\nCancelled.")
                return

        # Confirm current branch is destination
        current_branch = self._run_git_command(['branch', '--show-current'])
        if current_branch != destination_branch:
            confirm = input(f"Current branch is '{current_branch}', but destination is '{destination_branch}'. Switch? (y/N): ")
            if confirm.lower() == 'y':
                print(f"Switching to {destination_branch}...")
                result = subprocess.run(['git', 'checkout', destination_branch], capture_output=True)
                if result.returncode != 0:
                    print(f"Failed to switch to {destination_branch}")
                    return
            else:
                print("Cherry-pick cancelled.")
                return

        # Perform cherry-picks
        selected_commits = [commits[i-1] for i in indices]
        self._cherry_pick_commits(selected_commits, source_branch, destination_branch)

    def _parse_selection(self, selection: str, max_count: int) -> List[int]:
        """Parse user selection string into list of indices"""
        indices = []
        parts = selection.split(',')

        for part in parts:
            part = part.strip()
            if '-' in part:
                try:
                    start, end = map(int, part.split('-', 1))
                    if 1 <= start <= max_count and 1 <= end <= max_count and start <= end:
                        indices.extend(range(start, end + 1))
                except ValueError:
                    return []
            else:
                try:
                    num = int(part)
                    if 1 <= num <= max_count:
                        indices.append(num)
                except ValueError:
                    return []

        return sorted(set(indices))

    def _cherry_pick_commits(self, commits: List[Dict], source_branch: str, destination_branch: str):
        """Cherry-pick selected commits"""
        print(f"\nCherry-picking {len(commits)} commits...\n")

        failed_commits = []
        successful_commits = []

        for commit in commits:
            print(f"Cherry-picking {commit['short_hash']}: {commit['subject']}")

            result = subprocess.run(['git', 'cherry-pick', commit['hash']],
                                  capture_output=True, text=True)

            if result.returncode == 0:
                print(f"  ✓ Success")
                successful_commits.append(commit)
            else:
                print(f"  ✗ Failed: {result.stderr.strip()}")
                failed_commits.append((commit, result.stderr))

                # Ask user what to do
                while True:
                    choice = input("  Continue (c), Abort (a), Resolve manually (r): ").lower()
                    if choice == 'a':
                        subprocess.run(['git', 'cherry-pick', '--abort'])
                        print("Cherry-pick aborted.")
                        return
                    elif choice == 'c':
                        subprocess.run(['git', 'cherry-pick', '--skip'])
                        break
                    elif choice == 'r':
                        print("  Resolve conflicts manually, then run 'git cherry-pick --continue'")
                        input("  Press Enter when resolved...")
                        result = subprocess.run(['git', 'cherry-pick', '--continue'])
                        if result.returncode == 0:
                            successful_commits.append(commit)
                        break
            print()

        # Update tracking data with last successful commit
        if successful_commits:
            tracking_key = f"{source_branch}->{destination_branch}"
            self.data['tracked_branches'][tracking_key]['last_merge_commit'] = successful_commits[-1]['hash']
            self._save_data()

        # Summary
        print(f"\n=== Summary ===")
        print(f"Successfully cherry-picked: {len(successful_commits)} commits")
        if failed_commits:
            print(f"Failed: {len(failed_commits)} commits")

        if successful_commits:
            print(f"\nSuccessful commits:")
            for commit in successful_commits:
                jira_str = f" [{commit['jira']['ticket_id']}]" if commit['jira'] else ""
                print(f"  {commit['short_hash']}: {commit['subject']}{jira_str}")

    def show_status(self):
        """Show current tracking status"""
        if not self.data['tracked_branches']:
            print("No branches currently tracked.")
            return

        print("Tracked branch pairs:")
        print("-" * 50)

        for track_key, track_info in self.data['tracked_branches'].items():
            commits = self._get_commits_since_merge(
                track_info['source'],
                track_info['destination'],
                track_info.get('last_merge_commit')
            )

            print(f"{track_info['source']} -> {track_info['destination']}")
            print(f"  Created: {track_info['created_at'][:10]}")
            print(f"  New commits: {len(commits)}")
            if track_info.get('last_merge_commit'):
                print(f"  Last merge: {track_info['last_merge_commit'][:8]}")
            print()

def main():
    parser = argparse.ArgumentParser(description='Git Cherry Pick - Track merges and cherry-pick with Jira integration')
    subparsers = parser.add_subparsers(dest='command', help='Available commands')

    # Track command
    track_parser = subparsers.add_parser('track', help='Start tracking branches')
    track_parser.add_argument('source', help='Source branch')
    track_parser.add_argument('destination', help='Destination branch')

    # List command
    list_parser = subparsers.add_parser('list', help='List available commits')
    list_parser.add_argument('source', nargs='?', help='Source branch (optional)')

    # Select command
    select_parser = subparsers.add_parser('select', help='Interactive commit selection')
    select_parser.add_argument('source', help='Source branch')
    select_parser.add_argument('destination', help='Destination branch')

    # Status command
    subparsers.add_parser('status', help='Show tracking status')

    args = parser.parse_args()

    if not args.command:
        parser.print_help()
        return

    gcp = GitCherryPick()

    if args.command == 'track':
        gcp.track_branches(args.source, args.destination)
    elif args.command == 'list':
        gcp.list_commits(args.source)
    elif args.command == 'select':
        gcp.interactive_select(args.source, args.destination)
    elif args.command == 'status':
        gcp.show_status()

if __name__ == '__main__':
    main()