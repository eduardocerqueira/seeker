#date: 2026-01-02T16:59:38Z
#url: https://api.github.com/gists/4d55f00f933ceaf8aec9ac87cf8a4703
#owner: https://api.github.com/users/thekirkulees

"""
title: Jake Portfolio Pipe
description: Portfolio facts query handler - deterministic Python logic, no LLM computation
author: kirk
version: 1.2.0
"""

from pydantic import BaseModel, Field
from typing import Optional, Dict, List, Tuple, Any
import os
import re
from datetime import datetime


class Pipe:
    class Valves(BaseModel):
        portfolio_path: str = Field(
            default="/Users/kirk/Documents/Schwab/Current/portfolio_full_latest.md",
            description="Path to portfolio file generated by portfolio_pulse.py"
        )
        enable_llm_presentation: bool = Field(
            default=True,
            description="Use LLM for natural language formatting (disable for raw output)"
        )
        skip_llm_for_simple_queries: bool = Field(
            default=True,
            description="Return exact strings for yes/no queries without LLM call"
        )

    def __init__(self):
        self.valves = self.Valves()
        self.type = "pipe"

    # ========================================================================
    # PHASE 1: DATA LOADING (LAZY - ONLY LOAD WHAT'S NEEDED)
    # ========================================================================
    # RULE 1.1: Load and parse PORTFOLIO_INDEX as authoritative source

    def _load_portfolio_index(self, portfolio_path: str) -> Dict[str, Dict[str, Any]]:
        """
        Extract and parse PORTFOLIO_INDEX section.

        Returns:
            dict mapping ticker -> {allocation_pct, gain_loss_pct, holding_period}
        """
        try:
            with open(os.path.expanduser(portfolio_path), 'r') as f:
                content = f.read()

            begin = "### BEGIN PORTFOLIO_INDEX"
            end = "### END PORTFOLIO_INDEX"

            if begin not in content or end not in content:
                return {}

            index_block = content.split(begin, 1)[1].split(end, 1)[0]

            # Parse PORTFOLIO_INDEX structure:
            # TICKER: AAPL
            #   allocation_pct: 5.2
            #   allocation_unit: percent
            #   gain_loss_pct: +12.3
            #   holding_period: Long-term

            index_data = {}
            current_ticker = None

            for line in index_block.split('\n'):
                line = line.strip()
                if not line:
                    continue

                if line.startswith('TICKER:'):
                    current_ticker = line.split('TICKER:', 1)[1].strip()
                    index_data[current_ticker] = {}
                elif current_ticker and ':' in line:
                    key, value = line.split(':', 1)
                    key = key.strip()
                    value = value.strip()

                    # Convert numeric values
                    if key in ['allocation_pct', 'gain_loss_pct']:
                        try:
                            index_data[current_ticker][key] = float(value.replace('+', ''))
                        except ValueError:
                            index_data[current_ticker][key] = value
                    else:
                        index_data[current_ticker][key] = value

            return index_data

        except FileNotFoundError:
            return {}
        except Exception as e:
            return {}

    # RULE 1.3: Load specific portfolio sections (lazy loading)

    def _load_portfolio_section(self, portfolio_path: str, section_name: str) -> str:
        """
        Load a specific section from portfolio file.

        Args:
            section_name: e.g., 'Position Allocation', 'Tax Flags Summary', 'Rebalance Actions'

        Returns:
            Section content as string
        """
        try:
            with open(os.path.expanduser(portfolio_path), 'r') as f:
                content = f.read()

            # Find section by markdown header
            pattern = rf'## {re.escape(section_name)}.*?\n(.*?)(?=\n## |\Z)'
            match = re.search(pattern, content, re.DOTALL)

            if match:
                return match.group(1).strip()
            return ""

        except FileNotFoundError:
            return ""

    def _parse_position_table(self, table_text: str) -> List[Dict[str, Any]]:
        """Parse Position Allocation table into structured data."""
        positions = []
        lines = table_text.strip().split('\n')

        # Skip header and separator lines
        data_lines = [l for l in lines if l.strip() and not l.strip().startswith('|--')]
        if len(data_lines) < 2:
            return positions

        # Skip header row
        for line in data_lines[1:]:
            if not line.strip():
                continue

            # Parse: | Symbol | Qty | Price | Value | % |
            parts = [p.strip() for p in line.split('|') if p.strip()]
            if len(parts) >= 5:
                try:
                    symbol = parts[0]
                    qty = parts[1].replace(',', '')
                    price = parts[2].replace('$', '').replace(',', '')
                    value = parts[3].replace('$', '').replace(',', '')
                    pct = parts[4].replace('%', '')

                    positions.append({
                        'symbol': symbol,
                        'quantity': float(qty) if qty != '-' else 0,
                        'price': float(price) if price != '-' else 0,
                        'value': float(value) if value != '-' else 0,
                        'allocation_pct': float(pct) if pct else 0
                    })
                except (ValueError, IndexError):
                    continue

        return positions

    def _parse_rebalance_actions(self, section_text: str) -> List[Dict[str, Any]]:
        """Parse Rebalance Actions section."""
        actions = []

        # Look for lines like:
        # - **VTI**: 10.0% → 8.0% target | Sell 2.0% (~$8,450, ~25 shares) | ⚠️ BLOCKED (wash sale until 2024-12-31)
        # - **SCHF**: 5.0% → 7.0% target | Buy 2.0% (~$8,450, ~35 shares)

        pattern = r'\*\*([A-Z]+)\*\*:\s*(\d+\.?\d*)%\s*→\s*(\d+\.?\d*)%.*?\|\s*(Buy|Sell|Deploy|Build)\s+(\d+\.?\d*)%.*?(?:\(~?\$?([\d,]+).*?~?(\d+)\s*shares\))?(?:.*?BLOCKED.*?until\s+(\d{4}-\d{2}-\d{2}))?'

        for match in re.finditer(pattern, section_text, re.IGNORECASE):
            ticker = match.group(1)
            current_pct = float(match.group(2))
            target_pct = float(match.group(3))
            action = match.group(4)
            diff_pct = float(match.group(5))
            dollar_amount = match.group(6).replace(',', '') if match.group(6) else None
            shares = match.group(7) if match.group(7) else None
            blocked_until = match.group(8) if match.group(8) else None

            actions.append({
                'ticker': ticker,
                'current_pct': current_pct,
                'target_pct': target_pct,
                'action': action,
                'diff_pct': diff_pct,
                'dollar_amount': float(dollar_amount) if dollar_amount else 0,
                'shares': int(shares) if shares else 0,
                'wash_blocked': bool(blocked_until),
                'wash_blocked_until': blocked_until
            })

        return actions

    # ========================================================================
    # PHASE 2: VALIDATION & REFUSAL (DETERMINISTIC GATES)
    # ========================================================================
    # RULE 1.2: Normalize ticker symbols to uppercase

    def _normalize_tickers(self, query: str, portfolio_index: Dict[str, Any]) -> str:
        """
        Find ticker references in query and normalize to uppercase.
        Only replaces tickers that exist in portfolio_index.
        """
        normalized = query

        # Find all potential ticker symbols (2-5 uppercase letters)
        potential_tickers = re.findall(r'\b[A-Za-z]{2,5}\b', query)

        for ticker in potential_tickers:
            ticker_upper = ticker.upper()
            # Only normalize if it's in the portfolio
            if ticker_upper in portfolio_index:
                # Replace case-insensitive
                normalized = re.sub(
                    rf'\b{re.escape(ticker)}\b',
                    ticker_upper,
                    normalized,
                    flags=re.IGNORECASE
                )

        return normalized

    # RULE 2.1: Enforce atomic execution (ONE question per response)

    def _detect_multiple_questions(self, query: str) -> bool:
        """
        Detect if query contains multiple questions.
        Returns True if multiple questions detected.
        """
        # Count question marks
        question_marks = query.count('?')
        if question_marks > 1:
            return True

        # Check for list markers
        list_patterns = [
            r'\b(first|second|third|also|additionally|and then)\b',
            r'\b\d+\.',  # 1. 2. 3.
            r'\b(and|also)\s+(what|how|which|show|tell|list)',
        ]

        for pattern in list_patterns:
            if re.search(pattern, query, re.IGNORECASE):
                return True

        # Check for multiple imperative verbs
        imperatives = ['show', 'list', 'tell', 'give', 'what', 'which', 'how']
        imperative_count = sum(1 for imp in imperatives if re.search(rf'\b{imp}\b', query, re.IGNORECASE))
        if imperative_count > 1:
            return True

        return False

    # RULE 2.2: Refuse strategy/judgment questions

    def _is_strategy_question(self, query: str) -> bool:
        """
        Detect if query asks for strategy, judgment, or advice.
        Returns True if strategy question detected.
        """
        strategy_patterns = [
            r'\b(should|recommend|suggest|advice|opinion)\b',
            r'\b(strategy|tactical|best|better|worse|prefer)\b',
            r'\b(rank|rate|evaluate|assess|judge|compare)\b',
            r'\b(trim|rebalance|adjust|optimize)\b',
            r'\b(suitable|appropriate|good|bad)\b',
            r'\b(when should|timing|safe to sell|can I sell|should I buy)\b',
            r'\b(tax implications|tax.?sale|compliance|violation)\b',
        ]

        return any(re.search(p, query, re.IGNORECASE) for p in strategy_patterns)

    # RULE 2.3: Ticker existence validation

    def _extract_tickers_from_query(self, query: str) -> List[str]:
        """Extract potential ticker symbols from query."""
        # Match 2-5 uppercase letter words (common ticker pattern)
        potential_tickers = re.findall(r'\b[A-Z]{2,5}\b', query)
        return list(set(potential_tickers))  # Deduplicate

    def _validate_tickers(self, tickers: List[str], portfolio_index: Dict[str, Any]) -> Tuple[bool, str]:
        """
        Validate that all extracted tickers exist in PORTFOLIO_INDEX.
        Returns (is_valid, error_message)
        """
        for ticker in tickers:
            if ticker not in portfolio_index:
                return False, f"Ticker {ticker} not found in PORTFOLIO_INDEX"
        return True, ""

    # ========================================================================
    # PHASE 3: QUERY CLASSIFICATION
    # ========================================================================
    # RULE 3.1: Classify query type

    def _classify_query_type(self, query: str) -> str:
        """
        Classify query into one of 7 supported types.
        Returns query_type string or 'unsupported'.
        """
        query_lower = query.lower()

        # ticker_existence - "do I hold X?", "is X in portfolio?"
        if re.search(r'\b(do i hold|do i own|is .+ in|have .+ in portfolio)\b', query_lower):
            return 'ticker_existence'

        # single_position - "what is my X position?", "show me X", "how many shares"
        if re.search(r'\b(what is my .+ position|show me |position in |how much |how many shares|shares of|quantity of)\b', query_lower):
            # Check if asking about a specific ticker
            tickers = self._extract_tickers_from_query(query)
            if len(tickers) == 1:
                return 'single_position'

        # portfolio_inventory - "list all tickers", "what do I hold?"
        if re.search(r'\b(list all|all tickers|all holdings|what do I hold|inventory|everything)\b', query_lower):
            return 'portfolio_inventory'

        # allocation_filter - "holdings above/below X%", "positions over"
        if re.search(r'\b(above|below|over|under|greater than|less than).+\d+.*%', query_lower):
            return 'allocation_filter'
        if re.search(r'\b\d+.*%.*?(above|below|over|under)', query_lower):
            return 'allocation_filter'

        # holding_classification - "short-term holdings", "long-term positions"
        if re.search(r'\b(short.?term|long.?term) (holdings|positions)', query_lower):
            return 'holding_classification'

        # concentration_risk - "over limit", "concentrated positions"
        if re.search(r'\b(over limit|concentration|concentrated|risk)', query_lower):
            return 'concentration_risk'

        # tos_order - "create order", "buy/sell ticket", "order for"
        if re.search(r'\b(create order|buy order|sell order|ticket|order for|tos order)\b', query_lower):
            return 'tos_order'

        # Unsupported query type
        return 'unsupported'

    # ========================================================================
    # PHASE 4: QUERY HANDLERS (DETERMINISTIC - EXTRACT ONLY, NO MATH)
    # ========================================================================

    def _handle_ticker_existence(
        self,
        ticker: str,
        portfolio_index: Dict[str, Any]
    ) -> Tuple[str, bool]:
        """
        Check if ticker exists in portfolio.
        Returns (response_text, skip_llm_flag)

        RULE 4.2: Simple deterministic response - can skip LLM
        """
        if ticker in portfolio_index:
            return f"Yes, {ticker} is held in the portfolio.", True
        else:
            return f"Ticker {ticker} not found in PORTFOLIO_INDEX", True

    def _handle_single_position(
        self,
        ticker: str,
        portfolio_index: Dict[str, Any],
        portfolio_path: str
    ) -> Dict[str, Any]:
        """
        Get detailed position data for a single ticker.
        Returns structured data for LLM presentation.

        RULE 4.1: Extract only, no computation
        """
        # Get data from PORTFOLIO_INDEX
        index_data = portfolio_index.get(ticker, {})

        # Load Position Allocation table for detailed data
        position_section = self._load_portfolio_section(portfolio_path, 'Position Allocation')
        positions = self._parse_position_table(position_section)

        # Find matching position
        position = next((p for p in positions if p['symbol'] == ticker), None)

        if not position:
            # Fallback to index data only
            return {
                'ticker': ticker,
                'allocation_pct': index_data.get('allocation_pct', 0),
                'gain_loss_pct': index_data.get('gain_loss_pct', 0),
                'holding_period': index_data.get('holding_period', 'Unknown')
            }

        return {
            'ticker': ticker,
            'quantity': position.get('quantity', 0),
            'price': position.get('price', 0),
            'value': position.get('value', 0),
            'allocation_pct': index_data.get('allocation_pct', 0),
            'gain_loss_pct': index_data.get('gain_loss_pct', 0),
            'holding_period': index_data.get('holding_period', 'Unknown')
        }

    def _handle_portfolio_inventory(
        self,
        portfolio_index: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Return complete list of tickers and count.

        RULE 4.1: Extract only
        """
        tickers = sorted(portfolio_index.keys())
        return {
            'tickers': tickers,
            'count': len(tickers)
        }

    def _handle_allocation_filter(
        self,
        query: str,
        portfolio_index: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Filter positions by allocation percentage threshold.

        RULE 4.1: Extract and filter, no computation
        """
        # Extract threshold and operator
        threshold_match = re.search(r'(\d+\.?\d*)\s*%', query)
        if not threshold_match:
            return {'error': 'Could not extract allocation threshold'}

        threshold = float(threshold_match.group(1))

        # Determine operator (above/below)
        operator = 'above' if re.search(r'\b(above|over|greater|more)\b', query, re.IGNORECASE) else 'below'

        # Filter positions
        filtered = []
        for ticker, data in portfolio_index.items():
            allocation = data.get('allocation_pct', 0)

            if operator == 'above' and allocation > threshold:
                filtered.append({
                    'ticker': ticker,
                    'allocation_pct': allocation,
                    'gain_loss_pct': data.get('gain_loss_pct', 0),
                    'holding_period': data.get('holding_period', 'Unknown')
                })
            elif operator == 'below' and allocation < threshold:
                filtered.append({
                    'ticker': ticker,
                    'allocation_pct': allocation,
                    'gain_loss_pct': data.get('gain_loss_pct', 0),
                    'holding_period': data.get('holding_period', 'Unknown')
                })

        # Sort by allocation descending
        filtered.sort(key=lambda x: x['allocation_pct'], reverse=True)

        return {
            'threshold': threshold,
            'operator': operator,
            'positions': filtered,
            'count': len(filtered)
        }

    def _handle_holding_classification(
        self,
        query: str,
        portfolio_index: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Filter positions by holding period (short-term or long-term).

        RULE 4.1: Extract and filter
        """
        # Determine term type
        term_type = 'short-term' if re.search(r'\bshort.?term\b', query, re.IGNORECASE) else 'long-term'

        # Filter by holding period
        filtered = []
        for ticker, data in portfolio_index.items():
            holding_period = data.get('holding_period', '').lower()

            if term_type.lower() in holding_period:
                filtered.append({
                    'ticker': ticker,
                    'allocation_pct': data.get('allocation_pct', 0),
                    'gain_loss_pct': data.get('gain_loss_pct', 0),
                    'holding_period': data.get('holding_period', 'Unknown')
                })

        # Sort by allocation descending
        filtered.sort(key=lambda x: x['allocation_pct'], reverse=True)

        return {
            'term_type': term_type,
            'positions': filtered,
            'count': len(filtered)
        }

    def _handle_concentration_risk(
        self,
        portfolio_path: str
    ) -> Dict[str, Any]:
        """
        Extract positions over limit from Tax Flags Summary.

        RULE 4.1: Extract only from pre-computed section
        """
        # Load Tax Flags Summary section
        tax_flags = self._load_portfolio_section(portfolio_path, 'Tax Flags Summary')

        # Parse "Positions Over 10% Limit" subsection
        over_limit = []

        if 'Positions Over 10% Limit' in tax_flags:
            # Extract lines after this header
            lines = tax_flags.split('Positions Over 10% Limit')[1].split('###')[0]

            # Parse lines like: - **SCHF**: 10.8% (+0.8% over limit)
            pattern = r'\*\*([A-Z]+)\*\*:\s*(\d+\.?\d*)%\s*\(\+(\d+\.?\d*)%\s*over limit\)'

            for match in re.finditer(pattern, lines):
                ticker = match.group(1)
                allocation = float(match.group(2))
                overage = float(match.group(3))

                over_limit.append({
                    'ticker': ticker,
                    'allocation_pct': allocation,
                    'overage_pct': overage
                })

        return {
            'over_limit_positions': over_limit,
            'count': len(over_limit)
        }

    def _handle_tos_order(
        self,
        query: str,
        portfolio_path: str
    ) -> Dict[str, Any]:
        """
        Extract TOS order from pre-computed rebalance actions.
        Applies deterministic wash sale gate.

        RULE 4.2 (TOS handler): Extract from rebalance_actions + wash sale gate

        Returns:
            - If wash blocked: refuse with specific end date
            - If not blocked: return order ticket + warnings
        """
        # Extract ticker from query
        tickers = self._extract_tickers_from_query(query)
        if not tickers:
            return {'error': 'No ticker found in query'}

        ticker = tickers[0]  # Use first ticker found

        # Load Rebalance Actions section
        rebalance_section = self._load_portfolio_section(portfolio_path, 'Rebalance Actions')
        actions = self._parse_rebalance_actions(rebalance_section)

        # Find action for this ticker
        action = next((a for a in actions if a['ticker'] == ticker), None)

        if not action:
            return {
                'error': f'No rebalance action found for {ticker}. Ticker may already be at target allocation.'
            }

        # DETERMINISTIC WASH SALE GATE
        if action['wash_blocked']:
            # REFUSE with specific date
            return {
                'wash_blocked': True,
                'ticker': ticker,
                'blocked_until': action['wash_blocked_until'],
                'refusal_message': f"Order for {ticker} is BLOCKED due to wash sale risk until {action['wash_blocked_until']}.\n\nSelling at a loss before this date would trigger wash sale rules."
            }

        # NOT BLOCKED - return order ticket
        # Determine order action
        order_action = 'BUY' if action['action'] in ['Buy', 'Build'] else 'SELL'

        # Load position data for current price
        position_section = self._load_portfolio_section(portfolio_path, 'Position Allocation')
        positions = self._parse_position_table(position_section)
        position = next((p for p in positions if p['symbol'] == ticker), None)

        current_price = position['price'] if position else 0

        return {
            'wash_blocked': False,
            'ticker': ticker,
            'action': order_action,
            'shares': abs(action['shares']),
            'price': current_price,
            'current_pct': action['current_pct'],
            'target_pct': action['target_pct'],
            'diff_pct': action['diff_pct'],
            'dollar_amount': action['dollar_amount'],
            'order_type': 'LIMIT',
            'time_in_force': 'GTC',
            'warnings': []  # Could add warnings from tax flags if needed
        }

    # ========================================================================
    # PHASE 5: OUTPUT FORMATTING
    # ========================================================================
    # RULE 5.2: Literal, complete, exact output

    def _format_response(self, query_type: str, data: Dict[str, Any]) -> str:
        """
        Format response using strict templates.
        No freeform text generation - structured output only.
        """
        if query_type == 'ticker_existence':
            # Simple yes/no - already formatted in handler
            return data

        elif query_type == 'single_position':
            return f"""Position: {data['ticker']}
Quantity: {data.get('quantity', 'N/A')}
Price: ${data.get('price', 0):.2f}
Value: ${data.get('value', 0):,.2f}
Allocation: {data.get('allocation_pct', 0):.1f}%
Gain/Loss: {data.get('gain_loss_pct', 0):+.1f}%
Holding Period: {data.get('holding_period', 'Unknown')}"""

        elif query_type == 'portfolio_inventory':
            tickers_str = ', '.join(data['tickers'])
            return f"""Portfolio Inventory:
Total Holdings: {data['count']}

Tickers: {tickers_str}"""

        elif query_type == 'allocation_filter':
            if data.get('error'):
                return data['error']

            lines = [f"Positions {data['operator']} {data['threshold']}%:"]
            lines.append(f"Found {data['count']} positions\n")

            for pos in data['positions']:
                lines.append(f"- {pos['ticker']}: {pos['allocation_pct']:.1f}% | {pos['gain_loss_pct']:+.1f}% | {pos['holding_period']}")

            return '\n'.join(lines)

        elif query_type == 'holding_classification':
            lines = [f"{data['term_type'].title()} Holdings:"]
            lines.append(f"Found {data['count']} positions\n")

            for pos in data['positions']:
                lines.append(f"- {pos['ticker']}: {pos['allocation_pct']:.1f}% | {pos['gain_loss_pct']:+.1f}%")

            return '\n'.join(lines)

        elif query_type == 'concentration_risk':
            if data['count'] == 0:
                return "No positions over 10% limit."

            lines = ["Positions Over 10% Limit:"]
            for pos in data['over_limit_positions']:
                lines.append(f"- {pos['ticker']}: {pos['allocation_pct']:.1f}% (+{pos['overage_pct']:.1f}% over limit)")

            return '\n'.join(lines)

        elif query_type == 'tos_order':
            if data.get('error'):
                return data['error']

            if data.get('wash_blocked'):
                return data['refusal_message']

            # Format order ticket
            lines = [
                f"TOS Order Ticket for {data['ticker']}:",
                f"",
                f"Action: {data['action']} {data['shares']} shares",
                f"Price: ${data['price']:.2f} LIMIT",
                f"Time in Force: {data['time_in_force']}",
                f"",
                f"Rationale:",
                f"- Current allocation: {data['current_pct']:.1f}%",
                f"- Target allocation: {data['target_pct']:.1f}%",
                f"- Adjustment: {data['action']} {data['diff_pct']:.1f}% (~${data['dollar_amount']:,.2f})",
            ]

            if data.get('warnings'):
                lines.append("")
                lines.append("Warnings:")
                for warning in data['warnings']:
                    lines.append(f"- {warning}")

            return '\n'.join(lines)

        else:
            return f"Unsupported query type: {query_type}"

    def _create_llm_messages(self, summary: str, original_query: str) -> List[Dict[str, str]]:
        """
        Create messages for LLM presentation.
        LLM's ONLY job is formatting - no interpretation or advice.

        RULE 6.1: LLM receives ONLY presentation-ready data
        """
        return [
            {
                "role": "system",
                "content": """You are Jake, a portfolio data assistant operating in FACTS-ONLY mode.

Present the data below to the user in a clear, professional format.

ABSOLUTE RULES:
- DO NOT add interpretation, advice, or additional context
- DO NOT suggest actions or strategies
- ONLY format the data provided below
- If the data includes an error or refusal, present it verbatim

DATA TO PRESENT:"""
            },
            {
                "role": "user",
                "content": f"""{summary}

---
Original question: {original_query}"""
            }
        ]

    # ========================================================================
    # MAIN ORCHESTRATION
    # ========================================================================

    def pipe(self, body: dict) -> dict:
        """
        Main orchestration method - implements deterministic query processing.

        Flow:
        1. Load PORTFOLIO_INDEX (always required)
        2. Extract and validate query
        3. Apply refusal gates (strategy, multiple questions, invalid tickers)
        4. Classify query type
        5. Execute handler (lazy-load additional sections as needed)
        6. Format response
        7. Return (with or without LLM call)
        """
        # ====================================================================
        # STEP 1: LOAD PORTFOLIO_INDEX (AUTHORITATIVE SOURCE)
        # ====================================================================

        portfolio_path = os.path.expanduser(self.valves.portfolio_path)

        if not os.path.exists(portfolio_path):
            return f"ERROR: Portfolio file not found at {portfolio_path}"

        portfolio_index = self._load_portfolio_index(portfolio_path)

        if not portfolio_index:
            return "ERROR: PORTFOLIO_INDEX section not found in portfolio file"

        # ====================================================================
        # STEP 2: EXTRACT QUERY
        # ====================================================================

        messages = body.get("messages", [])

        # Find last user message
        user_query = None
        for msg in reversed(messages):
            if msg.get("role") == "user":
                user_query = msg.get("content", "")
                break

        if not user_query:
            return {
                "error": True,
                "message": "ERROR: No user query found"
            }

        # Normalize tickers in query
        normalized_query = self._normalize_tickers(user_query, portfolio_index)

        # ====================================================================
        # STEP 3: VALIDATION & REFUSAL GATES (DETERMINISTIC)
        # ====================================================================

        # GATE 1: Multiple questions
        if self._detect_multiple_questions(normalized_query):
            return "Multiple factual questions detected.\nPlease ask ONE portfolio facts question at a time."

        # GATE 2: Strategy/judgment questions
        if self._is_strategy_question(normalized_query):
            return "This question requires portfolio strategy or judgment.\nI am operating in FACTS-ONLY mode and cannot answer it.\nPlease switch to the Strategy model."

        # ====================================================================
        # STEP 3.5: CLASSIFY QUERY TYPE (BEFORE TICKER VALIDATION)
        # ====================================================================
        # Classification must happen before ticker validation because
        # ticker_existence queries are specifically asking IF a ticker exists

        query_type = self._classify_query_type(normalized_query)

        # GATE 3: Ticker validation (skip for ticker_existence and inventory queries)
        tickers = self._extract_tickers_from_query(normalized_query)

        # GATE 3a: Multiple tickers in single-ticker query types
        if len(tickers) > 1 and query_type in ['single_position', 'ticker_existence', 'tos_order']:
            ticker_list = ', '.join(tickers)
            return f"Multiple tickers detected: {ticker_list}\n\nPlease ask about ONE ticker at a time.\n\nExample: What is my {tickers[0]} position?"

        # Only validate if:
        # - Tickers were found
        # - NOT a ticker_existence query (those are asking if ticker exists)
        # - NOT a portfolio_inventory query (those don't reference specific tickers)
        if tickers and query_type not in ['ticker_existence', 'portfolio_inventory']:
            valid, error_msg = self._validate_tickers(tickers, portfolio_index)
            if not valid:
                return error_msg

        # ====================================================================
        # STEP 4: HANDLE UNSUPPORTED QUERY TYPES
        # ====================================================================

        # Refuse unsupported query types
        if query_type == 'unsupported':
            # Check if it's a single-word ticker query (e.g., "vti")
            if len(normalized_query.strip().split()) == 1 and tickers:
                ticker = tickers[0]
                return f"Single-word ticker queries are not supported.\n\nPlease ask a specific question, e.g.:\n- What is my {ticker} position?\n- Do I hold {ticker}?\n- How many shares of {ticker} do I have?"
            else:
                return "This query type is not supported in FACTS-ONLY mode.\n\nSupported query types:\n- Ticker existence check\n- Single position lookup\n- Portfolio inventory\n- Allocation filter\n- Holding classification\n- Concentration risk\n- TOS order generation"

        # ====================================================================
        # STEP 5: EXECUTE HANDLER (LAZY LOADING)
        # ====================================================================

        try:
            if query_type == 'ticker_existence':
                ticker = tickers[0] if tickers else None
                if not ticker:
                    result = "ERROR: No ticker specified"
                    skip_llm = True
                else:
                    result, skip_llm = self._handle_ticker_existence(ticker, portfolio_index)

            elif query_type == 'single_position':
                ticker = tickers[0] if tickers else None
                if not ticker:
                    result = "ERROR: No ticker specified"
                    skip_llm = False
                else:
                    data = self._handle_single_position(ticker, portfolio_index, portfolio_path)
                    result = self._format_response(query_type, data)
                    skip_llm = False

            elif query_type == 'portfolio_inventory':
                data = self._handle_portfolio_inventory(portfolio_index)
                result = self._format_response(query_type, data)
                skip_llm = False

            elif query_type == 'allocation_filter':
                data = self._handle_allocation_filter(normalized_query, portfolio_index)
                result = self._format_response(query_type, data)
                skip_llm = False

            elif query_type == 'holding_classification':
                data = self._handle_holding_classification(normalized_query, portfolio_index)
                result = self._format_response(query_type, data)
                skip_llm = False

            elif query_type == 'concentration_risk':
                data = self._handle_concentration_risk(portfolio_path)
                result = self._format_response(query_type, data)
                skip_llm = False

            elif query_type == 'tos_order':
                data = self._handle_tos_order(normalized_query, portfolio_path)
                result = self._format_response(query_type, data)
                # Skip LLM for wash blocked orders (they're refusals)
                skip_llm = data.get('wash_blocked', False)

            else:
                result = f"ERROR: Unhandled query type: {query_type}"
                skip_llm = True

        except Exception as e:
            result = f"ERROR processing query: {str(e)}"
            skip_llm = True

        # ====================================================================
        # STEP 6: RETURN (WITH OR WITHOUT LLM)
        # ====================================================================

        # Return the result string directly (Open WebUI pipes return strings, not message dicts)
        return result
