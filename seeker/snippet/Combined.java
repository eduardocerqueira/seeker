//date: 2025-04-15T16:31:29Z
//url: https://api.github.com/gists/4d943bd6e9ea305ff9d5e6d0b161ccc3
//owner: https://api.github.com/users/burakbayramli

/** commons-lang3-3.13.0.jar is needed for compilation **/
import java.util.*;
import java.util.stream.Collectors;
import java.lang.Math;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.Calendar;
import java.util.Date;
import java.util.Arrays;
import java.util.Date;
import java.util.List;
import java.text.*;  // DateFormat etc.
import java.net.*;
import java.io.*;
import java.util.StringTokenizer;
import java.util.TimeZone;
import java.math.*;

class AyaInit {
  double t0;
  double ayan_t0;
  AyaInit(double t0, double ayan_t0) {
    this.t0=t0;
    this.ayan_t0=ayan_t0;
  }
}
class CFmt {
  // public:
  // Constructors:
  
  public CFmt() {
    this.hexByteCnt=8;
  }
  
  public CFmt(int hexByteCnt) {
    setHexByteCnt(hexByteCnt);
  }
  // Public Methods: /////////////////////////////////////////////////////////
  
  public void setHexByteCnt(int hexByteCnt) {
    if (hexByteCnt==8 || hexByteCnt==4) {
      this.hexByteCnt=hexByteCnt;
    }
  }
  
  public int getHexByteCnt() {
    return this.hexByteCnt;
  }
  // Methods for conversion: /////////////////////////////////////////////////
  // char "c":
  
  public String fmt( String conv, char c ) {
    return fmt(conv, new Character(c).toString());
  }
  // Strings "s":
  
  public String fmt( String conv, String s ) {
    CFmtCvt cv = new CFmtCvt(conv);
    if (cv.type=='c') {
      s=s.substring(0,1);
    } else if (cv.type!='s') {
      return "";
    }
    // Precision:
    if (cv.withPrec && cv.precision<s.length() && cv.type!='c') {
      s=s.substring(0,cv.precision);
    }
    // MinimumFieldWidth:
    if (cv.minimum>320) { cv.minimum=320; }
    String padString=empty;
    if (cv.padChar=='0' && !cv.fMinus) { padString=zeros; }
    if (cv.withMin && s.length()<cv.minimum) {
      if (cv.fMinus) {
        s+=padString.substring(0,cv.minimum-s.length());
      } else {
        s=padString.substring(0,cv.minimum-s.length())+s;
      }
    }
    return s;
  }
  // byte d,i,o,p,u,x,X:
  
  public String fmt( String conv, byte bval ) {
    return intFmt(conv, (long) bval, 'b');
  }
  
  public String fmt( String conv, int ival  ) {
    return intFmt(conv, (long) ival, 'i');
  }
  
  public String fmt( String conv, long lval  ) {
    return intFmt(conv, lval, 'l');
  }
  
  public String fmt( String conv, float fval  ) {
    return fmt( conv, (double)fval );
  }
  
  public String fmt( String conv, double dval  ) {
    CFmtCvt cv = new CFmtCvt(conv);
    boolean isG=false;
    boolean neg=false;
    String res="";
    neg=(Double.doubleToLongBits(dval)&0x8000000000000000L)!=0L;
    if (Double.isNaN(dval)) { res="nan"; }
    if (dval == Double.NEGATIVE_INFINITY ||
        dval == Double.POSITIVE_INFINITY) {
      if (cv.precision<8) { res="Inf";
      } else { res="Infinity";
      }
    }
    if (neg) { dval=-dval; }
    if (res=="") {
      if (!cv.withPrec) { cv.precision=6; cv.withPrec=true; }
      if (cv.type=='g' || cv.type=='G') { isG=true; }
double dval_tmp=dval; 
      int pexp=0;
      int nexp=0;
      if (dval_tmp!=0.) {
        double fd=dval_tmp;
        while (fd>=10.) { fd/=10.; pexp++; }
        while (fd<1.) { fd*=10.; nexp++; }
        if (isG) {
          if (cv.precision==0) { cv.precision++; }
          dval_tmp+=5*Math.pow(10,pexp-nexp-cv.precision);
        } else {
          if (cv.type=='e' || cv.type=='E') { // Exponential number:
            dval_tmp+=5*Math.pow(10,-cv.precision-1+pexp-nexp);
          } else { // Floatingpoint number without exponent:
            dval_tmp+=5*Math.pow(10,-cv.precision-1);
          }
        }
      }
      if (isG) {
        if (dval_tmp!=0. && (dval_tmp<1E-4 || dval_tmp>=Math.pow(10,cv.precision))) {
          if (cv.precision>0) { cv.precision--; } // Digit before decimalpoint
          if (cv.type=='g') { cv.type='e';
          } else { cv.type='E';
          }
        } else {
          cv.precision=cv.precision-pexp-1+nexp;
          cv.type='f';
        }
        if (cv.precision<0) { cv.precision=0; }
      }
      if (cv.type!='f' && cv.type!='e' && cv.type!='E') {
        return "";
      }
      String integer="";
      String mantisse="";
      int exponent=0;
      int i;
res=dblToString(dval,cv.precision); // Includes rounding!!!
      exponent=res.indexOf(".")-1;
      integer=res.substring(0,exponent+1);
      mantisse=res.substring(exponent+2);
      if (mantisse.indexOf("E")>=0) {
        exponent+=Integer.parseInt(mantisse.substring(mantisse.indexOf("E")+1));
        mantisse=mantisse.substring(0,mantisse.indexOf("E"));
      }
      // "integer" is supposed to hold all digits
      if (integer.charAt(0)=='0' && dval!=0.) {
        exponent--; i=0;
        integer=integer.substring(1);
        while (i<mantisse.length() && mantisse.charAt(i)=='0') {
          exponent--; i++;
        }
        mantisse=mantisse.substring(i);
      }
      integer+=mantisse;
      mantisse="";
      // Separating integer part and mantissa into the desired forms ('f', 'e')
      if (cv.type=='f') {
        if (exponent<0) {
          mantisse=zeros.substring(0,-exponent-1)+integer;
          integer="0";
        } else {
          if (integer.length()<exponent+1) {
            integer+=zeros.substring(0,exponent+1-integer.length());
          }
          mantisse=integer.substring(exponent+1);
          integer=integer.substring(0,exponent+1);
        }
      } else { // Exponential form
        mantisse=integer.substring(1);
        integer=integer.substring(0,1);
      }
      if (cv.precision>320) { cv.precision=320; }
      int len=mantisse.length();
      if (cv.precision>len && (!isG || cv.fHash)) {
        mantisse+=zeros.substring(0,cv.precision-len);
      } else if (cv.precision<len) {
        mantisse=mantisse.substring(0,cv.precision);
      }
      if (isG && !cv.fHash) {
        i=mantisse.length()-1;
        while (i>=0 && mantisse.charAt(i)=='0') {
          i--;
        }
        mantisse=mantisse.substring(0,i+1);
      }
      res=integer;
      if (cv.fHash || (cv.withPrec && !isG && cv.precision>0) ||
          (isG && cv.withPrec && mantisse.length()>0 )) {
        res+="."+mantisse;
      }
      if (cv.type=='e' || cv.type=='E') {
        if (cv.type=='e') { res+="e"; } else { res+='E'; }
        if (exponent<0) {
          exponent=-exponent; res+="-";
        } else {
          res+="+";
        }
        if (exponent<10) {
          res+="0";
        }
        res+=Integer.toString(exponent);
      }
    }
    String prefix="";
    if (neg) { prefix="-";
    } else if (cv.fPlus) { prefix="+";
    } else if (cv.fSpace) { prefix=" ";
    }
    if (cv.withMin && cv.padChar=='0') {
      int len=prefix.length();
      // Pad left, before a sign or others will be prefixed!
      if (res.length()+len<cv.minimum && !cv.fMinus) {
        res=zeros.substring(0,cv.minimum-res.length()-len)+res;
      }
    }
    res=prefix+res;
    // MinimumFieldWidth:
    if (cv.withMin) {
      if (res.length()<cv.minimum) {
        if (cv.minimum>320) { cv.minimum=320; }
        if (cv.fMinus) {
          res+=empty.substring(0,cv.minimum-res.length());
        } else {
          String padString=empty;
          if (cv.padChar=='0') { padString=zeros; }
          res=padString.substring(0,cv.minimum-res.length())+res;
        }
      }
    }
    return res;
  } // double
  // Private Methods: ////////////////////////////////////////////////////////
  private String intFmt( String conv, long lval, char baseType ) {
    CFmtCvt cv = new CFmtCvt(conv);
    if (cv.type!='d' && cv.type!='i' && cv.type!='o' && cv.type!='p' &&
        cv.type!='u' && cv.type!='x' && cv.type!='X') {
      return "";
    }
    if (baseType=='l' && cv.type=='u') { return ""; }
    boolean neg=false;
    String res="";
    String padString=empty;
    if (cv.type=='d' || cv.type=='i') { // signed decimal
      if (lval<0) { lval=-lval; neg=true; }
      res=String.valueOf(lval);
    } else if (cv.type=='o') { // unsigned octal
      res=Long.toOctalString(lval);
      if (lval<0 && this.hexByteCnt==4 && baseType!='l') {
        // 1 777 777 777 777 777 777 777 -> 37777777777 [         -1]
        // 1 777 777 777 760 000 000 000 -> 20000000000 [-2147483648]
        if (res.charAt(11)=='7') {
          res="3"+res.substring(12);
        } else {
          res="2"+res.substring(12);
        }
      }
    } else if (cv.type=='u') { // unsigned decimal
      if (lval>=0) {
        res=Long.toString(lval);
      } else { // Negative number to be interpreted as positive
        res=Long.toString(256L*256L*256L*256L+lval);
      }
    } else if (cv.type=='x' || cv.type=='p' || cv.type=='X') {
                                                     // unsigned hexadecimal
      // "p" exists ONLY as "%p" without any modifications and then seems to
      // be identical with "%x"!
      res=Long.toHexString(lval);
      if (cv.type=='p' && (cv.withPrec || cv.withMin || cv.fMinus ||
                                    cv.fPlus || cv.fSpace || cv.fHash)) {
        return "";
      }
      if (this.hexByteCnt==4 && baseType!='l') { res=res.substring(8); }
    }
    // Precision:
    // Minimum count of digits (WITHOUT sign!). Add zeros before the number
    // if necessary.
    if (!cv.withPrec) { cv.precision=1; }
    if (cv.precision>320) { cv.precision=320; }
    if (cv.precision>res.length()) {
      res=zeros.substring(0,cv.precision-res.length())+res;
    } else if (cv.precision==0 && lval==0) {
      res="";
    }
    String prefix="";
    if (cv.type=='d' || cv.type=='i') { // negative / positive
      // Flags:
      if (neg) {
        prefix="-";
      } else if (cv.fPlus) {
        prefix="+";
      } else if (cv.fSpace) {
        prefix=" ";
      }
    } else if (cv.type=='o' && cv.fHash && res.charAt(0)!='0') {
      res="0"+res;
    } else if (cv.fHash && lval!=0 && (cv.type=='x' || cv.type=='X')) {
      prefix="0x";
    }
    // MinimumFieldWidth:
    if (cv.minimum>320) { cv.minimum=320; }
    if (cv.withPrec) { cv.padChar=' '; }
    if (cv.padChar=='0' && !cv.fMinus) { padString=zeros; }
    if (cv.withMin) {
      if (cv.padChar=='0') {
        // First pad, then add sign in front:
        int len=prefix.length();
        if (res.length()+len<cv.minimum) {
          res=padString.substring(0,cv.minimum-res.length()-len)+res;
        }
        res=prefix+res;
      } else {
        // First the sign, then pad the string
        res=prefix+res;
        if (res.length()<cv.minimum) {
          if (cv.fMinus) {
            res+=empty.substring(0,cv.minimum-res.length());
          } else {
            res=empty.substring(0,cv.minimum-res.length())+res;
          }
        }
      }
    } else {
      res=prefix+res;
    }
    if (cv.type=='X') { // ALL letters uppercase
      res=res.toUpperCase();
    }
    return res;
  }
  private int hexByteCnt;
  // 340 chars (how much max.?)
  static private final String empty="                                        "+
        "                                                            "+
        "                                                            "+
        "                                                            "+
        "                                                            "+
        "                                                            ";
  static private final String zeros="0000000000000000000000000000000000000000"+
        "000000000000000000000000000000000000000000000000000000000000"+
        "000000000000000000000000000000000000000000000000000000000000"+
        "000000000000000000000000000000000000000000000000000000000000"+
        "000000000000000000000000000000000000000000000000000000000000"+
        "000000000000000000000000000000000000000000000000000000000000";
  private BigDecimal const2_52=new BigDecimal("2251799813685248");
  private BigDecimal const2=new BigDecimal("2");
  private String dblToString(double d, int prec) {
    long exp, i, lMant;
    boolean nexp=false;

    lMant=Double.doubleToLongBits(d)&0x000fffffffffffffL;
    exp =(Double.doubleToLongBits(d)&0x3ff0000000000000L) >> 52;
    nexp=(Double.doubleToLongBits(d)&0x4000000000000000L) == 0L;
    if (nexp) { exp=-1024+exp; }
    BigDecimal mant=new BigDecimal(Long.toString(lMant));
    BigDecimal res=new BigDecimal("0");
    BigDecimal res1;
    if (exp==0 && lMant==0L) {
      res1=new BigDecimal("0");
    } else {
      res1=new BigDecimal("1");
      if (exp>0) {
        for(i=0; i<exp; i++) {
          res1=res1.multiply(const2);
        }
      } else {
        for(i=0; i>exp; i--) {
          res1=res1.divide(const2,50,BigDecimal.ROUND_HALF_UP);
        }
      }
    }
    res=res1.multiply(const2);
    res=res.add(res1.multiply(mant.divide(const2_52,50,BigDecimal.ROUND_HALF_UP)));
    res=res.add((new BigDecimal("5")).movePointLeft(prec+1));
    return res.toString();
  }
} // End of class CFmt
class CFmtCvt { // Interprets a formatting string
  char flag='\0';
  boolean fMinus=false;
  boolean fPlus=false;
  boolean fSpace=false;
  boolean fHash=false;
  char padChar=' ';
  int minimum=0;
  int precision=0;
  boolean longSpec=false; // longSpec does not have any meaning???
  char type='\0';
  boolean withMin=false;
  boolean withPrec=false;
  boolean validConv=false;
  CFmtCvt(String cv) {
    char ch;
    int len=cv.length()-1;
    if (len>=1 && cv.charAt(0)=='%') {
      int i=1;
      type=cv.charAt(len); len--;
      if (cv.charAt(len)=='l') { longSpec=true; len--; }
      // Flags:
      do {
        ch=cv.charAt(i);
        if (ch=='-')      { fMinus=true; }
        else if (ch=='+') { fPlus=true;  }
        else if (ch==' ') { fSpace=true; }
        else if (ch=='#') { fHash=true;  }
        i++;
      } while (i<=len && (ch=='-' || ch=='+' || ch==' ' || ch=='#'));
      i--;
      // Minimum fieldwidth:
      ch=cv.charAt(i);
      if (ch=='0') {
        withMin=true;
        padChar='0';
        withMin=true;
        i++; if (i>len) { return; }
        ch=cv.charAt(i);
      }
      if (Character.isDigit(ch)) {
        withMin=true;
        minimum=Character.digit(ch,10);
        i++; if (i>len) { return; }
        ch=cv.charAt(i);
        while (Character.isDigit(ch)) {
          minimum=10*minimum+Character.digit(ch,10);
          i++; if (i>len) { return; }
          ch=cv.charAt(i);
        }
      }
      // Precision:
      if (ch=='.') {
        withPrec=true;
        i++; if (i>len) { return; }
        ch=cv.charAt(i);
        while (Character.isDigit(ch)) {
          precision=10*precision+Character.digit(ch,10);
          i++; ch=cv.charAt(i);
        }
      }
    }
  }
} // End of class CFmtCvt
class DblObj {
  
  public double val;
}
class DevNull {
  public static void print(String s) {}
  public static void println(String s) {}
  public static void println() {}
}
class Epsilon {
  
  double teps, eps, seps, ceps;         
  void clearData() {
    teps=0.0;
    eps=0.0;
    seps=0.0;
    ceps=0.0;
  }
}
class Extensions {
  SwissEph sw;
  Extensions(SwissEph sw) {
    this.sw = sw;
  }
  double getTransit(TransitCalculator tc, double jdET, boolean back,
                    double jdMax)
         throws IllegalArgumentException, SwissephException {
    double max = tc.getMaxSpeed();
    double min = tc.getMinSpeed();
    double jdPlus, jdMinus;
    double lastJD = jdET;
    boolean found = false;
    boolean above;
    double lastVal;
    double val;
    double offset = tc.getOffset();
    boolean xneg = (max < 0);
    boolean mneg = (min < 0);
    if (!xneg && !mneg) { min = max; }
    if (xneg && mneg) { max = min; }
    double degPrec = tc.getDegreePrecision(jdET)/2.; // Divided by two to have a range of +-degPrec
    double timePrec = tc.getTimePrecision(degPrec);
    val = tc.calc(jdET);
    if (offset-val == 0.) { // If not 0.0 but "very small", then
                            // interpolate after another calculation
                            // in the calculation loop below
      return jdET;
    }
    if (max == 0. && min == 0.) { // No possible change in position or speed
      throw new SwissephException(jdET, SwissephException.OUT_OF_TIME_RANGE,
          "No transit possible due to lack of variation of speed or position.");
    }
    while (true) {
      if (tc.rollover) {
        while (val >= tc.rolloverVal) { val -= tc.rolloverVal; }
        while (val < 0.) { val += tc.rolloverVal; }
      }
      above = (val >= offset);
      lastJD = jdET;
      lastVal = val;
      if (tc.rollover && !above) { val += tc.rolloverVal; }
      if (tc.rollover) {
        jdPlus  = Math.min(val-offset,360-val+offset)/Math.abs(max);
        jdMinus = Math.min(val-offset,360-val+offset)/Math.abs(min);
        if (back) {
          jdET -= Math.min(jdPlus,jdMinus);
        } else {
          jdET += Math.min(jdPlus,jdMinus);
        }
      } else { 
        jdPlus = (offset-val)/max;
        jdMinus = (offset-val)/min;
        if (back) {
          if (jdPlus >= 0 && jdMinus >= 0) {
            throw new SwissephException(jdET, SwissephException.OUT_OF_TIME_RANGE,
                -1, "No transit in ephemeris time range."); // I mean: No transits possible...
          } else if (jdPlus >= 0) {
            jdET += jdMinus;
          } else { // if (jdMinus >= 0)
            jdET += jdPlus;
          }
        } else {
          if (jdPlus <= 0 && jdMinus <= 0) {
            throw new SwissephException(jdET, SwissephException.OUT_OF_TIME_RANGE,
                -1, "No transit in ephemeris time range."); // I mean: No transits possible...
          } else if (jdPlus <= 0) {
            jdET += jdMinus;
          } else { // if (jdMinus <= 0)
            jdET += jdPlus;
          }
        }
      }
      if (Math.abs(jdET - lastJD) < timePrec) {
        jdET = lastJD + (back?-timePrec:+timePrec);
      }
      if (jdET == lastJD) {
        return jdET;
      }
      val = tc.calc(jdET);
      if (tc.rollover && val >= tc.rolloverVal) { val %= tc.rolloverVal; }
      while (tc.rollover && val < 0.) { val += tc.rolloverVal; }
      if (offset-val == 0.) {
        return jdET;
      }
      boolean pxway = true;
      if (tc.rollover) {
        double deltadeg1 = val-lastVal;
        if (deltadeg1<0) { deltadeg1+=tc.rolloverVal; }
        double deltadeg2 = lastVal-val;
        if (deltadeg2<0) { deltadeg2+=tc.rolloverVal; }
        pxway = Math.abs(deltadeg1/max)<Math.abs(deltadeg2/min);
      } else {
        pxway = lastVal<=val;
      }
      found = (// transits from higher deg. to lower deg.:
               ( above && val<=offset && !pxway) ||
               // transits from lower deg. to higher deg.:
               (!above && val>=offset &&  pxway)) ||
              (tc.rollover && (
               // transits from above the transit degree via rollover over
               // 0 degrees to a higher degree:
               (offset<lastVal && val>340. && lastVal<20. && !pxway) ||
               // transits from below the transit degree via rollover over
               // 360 degrees to a lower degree:
               (offset>lastVal && val<20. && lastVal>340. &&  pxway) ||
               // transits from below the transit degree via rollover over
               // 0 degrees to a higher degree:
               (offset>val && val>340. && lastVal<20. && !pxway) ||
               // transits from above the transit degree via rollover over
               // 360 degrees to a lower degree:
               (offset<val && val<20. && lastVal>340. &&  pxway))
              );
      if (found) { // Return an interpolated value, but not prior to (after)
                   // the initial time (if backward):
        if (tc.rollover) {
          if (tc.rollover && Math.abs(val - lastVal) > 300.) {   // How to do it formally correct???
            // Probably one value is about 359.99 and the other one is in the area of 0.01
            if (val > lastVal) { lastVal += tc.rolloverVal; } else { val += tc.rolloverVal; }
            if (offset < 10.) { offset += tc.rolloverVal; } // How to do it formally correct???
          }
          // offset-lastVal and val-lastVal have to have equal signs
          if (val-lastVal < 0 && offset-lastVal > 0) {
            val += tc.rolloverVal;
          } else if (val-lastVal > 0 && offset-lastVal < 0) {
            offset += tc.rolloverVal;
          }
        }
        double jdRet = lastJD+(jdET-lastJD)*(offset-lastVal)/(val-lastVal);
        if (back) {
          return Math.max(jdRet, jdET);
        } else {
          return Math.min(jdRet, jdET);
        }
      }
      if ((back && jdET < jdMax) ||
          (!back && jdET > jdMax)) {
        throw new SwissephException(jdET, SwissephException.BEYOND_USER_TIME_LIMIT,
            -1, "User time limit of " + jdMax + " has been reached.");
      }
    }
  }
  // The precision of a distance calculation is related to the barycentric
  // distance
  // E.g.: java Swetest -b1.1.0 -p0 -n100000 -fR -bary | sort -n
  protected double maxBaryDist[] = new double[] {
     0.009570999,    // 0 Sun        ==  0                   1.017545559
     1.028809521,    // 1 Moon       ==  1
     0.466604085,    // 2 Mercury    ==  2
     0.728698831,    // 3 Venus      ==  3
     0.728698831,    // 4 Mars       ==  4
     4.955912195,    // 5 Jupiter    ==  5
     8.968685733,    // 6 Saturn     ==  6
    19.893326756,    // 7 Uranus     ==  7
    30.326750627,    // 8 Neptune    ==  8
    41.499626899,    // 9 Pluto      ==  9
     0.002569555,    // m MeanNode   == 10
     0.002774851,    // t TrueNode   == 11
     1.0,            // A Mean Apog. == 12            // Does not vary distance anyway
     0.002782378,    // B Oscu.Apog. == 13
     0.0,            // C Earth      == 14 (skip)
     0.05,           // D Chiron     == 15            // No distance available, is 0.05 good???
    31.901319663,    // E Pholus     == 16
     3.012409508,    // F Ceres      == 17
     3.721614106,    // G Pallas     == 18
     3.326307148,    // H Juno       == 19
     2.570197288,    // I Vesta      == 20
  };
}

class FileData {
  final byte SEI_FILE_NMAXPLAN=50;
  String fnam;          
  int fversion;         
  String astnam;        
  int sweph_denum;     
  FilePtr fptr;
  double tfstart;       
  double tfend;         
  int iflg;             
  short npl;            
  int ipl[] = new int[SEI_FILE_NMAXPLAN]; 
  void clearData() {
    int j;
    fnam="";
    fversion=0;
    astnam="";
    sweph_denum=0;
    try {
      if (fptr!=null) { fptr.close(); }
    } catch (java.io.IOException e) {
    }
    fptr=null;
    tfstart=0.0;
    tfend=0.0;
    iflg=0;
    npl=0;
    for(j=0; j<SEI_FILE_NMAXPLAN; j++) { ipl[j]=0; }
  }
//
  
  int read_const(int ifno, StringBuffer serr, SwissData swed) {
    String s="";
    String s2="";
    String sastnam="";
    int i, ipli, kpl;
    int fendian, freord;
    int lastnam = 19;
    long lng;
    long ulng; // hat 'unsigned' long hier eine wesentliche Bedeutung?
    long flen, fpos;
    short nplan;
    PlanData pdp;
    String serr_file_damage = "Ephemeris file "+fnam+" is damaged. ";
    int nbytes_ipl = 2;
    try {
      
      byte b=0;
      char cLast;
      do {
        cLast=(char)b;
        b=fptr.readByte();
        s+=(char)b;
      } while (cLast!='\r' && (char)(b)!='\n' && s.length()<SwissData.AS_MAXCH);
      s=s.trim();
      int offs=0;
      int ver=-1;
      while (!Character.isDigit(s.charAt(offs))) { offs++; }
      try {
        ver=Integer.parseInt(s.substring(offs));
      } catch (NumberFormatException n) {
        DevNull.println(serr_file_damage+" (1)");
        fptr.close();
        throw new SwissephException(tfstart, SwissephException.DATA_FILE_ERROR,
            SweConst.ERR, serr);
      }
      fversion=ver;
      
      b=0; s="";
      do {
        cLast=(char)b;
        b=fptr.readByte();
        s+=(char)b;
      } while (cLast!='\r' && (char)(b)!='\n' && s.length()<SwissData.AS_MAXCH);
      s2=fnam.substring(fnam.lastIndexOf(swed.DIR_GLUE)+1).toLowerCase();
      s=s.trim().toLowerCase();
      if (!s.equals(s2)) {
        // Http addresses will end with '/' independent of DIR_GLUE...
        s2=fnam.substring(fnam.lastIndexOf("/")+1).toLowerCase();
        if (!s.equals(s2)) {
          s2=fnam.substring(fnam.lastIndexOf(swed.DIR_GLUE)+1).toLowerCase();
          //DevNull.println("Ephemeris file name '"+s2+"' is wrong; rename to '"+s+"'");
          fptr.close();
          throw new SwissephException(tfstart, SwissephException.DATA_FILE_ERROR,
              SweConst.ERR, serr);
        }
      }
      
      b=0; s="";
      do {
        cLast=(char)b;
        b=fptr.readByte();
        s+=(char)b;
      } while (cLast!='\r' && (char)(b)!='\n' && s.length()<SwissData.AS_MAXCH);
      
      // Read up to end of line or AS_MAXCH*2 into var. 's':
      if (ifno == SwephData.SEI_FILE_ANY_AST) {
        b=0; s="";
        do {
          cLast=(char)b;
          b=fptr.readByte();
          s+=(char)b;
        } while (cLast!='\r' && (char)(b)!='\n' && s.length()<SwissData.AS_MAXCH*2);
        
        String sp = s;
        // Strip leading white space from 'sp':
        while(Character.isWhitespace(sp.charAt(0))) {
          sp = sp.substring(1);
        }
        // Remove leading numbers from 'sp':
        while(Character.isDigit(sp.charAt(0))) {
          sp = sp.substring(1);
        }
        // Skip next character as well:
        sp = sp.substring(1);
        i = s.length() - sp.length();
        sastnam = sp.substring(0,lastnam+i);
        
        swed.astelem = s;
        
        swed.ast_H = SwissLib.atof(s.substring(35 + i));
        swed.ast_G = SwissLib.atof(s.substring(42 + i));
        if (swed.ast_G == 0) swed.ast_G = 0.15;
        
        s2 = s.substring(51 + i, 58 + i);
        swed.ast_diam = SwissLib.atof(s2);
        if (swed.ast_diam == 0) {
          
          swed.ast_diam = 1329/Math.sqrt(0.15) * Math.pow(10, -0.2 * swed.ast_H);
        }
      }
      
      int testendian = fptr.readInt();
      
lng = 0;
      if (testendian == SwephData.SEI_FILE_TEST_ENDIAN) {
        freord = SwephData.SEI_FILE_NOREORD;
      } else {
        freord = SwephData.SEI_FILE_REORD;
        lng = ((testendian & 0x000000ff) << 24) +
              ((testendian & 0x0000ff00) << 8 ) +
              ((testendian & 0x00ff0000) >> 8 ) +
              ((testendian & 0xff000000) >> 24);
        if (lng != SwephData.SEI_FILE_TEST_ENDIAN) {
          throw new SwissephException(tfstart, SwissephException.DATA_FILE_ERROR,
              SweConst.ERR, "File is damaged: byte ordering info not correct.");
        }
      }
      
      if (SwephData.SEI_FILE_TEST_ENDIAN / 16777216 ==
          (testendian & 0x000000ff)) {
        fendian = SwephData.SEI_FILE_BIGENDIAN;
      } else {
        fendian = SwephData.SEI_FILE_LITENDIAN;
      }
      iflg = freord | fendian;
      
      lng=(long)read4(fptr, SwephData.SEI_CURR_FPOS, false, freord, fendian);
      if (lng < 0) { lng &= 0xffffffff; }
      fpos=fptr.getFilePointer();
      flen=fptr.length();
      if (lng!=flen) {
        DevNull.println(serr_file_damage+" (2)");
        fptr.close();
        throw new SwissephException(tfstart, SwissephException.DATA_FILE_ERROR,
            SweConst.ERR, serr);
      }
      fptr.seek(fpos);
      
      sweph_denum = read4(fptr, fpos, false, freord, fendian);
      swed.jpldenum = sweph_denum;
      
      tfstart=read8(fptr, SwephData.SEI_CURR_FPOS, freord, fendian);
      tfend=read8(fptr, SwephData.SEI_CURR_FPOS, freord, fendian);
      
      nplan=read2(fptr, SwephData.SEI_CURR_FPOS, freord, fendian);
      if (nplan > 256) {
        nbytes_ipl = 4;
        nplan %= 256;
      }
      if (nplan < 1 || nplan > 20) {
        DevNull.println(serr_file_damage+" (3)");
        fptr.close();
        throw new SwissephException(tfstart, SwissephException.DATA_FILE_ERROR,
            SweConst.ERR, serr);
      }
      npl = nplan;
      if (nbytes_ipl == 2) {
        for(i=0; i<nplan; i++) {
          ipl[i]=(int)(read2(fptr, SwephData.SEI_CURR_FPOS, freord, fendian));
        }
      } else if (nbytes_ipl == 4) {
        for(i=0; i<nplan; i++) {
          ipl[i]=read4(fptr, SwephData.SEI_CURR_FPOS, false, freord, fendian);
        }
      } else { // Can't be???
        DevNull.println(serr_file_damage+" (3b)");
      }
      
      if (ifno == SwephData.SEI_FILE_ANY_AST) {
        String sastno;
        int j;
        
        j = 4;      
        while (sastnam.charAt(j) != ' ' && j < 10) {  
          j++;
        }
        sastno=sastnam.substring(0,Math.min(sastnam.length(),j)).trim();
        i = Integer.parseInt(sastno);
        if (i == ipl[0] - SweConst.SE_AST_OFFSET) {
          
          astnam=sastnam.substring(Math.min(sastnam.length(),j+1),
                                   Math.min(sastnam.length(),j+1+lastnam));
          
          s="";
          for(i=0; i<30; i++) {
            s+=(char)fptr.readByte();
          }
        } else {
          
          astnam="";
          for(i=0; i<30; i++) {
            astnam+=(char)fptr.readByte();
          }
        }
        astnam=astnam.trim();
      }
      
      fpos = fptr.getFilePointer();
      
      ulng=(long)(read4(fptr, SwephData.SEI_CURR_FPOS, false, freord, fendian));
      
      fptr.seek(0L);
      
      if (fpos - 1 > 2 * SwissData.AS_MAXCH) {
        DevNull.println(serr_file_damage+" (4)");
        fptr.close();
        throw new SwissephException(tfstart, SwissephException.DATA_FILE_ERROR,
            SweConst.ERR, serr);
      }
      b=0; s="";
byte[] ba=new byte[2*SwissData.AS_MAXCH];
      for(i=0;i<fpos;i++) {
        cLast=(char)b;
        b=fptr.readByte();
//DevNull.println(b);
        ba[i]=b;
        s+=(char)b;
      }
  if ((int)swi_crc32( ba, (int) fpos) != (int)ulng) {
    System.err.println(serr_file_damage+" (5)");
    fptr.close();
    throw new SwissephException(tfstart, SwissephException.DATA_FILE_ERROR,
        SweConst.ERR, serr);
  }
      fptr.seek(fpos+4L);
      
      
      swed.gcdat.clight       = read8(fptr, SwephData.SEI_CURR_FPOS, freord, fendian);
      swed.gcdat.aunit        = read8(fptr, SwephData.SEI_CURR_FPOS, freord, fendian);
      swed.gcdat.helgravconst = read8(fptr, SwephData.SEI_CURR_FPOS, freord, fendian);
      swed.gcdat.ratme        = read8(fptr, SwephData.SEI_CURR_FPOS, freord, fendian);
      swed.gcdat.sunradius    = read8(fptr, SwephData.SEI_CURR_FPOS, freord, fendian);
      
      for (kpl = 0; kpl < npl; kpl++) {
        
        ipli = ipl[kpl];
        if (ipli >= SweConst.SE_AST_OFFSET) {
          pdp = swed.pldat[SwephData.SEI_ANYBODY];
        } else {
          pdp = swed.pldat[ipli];
        }
        pdp.ibdy = ipli;
        
        pdp.lndx0=(long)(read4(fptr, SwephData.SEI_CURR_FPOS, false, freord, fendian))&0xffffffffL;
        
        pdp.iflg=fptr.readUnsignedByte();
        
        
        pdp.ncoe=fptr.readUnsignedByte();
        
        lng=read4(fptr, SwephData.SEI_CURR_FPOS, false, freord, fendian);
        pdp.rmax = (double)lng / 1000.0;
        
        
        pdp.tfstart  = read8(fptr, SwephData.SEI_CURR_FPOS, freord, fendian);
        pdp.tfend    = read8(fptr, SwephData.SEI_CURR_FPOS, freord, fendian);
        pdp.dseg     = read8(fptr, SwephData.SEI_CURR_FPOS, freord, fendian);
        pdp.nndx     = (int) ((pdp.tfend - pdp.tfstart + 0.1) /pdp.dseg);
        pdp.telem    = read8(fptr, SwephData.SEI_CURR_FPOS, freord, fendian);
        pdp.prot     = read8(fptr, SwephData.SEI_CURR_FPOS, freord, fendian);
        pdp.dprot    = read8(fptr, SwephData.SEI_CURR_FPOS, freord, fendian);
        pdp.qrot     = read8(fptr, SwephData.SEI_CURR_FPOS, freord, fendian);
        pdp.dqrot    = read8(fptr, SwephData.SEI_CURR_FPOS, freord, fendian);
        pdp.peri     = read8(fptr, SwephData.SEI_CURR_FPOS, freord, fendian);
        pdp.dperi    = read8(fptr, SwephData.SEI_CURR_FPOS, freord, fendian);
        
        
        if ((pdp.iflg & SwephData.SEI_FLG_ELLIPSE)!=0) {
          if (pdp.refep != null) { 
            pdp.refep = null;
            if (pdp.segp != null) {
              pdp.segp = null; 
            }
          }
          pdp.refep = new double[2*pdp.ncoe];
          for(i=0;i<2*pdp.ncoe;i++) {
            pdp.refep[i]=read8(fptr, SwephData.SEI_CURR_FPOS, freord, fendian);
          }
        }
      }
    } catch (java.io.IOException e) {
      try {
        fptr.close();
      } catch (java.io.IOException e2) {
      }
      DevNull.println(serr_file_damage+" (6)");
      DevNull.println(e.getMessage());
      throw new SwissephException(tfstart, SwissephException.DATA_FILE_ERROR,
          SweConst.ERR, serr);
    }
    return SweConst.OK;
  }
  
  
  static long crc32_table[]=null;
  
  long swi_crc32( byte[] buf, int len) {
    int pn;
     long crc;
    if (crc32_table==null) {  
      init_crc32();   
    }
    crc = 0xffffffffL;       
    for (pn = 0; len > 0; ++pn, --len) {
      crc = ((crc << 8)&0xffffffffL) ^ crc32_table[(int)((crc >> 24) ^ ((long)buf[pn]&0xff))];
    }
    return ~crc;            
  }
  
  static final int CRC32_POLY=0x04c11db7;    
  void init_crc32() {
    long i, j;
    long c;
    crc32_table = new long[256];
    for (i = 0; i < 256; ++i) {
      for (c = i << 24, j = 8; j > 0; --j) {
        c = (c & 0x80000000L)!=0 ? (c << 1) ^ CRC32_POLY : (c << 1);
      }
      c=c & 0xffffffffL;
      crc32_table[(int)i] = c;
    }
  }
  short read2(FilePtr fp, long fpos, int freord, int fendian)
      throws java.io.IOException {
    if (fpos >= 0) {
      fp.seek(fpos);
    }
    short val=(short)fp.readShort();
    if (freord != 0) {
      val = (short)(( val << 8 ) +
            ( val >>> 8 ));
    }
    return val;
  }
  int read3(FilePtr fp, long fpos, int freord, int fendian)
      throws java.io.IOException {
    if (fpos >= 0) {
      fp.seek(fpos);
    }
    int val=(int)fp.readUnsignedByte();
    int i2=(int)fp.readShort(); if(i2<0){i2&=0xffff;}
    val=(val<<16)+i2;
    if (freord != 0) {
      val = (( val & 0x000000ff ) << 24) +
            (( val & 0x0000ff00 ) <<  8) +
            (( val & 0x00ff0000 ) >>  8) +
            (( val & 0xff000000 ) >> 24);
      boolean do_shift = ((fendian == SwephData.SEI_FILE_BIGENDIAN && freord != 0) ||
                          (fendian == SwephData.SEI_FILE_LITENDIAN && freord == 0));
      return (do_shift?val>>8:val);
    }
    return val;
  }
  int read4(FilePtr fp, long fpos, boolean unsigned, int freord, int fendian)
      throws java.io.IOException {
    if (fpos >= 0) {
      fp.seek(fpos);
    }
    int val=(int)fp.readInt();
    if (freord != 0) {
      if (unsigned) {
        val = (( val & 0x000000ff ) << 24) +
              (( val & 0x0000ff00 ) <<  8) +
              (( val & 0x00ff0000 ) >>  8) +
              (( val & 0xff000000 ) >> 24);
      } else {
        val = (( val & 0x000000ff ) << 24) +
              (( val & 0x0000ff00 ) <<  8) +
              (( val & 0x00ff0000 ) >>  8) +
              (( val & 0xff000000 ) >>> 24);
      }
    } else {
      if (unsigned && val<0) { val&=0x7fffffff; }
    }
    return val;
  }
  double read8(FilePtr fp, long fpos, int freord, int fendian)
      throws java.io.IOException {
    if (fpos >= 0) {
      fp.seek(fpos);
    }
    long val=Double.doubleToLongBits(fp.readDouble());
    if (freord != 0) {
      val = (( val & 0x00000000000000ffL ) << 56) +
            (( val & 0x000000000000ff00L ) << 40) +
            (( val & 0x0000000000ff0000L ) << 24) +
            (( val & 0x00000000ff000000L ) <<  8) +
            (( val & 0x000000ff00000000L ) >>  8) +
            (( val & 0x0000ff0000000000L ) >> 24) +
            (( val & 0x00ff000000000000L ) >> 40) +
            (( val & 0xff00000000000000L ) >> 56);
    }
    return Double.longBitsToDouble(val);
  }
  
  int get_new_segment(SwissData swed, double tjd, int ipli, int ifno,
                      StringBuffer serr) {
    int i, j, k, m, n, o, icoord;
    int iseg;
    int fpos;
    int nsizes, nsize[]=new int[6];
    int nco;
    int idbl;
     short c[]=new short[4]; // unsigned (byte) ist wichtig?
    PlanData pdp = swed.pldat[ipli];
    FileData fdp = swed.fidat[ifno];
    int freord  = (int) (fdp.iflg & SwephData.SEI_FILE_REORD);
    int fendian = (int) (fdp.iflg & SwephData.SEI_FILE_LITENDIAN);
     long longs[]=new long[SwephData.MAXORD+1]; // unsigned ist wichtig?
    
    iseg = (int) ((tjd - pdp.tfstart) / pdp.dseg);
    
    pdp.tseg0 = pdp.tfstart + iseg * pdp.dseg;
    pdp.tseg1 = pdp.tseg0 + pdp.dseg;
    
    fpos = (int)pdp.lndx0 + iseg * 3;
    try {
      fpos = read3(fptr, fpos, freord, fendian);
      fptr.seek(fpos);
      
      if (pdp.segp == null) {
        pdp.segp = new double[pdp.ncoe*3];
      }
      for(i=0;i<pdp.segp.length;i++) { pdp.segp[i]=0.; }
      
      for (icoord = 0; icoord < 3; icoord++) {
        idbl = icoord * pdp.ncoe;
        
        
        c[0]=(short)fptr.readUnsignedByte();
        c[1]=(short)fptr.readUnsignedByte();
        if ((c[0] & 128)!=0) {
          nsizes = 6;
          c[2]=(short)fptr.readUnsignedByte();
          c[3]=(short)fptr.readUnsignedByte();
          nsize[0] = (int) c[1] / 16;
          nsize[1] = (int) c[1] % 16;
          nsize[2] = (int) c[2] / 16;
          nsize[3] = (int) c[2] % 16;
          nsize[4] = (int) c[3] / 16;
          nsize[5] = (int) c[3] % 16;
          nco = nsize[0] + nsize[1] + nsize[2] + nsize[3] + nsize[4] + nsize[5];
        } else {
          nsizes = 4;
          nsize[0] = (int) c[0] / 16;
          nsize[1] = (int) c[0] % 16;
          nsize[2] = (int) c[1] / 16;
          nsize[3] = (int) c[1] % 16;
          nco = nsize[0] + nsize[1] + nsize[2] + nsize[3];
        }
        
        if (nco > pdp.ncoe) {
          if (serr != null) {
            serr.append("error in ephemeris file "+fdp.fnam+": "+nco+
                        " coefficients instead of "+pdp.ncoe+". ");
          }
          throw new SwissephException(tfstart, SwissephException.DATA_FILE_ERROR,
              SweConst.ERR, serr);
        }
        
int kCnt;
        for (i = 0; i < nsizes; i++) {
          if (nsize[i] == 0) {
            continue;
          }
          if (i < 4) {
            j = (4 - i);
            k = nsize[i];
            for(kCnt=0; kCnt<k; kCnt++) {
              switch(j) {
                case 1: longs[kCnt]=(int)fptr.readUnsignedByte();
                        break;
                case 2: longs[kCnt]=(int)read2(fptr, SwephData.SEI_CURR_FPOS, freord, fendian);
                        if(longs[kCnt]<0){longs[kCnt]&=0xffff;}
                        break;
                case 3: longs[kCnt]=read3(fptr, SwephData.SEI_CURR_FPOS, freord, fendian);
                        if(longs[kCnt]<0){longs[kCnt]&=0xffffff;}
                        break;
                case 4: longs[kCnt]=read4(fptr, SwephData.SEI_CURR_FPOS, false, freord, fendian);
                        if(longs[kCnt]<0){longs[kCnt]&=0xffffffff;}
                        break;
              }
            }
            for (m = 0; m < k; m++, idbl++) {
              if ((longs[m] & 1)!=0) {   
                pdp.segp[idbl] = -((((longs[m]+1) / 2)&0x7fffffffL) / 1e+9 * pdp.rmax / 2);
              } else {
                pdp.segp[idbl] = ((longs[m] / 2)&0x7fffffffL) / 1e+9 * pdp.rmax / 2;
              }
            }
          } else if (i == 4) {              
            j = 1;
            k = (nsize[i] + 1) / 2;
            for(kCnt=0; kCnt<k; kCnt++) {
              longs[kCnt]=(int)fptr.readUnsignedByte();
            }
            for (m = 0, j = 0;
                 m < k && j < nsize[i];
                 m++) {
              for (n = 0, o = 16;
                   n < 2 && j < nsize[i];
                   n++, j++, idbl++, longs[m] %= o, o /= 16) {
                if ((longs[m] & o)!=0) {
                  pdp.segp[idbl] = -(((longs[m]+o) / o / 2) * pdp.rmax /
                                                                    2 / 1e+9);
                } else {
                  pdp.segp[idbl] = (longs[m] / o / 2) * pdp.rmax / 2 / 1e+9;
                }
              }
            }
          } else if (i == 5) {              
            j = 1;
            k = (nsize[i] + 3) / 4;
            for(kCnt=0; kCnt<k; kCnt++) {
              longs[kCnt]=(int)fptr.readUnsignedByte();
            }
            for (m = 0, j = 0;
                 m < k && j < nsize[i];
                 m++) {
              for (n = 0, o = 64;
                   n < 4 && j < nsize[i];
                   n++, j++, idbl++, longs[m] %= o, o /= 4) {
                if ((longs[m] & o)!=0) {
                  pdp.segp[idbl] = -(((longs[m]+o) / o / 2) * pdp.rmax /
                                                                    2 / 1e+9);
                } else {
                  pdp.segp[idbl] = (longs[m] / o / 2) * pdp.rmax / 2 / 1e+9;
                }
              }
            }
          }
        }
      }
      return SweConst.OK;
    } catch (java.io.IOException e) {
      serr.append("file error in swisseph.FileData: "+e.getMessage());
      throw new SwissephException(tfstart, SwissephException.DATA_FILE_ERROR,
          SweConst.ERR, serr);
    }
  }
  
} 
class FilePtr {
  public static final String useragent="swisseph-java-1.70.03(00)";
  private static final int MAX_FAILURES=100;
  RandomAccessFile fp;
  Socket sk;
  InputStream is;
  BufferedOutputStream os;
  String fnamp;
  private long fpos=0;
  private String host;
  private int port;
  private int BUFSIZE=20;
  // Holds max. 1 BUFSIZE byte chunks of read data: startidx, endidx, data:
  private long[] startIdx=new long[1];  // long, as it holds the file pointer pos.
  private long[] endIdx=new long[1];
  private byte[][] data;
  private byte inbuf[];
  private int idx=0; // What to fill next.
  private long savedLength=-1;
  
  public FilePtr(RandomAccessFile fp,
                 Socket sk,
                 InputStream is,
                 BufferedOutputStream os,
                 String fnamp,
                 long fileLength,
                 int bufsize) throws IOException {
    this.fp=fp;
    this.sk=sk;
    this.is=is;
    this.os=os;
    this.fnamp=fnamp;
    this.savedLength=fileLength;
    this.BUFSIZE=bufsize;
    data=new byte[BUFSIZE][1];
    inbuf=new byte[BUFSIZE];
    for (int i=0;i<data[0].length;i++) {
      startIdx[i]=-1; // Means: no data at this index.
    }
    if (fp==null) {
      try {
        URL u=new URL(fnamp);
        host=u.getHost();
        port=u.getPort();
        if (port<0) { port=80; } // Default port for http...
      } catch ( MalformedURLException me) {
        throw new IOException("Malformed URL '"+fnamp+"'");
      }
    }
  }
  
  public byte readByte() throws IOException, EOFException {
    if (startIdx[idx]<0 || fpos<startIdx[idx] || fpos>endIdx[idx]) {
      readToBuffer();
    }
    fpos++;
    return data[(int)(fpos-1-startIdx[idx])][idx];
  }
  
  public int readUnsignedByte() throws IOException, EOFException {
    return ((int)readByte()) & 0xff;
  }
  
  public short readShort() throws IOException, EOFException {
    return (short)((readByte()<<8)+readUnsignedByte());
  }
  
  public int readInt() throws IOException, EOFException {
    return (((int)readByte())<<24)+
           (((int)readUnsignedByte())<<16)+
           (((int)readUnsignedByte())<<8)+
           (int)readUnsignedByte();
  }
  
  public double readDouble() throws IOException, EOFException {
    long ldb=(((long)readUnsignedByte())<<56)+
             (((long)readUnsignedByte())<<48)+
             (((long)readUnsignedByte())<<40)+
             (((long)readUnsignedByte())<<32)+
             (((long)readUnsignedByte())<<24)+
             (((long)readUnsignedByte())<<16)+
             (((long)readUnsignedByte())<<8)+
             (long)readUnsignedByte();
    return Double.longBitsToDouble(ldb);
  }
  
  public String readLine() throws IOException, EOFException {
    String sout="";
    try {
      char ch;
      while ((ch=(char)readUnsignedByte())!='\n') {
        sout+=ch;
      }
      sout+=ch;
    } catch (EOFException e) {
      if (sout.length()==0) {
        throw e;
      }
    }
    return sout;
  }
  
  public void close() throws IOException {
    try {
      fnamp="";
      if (fp!=null) { fp.close(); }
      fp=null;
      if (sk!=null) { sk.close(); }
      sk=null;
      is=null;
      os=null;
    } catch (IOException ie) {
      try {
        if (sk!=null) { sk.close(); }
        sk=null;
        is=null;
        os=null;
      } catch (IOException ies) {
        throw ies;
      }
      throw ie;
    }
  }
  
  public long getFilePointer() {
    return fpos;
  }
  
  public long length() throws IOException {
    if (fp!=null && savedLength<0) { savedLength=fp.length(); }
    if (fp!=null || savedLength>=0) {

      return savedLength;
    }
    long len=0;
    String s="HEAD "+fnamp+" HTTP/1.1\r\n"+
             "User-Agent: "+useragent+"\r\n"+
             "Host: "+host+":"+port+"\r\n\r\n";
    String sout = "";
    int failures = 0;
    int rc = 0;
    while (true) {
      try {
        URLwrite(os,s);
        sout=URLread(is);
      } catch (IOException ioe) {
        if (++failures>=MAX_FAILURES) {
          throw new IOException("(java.net.SocketException) "+ioe.getMessage());
        }
        reconnect();
        continue;
      }
      rc=checkHeader(sout);
      if (rc<0) { // What has happened? Invalid header?
        if (++failures>=MAX_FAILURES) {
          throw new IOException("Failed to read a valid / complete header.");
        }
        reconnect();
        continue;
      }
      break;
    }
    int idx=sout.indexOf("Content-Length:");
    if (rc==200 && sout.indexOf("Content-Length:") >= 0) {
      sout=sout.substring(idx+"Content-Length:".length());
      sout=sout.substring(0,sout.indexOf("\n")).trim();
      len=Long.parseLong(sout);
    } else {
      throw new IOException("Can't determine length of (HTTP-)file '"+fnamp+
                            "'. HTTP error code: "+rc);
    }
    return len;
  }
  
  public void seek(long pos) {
    fpos=pos;
  }
  
  void skipBytes(int count) throws IOException {
    if (fpos+count>=length()) {
      throw new EOFException("Filepointer position "+(fpos+count)+" exceeds "+
                             "file length by "+(fpos+count-length()+1)+
                             " byte(s).");
    }
    fpos+=count;
  }

  private String URLread(InputStream is) throws IOException {
    StringBuffer sret=new StringBuffer("");
    int av = is.read();
    if (av == -1) {
      throw new IOException("No bytes available.");
    }
    sret.append((char)av);
    while (is.available()>0) {
      sret.append((char)is.read());
    }
    return sret.toString();
  }
  private void URLwrite(BufferedOutputStream os, String s) throws IOException {
    for(int n=0; n<s.length(); n++) {
      os.write((byte)s.charAt(n));
    }
    os.flush();
  }
  private String htmlStrip(String s) {
    int idx=s.indexOf("\r\n\r\n");
    if (idx>=0) {
      return s.substring(idx+4);
    }
    return "";
  }
  private int checkHeader(String s) {

    try {
      int ix1=s.indexOf(" ");
      int ix2=s.indexOf(" ",ix1+1);
      if (ix1<0 || ix2<0 || ix1<8 || ix1+4!=ix2) { return -1; }
      return Integer.parseInt(s.substring(ix1+1,ix2));
    } catch (NumberFormatException nf) {
      return -1;
    }
  }
  private void readToBuffer() throws IOException, EOFException {
    if (fp!=null) { 
      fp.seek(fpos);
      int cnt=fp.read(inbuf);
      if (cnt==-1) {
        throw new EOFException("Filepointer position "+fpos+" exceeds file"+
                               " length by "+(fpos-length()+1)+" byte(s).");
      }
      for(int n=0;n<cnt;n++) {
        data[n][idx]=inbuf[n];
      } 
      startIdx[idx]=fpos;
      endIdx[idx]=fpos+cnt-1;
      return;
    }
    if (fpos>=length()) {
      throw new EOFException("Filepointer position "+fpos+" exceeds file "+
                             "length by "+(fpos-length()+1)+" byte(s).");
    }
    String s="GET "+fnamp+" HTTP/1.1\r\n"+
             "User-Agent: "+useragent+"\r\n"+
             "Host: "+host+":"+port+"\r\n"+
             "Range: bytes="+fpos+"-"+
                                Math.min(length()-1,fpos+BUFSIZE-1)+"\r\n\r\n";
    String sout="";
    int slen=0;
    int failures=0;
    while (true) {
      try {
        URLwrite(os,s);
        sout=URLread(is);
      } catch (IOException ioe) {
        if (++failures>=MAX_FAILURES) {
          throw new IOException("(java.net.SocketException) "+ioe.getMessage());
        }
        reconnect();
        continue;
      }
      int rc=checkHeader(sout);
      if (rc<0) { // What has happened?
        if (++failures>=MAX_FAILURES) { // Too many failures in a row, abort:
          throw new IOException("Failed to read successfully from address\n'"+
                                fnamp+"'. The http reply from the server was "+
                                sout.length()+
                                " bytes long and it's content is:\n\n"+sout);
        }
        continue;
      }
      sout=htmlStrip(sout); // keep data part of http response only
      slen=sout.length();
      if ((rc!=200  && rc!=206 ) ||
          slen>BUFSIZE ||
          (slen<BUFSIZE && savedLength>=0 && fpos+slen != savedLength)) {
        if (++failures>=MAX_FAILURES) {
          throw new IOException("HTTP read failed with HTTP response "+rc+
                                ". Read "+slen+" bytes, requested "+BUFSIZE+
                                " bytes.");
        }
        continue;
      }
      if (slen==0) { // How is this to happen???
        if (++failures>=MAX_FAILURES) {
          throw new EOFException("Filepointer position "+fpos+" exceeds file "+
                                 "length by "+(fpos-length()+1)+" byte(s).");
        }
        continue;
      }
      break;
    }
    startIdx[idx]=fpos;
    endIdx[idx]=fpos+slen-1;
    for(int n=0;n<slen;n++) {
      data[n][idx]=(byte)sout.charAt(n);
    }
  }
  private void reconnect() throws IOException {
System.err.println("reconnecting...");
    sk.close();
    sk=new Socket(host,port);
    sk.setSoTimeout(5000);
    is=sk.getInputStream();
    os=new BufferedOutputStream(sk.getOutputStream());
  }
}
class GenConst {
 double clight,
        aunit,
        helgravconst,
        ratme,
        sunradius;
}
class Houses {
  
  double cusp[]=new double[37];
  
  double ac;
  
  double mc;
  
  double vertex;
  
  double equasc;
  
  double coasc1;
  
  double coasc2;
  
  double polasc;
}
class IntObj {
  
  public int val;
}
class Nut {
  
  double tnut;
  double nutlo[];      
  double snut, cnut;    
  double matrix[][];
  Nut() {
    nutlo = new double[2];
    matrix = new double[3][3];
  }
  void clearData() {
    int i,j;
    tnut=0.0;
    snut=0.0;
    cnut=0.0;
    for(j=0; j<nutlo.length; j++) { nutlo[j]=0.0; }
    for(j=0; j<matrix.length; j++) {
      for(i=0; i<matrix[j].length; i++) {
        matrix[j][i]=0.0;
      }
    }
  }
}
class PlanData {
  double x[]=new double[6]; 
  double xreturn[]=new double[24]; 
  
  int ibdy=0;           
  int iflg=0;          
  int ncoe=0;           
  
  long lndx0=0;         
  int nndx=0;           
  double tfstart=0;     
  double tfend=0;       
  double dseg=0;        
  
  double telem=0;       
  double prot=0;
  double qrot=0;
  double dprot=0;
  double dqrot=0;
  double rmax=0;        
  
  double peri=0;
  double dperi=0;
////  double *refep;        
  double refep[]=null;  
  
  double tseg0=0, tseg1=0;  
////  double *segp;         
  double segp[]=null;   
  int neval=0;          
  
  double teval=0;       
  int iephe=0;          
  int xflgs=0;         
  PlanData() {
    for(int i=0;i<x.length;i++) { x[i]=0.; } // Really?
    for(int i=0;i<x.length;i++) { xreturn[i]=0.; } // Really?
  }
  void clearData() {
    int j;
    ibdy=0;
    iflg=0;
    ncoe=0;
    lndx0=0;
    nndx=0;
    tfstart=0.0;
    tfend=0.0;
    dseg=0.0;
    telem=0.0;
    prot=0.0;
    qrot=0.0;
    dprot=0.0;
    dqrot=0.0;
    rmax=0.0;
    peri=0.0;
    dperi=0.0;
    tseg0=0.0;
    tseg1=0.0;
    neval=0;
    teval=0.0;
    iephe=0;
    xflgs=0;
    for(j=0; j<x.length; j++) { x[j]=0.0; }
    for(j=0; j<xreturn.length; j++) { xreturn[j]=0.0; }
    refep=null;
    segp=null;
  }
}
class Plantbl {
  short max_harmonic[]=new short[9];
  short max_power_of_t;
  byte[] arg_tbl;
  double[] lon_tbl;
  double[] lat_tbl;
  double[] rad_tbl;
  double distance;
  Plantbl(short[] max_harmonic, short max_power_of_t, byte[] arg_tbl,
          double[] lon_tbl, double[] lat_tbl, double[] rad_tbl,
          double distance) {
    this.max_harmonic=max_harmonic;
    this.max_power_of_t=max_power_of_t;
    this.arg_tbl=arg_tbl;
    this.lon_tbl=lon_tbl;
    this.lat_tbl=lat_tbl;
    this.rad_tbl=rad_tbl;
    this.distance=distance;
  }
}
class SavePositions {
  int ipl;
  double tsave=0.;
  int iflgsave;
  
  double xsaves[]=new double[24];
  void clearData() {
    for (int i=0; i<xsaves.length; i++) {
      xsaves[i]=0.;
    }
    ipl=0; tsave=0.; iflgsave=0;
  }
}
class SidData {
  int sid_mode=0;
  double ayan_t0=0.;
  double t0=0.;
}
class Swecl {
  SwissEph  sw=null;
  SwissLib  sl=null;
  Swemmoon  sm=null;
  SwissData swed=null;
  private static final double DSUN=(1392000000.0 / SweConst.AUNIT);
  private static final double DMOON=(3476300.0 / SweConst.AUNIT);
  private static final double DEARTH=(6378140.0 * 2 / SweConst.AUNIT);
  private static final double RSUN=(DSUN / 2);
  private static final double RMOON=(DMOON / 2);
  private static final double REARTH=(DEARTH / 2);
  private static final int SEI_OCC_FAST=(16 * 1024);
  private static final double lnlog=Math.log(10);
  private double log10(double x) { return Math.log(x)/lnlog; }
  
  Swecl() {
    this(null, null, null, null);
    sw=new SwissEph();
    sl=new SwissLib();
    sm=new Swemmoon();
    swed=new SwissData();
  }
  
  Swecl(SwissEph sw, SwissLib sl, Swemmoon sm, SwissData swed) {
    this.sw=sw;
    this.sl=sl;
    this.sm=sm;
    this.swed=swed;
    if (sw==null) { this.sw=new SwissEph(); }
    if (sl==null) { this.sl=new SwissLib(); }
    if (sm==null) { this.sm=new Swemmoon(); }
    if (swed==null) { this.swed=new SwissData(); }
  }
  
  
  int swe_sol_eclipse_where(double tjd_ut,
                            int ifl,
                            double[] geopos,
                            double[] attr,
                            StringBuffer serr) {
    int retflag, retflag2;
    double dcore[]=new double[10];
    ifl &= SweConst.SEFLG_EPHMASK;
    if ((retflag = eclipse_where(tjd_ut, SweConst.SE_SUN, null, ifl, geopos, dcore, serr)) < 0) {
      return retflag;
    }
    if ((retflag2 = eclipse_how(tjd_ut, SweConst.SE_SUN, null, ifl, geopos[0], geopos[1], 0, attr, serr)) == SweConst.ERR) {
      return retflag2;
    }
    attr[3] = dcore[0];
    return retflag;
  }
  int swe_lun_occult_where(double tjd_ut,
                           int ipl,
                           StringBuffer starname,
                           int ifl,
                           double[] geopos,
                           double[] attr,
                           StringBuffer serr) {
    int retflag, retflag2;
    double dcore[]=new double[10];
    ifl &= SweConst.SEFLG_EPHMASK;
    if ((retflag = eclipse_where(tjd_ut, ipl, starname, ifl, geopos, dcore, serr)) < 0) {
      return retflag;
    }
    if ((retflag2 = eclipse_how(tjd_ut, ipl, starname, ifl, geopos[0], geopos[1], 0, attr, serr)) == SweConst.ERR) {
      return retflag2;
    }
    attr[3] = dcore[0];
    return retflag;
  }
  
  private int eclipse_where(double tjd_ut, int ipl, StringBuffer starname, int ifl,
                            double[] geopos, double[] dcore, StringBuffer serr) {
    int i;
    int retc = 0, niter = 0;
    double e[]=new double[6], et[]=new double[6], erm[]=new double[6],
           rm[]=new double[6], rs[]=new double[6], rmt[]=new double[6],
           rst[]=new double[6], xs[]=new double[6], xst[]=new double[6];
    double xssv[]=new double[16], x[]=new double[6];
    double lm[]=new double[6], ls[]=new double[6], lx[]=new double[6];
    double dsm, dsmt, d0, D0, s0, r0, d, s, dm;
    double de = 6378140.0 / SweConst.AUNIT;
    double earthobl = 1 - SwephData.EARTH_OBLATENESS;
    double deltat, tjd, sidt;
    double drad;
    double sinf1, sinf2, cosf1, cosf2;
    int iflag, iflag2;
    
    boolean no_eclipse = false;
    Epsilon oe = swed.oec;
    for (i = 0; i < 10; i++)
      dcore[i] = 0;
    
    iflag = SweConst.SEFLG_SPEED | SweConst.SEFLG_EQUATORIAL | ifl;
    iflag2 = iflag | SweConst.SEFLG_RADIANS;
    iflag  = iflag | SweConst.SEFLG_XYZ;
    deltat = SweDate.getDeltaT(tjd_ut);
    tjd = tjd_ut + deltat;
    
    if ((retc = sw.swe_calc(tjd, SweConst.SE_MOON, iflag, rm, serr)) == SweConst.ERR) {
      return retc;
    }
    
    if ((retc = sw.swe_calc(tjd, SweConst.SE_MOON, iflag2, lm, serr)) == SweConst.ERR)
      return retc;
    
    if ((retc = calc_planet_star(tjd, ipl, starname, iflag, rs, serr)) == SweConst.ERR)
      return retc;
    
    if ((retc = calc_planet_star(tjd, ipl, starname, iflag2, ls, serr)) == SweConst.ERR)
      return retc;
    
    for (i = 0; i <= 2; i++)
      rst[i] = rs[i];
    
    for (i = 0; i <= 2; i++)
      rmt[i] = rm[i];
    if ((iflag & SweConst.SEFLG_NONUT)!=0) {
      sidt = sl.swe_sidtime0(tjd_ut, oe.eps * SwissData.RADTODEG, 0) * 15 *
                                                            SwissData.DEGTORAD;
    } else {
      sidt = sl.swe_sidtime(tjd_ut) * 15 * SwissData.DEGTORAD;
    }
    
    if (starname != null && starname.length() > 0)
      drad = 0;
    else if (ipl < SwephData.NDIAM)
      drad = SwephData.pla_diam[ipl] / 2 / SweConst.AUNIT;
    else if (ipl > SweConst.SE_AST_OFFSET)
      drad = swed.ast_diam / 2 * 1000 / SweConst.AUNIT; 
    else
      drad = 0;
//iter_where:
    while(true) {
      for (i = 0; i <= 2; i++) {
        rs[i] = rst[i];
        rm[i] = rmt[i];
      }
      
      for (i = 0; i <= 2; i++)
        lx[i] = lm[i];
      sl.swi_polcart(lx, rm);
      rm[2] /= earthobl;
      
      dm = Math.sqrt(sl.square_sum(rm));
      
      for (i = 0; i <= 2; i++)
        lx[i] = ls[i];
      sl.swi_polcart(lx, rs);
      rs[2] /= earthobl;
      
      for (i = 0; i <= 2; i++) {
        e[i] = (rm[i] - rs[i]);
        et[i] = (rmt[i] - rst[i]);
      }
      
      dsm = Math.sqrt(sl.square_sum(e));
      dsmt = Math.sqrt(sl.square_sum(et));
      
      for (i = 0; i <= 2; i++) {
        e[i] /= dsm;
        et[i] /= dsmt;
        erm[i] = rm[i] / dm;
      }
      sinf1 = ((drad - RMOON) / dsm);
      cosf1 = Math.sqrt(1 - sinf1 * sinf1);
      sinf2 = ((drad + RMOON) / dsm);
      cosf2 = Math.sqrt(1 - sinf2 * sinf2);
      
      s0 = -sw.dot_prod(rm, e);
      
      r0 = Math.sqrt(dm * dm - s0 * s0);
      
      d0 = (s0 / dsm * (drad * 2 - DMOON) - DMOON) / cosf1;
      
      D0 = (s0 / dsm * (drad * 2 + DMOON) + DMOON) / cosf2;
      dcore[2] = r0;
      dcore[3] = d0;
      dcore[4] = D0;
      dcore[5] = cosf1;
      dcore[6] = cosf2;
      for (i = 2; i < 5; i++)
        dcore[i] *= SweConst.AUNIT / 1000.0;
      
      retc = 0;
      if (de * cosf1 >= r0) {
        retc |= SweConst.SE_ECL_CENTRAL;
      } else if (r0 <= de * cosf1 + Math.abs(d0) / 2) {
        retc |= SweConst.SE_ECL_NONCENTRAL;
      } else if (r0 <= de * cosf2 + D0 / 2) {
        retc |= (SweConst.SE_ECL_PARTIAL | SweConst.SE_ECL_NONCENTRAL);
      } else {
        if (serr != null) {
          serr.setLength(0);
          serr.append("no solar eclipse at tjd = "+tjd);
        }
        for (i = 0; i < 10; i++)
          geopos[i] = 0;
        dcore[0] = 0;
        retc = 0;
        d = 0;
        no_eclipse = true;
        
      }
      
      d = s0 * s0 + de * de - dm * dm;
      if (d > 0) {
        d = Math.sqrt(d);
      } else {
        d = 0;
      }
      
      s = s0 - d;
      
      
      for (i = 0; i <= 2; i++)
        xs[i] = rm[i] + s * e[i];
      
      for (i = 0; i <= 2; i++)
        xst[i] = xs[i];
      xst[2] *= earthobl;
      sl.swi_cartpol(xst, xst);
      if (niter <= 0) {
        double cosfi = Math.cos(xst[1]);
        double sinfi = Math.sin(xst[1]);
        double eobl = SwephData.EARTH_OBLATENESS;
        double cc= 1 / Math.sqrt(cosfi * cosfi + (1-eobl) * (1-eobl) * sinfi * sinfi);
        double ss= (1-eobl) * (1-eobl) * cc;
        earthobl =  ss;
        niter++;
        continue;
      }
      sl.swi_polcart(xst, xst);
      
      sl.swi_cartpol(xs, xs);
      
      xs[0] -= sidt;
      xs[0] *= SwissData.RADTODEG;
      xs[1] *= SwissData.RADTODEG;
      xs[0] = sl.swe_degnorm(xs[0]);
      
      if (xs[0] > 180) {
        xs[0] -= 360;
      }
      xssv[0] = xs[0];
      xssv[1] = xs[1];
      geopos[0] = xs[0];
      geopos[1] = xs[1];
      
      for (i = 0; i <= 2; i++)
        x[i] = rmt[i] - xst[i];
      s = Math.sqrt(sl.square_sum(x));
      
      dcore[0] = (s / dsmt * ( drad * 2 - DMOON) - DMOON) * cosf1;
      dcore[0] *= SweConst.AUNIT / 1000.0;
      
      dcore[1] = (s / dsmt * ( drad * 2 + DMOON) + DMOON) * cosf2;
      dcore[1] *= SweConst.AUNIT / 1000.0;
      if ((retc & SweConst.SE_ECL_PARTIAL)==0 && !no_eclipse) {
        if (dcore[0] > 0) {
          retc |= SweConst.SE_ECL_ANNULAR;
        } else {
          
          retc |= SweConst.SE_ECL_TOTAL;
        }
      }
      break; // while (true) ... [goto iter_where]
    }
    return retc;
  }
  private int calc_planet_star(double tjd_et, int ipl, StringBuffer starname, int iflag, double[] x, StringBuffer serr) {
    int i;
    int retc = SweConst.OK;
    if (starname == null || starname.length() == 0) {
      retc = sw.swe_calc(tjd_et, ipl, iflag, x, serr);
    } else {
      if ((retc = sw.swe_fixstar(starname, tjd_et, iflag, x, serr)) ==
                                                                SweConst.OK) {
        
        if ((iflag & SweConst.SEFLG_XYZ)!=0) {
          for (i = 0; i < 3; i++)
            x[i] *= 100000000;
        } else {
          x[2] *= 100000000;
        }
      }
    }
    return retc;
  }
  
  
  int swe_sol_eclipse_how(double tjd_ut,
                          int ifl,
                          double[] geopos,
                          double[] attr,
                          StringBuffer serr) {
    int retflag, retflag2;
    double dcore[]=new double[10];
    double geopos2[]=new double[20];
    ifl &= SweConst.SEFLG_EPHMASK;
    if ((retflag = eclipse_how(tjd_ut, SweConst.SE_SUN, null, ifl, geopos[0],
                               geopos[1], geopos[2], attr, serr)) == SweConst.ERR) {
      return retflag;
    }
    if ((retflag2 = eclipse_where(tjd_ut, SweConst.SE_SUN, null, ifl, geopos2,
                                  dcore, serr)) == SweConst.ERR) {
      return retflag2;
    }
    if (retflag!=0) {
      retflag |= (retflag2 & (SweConst.SE_ECL_CENTRAL | SweConst.SE_ECL_NONCENTRAL));
    }
    attr[3] = dcore[0];
    return retflag;
  }
  private int eclipse_how(double tjd_ut, int ipl, StringBuffer starname,
                          int ifl, double geolon, double geolat, double geohgt,
                          double[] attr, StringBuffer serr) {
    int i;
    int retc = 0;
    double te;
    double xs[]=new double[6], xm[]=new double[6], ls[]=new double[6],
           lm[]=new double[6], x1[]=new double[6], x2[]=new double[6];
    double rmoon, rsun, rsplusrm, rsminusrm;
    double dctr;
    double drad;
    int iflag = SweConst.SEFLG_EQUATORIAL | SweConst.SEFLG_TOPOCTR | ifl;
    int iflagcart = iflag | SweConst.SEFLG_XYZ;
    double mdd, eps, sidt, armc, xh[]=new double[6], hmin_appr;
    double lsun, lmoon, lctr, lsunleft, a, b, sc1, sc2;
    for (i = 0; i < 10; i++)
      attr[i] = 0;
    te = tjd_ut + SweDate.getDeltaT(tjd_ut);
    sw.swe_set_topo(geolon, geolat, geohgt);
    if (calc_planet_star(te, ipl, starname, iflag, ls, serr) == SweConst.ERR) {
      return SweConst.ERR;
    }
    if (sw.swe_calc(te, SweConst.SE_MOON, iflag, lm, serr) == SweConst.ERR) {
      return SweConst.ERR;
    }
    if (calc_planet_star(te, ipl, starname, iflagcart, xs, serr) == SweConst.ERR) {
      return SweConst.ERR;
    }
    if (sw.swe_calc(te, SweConst.SE_MOON, iflagcart, xm, serr) == SweConst.ERR) {
      return SweConst.ERR;
    }
    
    if (starname != null && starname.length() > 0)
      drad = 0;
    else if (ipl < SwephData.NDIAM)
      drad = SwephData.pla_diam[ipl] / 2 / SweConst.AUNIT;
    else if (ipl > SweConst.SE_AST_OFFSET)
      drad = swed.ast_diam / 2 * 1000 / SweConst.AUNIT; 
    else
      drad = 0;
    
    eps = sl.swi_epsiln(te);
    if ((iflag & SweConst.SEFLG_NONUT)!=0) {
      sidt = sl.swe_sidtime0(tjd_ut, eps * SwissData.RADTODEG, 0) * 15;
    } else {
      sidt = sl.swe_sidtime(tjd_ut) * 15;
    }
    armc = sidt + geolon;
    mdd = sl.swe_degnorm(ls[0] - armc);
    xh[0] = sl.swe_degnorm(mdd - 90);
    xh[1] = ls[1];
    xh[2] = ls[2];
    sl.swe_cotrans(xh, 0, xh, 0, 90 - geolat);   
    
    rmoon = Math.asin(RMOON / lm[2]) * SwissData.RADTODEG;
    rsun = Math.asin(drad / ls[2]) * SwissData.RADTODEG;
    rsplusrm = rsun + rmoon;
    rsminusrm = rsun - rmoon;
    for (i = 0; i < 3; i++) {
      x1[i] = xs[i] / ls[2];
      x2[i] = xm[i] / lm[2];
    }
    dctr = Math.acos(sl.swi_dot_prod_unit(x1, x2)) * SwissData.RADTODEG;
    
    if (dctr < rsminusrm) {
      retc = SweConst.SE_ECL_ANNULAR;
    } else if (dctr < Math.abs(rsminusrm)) {
      retc = SweConst.SE_ECL_TOTAL;
    } else if (dctr < rsplusrm) {
      retc = SweConst.SE_ECL_PARTIAL;
    } else {
      retc = 0;
      if (serr != null) {
        serr.setLength(0);
        serr.append("no solar eclipse at tjd = "+tjd_ut);
      }
    }
    
    
    lsun = Math.asin(rsun / 2 * SwissData.DEGTORAD) * 2;
    lmoon = Math.asin(rmoon / 2 * SwissData.DEGTORAD) * 2;
    lctr = Math.asin(dctr / 2 * SwissData.DEGTORAD) * 2;
    lsunleft = Math.asin((-dctr + rsun + rmoon) * SwissData.DEGTORAD / 2) * 2;
    if (lsun > 0)
      attr[0] = lsunleft / lsun / 2;
    else
      attr[0] = 100;
    
    if (lsun > 0)
      attr[1] = lmoon / lsun;
    else
      attr[1] = 0;
    
    if (retc == 0 || lsun == 0) {
      attr[2] = 100;
    } else if (retc == SweConst.SE_ECL_TOTAL || retc == SweConst.SE_ECL_ANNULAR) {
      attr[2] = lmoon * lmoon / lsun / lsun;
    } else {
      a = 2 * lctr * lmoon;
      b = 2 * lctr * lsun;
      if (a < 1e-9) {
        attr[2] = lmoon * lmoon / lsun / lsun;
      } else {
        a = (lctr * lctr + lmoon * lmoon - lsun * lsun) / a;
        if (a > 1) a = 1;
        if (a < -1) a = -1;
        b = (lctr * lctr + lsun * lsun - lmoon * lmoon) / b;
        if (b > 1) b = 1;
        if (b < -1) b = -1;
        a = Math.acos(a);
        b = Math.acos(b);
        sc1 = a * lmoon * lmoon / 2;
        sc2 = b * lsun * lsun / 2;
        sc1 -= (Math.cos(a) * Math.sin(a)) * lmoon * lmoon / 2;
        sc2 -= (Math.cos(b) * Math.sin(b)) * lsun * lsun / 2;
        attr[2] = (sc1 + sc2) * 2 / SwephData.PI / lsun / lsun;
      }
    }
    attr[7] = dctr;
    
    hmin_appr = -(34.4556 + (1.75 + 0.37) * Math.sqrt(geohgt)) / 60;
    if (xh[1] + rsun + Math.abs(hmin_appr) >= 0 && retc!=0) {
      retc |= SweConst.SE_ECL_VISIBLE;        
    }
    attr[4] = sl.swe_degnorm(90 - xh[0]);   
    attr[5] = xh[1]; 
    return retc;
  }
  
  
  int swe_sol_eclipse_when_glob(double tjd_start, int ifl, int ifltype,
                                double tret[], int backward,
                                StringBuffer serr) {
    int i, j, k, m, n, o, i1 = 0, i2 = 0;
    int retflag = 0, retflag2 = 0;
    double de = 6378.140, a;
    double t, tt, tjd, tjds, dt, dta, dtb;
    DblObj dtint=new DblObj();
    double T, T2, T3, T4, K, M, Mm;
    double E, Ff;
    double xs[]=new double[6], xm[]=new double[6],
           ls[]=new double[6], lm[]=new double[6];
    double rmoon, rsun, dcore[]=new double[10];
    double dc[]=new double[3];
    DblObj dctr=new DblObj();
    double twohr = 2.0 / 24.0;
    double tenmin = 10.0 / 24.0 / 60.0;
    DblObj dt1=new DblObj(), dt2=new DblObj();
    double geopos[]=new double[20], attr[]=new double[20];
    double dtstart, dtdiv;
    double xa[]=new double[6], xb[]=new double[6];
    int direction = 1;
    boolean dont_times = false;
    int iflag, iflagcart;
    ifl &= SweConst.SEFLG_EPHMASK;
    iflag = SweConst.SEFLG_EQUATORIAL | ifl;
    iflagcart = iflag | SweConst.SEFLG_XYZ;
    if (ifltype == (SweConst.SE_ECL_PARTIAL | SweConst.SE_ECL_CENTRAL)) {
      if (serr != null) {
        serr.setLength(0);
        serr.append("central partial eclipses do not exist");
      }
      return SweConst.ERR;
    }
    if (ifltype == 0) {
      ifltype = SweConst.SE_ECL_TOTAL | SweConst.SE_ECL_ANNULAR
             | SweConst.SE_ECL_PARTIAL | SweConst.SE_ECL_ANNULAR_TOTAL
             | SweConst.SE_ECL_NONCENTRAL | SweConst.SE_ECL_CENTRAL;
    }
    if (backward!=0) {
      direction = -1;
    }
    K = (int) ((tjd_start - SwephData.J2000) / 365.2425 * 12.3685);
    K -= direction;
//next_try:
    while(true) {
      retflag = 0;
      dont_times = false;
      for (i = 0; i <= 9; i++)
        tret[i] = 0;
      T = K / 1236.85;
      T2 = T * T; T3 = T2 * T; T4 = T3 * T;
      Ff = sl.swe_degnorm(160.7108 + 390.67050274 * K
                   - 0.0016341 * T2
                   - 0.00000227 * T3
                   + 0.000000011 * T4);
      if (Ff > 180) {
        Ff -= 180;
      }
      if (Ff > 21 && Ff < 159) {    
        K += direction;
        continue;
      }
      
      tjd = 2451550.09765 + 29.530588853 * K
                          + 0.0001337 * T2
                          - 0.000000150 * T3
                          + 0.00000000073 * T4;
      M = sl.swe_degnorm(2.5534 + 29.10535669 * K
                          - 0.0000218 * T2
                          - 0.00000011 * T3);
      Mm = sl.swe_degnorm(201.5643 + 385.81693528 * K
                          + 0.1017438 * T2
                          + 0.00001239 * T3
                          + 0.000000058 * T4);
      E = 1 - 0.002516 * T - 0.0000074 * T2;
      M *= SwissData.DEGTORAD;
      Mm *= SwissData.DEGTORAD;
      tjd = tjd - 0.4075 * Math.sin(Mm)
                + 0.1721 * E * Math.sin(M);
      
      dtstart = 1;
      if (tjd < 2000000) {
        dtstart = 5;
      }
      dtdiv = 4;
      for (dt = dtstart;
           dt > 0.0001;
           dt /= dtdiv) {
        for (i = 0, t = tjd - dt; i <= 2; i++, t += dt) {
          if (sw.swe_calc(t, SweConst.SE_SUN, iflag, ls, serr) == SweConst.ERR) {
            return SweConst.ERR;
          }
          if (sw.swe_calc(t, SweConst.SE_MOON, iflag, lm, serr) == SweConst.ERR) {
            return SweConst.ERR;
          }
          if (sw.swe_calc(t, SweConst.SE_SUN, iflagcart, xs, serr) == SweConst.ERR) {
            return SweConst.ERR;
          }
          if (sw.swe_calc(t, SweConst.SE_MOON, iflagcart, xm, serr) == SweConst.ERR) {
            return SweConst.ERR;
          }
          for (m = 0; m < 3; m++) {
            xa[m] = xs[m] / ls[2];
            xb[m] = xm[m] / lm[2];
          }
          dc[i] = Math.acos(sl.swi_dot_prod_unit(xa, xb)) * SwissData.RADTODEG;
          rmoon = Math.asin(RMOON / lm[2]) * SwissData.RADTODEG;
          rsun = Math.asin(RSUN / ls[2]) * SwissData.RADTODEG;
          dc[i] -= (rmoon + rsun);
        }
        find_maximum(dc[0], dc[1], dc[2], dt, dtint, dctr);
        tjd += dtint.val + dt;
      }
      tjds = tjd = tjd - SweDate.getDeltaT(tjd);
      if ((retflag = eclipse_where(tjd, SweConst.SE_SUN, null, ifl, geopos, dcore, serr)) ==
                                                                 SweConst.ERR) {
        return retflag;
      }
      retflag2 = retflag;
        
      if ((retflag2 = eclipse_how(tjd, SweConst.SE_SUN, null, ifl, geopos[0], geopos[1], 0, attr,
                                                        serr)) == SweConst.ERR) {
        return retflag2;
      }
      if (retflag2 == 0) {
        K += direction;
        continue;
      }
      tret[0] = tjd;
      if ((backward!=0 && tret[0] >= tjd_start - 0.0001)
        || (backward==0 && tret[0] <= tjd_start + 0.0001)) {
        K += direction;
        continue;
      }
      
      if ((retflag = eclipse_where(tjd, SweConst.SE_SUN, null, ifl, geopos, dcore, serr)) ==
                                                                 SweConst.ERR) {
        return retflag;
      }
      if (retflag == 0) {   
        retflag = SweConst.SE_ECL_PARTIAL | SweConst.SE_ECL_NONCENTRAL;
        tret[4] = tret[5] = tjd;    
        dont_times = true;
      }
      
      
      if ((ifltype & SweConst.SE_ECL_NONCENTRAL)==0 &&
                                   (retflag & SweConst.SE_ECL_NONCENTRAL)!=0) {
        K += direction;
        continue;
      }
      
      if ((ifltype & SweConst.SE_ECL_CENTRAL)==0 &&
                                      (retflag & SweConst.SE_ECL_CENTRAL)!=0) {
        K += direction;
        continue;
      }
      
      if ((ifltype & SweConst.SE_ECL_ANNULAR)==0 &&
                                      (retflag & SweConst.SE_ECL_ANNULAR)!=0) {
        K += direction;
        continue;
      }
      
      if ((ifltype & SweConst.SE_ECL_PARTIAL)==0 &&
                                      (retflag & SweConst.SE_ECL_PARTIAL)!=0) {
        K += direction;
        continue;
      }
      
      if ((ifltype & (SweConst.SE_ECL_TOTAL | SweConst.SE_ECL_ANNULAR_TOTAL))==0
                    && (retflag & SweConst.SE_ECL_TOTAL)!=0) {
        K += direction;
        continue;
      }
      if (dont_times) {
        break;
      }
      
      if ((retflag & SweConst.SE_ECL_PARTIAL)!=0) {
        o = 0;
      } else if ((retflag & SweConst.SE_ECL_NONCENTRAL)!=0) {
        o = 1;
      }
      else
        o = 2;
      dta = twohr;
      dtb = tenmin;
      for (n = 0; n <= o; n++) {
        if (n == 0) {
          
          i1 = 2; i2 = 3;
        } else if (n == 1) {
          if ((retflag & SweConst.SE_ECL_PARTIAL)!=0) {
            continue;
          }
          i1 = 4; i2 = 5;
        } else if (n == 2) {
          if ((retflag & SweConst.SE_ECL_NONCENTRAL)!=0) {
            continue;
          }
          i1 = 6; i2 = 7;
        }
        for (i = 0, t = tjd - dta; i <= 2; i += 1, t += dta) {
          if ((retflag2 = eclipse_where(t, SweConst.SE_SUN, null, ifl, geopos, dcore, serr)) ==
                                                                 SweConst.ERR) {
            return retflag2;
          }
          if (n == 0) {
            dc[i] = dcore[4] / 2 + de / dcore[5] - dcore[2];
          } else if (n == 1) {
            dc[i] = Math.abs(dcore[3]) / 2 + de / dcore[6] - dcore[2];
          } else if (n == 2) {
            dc[i] = de / dcore[6] - dcore[2];
          }
        }
        find_zero(dc[0], dc[1], dc[2], dta, dt1, dt2);
        tret[i1] = tjd + dt1.val + dta;
        tret[i2] = tjd + dt2.val + dta;
        for (m = 0, dt = dtb; m < 3; m++, dt /= 3) {
          for (j = i1; j <= i2; j += (i2 - i1)) {
            for (i = 0, t = tret[j] - dt; i < 2; i++, t += dt) {
              if ((retflag2 = eclipse_where(t, SweConst.SE_SUN, null, ifl, geopos, dcore, serr)) ==
                                                                 SweConst.ERR) {
                return retflag2;
              }
              if (n == 0) {
                dc[i] = dcore[4] / 2 + de / dcore[5] - dcore[2];
              } else if (n == 1) {
                dc[i] = Math.abs(dcore[3]) / 2 + de / dcore[6] - dcore[2];
              } else if (n == 2) {
                dc[i] = de / dcore[6] - dcore[2];
              }
            }
            dt1.val = dc[1] / ((dc[1] - dc[0]) / dt);
            tret[j] -= dt1.val;
          }
        }
      }
      
      if ((retflag & SweConst.SE_ECL_TOTAL)!=0) {
        if ((retflag2 = eclipse_where(tret[0], SweConst.SE_SUN, null, ifl, geopos, dcore, serr)) ==
                                                                 SweConst.ERR) {
          return retflag2;
        }
        dc[0] = dcore[0];
        if ((retflag2 = eclipse_where(tret[4], SweConst.SE_SUN, null, ifl, geopos, dcore, serr)) ==
                                                                 SweConst.ERR) {
          return retflag2;
        }
        dc[1] = dcore[0];
        if ((retflag2 = eclipse_where(tret[5], SweConst.SE_SUN, null, ifl, geopos, dcore, serr)) ==
                                                                 SweConst.ERR) {
          return retflag2;
        }
        dc[2] = dcore[0];
        
        if (dc[0] * dc[1] < 0 || dc[0] * dc[2] < 0) {
          retflag |= SweConst.SE_ECL_ANNULAR_TOTAL;
          retflag &= ~SweConst.SE_ECL_TOTAL;
        }
      }
      
      if ((ifltype & SweConst.SE_ECL_TOTAL)==0 &&
          (retflag & SweConst.SE_ECL_TOTAL)!=0) {
        K += direction;
        continue;
      }
      
      if ((ifltype & SweConst.SE_ECL_ANNULAR_TOTAL)==0 &&
          (retflag & SweConst.SE_ECL_ANNULAR_TOTAL)!=0) {
        K += direction;
        continue;
      }
      
      
      k = 2;
      for (i = 0; i < 2; i++) {
        j = i + k;
        tt = tret[j] + SweDate.getDeltaT(tret[j]);
        if (sw.swe_calc(tt, SweConst.SE_SUN, iflag, ls, serr) == SweConst.ERR) {
          return SweConst.ERR;
        }
        if (sw.swe_calc(tt, SweConst.SE_MOON, iflag, lm, serr) == SweConst.ERR) {
          return SweConst.ERR;
        }
        dc[i] = sl.swe_degnorm(ls[0] - lm[0]);
        if (dc[i] > 180) {
          dc[i] -= 360;
        }
      }
      if (dc[0] * dc[1] >= 0) {     
        tret[1] = 0;
      } else {
        tjd = tjds;
        dt = 0.1;
        dt1.val = (tret[3] - tret[2]) / 2.0;
        if (dt1.val < dt) {
          dt = dt1.val / 2.0;
        }
        for (j = 0;
            dt > 0.01;
            j++, dt /= 3) {
          for (i = 0, t = tjd; i <= 1; i++, t -= dt) {
            tt = t + SweDate.getDeltaT(t);
            if (sw.swe_calc(tt, SweConst.SE_SUN, iflag, ls, serr) ==
                                                                 SweConst.ERR) {
              return SweConst.ERR;
            }
            if (sw.swe_calc(tt, SweConst.SE_MOON, iflag, lm, serr) ==
                                                                 SweConst.ERR) {
              return SweConst.ERR;
            }
            dc[i] = sl.swe_degnorm(ls[0] - lm[0]);
            if (dc[i] > 180) {
              dc[i] -= 360;
            }
            if (dc[i] > 180) {
              dc[i] -= 360;
            }
          }
          a = (dc[1] - dc[0]) / dt;
          if (a < 1e-10) {
            break;
          }
          dt1.val = dc[0] / a;
          tjd += dt1.val;
        }
        tret[1] = tjd;
      }
      break;
    } // while (true)
    return retflag;
    
  }
  
  int swe_lun_occult_when_glob(
       double tjd_start, int ipl, StringBuffer starname, int ifl, int ifltype,
       double[] tret, int backward, StringBuffer serr) {
    int i, j, k, m, n, o, i1=0, i2=0;
    int retflag = 0, retflag2 = 0;
    double de = 6378.140, a;
    double t, tt, tjd=0, tjds, dt, dta, dtb;
    DblObj dtint=new DblObj();
    double drad;
    double xs[]=new double[6], xm[]=new double[6], ls[]=new double[6], lm[]=new double[6];
    double rmoon, rsun, dcore[]=new double[10];
    double dc[]=new double[20];
    DblObj dctr=new DblObj();
    double twohr = 2.0 / 24.0;
    double tenmin = 10.0 / 24.0 / 60.0;
    DblObj dt1=new DblObj(), dt2=new DblObj();
    double dadd = 10, dadd2 = 6;
    int nstartpos = 10;
    double geopos[]=new double[20];
    double dtstart, dtdiv;
    int direction = 1;
    int iflag, iflagcart;
    boolean dont_times = false;
    int one_try = backward & SweConst.SE_ECL_ONE_TRY;
    ifl &= SweConst.SEFLG_EPHMASK;
    iflag = SweConst.SEFLG_EQUATORIAL | ifl;
    iflagcart = iflag | SweConst.SEFLG_XYZ;
    backward &= 1L;
    
    if (ifltype == (SweConst.SE_ECL_PARTIAL | SweConst.SE_ECL_CENTRAL)) {
      if (serr != null) {
        serr.setLength(0);
        serr.append("central partial eclipses do not exist");
      }
      return SweConst.ERR;
    }
    if (ifltype == 0)
      ifltype = SweConst.SE_ECL_TOTAL | SweConst.SE_ECL_ANNULAR | SweConst.SE_ECL_PARTIAL
             | SweConst.SE_ECL_ANNULAR_TOTAL | SweConst.SE_ECL_NONCENTRAL | SweConst.SE_ECL_CENTRAL;
    retflag = 0;
    dont_times = false;
    if ((backward & SEI_OCC_FAST) != 0)
      dont_times = true;
    for (i = 0; i <= 9; i++)
      tret[i] = 0;
    if (backward!=0)
      direction = -1;
    t = tjd_start - direction * 0.001;
    while(true) {
//next_try:
      for (i = 0; i < nstartpos; i++, t += direction * dadd2) {
        if (calc_planet_star(t, ipl, starname, iflagcart, xs, serr) == SweConst.ERR)
            return SweConst.ERR;
        if (sw.swe_calc(t, SweConst.SE_MOON, iflagcart, xm, serr) == SweConst.ERR)
            return SweConst.ERR;
        dc[i] = Math.acos(sl.swi_dot_prod_unit(xs, xm)) * SwissData.RADTODEG;
        if (i > 1 && dc[i] > dc[i-1] && dc[i-2] > dc[i-1]) {
          tjd = t - direction * dadd2;
          break;
        } else if (i == nstartpos-1) {
          for (j = 0; j < nstartpos; j++)
            //DevNull.print(dc[j] + " ");
          System.err.println("problem planet");
          System.exit(0);
        }
      }
      
      if (starname != null && starname.length() > 0)
        drad = 0;
      else if (ipl < SwephData.NDIAM)
        drad = SwephData.pla_diam[ipl] / 2 / SweConst.AUNIT;
      else if (ipl > SweConst.SE_AST_OFFSET)
        drad = swed.ast_diam / 2 * 1000 / SweConst.AUNIT; 
      else
        drad = 0;
      
      dtstart = dadd2; 
      dtdiv = 3;
      for (dt = dtstart;
           dt > 0.0001;
           dt /= dtdiv) {
        for (i = 0, t = tjd - dt; i <= 2; i++, t += dt) {
          if (calc_planet_star(t, ipl, starname, iflag, ls, serr) == SweConst.ERR)
            return SweConst.ERR;
          if (sw.swe_calc(t, SweConst.SE_MOON, iflag, lm, serr) == SweConst.ERR)
            return SweConst.ERR;
          if (calc_planet_star(t, ipl, starname, iflagcart, xs, serr) == SweConst.ERR)
            return SweConst.ERR;
          if (sw.swe_calc(t, SweConst.SE_MOON, iflagcart, xm, serr) == SweConst.ERR)
            return SweConst.ERR;
          dc[i] = Math.acos(sl.swi_dot_prod_unit(xs, xm)) * SwissData.RADTODEG;
          rmoon = Math.asin(RMOON / lm[2]) * SwissData.RADTODEG;
          rsun = Math.asin(drad / ls[2]) * SwissData.RADTODEG;
          dc[i] -= (rmoon + rsun);
        }
        find_maximum(dc[0], dc[1], dc[2], dt, dtint, dctr);
        tjd += dtint.val + dt;
      }
      tjd -= SweDate.getDeltaT(tjd);
      tjds = tjd;
      if ((retflag = eclipse_where(tjd, ipl, starname, ifl, geopos, dcore, serr)) == SweConst.ERR)
        return retflag;
      retflag2 = retflag;
        
      
      if (retflag2 == 0) {
        
        if (one_try!=0) {
          tret[0] = tjd;
          return 0;
        }
        t= tjd + direction * dadd;
        continue;
      }
      tret[0] = tjd;
      if ((backward!=0 && tret[0] >= tjd_start - 0.0001)
        || (backward==0 && tret[0] <= tjd_start + 0.0001)) {
        t= tjd + direction * dadd;
        continue;
      }
      
      if ((retflag = eclipse_where(tjd, ipl, starname, ifl, geopos, dcore, serr)) == SweConst.ERR)
        return retflag;
      if (retflag == 0) { 
        retflag = SweConst.SE_ECL_PARTIAL | SweConst.SE_ECL_NONCENTRAL;
        tret[4] = tret[5] = tjd;  
        retflag = SweConst.SE_ECL_PARTIAL | SweConst.SE_ECL_NONCENTRAL;
        tret[4] = tret[5] = tjd;  
        dont_times = true;
      }
      
      
      if ((ifltype & SweConst.SE_ECL_NONCENTRAL)==0 && (retflag & SweConst.SE_ECL_NONCENTRAL)!=0) {
        t= tjd + direction * dadd;
        continue;
      }
      
      if ((ifltype & SweConst.SE_ECL_CENTRAL)==0 && (retflag & SweConst.SE_ECL_CENTRAL)!=0) {
        t= tjd + direction * dadd;
        continue;
      }
      
      if ((ifltype & SweConst.SE_ECL_ANNULAR)==0 && (retflag & SweConst.SE_ECL_ANNULAR)!=0) {
        t= tjd + direction * dadd;
        continue;
      }
      
      if ((ifltype & SweConst.SE_ECL_PARTIAL)==0 && (retflag & SweConst.SE_ECL_PARTIAL)!=0) {
        t= tjd + direction * dadd;
        continue;
      }
      
      if ((ifltype & (SweConst.SE_ECL_TOTAL | SweConst.SE_ECL_ANNULAR_TOTAL))==0 && (retflag & SweConst.SE_ECL_TOTAL)!=0) {
        t= tjd + direction * dadd;
        continue;
      }
      if (dont_times)
        return retflag;
      
      if ((retflag & SweConst.SE_ECL_PARTIAL)!=0)
        o = 0;
      else if ((retflag & SweConst.SE_ECL_NONCENTRAL)!=0)
        o = 1;
      else
        o = 2;
      dta = twohr;
      dtb = tenmin;
      for (n = 0; n <= o; n++) {
        if (n == 0) {
          
          i1 = 2; i2 = 3;
        } else if (n == 1) {
          if ((retflag & SweConst.SE_ECL_PARTIAL)!=0)
            continue;
          i1 = 4; i2 = 5;
        } else if (n == 2) {
          if ((retflag & SweConst.SE_ECL_NONCENTRAL)!=0)
            continue;
          i1 = 6; i2 = 7;
        }
        for (i = 0, t = tjd - dta; i <= 2; i += 1, t += dta) {
          if ((retflag2 = eclipse_where(t, ipl, starname, ifl, geopos, dcore, serr)) == SweConst.ERR)
            return retflag2;
          if (n == 0)
            dc[i] = dcore[4] / 2 + de / dcore[5] - dcore[2];
          else if (n == 1)
            dc[i] = Math.abs(dcore[3]) / 2 + de / dcore[6] - dcore[2];
          else if (n == 2)
            dc[i] = de / dcore[6] - dcore[2];
        }
        find_zero(dc[0], dc[1], dc[2], dta, dt1, dt2);
        tret[i1] = tjd + dt1.val + dta;
        tret[i2] = tjd + dt2.val + dta;
        for (m = 0, dt = dtb; m < 3; m++, dt /= 3) {
          for (j = i1; j <= i2; j += (i2 - i1)) {
            for (i = 0, t = tret[j] - dt; i < 2; i++, t += dt) {
              if ((retflag2 = eclipse_where(t, ipl, starname, ifl, geopos, dcore, serr)) == SweConst.ERR)
                return retflag2;
              if (n == 0)
                dc[i] = dcore[4] / 2 + de / dcore[5] - dcore[2];
              else if (n == 1)
                dc[i] = Math.abs(dcore[3]) / 2 + de / dcore[6] - dcore[2];
              else if (n == 2)
                dc[i] = de / dcore[6] - dcore[2];
            }
            dt1.val = dc[1] / ((dc[1] - dc[0]) / dt);
            tret[j] -= dt1.val;
          }
        }
      }
      
      if ((retflag & SweConst.SE_ECL_TOTAL)!=0) {
        if ((retflag2 = eclipse_where(tret[0], ipl, starname, ifl, geopos, dcore, serr)) == SweConst.ERR)
          return retflag2;
        dc[0] = dcore[0];
        if ((retflag2 = eclipse_where(tret[4], ipl, starname, ifl, geopos, dcore, serr)) == SweConst.ERR)
          return retflag2;
        dc[1] = dcore[0];
        if ((retflag2 = eclipse_where(tret[5], ipl, starname, ifl, geopos, dcore, serr)) == SweConst.ERR)
          return retflag2;
        dc[2] = dcore[0];
        
        if (dc[0] * dc[1] < 0 || dc[0] * dc[2] < 0) {
          retflag |= SweConst.SE_ECL_ANNULAR_TOTAL;
          retflag &= ~SweConst.SE_ECL_TOTAL;
        }
      }
      
      if ((ifltype & SweConst.SE_ECL_TOTAL)==0 && (retflag & SweConst.SE_ECL_TOTAL)!=0) {
        t= tjd + direction * dadd;
        continue;
      }
      
      if ((ifltype & SweConst.SE_ECL_ANNULAR_TOTAL)==0 && (retflag & SweConst.SE_ECL_ANNULAR_TOTAL)!=0) {
        t= tjd + direction * dadd;
        continue;
      }
      
      
      k = 2;
      for (i = 0; i < 2; i++) {
        j = i + k;
        tt = tret[j] + SweDate.getDeltaT(tret[j]);
        if (calc_planet_star(tt, ipl, starname, iflag, ls, serr) == SweConst.ERR)
            return SweConst.ERR;
        if (sw.swe_calc(tt, SweConst.SE_MOON, iflag, lm, serr) == SweConst.ERR)
            return SweConst.ERR;
        dc[i] = sl.swe_degnorm(ls[0] - lm[0]);
        if (dc[i] > 180)
          dc[i] -= 360;
      }
      if (dc[0] * dc[1] >= 0)     
        tret[1] = 0;
      else {
        tjd = tjds;
        dt = 0.1;
        dt1.val = (tret[3] - tret[2]) / 2.0;
        if (dt1.val < dt)
          dt = dt1.val / 2.0;
        for (j = 0;
             dt > 0.01;
             j++, dt /= 3) {
          for (i = 0, t = tjd; i <= 1; i++, t -= dt) {
            tt = t + SweDate.getDeltaT(t);
            if (calc_planet_star(tt, ipl, starname, iflag, ls, serr) == SweConst.ERR)
              return SweConst.ERR;
            if (sw.swe_calc(tt, SweConst.SE_MOON, iflag, lm, serr) == SweConst.ERR)
              return SweConst.ERR;
            dc[i] = sl.swe_degnorm(ls[0] - lm[0]);
            if (dc[i] > 180)
              dc[i] -= 360;
            if (dc[i] > 180)
              dc[i] -= 360;
          }
          a = (dc[1] - dc[0]) / dt;
          if (a < 1e-10)
            break;
          dt1.val = dc[0] / a;
          tjd += dt1.val;
        }
        tret[1] = tjd;
      }
      break;
    }
//end_search_global:
    return retflag;
    
  }
 
 
  
  int swe_sol_eclipse_when_loc(double tjd_start, int ifl,
                               double[] geopos, double[] tret,
                               double[] attr, int backward,
                               StringBuffer serr) {
    int retflag = 0, retflag2 = 0;
    double geopos2[]=new double[20], dcore[]=new double[10];
    ifl &= SweConst.SEFLG_EPHMASK;
    if ((retflag = eclipse_when_loc(tjd_start, ifl, geopos, tret, attr,
                                                        backward, serr)) <= 0) {
      return retflag;
    }
    
    if ((retflag2 = eclipse_where(tret[0], SweConst.SE_SUN, null, ifl, geopos2, dcore, serr)) ==
                                                                SweConst.ERR) {
      return retflag2;
    }
    retflag |= (retflag2 & SweConst.SE_ECL_NONCENTRAL);
    attr[3] = dcore[0];
    return retflag;
  }
  
  int swe_lun_occult_when_loc(double tjd_start, int ipl, StringBuffer starname, int ifl,
       double[] geopos, double[] tret, double[] attr, int backward, StringBuffer serr) {
    int retflag = 0, retflag2 = 0;
    double geopos2[]=new double[20], dcore[]=new double[10];
    ifl &= SweConst.SEFLG_EPHMASK;
    if ((retflag = occult_when_loc(tjd_start, ipl, starname, ifl, geopos, tret, attr, backward, serr)) <= 0)
      return retflag;
    
    if ((retflag2 = eclipse_where(tret[0], ipl, starname, ifl, geopos2, dcore, serr)) == SweConst.ERR)
      return retflag2;
    retflag |= (retflag2 & SweConst.SE_ECL_NONCENTRAL);
    attr[3] = dcore[0];
    return retflag;
  }
  private int eclipse_when_loc(double tjd_start, int ifl, double[] geopos,
                               double[] tret, double[] attr, int backward,
                               StringBuffer serr) {
    int i, j, k, m;
    int retflag = 0;
    double t, tjd, dt, K, T, T2, T3, T4, F, M, Mm;
    DblObj dtint=new DblObj();
    double E, Ff, A1, Om;
    double xs[]=new double[6], xm[]=new double[6],
           ls[]=new double[6], lm[]=new double[6],
           x1[]=new double[6], x2[]=new double[6], dm, ds;
    double rmoon, rsun, rsplusrm, rsminusrm;
    double dc[]=new double[3], dctrmin;
    DblObj dctr=new DblObj();
    double twomin = 2.0 / 24.0 / 60.0;
    double tensec = 10.0 / 24.0 / 60.0 / 60.0;
    double twohr = 2.0 / 24.0;
    double tenmin = 10.0 / 24.0 / 60.0;
    DblObj dt1=new DblObj(), dt2=new DblObj();
    double dtdiv, dtstart;
    int iflag = SweConst.SEFLG_EQUATORIAL | SweConst.SEFLG_TOPOCTR | ifl;
    int iflagcart = iflag | SweConst.SEFLG_XYZ;
    sw.swe_set_topo(geopos[0], geopos[1], geopos[2]);
    K = (int) ((tjd_start - SwephData.J2000) / 365.2425 * 12.3685);
    if (backward!=0) {
      K++;
    } else {
      K--;
    }
//next_try:
    while (true) {
      T = K / 1236.85;
      T2 = T * T; T3 = T2 * T; T4 = T3 * T;
      Ff = F = sl.swe_degnorm(160.7108 + 390.67050274 * K
                   - 0.0016341 * T2
                   - 0.00000227 * T3
                   + 0.000000011 * T4);
      if (Ff > 180) {
        Ff -= 180;
      }
      if (Ff > 21 && Ff < 159) {         
        if (backward!=0) {
          K--;
        } else {
          K++;
        }
        continue;
      }
      
      tjd = 2451550.09765 + 29.530588853 * K
                          + 0.0001337 * T2
                          - 0.000000150 * T3
                          + 0.00000000073 * T4;
      M = sl.swe_degnorm(2.5534 + 29.10535669 * K
                          - 0.0000218 * T2
                          - 0.00000011 * T3);
      Mm = sl.swe_degnorm(201.5643 + 385.81693528 * K
                          + 0.1017438 * T2
                          + 0.00001239 * T3
                          + 0.000000058 * T4);
      Om = sl.swe_degnorm(124.7746 - 1.56375580 * K
                          + 0.0020691 * T2
                          + 0.00000215 * T3);
      E = 1 - 0.002516 * T - 0.0000074 * T2;
      A1 = sl.swe_degnorm(299.77 + 0.107408 * K - 0.009173 * T2);
      M *= SwissData.DEGTORAD;
      Mm *= SwissData.DEGTORAD;
      F *= SwissData.DEGTORAD;
      Om *= SwissData.DEGTORAD;
      A1 *= SwissData.DEGTORAD;
      tjd = tjd - 0.4075 * Math.sin(Mm)
                + 0.1721 * E * Math.sin(M);
      sw.swe_set_topo(geopos[0], geopos[1], geopos[2]);
      dtdiv = 2;
      dtstart = 0.5;
      if (tjd < 1900000) { 
        dtstart = 2;
      }
      for (dt = dtstart;
           dt > 0.00001;
           dt /= dtdiv) {
        if (dt < 0.1) {
          dtdiv = 3;
        }
        for (i = 0, t = tjd - dt; i <= 2; i++, t += dt) {
          
          if (sw.swe_calc(t, SweConst.SE_SUN, iflagcart, xs, serr) ==
                                                                SweConst.ERR) {
            return SweConst.ERR;
          }
          if (sw.swe_calc(t, SweConst.SE_SUN, iflag, ls, serr) == SweConst.ERR) {
            return SweConst.ERR;
          }
          if (sw.swe_calc(t, SweConst.SE_MOON, iflagcart, xm, serr) ==
                                                                SweConst.ERR) {
            return SweConst.ERR;
          }
          if (sw.swe_calc(t, SweConst.SE_MOON, iflag, lm, serr) == SweConst.ERR) {
            return SweConst.ERR;
          }
          dm = Math.sqrt(sl.square_sum(xm));
          ds = Math.sqrt(sl.square_sum(xs));
          for (k = 0; k < 3; k++) {
            x1[k] = xs[k] / ds ;
            x2[k] = xm[k] / dm ;
          }
          dc[i] = Math.acos(sl.swi_dot_prod_unit(x1, x2)) * SwissData.RADTODEG;
        }
        find_maximum(dc[0], dc[1], dc[2], dt, dtint, dctr);
        tjd += dtint.val + dt;
      }
      if (sw.swe_calc(tjd, SweConst.SE_SUN, iflagcart, xs, serr) ==
                                                                 SweConst.ERR) {
        return SweConst.ERR;
      }
      if (sw.swe_calc(tjd, SweConst.SE_SUN, iflag, ls, serr) == SweConst.ERR) {
        return SweConst.ERR;
      }
      if (sw.swe_calc(tjd, SweConst.SE_MOON, iflagcart, xm, serr) ==
                                                                 SweConst.ERR) {
        return SweConst.ERR;
      }
      if (sw.swe_calc(tjd, SweConst.SE_MOON, iflag, lm, serr) == SweConst.ERR) {
        return SweConst.ERR;
      }
      dctr.val = Math.acos(sl.swi_dot_prod_unit(xs, xm)) * SwissData.RADTODEG;
      rmoon = Math.asin(RMOON / lm[2]) * SwissData.RADTODEG;
      rsun = Math.asin(RSUN / ls[2]) * SwissData.RADTODEG;
      rsplusrm = rsun + rmoon;
      rsminusrm = rsun - rmoon;
      if (dctr.val > rsplusrm) {
        if (backward!=0) {
          K--;
        } else {
          K++;
        }
        continue;
      }
      tret[0] = tjd - SweDate.getDeltaT(tjd);
      if ((backward!=0 && tret[0] >= tjd_start - 0.0001)
        || (backward==0 && tret[0] <= tjd_start + 0.0001)) {
        if (backward!=0) {
          K--;
        } else {
          K++;
        }
        continue;
      }
      if (dctr.val < rsminusrm) {
        retflag = SweConst.SE_ECL_ANNULAR;
      } else if (dctr.val < Math.abs(rsminusrm)) {
        retflag = SweConst.SE_ECL_TOTAL;
      } else if (dctr.val <= rsplusrm) {
        retflag = SweConst.SE_ECL_PARTIAL;
      }
      dctrmin = dctr.val;
      
      if (dctr.val > Math.abs(rsminusrm)) {
        tret[2] = tret[3] = 0;
      } else {
        dc[1] = Math.abs(rsminusrm) - dctrmin;
        for (i = 0, t = tjd - twomin; i <= 2; i += 2, t = tjd + twomin) {
          if (sw.swe_calc(t, SweConst.SE_SUN, iflagcart, xs, serr) ==
                                                                 SweConst.ERR) {
            return SweConst.ERR;
          }
          if (sw.swe_calc(t, SweConst.SE_MOON, iflagcart, xm, serr) ==
                                                                 SweConst.ERR) {
            return SweConst.ERR;
          }
          dm = Math.sqrt(sl.square_sum(xm));
          ds = Math.sqrt(sl.square_sum(xs));
          rmoon = Math.asin(RMOON / dm) * SwissData.RADTODEG;
          rsun = Math.asin(RSUN / ds) * SwissData.RADTODEG;
          rsminusrm = rsun - rmoon;
          for (k = 0; k < 3; k++) {
            x1[k] = xs[k] / ds ;
            x2[k] = xm[k] / dm ;
          }
          dctr.val = Math.acos(sl.swi_dot_prod_unit(x1, x2)) * SwissData.RADTODEG;
          dc[i] = Math.abs(rsminusrm) - dctr.val;
        }
        find_zero(dc[0], dc[1], dc[2], twomin, dt1, dt2);
        tret[2] = tjd + dt1.val + twomin;
        tret[3] = tjd + dt2.val + twomin;
        for (m = 0, dt = tensec; m < 2; m++, dt /= 10) {
          for (j = 2; j <= 3; j++) {
            if (sw.swe_calc(tret[j], SweConst.SE_SUN,
                            iflagcart | SweConst.SEFLG_SPEED, xs, serr) ==
                                                                 SweConst.ERR) {
              return SweConst.ERR;
            }
            if (sw.swe_calc(tret[j], SweConst.SE_MOON,
                            iflagcart | SweConst.SEFLG_SPEED, xm, serr) ==
                                                                 SweConst.ERR) {
              return SweConst.ERR;
            }
            for (i = 0; i < 2; i++) {
              if (i == 1) {
                for(k = 0; k < 3; k++) {
                  xs[k] -= xs[k+3] * dt;
                  xm[k] -= xm[k+3] * dt;
                }
              }
              dm = Math.sqrt(sl.square_sum(xm));
              ds = Math.sqrt(sl.square_sum(xs));
              rmoon = Math.asin(RMOON / dm) * SwissData.RADTODEG;
              rsun = Math.asin(RSUN / ds) * SwissData.RADTODEG;
              rsminusrm = rsun - rmoon;
              for (k = 0; k < 3; k++) {
                x1[k] = xs[k] / ds ;
                x2[k] = xm[k] / dm ;
              }
              dctr.val = Math.acos(sl.swi_dot_prod_unit(x1, x2)) *
                                                             SwissData.RADTODEG;
              dc[i] = Math.abs(rsminusrm) - dctr.val;
            }
            dt1.val = -dc[0] / ((dc[0] - dc[1]) / dt);
            tret[j] += dt1.val;
          }
        }
        tret[2] -= SweDate.getDeltaT(tret[2]);
        tret[3] -= SweDate.getDeltaT(tret[3]);
      }
      
      dc[1] = rsplusrm - dctrmin;
      for (i = 0, t = tjd - twohr; i <= 2; i += 2, t = tjd + twohr) {
        if (sw.swe_calc(t, SweConst.SE_SUN, iflagcart, xs, serr) ==
                                                                 SweConst.ERR) {
          return SweConst.ERR;
        }
        if (sw.swe_calc(t, SweConst.SE_MOON, iflagcart, xm, serr) ==
                                                                 SweConst.ERR) {
          return SweConst.ERR;
        }
        dm = Math.sqrt(sl.square_sum(xm));
        ds = Math.sqrt(sl.square_sum(xs));
        rmoon = Math.asin(RMOON / dm) * SwissData.RADTODEG;
        rsun = Math.asin(RSUN / ds) * SwissData.RADTODEG;
        rsplusrm = rsun + rmoon;
        for (k = 0; k < 3; k++) {
          x1[k] = xs[k] / ds ;
          x2[k] = xm[k] / dm ;
        }
        dctr.val = Math.acos(sl.swi_dot_prod_unit(x1, x2)) * SwissData.RADTODEG;
        dc[i] = rsplusrm - dctr.val;
      }
      find_zero(dc[0], dc[1], dc[2], twohr, dt1, dt2);
      tret[1] = tjd + dt1.val + twohr;
      tret[4] = tjd + dt2.val + twohr;
      for (m = 0, dt = tenmin; m < 3; m++, dt /= 10) {
        for (j = 1; j <= 4; j += 3) {
          if (sw.swe_calc(tret[j], SweConst.SE_SUN,
                          iflagcart | SweConst.SEFLG_SPEED, xs, serr) ==
                                                                 SweConst.ERR) {
            return SweConst.ERR;
          }
          if (sw.swe_calc(tret[j], SweConst.SE_MOON,
                          iflagcart | SweConst.SEFLG_SPEED, xm, serr) ==
                                                                 SweConst.ERR) {
            return SweConst.ERR;
          }
          for (i = 0; i < 2; i++) {
            if (i == 1) {
              for(k = 0; k < 3; k++) {
                xs[k] -= xs[k+3] * dt;
                xm[k] -= xm[k+3] * dt;
              }
            }
            dm = Math.sqrt(sl.square_sum(xm));
            ds = Math.sqrt(sl.square_sum(xs));
            rmoon = Math.asin(RMOON / dm) * SwissData.RADTODEG;
            rsun = Math.asin(RSUN / ds) * SwissData.RADTODEG;
            rsplusrm = rsun + rmoon;
            for (k = 0; k < 3; k++) {
              x1[k] = xs[k] / ds ;
              x2[k] = xm[k] / dm ;
            }
            dctr.val = Math.acos(sl.swi_dot_prod_unit(x1, x2)) * SwissData.RADTODEG;
            dc[i] = Math.abs(rsplusrm) - dctr.val;
          }
          dt1.val = -dc[0] / ((dc[0] - dc[1]) / dt);
          tret[j] += dt1.val;
        }
      }
      tret[1] -= SweDate.getDeltaT(tret[1]);
      tret[4] -= SweDate.getDeltaT(tret[4]);
      
      for (i = 4; i >= 0; i--) {        
        if (tret[i] == 0) {
          continue;
        }
        if (eclipse_how(tret[i], SweConst.SE_SUN, null, ifl, geopos[0], geopos[1], geopos[2],
                          attr, serr) == SweConst.ERR) {
          return SweConst.ERR;
        }
        
        if (attr[5] > 0) {        
          retflag |= SweConst.SE_ECL_VISIBLE;
          switch(i) {
          case 0: retflag |= SweConst.SE_ECL_MAX_VISIBLE; break;
          case 1: retflag |= SweConst.SE_ECL_1ST_VISIBLE; break;
          case 2: retflag |= SweConst.SE_ECL_2ND_VISIBLE; break;
          case 3: retflag |= SweConst.SE_ECL_3RD_VISIBLE; break;
          case 4: retflag |= SweConst.SE_ECL_4TH_VISIBLE; break;
          default:  break;
          }
        }
      }
      if ((retflag & SweConst.SE_ECL_VISIBLE)==0) {
        if (backward!=0) {
          K--;
        } else {
          K++;
        }
        continue;
      }
      break;
    } // while (true)
    return retflag;
  }
  private int occult_when_loc(double tjd_start, int ipl, StringBuffer starname,
      int ifl, double[] geopos, double[] tret, double[] attr,
      int backward, StringBuffer serr) {
    int i, j, k, m;
    int retflag = 0;
    double t, tjd, dt;
    DblObj dtint=new DblObj();
    double xs[]=new double[6], xm[]=new double[6], ls[]=new double[6], lm[]=new double[6], x1[]=new double[6], x2[]=new double[6], dm, ds;
    double rmoon, rsun, rsplusrm, rsminusrm;
    double dc[]=new double[20], dctrmin;
    DblObj dctr=new DblObj();
    double twomin = 2.0 / 24.0 / 60.0;
    double tensec = 10.0 / 24.0 / 60.0 / 60.0;
    double twohr = 2.0 / 24.0;
    double tenmin = 10.0 / 24.0 / 60.0;
    DblObj dt1=new DblObj(), dt2=new DblObj();
    double dtdiv, dtstart;
    double dadd2 = 6;
    int nstartpos = 10;
    double drad;
    int iflag = SweConst.SEFLG_TOPOCTR | ifl;
    int iflaggeo = iflag & ~SweConst.SEFLG_TOPOCTR;
    int iflagcart = iflag | SweConst.SEFLG_XYZ;
    int iflagcartgeo = iflaggeo | SweConst.SEFLG_XYZ;
    int direction = 1;
    int one_try = backward & SweConst.SE_ECL_ONE_TRY;
    boolean stop_after_this = false;
    backward &= 1L;
    retflag = 0;
    for (i = 0; i <= 9; i++)
      tret[i] = 0;
    if (backward!=0)
      direction = -1;
    t = tjd_start - direction * 0.1;
    tjd = tjd_start;
    while (true) {
//next_try:
      for (i = 0; i < nstartpos; i++, t += direction * dadd2) {
        if (calc_planet_star(t, ipl, starname, iflagcartgeo, xs, serr) == SweConst.ERR)
            return SweConst.ERR;
        if (sw.swe_calc(t, SweConst.SE_MOON, iflagcartgeo, xm, serr) == SweConst.ERR)
            return SweConst.ERR;
        dc[i] = Math.acos(sl.swi_dot_prod_unit(xs, xm)) * SwissData.RADTODEG;
        if (i > 1 && dc[i] > dc[i-1] && dc[i-2] > dc[i-1]) {
          tjd = t - direction*dadd2;
          break;
        } else if (i == nstartpos-1) {
          for (j = 0; j < nstartpos; j++)
              //DevNull.print(dc[j] + " ");
          DevNull.print("swe_lun_occult_when_loc(): problem planet\n");
          return SweConst.ERR;
        }
      }
      
      if (starname != null && starname.length() > 0)
        drad = 0;
      else if (ipl < SwephData.NDIAM)
        drad = SwephData.pla_diam[ipl] / 2 / SweConst.AUNIT;
      else if (ipl > SweConst.SE_AST_OFFSET)
        drad = swed.ast_diam / 2 * 1000 / SweConst.AUNIT; 
      else
        drad = 0;
      
      dtdiv = 3;
      dtstart = dadd2; 
      for (dt = dtstart; 
           dt > 0.00001; 
           dt /= dtdiv) {
        if (dt < 0.01) 
          dtdiv = 3;
        for (i = 0, t = tjd - dt; i <= 2; i++, t += dt) {
          
          if (calc_planet_star(t, ipl, starname, iflagcart, xs, serr) == SweConst.ERR)
            return SweConst.ERR;
          if (calc_planet_star(t, ipl, starname, iflag, ls, serr) == SweConst.ERR)
            return SweConst.ERR;
          if (sw.swe_calc(t, SweConst.SE_MOON, iflagcart, xm, serr) == SweConst.ERR)
            return SweConst.ERR;
          if (sw.swe_calc(t, SweConst.SE_MOON, iflag, lm, serr) == SweConst.ERR)
            return SweConst.ERR;
          if (dt < 1 && Math.abs(ls[1] - lm[1]) > 2) {
            if (one_try != 0) {
              stop_after_this = true;
            } else {
              t = tjd + direction * 2;
//goto next_try;
              continue;
            }
          }
          dc[i] = Math.acos(sl.swi_dot_prod_unit(xs, xm)) * SwissData.RADTODEG;
          rmoon = Math.asin(RMOON / lm[2]) * SwissData.RADTODEG;
          rsun = Math.asin(drad / ls[2]) * SwissData.RADTODEG;
          dc[i] -= (rmoon + rsun);
        }
        find_maximum(dc[0], dc[1], dc[2], dt, dtint, dctr);
        tjd += dtint.val + dt;
      }
      if (stop_after_this) { 
        tret[0] = tjd;
        return 0;
      }
      if (calc_planet_star(tjd, ipl, starname, iflagcart, xs, serr) == SweConst.ERR)
        return SweConst.ERR;
      if (calc_planet_star(tjd, ipl, starname, iflag, ls, serr) == SweConst.ERR)
        return SweConst.ERR;
      if (sw.swe_calc(tjd, SweConst.SE_MOON, iflagcart, xm, serr) == SweConst.ERR)
        return SweConst.ERR;
      if (sw.swe_calc(tjd, SweConst.SE_MOON, iflag, lm, serr) == SweConst.ERR)
        return SweConst.ERR;
      dctr.val = Math.acos(sl.swi_dot_prod_unit(xs, xm)) * SwissData.RADTODEG;
      rmoon = Math.asin(RMOON / lm[2]) * SwissData.RADTODEG;
      rsun = Math.asin(drad / ls[2]) * SwissData.RADTODEG;
      rsplusrm = rsun + rmoon;
      rsminusrm = rsun - rmoon;
      if (dctr.val > rsplusrm) {
        if (one_try!=0) {
          tret[0] = tjd;
          return 0;
        }
        t = tjd + direction;
        continue;
      }
      tret[0] = tjd - SweDate.getDeltaT(tjd);
      if ((backward!=0 && tret[0] >= tjd_start - 0.0001) 
        || (backward==0 && tret[0] <= tjd_start + 0.0001)) {
          t = tjd + direction;
        continue;
      }
      if (dctr.val < rsminusrm)
        retflag = SweConst.SE_ECL_ANNULAR;
      else if (dctr.val < Math.abs(rsminusrm))
        retflag = SweConst.SE_ECL_TOTAL;
      else if (dctr.val <= rsplusrm)
        retflag = SweConst.SE_ECL_PARTIAL;
      dctrmin = dctr.val;
      
      if (dctr.val > Math.abs(rsminusrm))  
        tret[2] = tret[3] = 0;
      else {
        dc[1] = Math.abs(rsminusrm) - dctrmin;
        for (i = 0, t = tjd - twomin; i <= 2; i += 2, t = tjd + twomin) {
          if (calc_planet_star(t, ipl, starname, iflagcart, xs, serr) == SweConst.ERR)
            return SweConst.ERR;
          if (sw.swe_calc(t, SweConst.SE_MOON, iflagcart, xm, serr) == SweConst.ERR)
            return SweConst.ERR;
          dm = Math.sqrt(sl.square_sum(xm));
          ds = Math.sqrt(sl.square_sum(xs));
          rmoon = Math.asin(RMOON / dm) * SwissData.RADTODEG;
          rsun = Math.asin(drad / ds) * SwissData.RADTODEG;
          rsminusrm = rsun - rmoon;
          for (k = 0; k < 3; k++) {
            x1[k] = xs[k] / ds ;
            x2[k] = xm[k] / dm ;
          }
          dctr.val = Math.acos(sl.swi_dot_prod_unit(x1, x2)) * SwissData.RADTODEG;
          dc[i] = Math.abs(rsminusrm) - dctr.val;
        }
        find_zero(dc[0], dc[1], dc[2], twomin, dt1, dt2);
        tret[2] = tjd + dt1.val + twomin;
        tret[3] = tjd + dt2.val + twomin;
        for (m = 0, dt = tensec; m < 2; m++, dt /= 10) {
          for (j = 2; j <= 3; j++) {
            if (calc_planet_star(tret[j], ipl, starname, iflagcart | SweConst.SEFLG_SPEED, xs, serr) == SweConst.ERR)
              return SweConst.ERR;
            if (sw.swe_calc(tret[j], SweConst.SE_MOON, iflagcart | SweConst.SEFLG_SPEED, xm, serr) == SweConst.ERR)
              return SweConst.ERR;
            for (i = 0; i < 2; i++) {
              if (i == 1) {
                for(k = 0; k < 3; k++) {
                  xs[k] -= xs[k+3] * dt;
                  xm[k] -= xm[k+3] * dt;
                }
              }
              dm = Math.sqrt(sl.square_sum(xm));
              ds = Math.sqrt(sl.square_sum(xs));
              rmoon = Math.asin(RMOON / dm) * SwissData.RADTODEG;
              rsun = Math.asin(drad / ds) * SwissData.RADTODEG;
              rsminusrm = rsun - rmoon;
              for (k = 0; k < 3; k++) {
                x1[k] = xs[k] / ds ;
                x2[k] = xm[k] / dm ;
              }
              dctr.val = Math.acos(sl.swi_dot_prod_unit(x1, x2)) * SwissData.RADTODEG;
              dc[i] = Math.abs(rsminusrm) - dctr.val;
            }
            dt1.val = -dc[0] / ((dc[0] - dc[1]) / dt);
            tret[j] += dt1.val;
          }
        }
        tret[2] -= SweDate.getDeltaT(tret[2]);
        tret[3] -= SweDate.getDeltaT(tret[3]);
      }
      
      dc[1] = rsplusrm - dctrmin;
      for (i = 0, t = tjd - twohr; i <= 2; i += 2, t = tjd + twohr) {
        if (calc_planet_star(t, ipl, starname, iflagcart, xs, serr) == SweConst.ERR)
          return SweConst.ERR;
        if (sw.swe_calc(t, SweConst.SE_MOON, iflagcart, xm, serr) == SweConst.ERR)
          return SweConst.ERR;
        dm = Math.sqrt(sl.square_sum(xm));
        ds = Math.sqrt(sl.square_sum(xs));
        rmoon = Math.asin(RMOON / dm) * SwissData.RADTODEG;
        rsun = Math.asin(drad / ds) * SwissData.RADTODEG;
        rsplusrm = rsun + rmoon;
        for (k = 0; k < 3; k++) {
          x1[k] = xs[k] / ds ;
          x2[k] = xm[k] / dm ;
        }
        dctr.val = Math.acos(sl.swi_dot_prod_unit(x1, x2)) * SwissData.RADTODEG;
        dc[i] = rsplusrm - dctr.val;
      }
      find_zero(dc[0], dc[1], dc[2], twohr, dt1, dt2);
      tret[1] = tjd + dt1.val + twohr;
      tret[4] = tjd + dt2.val + twohr;
      for (m = 0, dt = tenmin; m < 3; m++, dt /= 10) {
        for (j = 1; j <= 4; j += 3) {
          if (calc_planet_star(tret[j], ipl, starname, iflagcart | SweConst.SEFLG_SPEED, xs, serr) == SweConst.ERR)
            return SweConst.ERR;
          if (sw.swe_calc(tret[j], SweConst.SE_MOON, iflagcart | SweConst.SEFLG_SPEED, xm, serr) == SweConst.ERR)
            return SweConst.ERR;
          for (i = 0; i < 2; i++) {
            if (i == 1) {
              for(k = 0; k < 3; k++) {
                xs[k] -= xs[k+3] * dt;
                xm[k] -= xm[k+3] * dt;
              }
            }
            dm = Math.sqrt(sl.square_sum(xm));
            ds = Math.sqrt(sl.square_sum(xs));
            rmoon = Math.asin(RMOON / dm) * SwissData.RADTODEG;
            rsun = Math.asin(drad / ds) * SwissData.RADTODEG;
            rsplusrm = rsun + rmoon;
            for (k = 0; k < 3; k++) {
              x1[k] = xs[k] / ds ;
              x2[k] = xm[k] / dm ;
            }
            dctr.val = Math.acos(sl.swi_dot_prod_unit(x1, x2)) * SwissData.RADTODEG;
            dc[i] = Math.abs(rsplusrm) - dctr.val;
          }
          dt1.val = -dc[0] / ((dc[0] - dc[1]) / dt);
          tret[j] += dt1.val;
        }
      }
      tret[1] -= SweDate.getDeltaT(tret[1]);
      tret[4] -= SweDate.getDeltaT(tret[4]);
      
      for (i = 4; i >= 0; i--) {	
        if (tret[i] == 0)
          continue;
        if (eclipse_how(tret[i], ipl, starname, ifl, geopos[0], geopos[1], geopos[2], 
    		attr, serr) == SweConst.ERR)
          return SweConst.ERR;
        
        if (attr[5] > 0) {	
          retflag |= SweConst.SE_ECL_VISIBLE;
          switch(i) {
          case 0: retflag |= SweConst.SE_ECL_MAX_VISIBLE; break;
          case 1: retflag |= SweConst.SE_ECL_1ST_VISIBLE; break;
          case 2: retflag |= SweConst.SE_ECL_2ND_VISIBLE; break;
          case 3: retflag |= SweConst.SE_ECL_3RD_VISIBLE; break;
          case 4: retflag |= SweConst.SE_ECL_4TH_VISIBLE; break;
          default:  break;
          }
        }
      }
      if ((retflag & SweConst.SE_ECL_VISIBLE)==0) {
        t = tjd + direction;
        continue;
      }
      break; // next_try
    } // while (true) .. [goto next_try]
    return retflag;
  }
  
  
  void swe_azalt(double tjd_ut,
                 int calc_flag,
                 double[] geopos,
                 double atpress,
                 double attemp,
                 double[] xin,
                 double[] xaz) {
    int i;
    double x[]=new double[6], xra[]=new double[3];
    double armc = sl.swe_degnorm(sl.swe_sidtime(tjd_ut) * 15 + geopos[0]);
    double mdd, eps_true, tjd_et;
    for (i = 0; i < 2; i++)
      xra[i] = xin[i];
    xra[2] = 1;
    if (calc_flag == SweConst.SE_ECL2HOR) {
          tjd_et = tjd_ut + SweDate.getDeltaT(tjd_ut);
      sw.swe_calc(tjd_et, SweConst.SE_ECL_NUT, 0, x, null);
      eps_true = x[0];
          sl.swe_cotrans(xra, 0, xra, 0, -eps_true);
    }
    mdd = sl.swe_degnorm(xra[0] - armc);
    x[0] = sl.swe_degnorm(mdd - 90);
    x[1] = xra[1];
    x[2] = 1;
    
    sl.swe_cotrans(x, 0, x, 0, 90 - geopos[1]);
    
    x[0] = sl.swe_degnorm(x[0] + 90);
    xaz[0] = 360 - x[0];
    xaz[1] = x[1];                
    if (atpress == 0) {
      
      atpress = 1013.25 * Math.pow(1 - 0.0065 * geopos[2] / 288, 5.255);
    }
    xaz[2] = swe_refrac(x[1], atpress, attemp, SweConst.SE_TRUE_TO_APP);
  }
  
  
  void swe_azalt_rev(double tjd_ut,
                     int calc_flag,
                     double[] geopos,
                     double[] xin,
                     double[] xout) {
    int i;
    double x[]=new double[6], xaz[]=new double[3];
    double geolon = geopos[0];
    double geolat = geopos[1];
    double armc = sl.swe_degnorm(sl.swe_sidtime(tjd_ut) * 15 + geolon);
    double eps_true, tjd_et;
    for (i = 0; i < 2; i++)
      xaz[i] = xin[i];
    xaz[2] = 1;
    
    xaz[0] = 360 - xaz[0];
    xaz[0] = sl.swe_degnorm(xaz[0] - 90);
    
    sl.swe_cotrans(xaz, 0, xaz, 0, geolat - 90);
    xaz[0] = sl.swe_degnorm(xaz[0] + armc + 90);
    xout[0] = xaz[0];
    xout[1] = xaz[1];
    
    if (calc_flag == SweConst.SE_HOR2ECL) {
      tjd_et = tjd_ut + SweDate.getDeltaT(tjd_ut);
      sw.swe_calc(tjd_et, SweConst.SE_ECL_NUT, 0, x, null);
      eps_true = x[0];
      sl.swe_cotrans(xaz, 0, x, 0, eps_true);
      xout[0] = x[0];
      xout[1] = x[1];
    }
  }
  
  
  double swe_refrac(double inalt, double atpress, double attemp,
                    int calc_flag) {
    double a, refr;
    double pt_factor = atpress / 1010.0 * 283.0 / (273.0 + attemp);
    double trualt, appalt;
    
    if (calc_flag == SweConst.SE_TRUE_TO_APP) {
      trualt = inalt;
      if (trualt > 15) {
        a = Math.tan((90 - trualt) * SwissData.DEGTORAD);
        refr = (58.276 * a - 0.0824 * a * a * a);
        refr *=  pt_factor / 3600.0;
      } else if (trualt > -5) {
        
        a = trualt + 10.3 / (trualt + 5.11);
        if (a + 1e-10 >= 90) {
          refr = 0;
        } else {
          refr = 1.02 / Math.tan(a * SwissData.DEGTORAD);
        }
        refr *= pt_factor / 60.0;
      } else {
        refr = 0;
      }
      appalt = trualt;
      if (appalt + refr > 0) {
        appalt += refr;
      }
      return appalt;
    } else { // SE_TRUE_TO_APP
      appalt = inalt;
      if (appalt > 15) {
        a = Math.tan((90 - appalt) * SwissData.DEGTORAD);
        refr = (58.294 * a - 0.0668 * a * a * a);
        refr *=  pt_factor / 3600.0;
      } else {
        
        a = appalt + 7.31 / (appalt + 4.4);
        if (a + 1e-10 >= 90) {
          refr = 0;
        } else {
          refr = 1.00 / Math.tan(a * SwissData.DEGTORAD);
          refr -= 0.06 * Math.sin(14.7 * refr + 13);
        }
        refr *= pt_factor / 60.0;
      }
      trualt = appalt;
      if (trualt - refr > 0) {
        trualt -= refr;
      }
      return trualt;
    }
  }
  
  
  int swe_lun_eclipse_how(double tjd_ut,
                          int ifl,
                          double[] geopos,
                          double[] attr,
                          StringBuffer serr) {
    double dcore[]=new double[10];
    
    // geopos[0] = geopos[0]; 
    ifl = ifl & ~SweConst.SEFLG_TOPOCTR;
    return lun_eclipse_how(tjd_ut, ifl, attr, dcore, serr);
  }
  
  private int lun_eclipse_how(double tjd_ut,
                              int ifl,
                              double[] attr,
                              double[] dcore,
                              StringBuffer serr) {
    int i;
    int retc = 0;
    double e[]=new double[6], rm[]=new double[6], rs[]=new double[6];
    double dsm, d0, D0, s0, r0, ds, dm;
    double dctr, x1[]=new double[6], x2[]=new double[6];
    double f1, f2;
    double deltat, tjd;
    double cosf1, cosf2;
    int iflag;
    for (i = 0; i < 10; i++)
      dcore[i] = 0;
    for (i = 0; i < 20; i++)
      attr[i] = 0;
    
    iflag = SweConst.SEFLG_SPEED | SweConst.SEFLG_EQUATORIAL | ifl;
    iflag  = iflag | SweConst.SEFLG_XYZ;
    deltat = SweDate.getDeltaT(tjd_ut);
    tjd = tjd_ut + deltat;
    
    if (sw.swe_calc(tjd, SweConst.SE_MOON, iflag, rm, serr) == SweConst.ERR) {
      return SweConst.ERR;
    }
    
    dm = Math.sqrt(sl.square_sum(rm));
    
    if (sw.swe_calc(tjd, SweConst.SE_SUN, iflag, rs, serr) == SweConst.ERR) {
      return SweConst.ERR;
    }
    
    ds = Math.sqrt(sl.square_sum(rs));
    for (i = 0; i < 3; i++) {
      x1[i] = rs[i] / ds;
      x2[i] = rm[i] / dm;
    }
    dctr = Math.acos(sl.swi_dot_prod_unit(x1, x2)) * SwissData.RADTODEG;
    
    for (i = 0; i <= 2; i++)
      rs[i] -= rm[i];
    
    for (i = 0; i <= 2; i++)
      rm[i] = -rm[i];
    
    for (i = 0; i <= 2; i++)
      e[i] = (rm[i] - rs[i]);
    
    dsm = Math.sqrt(sl.square_sum(e));
    
    for (i = 0; i <= 2; i++)
      e[i] /= dsm;
    f1 = ((RSUN - REARTH) / dsm);
    cosf1 = Math.sqrt(1 - f1 * f1);
    f2 = ((RSUN + REARTH) / dsm);
    cosf2 = Math.sqrt(1 - f2 * f2);
    
    s0 = -sw.dot_prod(rm, e);
    
    r0 = Math.sqrt(dm * dm - s0 * s0);
    
    d0 = Math.abs(s0 / dsm * (DSUN - DEARTH) - DEARTH) * (1 + 1.0 / 50) / cosf1;
           
    
    D0 = (s0 / dsm * (DSUN + DEARTH) + DEARTH) * (1 + 1.0 / 50) / cosf2;
    d0 /= cosf1;
    D0 /= cosf2;
    dcore[0] = r0;
    dcore[1] = d0;
    dcore[2] = D0;
    dcore[3] = cosf1;
    dcore[4] = cosf2;
    
    retc = 0;
    if (d0 / 2 >= r0 + RMOON / cosf1) {
      retc = SweConst.SE_ECL_TOTAL;
      attr[0] = (d0 / 2 - r0 + RMOON) / DMOON;
    } else if (d0 / 2 >= r0 - RMOON / cosf1) {
      retc = SweConst.SE_ECL_PARTIAL;
      attr[0] = (d0 / 2 - r0 + RMOON) / DMOON;
    } else if (D0 / 2 >= r0 - RMOON / cosf2) {
      retc = SweConst.SE_ECL_PENUMBRAL;
      attr[0] = 0;
    } else {
      if (serr != null) {
        serr.setLength(0);
        serr.append("no lunar eclipse at tjd = "+tjd);
      }
    }
    
    attr[1] = (D0 / 2 - r0 + RMOON) / DMOON;
    if (retc != 0) {
      attr[7] = 180 - Math.abs(dctr);
    }
    return retc;
  }
  
  
  int swe_lun_eclipse_when(double tjd_start, int ifl, int ifltype,
                           double[] tret, int backward,
                           StringBuffer serr) {
    int i, j, m, n, o, i1 = 0, i2 = 0;
    int retflag = 0, retflag2 = 0;
    double t, tjd, dt, dta, dtb;
    DblObj dtint=new DblObj();
    double T, T2, T3, T4, K, F, M, Mm;
    double E, Ff, F1, A1, Om;
    double xs[]=new double[6], xm[]=new double[6], dm, ds;
    double rsun, rearth, dcore[]=new double[10];
    double dc[]=new double[3];
    DblObj dctr=new DblObj();
    double twohr = 2.0 / 24.0;
    double tenmin = 10.0 / 24.0 / 60.0;
    DblObj dt1=new DblObj(), dt2=new DblObj();
    double kk;
    double attr[]=new double[20];
    double dtstart, dtdiv;
    double xa[]=new double[6], xb[]=new double[6];
    int direction = 1;
    int iflag;
    int iflagcart;
    ifl &= SweConst.SEFLG_EPHMASK;
    iflag = SweConst.SEFLG_EQUATORIAL | ifl;
    iflagcart = iflag | SweConst.SEFLG_XYZ;
    if (ifltype == 0) {
      ifltype = SweConst.SE_ECL_TOTAL | SweConst.SE_ECL_PENUMBRAL |
                SweConst.SE_ECL_PARTIAL;
    }
    if (backward!=0) {
      direction = -1;
    }
    K = (int) ((tjd_start - SwephData.J2000) / 365.2425 * 12.3685);
    K -= direction;
//next_try:
    while (true) {
      retflag = 0;
      for (i = 0; i <= 9; i++)
        tret[i] = 0;
      kk = K + 0.5;
      T = kk / 1236.85;
      T2 = T * T; T3 = T2 * T; T4 = T3 * T;
      Ff = F = sl.swe_degnorm(160.7108 + 390.67050274 * kk
                   - 0.0016341 * T2
                   - 0.00000227 * T3
                   + 0.000000011 * T4);
      if (Ff > 180) {
        Ff -= 180;
      }
      if (Ff > 21 && Ff < 159) {         
        K += direction;
        continue;
      }
      
      tjd = 2451550.09765 + 29.530588853 * kk
                          + 0.0001337 * T2
                          - 0.000000150 * T3
                          + 0.00000000073 * T4;
      M = sl.swe_degnorm(2.5534 + 29.10535669 * kk
                          - 0.0000218 * T2
                          - 0.00000011 * T3);
      Mm = sl.swe_degnorm(201.5643 + 385.81693528 * kk
                          + 0.1017438 * T2
                          + 0.00001239 * T3
                          + 0.000000058 * T4);
      Om = sl.swe_degnorm(124.7746 - 1.56375580 * kk
                          + 0.0020691 * T2
                          + 0.00000215 * T3);
      E = 1 - 0.002516 * T - 0.0000074 * T2;
      A1 = sl.swe_degnorm(299.77 + 0.107408 * kk - 0.009173 * T2);
      M *= SwissData.DEGTORAD;
      Mm *= SwissData.DEGTORAD;
      F *= SwissData.DEGTORAD;
      Om *= SwissData.DEGTORAD;
      F1 = F - 0.02665 * Math.sin(Om) * SwissData.DEGTORAD;
      A1 *= SwissData.DEGTORAD;
      tjd = tjd - 0.4075 * Math.sin(Mm)
                + 0.1721 * E * Math.sin(M)
                + 0.0161 * Math.sin(2 * Mm)
                - 0.0097 * Math.sin(2 * F1)
                + 0.0073 * E * Math.sin(Mm - M)
                - 0.0050 * E * Math.sin(Mm + M)
                - 0.0023 * Math.sin(Mm - 2 * F1)
                + 0.0021 * E * Math.sin(2 * M)
                + 0.0012 * Math.sin(Mm + 2 * F1)
                + 0.0006 * E * Math.sin(2 * Mm + M)
                - 0.0004 * Math.sin(3 * Mm)
                - 0.0003 * E * Math.sin(M + 2 * F1)
                + 0.0003 * Math.sin(A1)
                - 0.0002 * E * Math.sin(M - 2 * F1)
                - 0.0002 * E * Math.sin(2 * Mm - M)
                - 0.0002 * Math.sin(Om);
      
      dtstart = 0.1;
      if (tjd < 2000000) {
        dtstart = 5;
      }
      dtdiv = 4;
      for (j = 0, dt = dtstart;
           dt > 0.001;
           j++, dt /= dtdiv) {
        for (i = 0, t = tjd - dt; i <= 2; i++, t += dt) {
          if (sw.swe_calc(t, SweConst.SE_SUN, iflagcart, xs, serr) ==
                                                                 SweConst.ERR) {
            return SweConst.ERR;
          }
          if (sw.swe_calc(t, SweConst.SE_MOON, iflagcart, xm, serr) ==
                                                                 SweConst.ERR) {
            return SweConst.ERR;
          }
          for (m = 0; m < 3; m++) {
            xs[m] -= xm[m];        
            xm[m] = -xm[m];        
          }
          ds = Math.sqrt(sl.square_sum(xs));
          dm = Math.sqrt(sl.square_sum(xm));
          for (m = 0; m < 3; m++) {
            xa[m] = xs[m] / ds;
            xb[m] = xm[m] / dm;
          }
          dc[i] = Math.acos(sl.swi_dot_prod_unit(xa, xb)) * SwissData.RADTODEG;
          rearth = Math.asin(REARTH / dm) * SwissData.RADTODEG;
          rsun = Math.asin(RSUN / ds) * SwissData.RADTODEG;
          dc[i] -= (rearth + rsun);
        }
        find_maximum(dc[0], dc[1], dc[2], dt, dtint, dctr);
        tjd += dtint.val + dt;
      }
      tjd = tjd - SweDate.getDeltaT(tjd);
      if ((retflag = swe_lun_eclipse_how(tjd, ifl, null, attr, serr)) ==
                                                                 SweConst.ERR) {
        return retflag;
      }
      if (retflag == 0) {
        K += direction;
        continue;
      }
      tret[0] = tjd;
      if ((backward!=0 && tret[0] >= tjd_start - 0.0001)
        || (backward==0 && tret[0] <= tjd_start + 0.0001)) {
        K += direction;
        continue;
      }
      
      
      if ((ifltype & SweConst.SE_ECL_PENUMBRAL)==0 &&
          (retflag & SweConst.SE_ECL_PENUMBRAL)!=0) {
        K += direction;
        continue;
      }
      
      if ((ifltype & SweConst.SE_ECL_PARTIAL)==0 &&
          (retflag & SweConst.SE_ECL_PARTIAL)!=0) {
        K += direction;
        continue;
      }
      
      if ((ifltype & (SweConst.SE_ECL_TOTAL))==0 &&
          (retflag & SweConst.SE_ECL_TOTAL)!=0) {
        K += direction;
        continue;
      }
      
      if ((retflag & SweConst.SE_ECL_PENUMBRAL)!=0) {
        o = 0;
      } else if ((retflag & SweConst.SE_ECL_PARTIAL)!=0) {
        o = 1;
      } else {
        o = 2;
      }
      dta = twohr;
      dtb = tenmin;
      for (n = 0; n <= o; n++) {
        if (n == 0) {
          i1 = 6; i2 = 7;
        } else if (n == 1) {
          i1 = 2; i2 = 3;
        } else if (n == 2) {
          i1 = 4; i2 = 5;
        }
        for (i = 0, t = tjd - dta; i <= 2; i += 1, t += dta) {
          if ((retflag2 = lun_eclipse_how(t, ifl, attr, dcore, serr)) ==
                                                                 SweConst.ERR) {
            return retflag2;
          }
          if (n == 0) {
            dc[i] = dcore[2] / 2 + RMOON / dcore[4] - dcore[0];
          } else if (n == 1) {
            dc[i] = dcore[1] / 2 + RMOON / dcore[3] - dcore[0];
          } else if (n == 2) {
            dc[i] = dcore[1] / 2 - RMOON / dcore[3] - dcore[0];
          }
        }
        find_zero(dc[0], dc[1], dc[2], dta, dt1, dt2);
        dtb = (dt1.val + dta) / 2;
        tret[i1] = tjd + dt1.val + dta;
        tret[i2] = tjd + dt2.val + dta;
        for (m = 0, dt = dtb / 2; m < 3; m++, dt /= 2) {
          for (j = i1; j <= i2; j += (i2 - i1)) {
            for (i = 0, t = tret[j] - dt; i < 2; i++, t += dt) {
              if ((retflag2 = lun_eclipse_how(t, ifl, attr, dcore, serr)) ==
                                                                 SweConst.ERR) {
                return retflag2;
              }
              if (n == 0) {
                dc[i] = dcore[2] / 2 + RMOON / dcore[4] - dcore[0];
              } else if (n == 1) {
                dc[i] = dcore[1] / 2 + RMOON / dcore[3] - dcore[0];
              } else if (n == 2) {
                dc[i] = dcore[1] / 2 - RMOON / dcore[3] - dcore[0];
              }
            }
            dt1.val = dc[1] / ((dc[1] - dc[0]) / dt);
            tret[j] -= dt1.val;
          }
        }
      }
      break;
    } // while (true)
    return retflag;
  }
  
  private static final double EULER=2.718281828459;
  private static final int NMAG_ELEM=SweConst.SE_VESTA + 1;
  private static final double mag_elem[][] = {
                  
                  {-26.86, 0, 0, 0},
                  {-12.55, 0, 0, 0},
                  
                  {-0.42, 3.80, -2.73, 2.00},
                  {-4.40, 0.09, 2.39, -0.65},
                  {- 1.52, 1.60, 0, 0},   
                  {- 9.40, 0.5, 0, 0},    
                  {- 8.88, -2.60, 1.25, 0.044},   
                  {- 7.19, 0.0, 0, 0},    
                  {- 6.87, 0.0, 0, 0},    
                  {- 1.00, 0.0, 0, 0},    
                  {99, 0, 0, 0},          
                  {99, 0, 0, 0},
                  {99, 0, 0, 0},
                  {99, 0, 0, 0},
                  {99, 0, 0, 0},          
                  
                  {6.5, 0.15, 0, 0},      
                  {7.0, 0.15, 0, 0},      
                  {3.34, 0.12, 0, 0},     
                  {4.13, 0.11, 0, 0},     
                  {5.33, 0.32, 0, 0},     
                  {3.20, 0.32, 0, 0},     
                  };
  
  int swe_pheno(double tjd, int ipl, int iflag, double[] attr,
                StringBuffer serr) {
    int i;
    double xx[]=new double[6], xx2[]=new double[6], xxs[]=new double[6],
           lbr[]=new double[6], lbr2[]=new double[6], dt = 0, dsm, dd;
    double fac;
    double T, in, om, sinB, u1, u2, du;
    double ph1, ph2, me[]=new double[2];
    int iflagp;
    for (i = 0; i < 20; i++)
      attr[i] = 0;
    
    if (ipl > SweConst.SE_AST_OFFSET && ipl <= SweConst.SE_AST_OFFSET + 4) {
      ipl = ipl - SweConst.SE_AST_OFFSET - 1 + SweConst.SE_CERES;
    }
    iflag = iflag & (SweConst.SEFLG_EPHMASK |
                     SweConst.SEFLG_TRUEPOS |
                     SweConst.SEFLG_J2000 |
                     SweConst.SEFLG_NONUT |
                     SweConst.SEFLG_NOGDEFL |
                     SweConst.SEFLG_NOABERR |
                     SweConst.SEFLG_TOPOCTR);
    iflagp = iflag & (SweConst.SEFLG_EPHMASK |
                     SweConst.SEFLG_TRUEPOS |
                     SweConst.SEFLG_J2000 |
                     SweConst.SEFLG_NONUT |
                     SweConst.SEFLG_NOABERR);
    iflagp |= SweConst.SEFLG_HELCTR;
    
    if (sw.swe_calc(tjd, ipl, iflag | SweConst.SEFLG_XYZ, xx, serr) ==
                                                                 SweConst.ERR) {
      return SweConst.ERR;
    }
    if (sw.swe_calc(tjd, ipl, iflag, lbr, serr) == SweConst.ERR) {
      return SweConst.ERR;
    }
    
    if (ipl == SweConst.SE_MOON) {
      if (sw.swe_calc(tjd, SweConst.SE_SUN, iflag | SweConst.SEFLG_XYZ,
                      xxs, serr) == SweConst.ERR) {
        return SweConst.ERR;
      }
    }
    if (ipl != SweConst.SE_SUN && ipl != SweConst.SE_EARTH &&
      ipl != SweConst.SE_MEAN_NODE && ipl != SweConst.SE_TRUE_NODE &&
      ipl != SweConst.SE_MEAN_APOG && ipl != SweConst.SE_OSCU_APOG) {
      
      dt = lbr[2] * SweConst.AUNIT / SwephData.CLIGHT / 86400.0;
      if ((iflag & SweConst.SEFLG_TRUEPOS)!=0) {
        dt = 0;
      }
      
      if (sw.swe_calc(tjd - dt, ipl, iflagp | SweConst.SEFLG_XYZ, xx2, serr) ==
                                                                 SweConst.ERR) {
        return SweConst.ERR;
      }
      if (sw.swe_calc(tjd - dt, ipl, iflagp, lbr2, serr) == SweConst.ERR) {
        return SweConst.ERR;
      }
      
      attr[0] = Math.acos(sl.swi_dot_prod_unit(xx, xx2)) * SwissData.RADTODEG;
      
      attr[1] = (1 + Math.cos(attr[0] * SwissData.DEGTORAD)) / 2;
    }
    
    if (ipl < SwephData.NDIAM) {
      dd = SwephData.pla_diam[ipl];
    } else if (ipl > SweConst.SE_AST_OFFSET) {
      dd = swed.ast_diam * 1000;        
    } else {
      dd = 0;
    }
    if (lbr[2] < dd / 2 / SweConst.AUNIT) {
      attr[3] = 180;  
    } else {
      attr[3] = Math.asin(dd / 2 / SweConst.AUNIT / lbr[2]) * 2 * SwissData.RADTODEG;
    }
    
    if (ipl > SweConst.SE_AST_OFFSET ||
        (ipl < NMAG_ELEM && mag_elem[ipl][0] < 99)) {
      if (ipl == SweConst.SE_SUN) {
        
        fac = attr[3] / (Math.asin(SwephData.pla_diam[SweConst.SE_SUN] / 2.0 /
                                            SweConst.AUNIT) * 2 * SwissData.RADTODEG);
        fac *= fac;
        attr[4] = mag_elem[ipl][0] - 2.5 * log10(fac);
      } else if (ipl == SweConst.SE_MOON) {
        
        fac = attr[3] / (Math.asin(SwephData.pla_diam[SweConst.SE_MOON] / 2.0 /
                                            384400000.0) * 2 * SwissData.RADTODEG);
        
        for (i = 0; i < 3; i++)
          xxs[i] -= xx[i];
        dsm = Math.sqrt(sl.square_sum(xxs));
        
        fac *= fac * attr[1];
        
        fac *= dsm * dsm;
        attr[4] = mag_elem[ipl][0] - 2.5 * log10(fac);
      } else if (ipl == SweConst.SE_SATURN) {
        
        T = (tjd - dt - SwephData.J2000) / 36525.0;
        in = (28.075216 - 0.012998 * T + 0.000004 * T * T) * SwissData.DEGTORAD;
        om = (169.508470 + 1.394681 * T + 0.000412 * T * T) * SwissData.DEGTORAD;
        sinB = Math.abs(Math.sin(in) * Math.cos(lbr[1] * SwissData.DEGTORAD)
                      * Math.sin(lbr[0] * SwissData.DEGTORAD - om)
                      - Math.cos(in) * Math.sin(lbr[1] * SwissData.DEGTORAD));
        u1 = Math.atan2(Math.sin(in) * Math.tan(lbr2[1] * SwissData.DEGTORAD)
                               + Math.cos(in) * Math.sin(lbr2[0] *
                                                          SwissData.DEGTORAD - om),
                          Math.cos(lbr2[0] * SwissData.DEGTORAD - om)) *
                                                                 SwissData.RADTODEG;
        u2 = Math.atan2(Math.sin(in) * Math.tan(lbr[1] * SwissData.DEGTORAD)
                        + Math.cos(in) * Math.sin(lbr[0] * SwissData.DEGTORAD - om),
                          Math.cos(lbr[0] * SwissData.DEGTORAD - om)) *
                                                                 SwissData.RADTODEG;
        du = sl.swe_degnorm(u1 - u2);
        if (du > 10) {
          du = 360 - du;
        }
        attr[4] = 5 * log10(lbr2[2] * lbr[2])
                    + mag_elem[ipl][1] * sinB
                    + mag_elem[ipl][2] * sinB * sinB
                    + mag_elem[ipl][3] * du
                    + mag_elem[ipl][0];
      } else if (ipl < SweConst.SE_CHIRON) {
        attr[4] = 5 * log10(lbr2[2] * lbr[2])
                    + mag_elem[ipl][1] * attr[0] /100.0
                    + mag_elem[ipl][2] * attr[0] * attr[0] / 10000.0
                    + mag_elem[ipl][3] * attr[0] * attr[0] * attr[0] / 1000000.0
                    + mag_elem[ipl][0];
      } else if (ipl < NMAG_ELEM || ipl > SweConst.SE_AST_OFFSET) {
        ph1 = Math.pow(EULER, -3.33 *
                        Math.pow(Math.tan(attr[0] * SwissData.DEGTORAD / 2), 0.63));
        ph2 = Math.pow(EULER, -1.87 *
                        Math.pow(Math.tan(attr[0] * SwissData.DEGTORAD / 2), 1.22));
        if (ipl < NMAG_ELEM) {    
          me[0] = mag_elem[ipl][0];
          me[1] = mag_elem[ipl][1];
        } else if (ipl == SweConst.SE_AST_OFFSET + 1566) {
                    
                  me[0] = 16.9;
                  me[1] = 0.15;
        } else {      
          me[0] = swed.ast_H;
          me[1] = swed.ast_G;
        }
        attr[4] = 5 * log10(lbr2[2] * lbr[2])
            + me[0]
            - 2.5 * log10((1 - me[1]) * ph1 + me[1] * ph2);
      } else { 
        attr[4] = 0;
      }
    }
    if (ipl != SweConst.SE_SUN && ipl != SweConst.SE_EARTH) {
      
      if (sw.swe_calc(tjd, SweConst.SE_SUN, iflag | SweConst.SEFLG_XYZ,
                      xx2, serr) == SweConst.ERR) {
        return SweConst.ERR;
      }
      if (sw.swe_calc(tjd, SweConst.SE_SUN, iflag, lbr2, serr) == SweConst.ERR) {
        return SweConst.ERR;
      }
      attr[2] = Math.acos(sl.swi_dot_prod_unit(xx, xx2)) * SwissData.RADTODEG;
    }
    return SweConst.OK;
  }
  
  int swe_pheno_ut(double tjd_ut, int ipl, int iflag, double[] attr,
                   StringBuffer serr) {
    return swe_pheno(tjd_ut + SweDate.getDeltaT(tjd_ut), ipl, iflag, attr, serr);
  }
  private int find_maximum(double y00, double y11, double y2, double dx,
                           DblObj dxret, DblObj yret) {
    double a, b, c, x, y;
    c = y11;
    b = (y2 - y00) / 2.0;
    a = (y2 + y00) / 2.0 - c;
    x = -b / 2 / a;
    y = (4 * a * c - b * b) / 4 / a;
    dxret.val = (x - 1) * dx;
    if (yret != null) {
      yret.val = y;
    }
    return SweConst.OK;
  }
  private int find_zero(double y00, double y11, double y2, double dx,
                        DblObj dxret, DblObj dxret2) {
    double a, b, c, x1, x2;
    c = y11;
    b = (y2 - y00) / 2.0;
    a = (y2 + y00) / 2.0 - c;
    if (b * b - 4 * a * c < 0) {
      return SweConst.ERR;
    }
    x1 = (-b + Math.sqrt(b * b - 4 * a * c)) / 2 / a;
    x2 = (-b - Math.sqrt(b * b - 4 * a * c)) / 2 / a;
      dxret.val = (x1 - 1) * dx;
      dxret2.val = (x2 - 1) * dx;
    return SweConst.OK;
  }
  
  
  int swe_rise_trans(double tjd_ut, int ipl, StringBuffer starname,
                     int epheflag, int rsmi, double[] geopos,
                     double atpress, double attemp,
                     DblObj tret, StringBuffer serr) {
    int i, j, k, ii, calc_culm, nculm = -1;
    double tjd_et = tjd_ut + SweDate.getDeltaT(tjd_ut);
    double xc[]=new double[6], xh[][]=new double[20][6], ah[]=new double[6],
           aha;
    double tculm[]=new double[4], tcu, tc[]=new double[20], h[]=new double[20],
           t2[]=new double[6], dc[]=new double[6];
    DblObj dtint=new DblObj();
    DblObj dx=new DblObj();
    double rdi, dd = 0;
    int iflag = epheflag;
    int jmax = 14;
    double t, te, tt, dt, twohrs = 1.0 / 12.0;
    boolean do_fixstar = (starname != null && starname.length() > 0);
    // xh[0][0] = 0; 
    iflag &= SweConst.SEFLG_EPHMASK;
    tret.val = 0;
    iflag |= (SweConst.SEFLG_EQUATORIAL | SweConst.SEFLG_TOPOCTR);
    sw.swe_set_topo(geopos[0], geopos[1], geopos[2]);
    if ((rsmi & (SweConst.SE_CALC_MTRANSIT | SweConst.SE_CALC_ITRANSIT))!=0) {
      return calc_mer_trans(tjd_ut, ipl, epheflag, rsmi,
                  geopos, starname,
                  tret, serr);
    }
    if ((rsmi & ( SweConst.SE_CALC_RISE | SweConst.SE_CALC_SET))==0) {
      rsmi |= SweConst.SE_CALC_RISE;
    }
    
    if (do_fixstar) {
      if (sw.swe_fixstar(starname, tjd_et, iflag, xc, serr) == SweConst.ERR) {
        return SweConst.ERR;
      }
    }
    for (ii = 0, t = tjd_ut - twohrs; ii <= jmax; ii++, t += twohrs) {
      tc[ii] = t;
      if (!do_fixstar) {
        te = t + SweDate.getDeltaT(t);
        if (sw.swe_calc(te, ipl, iflag, xc, serr) == SweConst.ERR) {
          return SweConst.ERR;
        }
      }
      
      if (ii == 0) {
        if (do_fixstar) {
          dd = 0;
        } else
               if ((rsmi & SweConst.SE_BIT_DISC_CENTER)!=0) {
          dd = 0;
        } else if (ipl < SwephData.NDIAM) {
          dd = SwephData.pla_diam[ipl];
        } else if (ipl > SweConst.SE_AST_OFFSET) {
          dd = swed.ast_diam * 1000;        
        } else {
          dd = 0;
        }
      }
      
      rdi = Math.asin(dd / 2 / SweConst.AUNIT / xc[2]) * SwissData.RADTODEG;
      
      swe_azalt(t, SweConst.SE_EQU2HOR, geopos, atpress, attemp, xc, xh[ii]);
      
      xh[ii][1] += rdi;
      
      if ((rsmi & SweConst.SE_BIT_NO_REFRACTION)!=0) {
        h[ii] = xh[ii][1];
      } else {
        swe_azalt_rev(t, SweConst.SE_HOR2EQU, geopos, xh[ii], xc);
        swe_azalt(t, SweConst.SE_EQU2HOR, geopos, atpress, attemp, xc, xh[ii]);
        h[ii] = xh[ii][2];
      }
      calc_culm = 0;
      if (ii > 1) {
        dc[0] = xh[ii-2][1];
        dc[1] = xh[ii-1][1];
        dc[2] = xh[ii][1];
        if (dc[1] > dc[0] && dc[1] > dc[2]) {
          calc_culm = 1;
        }
        if (dc[1] < dc[0] && dc[1] < dc[2]) {
          calc_culm = 2;
        }
      }
      if (calc_culm!=0) {
        dt = twohrs;
        tcu = t - dt;
        find_maximum(dc[0], dc[1], dc[2], dt, dtint, dx);
        tcu += dtint.val + dt;
        dt /= 3;
        for (; dt > 0.0001; dt /= 3) {
          for (i = 0, tt = tcu - dt; i < 3; tt += dt, i++) {
            te = tt + SweDate.getDeltaT(tt);
            if (!do_fixstar) {
              if (sw.swe_calc(te, ipl, iflag, xc, serr) == SweConst.ERR) {
                return SweConst.ERR;
              }
            }
            swe_azalt(tt, SweConst.SE_EQU2HOR, geopos, atpress, attemp, xc, ah);
            dc[i] = ah[1];
          }
          find_maximum(dc[0], dc[1], dc[2], dt, dtint, dx);
          tcu += dtint.val + dt;
        }
        nculm++;
        tculm[nculm] = tcu;
      }
    }
    
    
    for (i = 0; i <= nculm; i++) {
      for (j = 1; j <= jmax; j++) {
        if (tculm[i] < tc[j]) {
          for (k = jmax; k >= j; k--) {
            tc[k+1] = tc[k];
            h[k+1] = h[k];
          }
          tc[j] = tculm[i];
          if (!do_fixstar) {
            te = tc[j] + SweDate.getDeltaT(tc[j]);
            if (sw.swe_calc(te, ipl, iflag, xc, serr) == SweConst.ERR) {
              return SweConst.ERR;
            }
          }
          
          rdi = Math.asin(dd / 2 / SweConst.AUNIT / xc[2]) * SwissData.RADTODEG;
          
          swe_azalt(tc[j], SweConst.SE_EQU2HOR, geopos, atpress, attemp, xc, ah);
          
          ah[1] += rdi;
          
          if ((rsmi & SweConst.SE_BIT_NO_REFRACTION)!=0) {
            h[j] = ah[1];
          } else {
            swe_azalt_rev(tc[j], SweConst.SE_HOR2EQU, geopos, ah, xc);
            swe_azalt(tc[j], SweConst.SE_EQU2HOR, geopos, atpress, attemp, xc, ah);
            h[j] = ah[2];
          }
          jmax++;
          break;
        }
      }
    }
    tret.val = 0;
    
    for (ii = 1; ii <= jmax; ii++) {
      if (h[ii-1] * h[ii] >= 0) {
        continue;
      }
      if (h[ii-1] < h[ii] && ((rsmi & SweConst.SE_CALC_RISE) == 0)) {
        continue;
      }
      if (h[ii-1] > h[ii] && ((rsmi & SweConst.SE_CALC_SET) == 0)) {
        continue;
      }
      dc[0] = h[ii-1];
      dc[1] = h[ii];
      t2[0] = tc[ii-1];
      t2[1] = tc[ii];
      for (i = 0; i < 20; i++) {
        t = (t2[0] + t2[1]) / 2;
        if (!do_fixstar) {
          te = t + SweDate.getDeltaT(t);
          if (sw.swe_calc(te, ipl, iflag, xc, serr) == SweConst.ERR) {
            return SweConst.ERR;
          }
        }
        
        rdi = Math.asin(dd / 2 / SweConst.AUNIT / xc[2]) * SwissData.RADTODEG;
        
        swe_azalt(t, SweConst.SE_EQU2HOR, geopos, atpress, attemp, xc, ah);
        
        ah[1] += rdi;
        
        if ((rsmi & SweConst.SE_BIT_NO_REFRACTION)!=0) {
          aha = ah[1];
        } else {
          swe_azalt_rev(t, SweConst.SE_HOR2EQU, geopos, ah, xc);
          swe_azalt(t, SweConst.SE_EQU2HOR, geopos, atpress, attemp, xc, ah);
          aha = ah[2];
        }
        if (aha * dc[0] <= 0) {
          dc[1] = aha;
          t2[1] = t;
        } else {
          dc[0] = aha;
          t2[0] = t;
        }
      }
      if (t > tjd_ut) {
       tret.val = t;
       return SweConst.OK;
      }
    }
    if (serr!=null)
      serr.append("rise or set not found for planet ").append(ipl);
    return -2; 
  }
  private int calc_mer_trans(double tjd_ut, int ipl, int epheflag, int rsmi,
                             double[] geopos, StringBuffer starname,
                             DblObj tret, StringBuffer serr) {
    int i;
    double tjd_et = tjd_ut + SweDate.getDeltaT(tjd_ut);
    double armc, armc0, arxc, x0[]=new double[6], x[]=new double[6], t, te;
    double mdd;
    int iflag = epheflag;
    boolean do_fixstar = (starname != null && starname.length() > 0);
    iflag &= SweConst.SEFLG_EPHMASK;
    tret.val = 0;
    iflag |= (SweConst.SEFLG_EQUATORIAL | SweConst.SEFLG_TOPOCTR);
    armc0 = sl.swe_sidtime(tjd_ut) + geopos[0] / 15;
    if (armc0 >= 24) {
      armc0 -= 24;
    }
    if (armc0 < 0) {
      armc0 += 24;
    }
    armc0 *= 15;
    if (do_fixstar) {
      if (sw.swe_fixstar(starname, tjd_et, iflag, x0, serr) == SweConst.ERR) {
        return SweConst.ERR;
      }
    } else {
      if (sw.swe_calc(tjd_et, ipl, iflag, x0, serr) == SweConst.ERR) {
        return SweConst.ERR;
      }
    }
    
      x[0] = x0[0];
      x[1] = x0[1];
      t = tjd_ut;
      arxc = armc0;
      if ((rsmi & SweConst.SE_CALC_ITRANSIT)!=0) {
        arxc = sl.swe_degnorm(arxc + 180);
      }
      for (i = 0; i < 4; i++) {
        mdd = sl.swe_degnorm(x[0] - arxc);
        if (i > 0 && mdd > 180) {
          mdd -= 360;
        }
        t += mdd / 361;
        armc = sl.swe_sidtime(t) + geopos[0] / 15;
        if (armc >= 24) {
          armc -= 24;
        }
        if (armc < 0) {
          armc += 24;
        }
        armc *= 15;
        arxc = armc;
        if ((rsmi & SweConst.SE_CALC_ITRANSIT)!=0) {
          arxc = sl.swe_degnorm(arxc + 180);
        }
        if (!do_fixstar) {
  //        te = t + swe_deltat(t);
          te = t + SweDate.getDeltaT(t);
          if (sw.swe_calc(te, ipl, iflag, x, serr) == SweConst.ERR) {
            return SweConst.ERR;
          }
        }
      }
    tret.val = t;
    return SweConst.OK;
  }
  
  
  private static final double el_node[][] = new double[][]
    {{ 48.330893,  1.1861890,  0.00017587,  0.000000211,}, 
    { 76.679920,  0.9011190,  0.00040665, -0.000000080,}, 
    {  0       ,  0        ,  0         ,  0          ,}, 
    { 49.558093,  0.7720923,  0.00001605,  0.000002325,}, 
    {100.464441,  1.0209550,  0.00040117,  0.000000569,}, 
    {113.665524,  0.8770970, -0.00012067, -0.000002380,}, 
    { 74.005947,  0.5211258,  0.00133982,  0.000018516,}, 
    {131.784057,  1.1022057,  0.00026006, -0.000000636,}, 
    };
  private static final double el_peri[][] = new double[][]
    {{ 77.456119,  1.5564775,  0.00029589,  0.000000056,}, 
    {131.563707,  1.4022188, -0.00107337, -0.000005315,}, 
    {102.937348,  1.7195269,  0.00045962,  0.000000499,}, 
    {336.060234,  1.8410331,  0.00013515,  0.000000318,}, 
    { 14.331309,  1.6126668,  0.00103127, -0.000004569,}, 
    { 93.056787,  1.9637694,  0.00083757,  0.000004899,}, 
    {173.005159,  1.4863784,  0.00021450,  0.000000433,}, 
    { 48.123691,  1.4262677,  0.00037918, -0.000000003,}, 
    };
  private static final double el_incl[][] = new double[][]
    {{  7.004986,  0.0018215, -0.00001809,  0.000000053,}, 
    {  3.394662,  0.0010037, -0.00000088, -0.000000007,}, 
    {  0,         0,          0,           0          ,}, 
    {  1.849726, -0.0006010,  0.00001276, -0.000000006,}, 
    {  1.303270, -0.0054966,  0.00000465, -0.000000004,}, 
    {  2.488878, -0.0037363, -0.00001516,  0.000000089,}, 
    {  0.773196,  0.0007744,  0.00003749, -0.000000092,}, 
    {  1.769952, -0.0093082, -0.00000708,  0.000000028,}, 
    };
  private static final double el_ecce[][] = new double[][]
    {{  0.20563175,  0.000020406, -0.0000000284, -0.00000000017,}, 
    {  0.00677188, -0.000047766,  0.0000000975,  0.00000000044,}, 
    {  0.01670862, -0.000042037, -0.0000001236,  0.00000000004,}, 
    {  0.09340062,  0.000090483, -0.0000000806, -0.00000000035,}, 
    {  0.04849485,  0.000163244, -0.0000004719, -0.00000000197,}, 
    {  0.05550862, -0.000346818, -0.0000006456,  0.00000000338,}, 
    {  0.04629590, -0.000027337,  0.0000000790,  0.00000000025,}, 
    {  0.00898809,  0.000006408, -0.0000000008, -0.00000000005,}, 
    };
  private static final double el_sema[][] = new double[][]
    {{  0.387098310,  0.0,  0.0,  0.0,}, 
    {  0.723329820,  0.0,  0.0,  0.0,}, 
    {  1.000001018,  0.0,  0.0,  0.0,}, 
    {  1.523679342,  0.0,  0.0,  0.0,}, 
    {  5.202603191,  0.0000001913,  0.0,  0.0,}, 
    {  9.554909596,  0.0000021389,  0.0,  0.0,}, 
    { 19.218446062, -0.0000000372,  0.00000000098,  0.0,}, 
    { 30.110386869, -0.0000001663,  0.00000000069,  0.0,}, 
    };
  
  private static final double plmass[] = new double[] {
      6023600,        
       408523.5,      
       328900.5,      
      3098710,        
         1047.350,    
         3498.0,      
        22960,        
        19314,        
    130000000,        
  };
  private static final int ipl_to_elem[] = new int[]
                                {2, 0, 0, 1, 3, 4, 5, 6, 7, 0, 0, 0, 0, 0, 2,};
  
  int swe_nod_aps(double tjd_et, int ipl, int iflag,
                  int  method,
                  double[] xnasc, double[] xndsc,
                  double[] xperi, double[] xaphe,
                  StringBuffer serr) {
    int ij, i, j;
    int iplx;
    int ipli;
    int istart, iend;
    int iflJ2000;
    double plm;
    double t = (tjd_et - SwephData.J2000) / 36525, dt;
    double x[]=new double[6], xx[]=new double[24], xp[],
           xobs[]=new double[6], x2000[]=new double[6];
    int xpOffs=0;
    double xpos[][]=new double[3][6], xnorm[]=new double[6];
    double xposm[]=new double[6];
    double xn[][]=new double[3][6], xs[][]=new double[3][6];
    double xq[][]=new double[3][6], xa[][]=new double[3][6];
    double xobs2[]=new double[6], x2[]=new double[6];
    double[] xna, xnd, xpe, xap;
    final int xndOffs = 6, xpeOffs = 12, xapOffs = 18;
    double incl, sema, ecce, parg, ea, vincl, vsema, vecce, pargx, eax;
    PlanData pedp = swed.pldat[SwephData.SEI_EARTH];
    PlanData psbdp = swed.pldat[SwephData.SEI_SUNBARY];
    PlanData pldat=new PlanData();
    double[] xsun = psbdp.x;
    double[] xear = pedp.x;
    double[] ep;
    double Gmsm, dzmin;
    double rxy, rxyz, fac, sgn;
    double sinnode, cosnode, sinincl, cosincl, sinu, cosu, sinE, cosE, cosE2;
    double uu, ny, ny2, c2, v2, pp, ro, ro2, rn, rn2;
    Epsilon oe;
    boolean is_true_nodaps = false;
    boolean do_aberr = (iflag &
                        (SweConst.SEFLG_TRUEPOS | SweConst.SEFLG_NOABERR))==0;
    boolean do_defl = (iflag & SweConst.SEFLG_TRUEPOS)==0 &&
                      (iflag & SweConst.SEFLG_NOGDEFL)==0;
    boolean do_focal_point = (method & SweConst.SE_NODBIT_FOPOINT) != 0;
    boolean ellipse_is_bary = false;
    int iflg0;
    xna = xx; 
    xnd = xx; // xndOffs = 6; 
    xpe = xx; // xpeOffs = 12; 
    xap = xx; // xapOffs = 18;
    // xpos[0][0] = 0; 
    
    sw.swi_force_app_pos_etc();
    method %= SweConst.SE_NODBIT_FOPOINT;
    ipli = ipl;
    if (ipl == SweConst.SE_SUN) {
      ipli = SweConst.SE_EARTH;
    }
    if (ipl == SweConst.SE_MOON) {
      do_defl = false;
      if ((iflag & SweConst.SEFLG_HELCTR)==0) {
        do_aberr = false;
      }
    }
    iflg0 = (iflag & (SweConst.SEFLG_EPHMASK|SweConst.SEFLG_NONUT)) |
            SweConst.SEFLG_SPEED | SweConst.SEFLG_TRUEPOS;
    if (ipli != SweConst.SE_MOON) {
      iflg0 |= SweConst.SEFLG_HELCTR;
    }
    if (ipl == SweConst.SE_MEAN_NODE || ipl == SweConst.SE_TRUE_NODE ||
            ipl == SweConst.SE_MEAN_APOG || ipl == SweConst.SE_OSCU_APOG ||
            ipl < 0 ||
            (ipl >= SweConst.SE_NPLANETS && ipl <= SweConst.SE_AST_OFFSET)) {
           
      if (serr != null) {
        serr.setLength(0);
        serr.append("nodes/apsides for planet "+ipl+
                    " are not implemented");
      }
      if (xnasc != null) {
        for (i = 0; i <= 5; i++)
          xnasc[i] = 0;
      }
      if (xndsc != null) {
        for (i = 0; i <= 5; i++)
          xndsc[i] = 0;
      }
      if (xaphe != null) {
        for (i = 0; i <= 5; i++)
          xaphe[i] = 0;
      }
      if (xperi != null) {
        for (i = 0; i <= 5; i++)
          xperi[i] = 0;
      }
      return SweConst.ERR;
    }
    for (i = 0; i < 24; i++)
      xx[i] = 0;
    
    
    if ((method == 0 || (method & SweConst.SE_NODBIT_MEAN)!=0) &&
          ((ipl >= SweConst.SE_SUN && ipl <= SweConst.SE_NEPTUNE) ||
                                                    ipl == SweConst.SE_EARTH)) {
      if (ipl == SweConst.SE_MOON) {
        DblObj xna0=new DblObj(); xna0.val=xna[0];
        DblObj xna3=new DblObj(); xna3.val=xna[3];
        DblObj xpe0=new DblObj(); xpe0.val=xpe[0+xpeOffs];
        DblObj xpe3=new DblObj(); xpe3.val=xpe[3+xpeOffs];
        sm.swi_mean_lunar_elements(tjd_et, xna0, xna3, xpe0, xpe3);
        xna[0]=xna0.val;
        xna[3]=xna3.val;
        xpe[0+xpeOffs]=xpe0.val;
        xpe[3+xpeOffs]=xpe3.val;
        incl = SwephData.MOON_MEAN_INCL;
        vincl = 0;
        ecce = SwephData.MOON_MEAN_ECC;
        vecce = 0;
        sema = SwephData.MOON_MEAN_DIST / SweConst.AUNIT;
        vsema = 0;
      } else {
        iplx = ipl_to_elem[ipl];
        ep = el_incl[iplx];
        incl = ep[0] + ep[1] * t + ep[2] * t * t + ep[3] * t * t * t;
        vincl = ep[1] / 36525;
        ep = el_sema[iplx];
        sema = ep[0] + ep[1] * t + ep[2] * t * t + ep[3] * t * t * t;
        vsema = ep[1] / 36525;
        ep = el_ecce[iplx];
        ecce = ep[0] + ep[1] * t + ep[2] * t * t + ep[3] * t * t * t;
        vecce = ep[1] / 36525;
        ep = el_node[iplx];
        
        xna[0] = ep[0] + ep[1] * t + ep[2] * t * t + ep[3] * t * t * t;
        xna[3] = ep[1] / 36525;
        
        ep = el_peri[iplx];
        xpe[0+xpeOffs] = ep[0] + ep[1] * t + ep[2] * t * t + ep[3] * t * t * t;
        xpe[3+xpeOffs] = ep[1] / 36525;
      }
      
      xnd[0+xndOffs] = sl.swe_degnorm(xna[0] + 180);
      xnd[3+xndOffs] = xna[3];
      
      parg = xpe[0+xpeOffs] = sl.swe_degnorm(xpe[0+xpeOffs] - xna[0]);
      pargx = xpe[3+xpeOffs] = sl.swe_degnorm(xpe[0+xpeOffs] + xpe[3+xpeOffs]  - xna[3]);
      
      sl.swe_cotrans(xpe, xpeOffs, xpe, xpeOffs, -incl);
      
      sl.swe_cotrans(xpe, 3+xpeOffs, xpe, 3+xpeOffs, -incl-vincl);
      
      xpe[0+xpeOffs] = sl.swe_degnorm(xpe[0+xpeOffs] + xna[0]);
      
      xpe[3+xpeOffs] = sl.swe_degnorm(xpe[3+xpeOffs] + xna[0] + xna[3]);
      
      xpe[3+xpeOffs] = sl.swe_degnorm(xpe[3+xpeOffs] - xpe[0+xpeOffs]);
      
      xpe[2+xpeOffs] = sema * (1 - ecce);
      xpe[5+xpeOffs] = (sema + vsema) * (1 - ecce - vecce) - xpe[2+xpeOffs];
      
      xap[0+xapOffs] = sl.swe_degnorm(xpe[xpeOffs] + 180);
      xap[1+xapOffs] = -xpe[1+xpeOffs];
      xap[3+xapOffs] = xpe[3+xpeOffs];
      xap[4+xapOffs] = -xpe[4+xpeOffs];
      if (do_focal_point) {
        xap[2+xapOffs] = sema * ecce * 2;
        xap[5+xapOffs] = (sema + vsema) * (ecce + vecce) * 2 - xap[2+xapOffs];
      } else {
        xap[2+xapOffs] = sema * (1 + ecce);
        xap[5+xapOffs] = (sema + vsema) * (1 + ecce + vecce) - xap[2+xapOffs];
      }
      
      ea = Math.atan(Math.tan(-parg * SwissData.DEGTORAD / 2) *
                                              Math.sqrt((1-ecce)/(1+ecce))) * 2;
      eax = Math.atan(Math.tan(-pargx * SwissData.DEGTORAD / 2) *
                                  Math.sqrt((1-ecce-vecce)/(1+ecce+vecce))) * 2;
      xna[2] = sema * (Math.cos(ea) - ecce) / Math.cos(parg * SwissData.DEGTORAD);
      xna[5] = (sema+vsema) * (Math.cos(eax) - ecce - vecce) /
                                                Math.cos(pargx * SwissData.DEGTORAD);
      xna[5] -= xna[2];
      ea = Math.atan(Math.tan((180 - parg) * SwissData.DEGTORAD / 2) *
                                              Math.sqrt((1-ecce)/(1+ecce))) * 2;
      eax = Math.atan(Math.tan((180 - pargx) * SwissData.DEGTORAD / 2) *
                                  Math.sqrt((1-ecce-vecce)/(1+ecce+vecce))) * 2;
      xnd[2+xndOffs] = sema * (Math.cos(ea) - ecce) / Math.cos((180 - parg) * SwissData.DEGTORAD);
      xnd[5+xndOffs] = (sema+vsema) * (Math.cos(eax) - ecce - vecce) /
                                             Math.cos((180 - pargx) * SwissData.DEGTORAD);
      xnd[5+xndOffs] -= xnd[2+xndOffs];
      
      for (i = 0, xp = xx, xpOffs = 0; i < 4; i++, xpOffs += 6) {
        
        xp[0+xpOffs] *= SwissData.DEGTORAD;
        xp[1+xpOffs] *= SwissData.DEGTORAD;
        xp[3+xpOffs] *= SwissData.DEGTORAD;
        xp[4+xpOffs] *= SwissData.DEGTORAD;
        sl.swi_polcart_sp(xp, xpOffs, xp, xpOffs);
      }
    
    } else {
      
      if (sw.swe_calc(tjd_et, ipli, iflg0, x, serr) == SweConst.ERR) {
        return SweConst.ERR;
      }
      iflJ2000 = (iflag & SweConst.SEFLG_EPHMASK)|
                 SweConst.SEFLG_J2000|
                 SweConst.SEFLG_EQUATORIAL|
                 SweConst.SEFLG_XYZ|
                 SweConst.SEFLG_TRUEPOS|
                 SweConst.SEFLG_NONUT|
                 SweConst.SEFLG_SPEED;
      ellipse_is_bary = false;
      if (ipli != SweConst.SE_MOON) {
        if ((method & SweConst.SE_NODBIT_OSCU_BAR)!=0 && x[2] > 6) {
          iflJ2000 |= SweConst.SEFLG_BARYCTR; 
          ellipse_is_bary = true;
        } else {
          iflJ2000 |= SweConst.SEFLG_HELCTR;
        }
      }
      
      if (ipli == SweConst.SE_MOON) {
        dt = SwephData.NODE_CALC_INTV;
        dzmin = 1e-15;
        Gmsm = SwephData.GEOGCONST * (1 + 1 / SwephData.EARTH_MOON_MRAT) /
                            SweConst.AUNIT/SweConst.AUNIT/SweConst.AUNIT*86400.0*86400.0;
      } else {
        if ((ipli >= SweConst.SE_MERCURY && ipli <= SweConst.SE_PLUTO) ||
                                                   ipli == SweConst.SE_EARTH) {
          plm = 1 / plmass[ipl_to_elem[ipl]];
        } else {
          plm = 0;
        }
        dt = SwephData.NODE_CALC_INTV * 10 * x[2];
        dzmin = 1e-15 * dt / SwephData.NODE_CALC_INTV;
        Gmsm = SwephData.HELGRAVCONST * (1 + plm) /
                            SweConst.AUNIT/SweConst.AUNIT/SweConst.AUNIT*86400.0*86400.0;
      }
      if ((iflag & SweConst.SEFLG_SPEED)!=0) {
        istart = 0;
        iend = 2;
      } else {
        istart = iend = 0;
        dt = 0;
      }
      for (i = istart, t = tjd_et - dt; i <= iend; i++, t += dt) {
        if (istart == iend) {
          t = tjd_et;
        }
        if (sw.swe_calc(t, ipli, iflJ2000, xpos[i], serr) == SweConst.ERR) {
          return SweConst.ERR;
        }
        
        if (ipli == SweConst.SE_EARTH) {
          if (sw.swe_calc(t,
                       SweConst.SE_MOON,
                       iflJ2000 & ~(SweConst.SEFLG_BARYCTR|SweConst.SEFLG_HELCTR),
                       xposm, serr) == SweConst.ERR) {
            return SweConst.ERR;
          }
          for (j = 0; j <= 2; j++)
            xpos[i][j] += xposm[j] / (SwephData.EARTH_MOON_MRAT + 1.0);
        }
        sw.swi_plan_for_osc_elem(iflg0, t, xpos[i]);
      }
      for (i = istart; i <= iend; i++) {
        if (Math.abs(xpos[i][5]) < dzmin) {
          xpos[i][5] = dzmin;
        }
        fac = xpos[i][2] / xpos[i][5];
        sgn = xpos[i][5] / Math.abs(xpos[i][5]);
        for (j = 0; j <= 2; j++) {
          xn[i][j] = (xpos[i][j] - fac * xpos[i][j+3]) * sgn;
          xs[i][j] = -xn[i][j];
        }
      }
      for (i = istart; i <= iend; i++) {
        
        rxy =  Math.sqrt(xn[i][0] * xn[i][0] + xn[i][1] * xn[i][1]);
        cosnode = xn[i][0] / rxy;
        sinnode = xn[i][1] / rxy;
        
        sl.swi_cross_prod(xpos[i], 0, xpos[i], 3, xnorm, 0);
        rxy =  xnorm[0] * xnorm[0] + xnorm[1] * xnorm[1];
        c2 = (rxy + xnorm[2] * xnorm[2]);
        rxyz = Math.sqrt(c2);
        rxy = Math.sqrt(rxy);
        sinincl = rxy / rxyz;
        cosincl = Math.sqrt(1 - sinincl * sinincl);
        
        cosu = xpos[i][0] * cosnode + xpos[i][1] * sinnode;
        sinu = xpos[i][2] / sinincl;
        uu = Math.atan2(sinu, cosu);
        
        rxyz = Math.sqrt(sl.square_sum(xpos[i]));
        v2 = sl.square_sum(xpos[i], 3);
        sema = 1 / (2 / rxyz - v2 / Gmsm);
        
        pp = c2 / Gmsm;
        ecce = Math.sqrt(1 - pp / sema);
        
        cosE = 1 / ecce * (1 - rxyz / sema);
        sinE = 1 / ecce / Math.sqrt(sema * Gmsm) *
                                        sw.dot_prod(xpos[i], xpos[i], 3);
        
        ny = 2 * Math.atan(Math.sqrt((1+ecce)/(1-ecce)) * sinE / (1 + cosE));
        
        xq[i][0] = sl.swi_mod2PI(uu - ny);
        xq[i][1] = 0;                        
        xq[i][2] = sema * (1 - ecce);        
        
        sl.swi_polcart(xq[i], xq[i]);
        sl.swi_coortrf2(xq[i], xq[i], -sinincl, cosincl);
        sl.swi_cartpol(xq[i], xq[i]);
        
        xq[i][0] += Math.atan2(sinnode, cosnode);
        xa[i][0] = sl.swi_mod2PI(xq[i][0] + SwephData.PI);
        xa[i][1] = -xq[i][1];
        if (do_focal_point) {
          xa[i][2] = sema * ecce * 2;        
        } else {
          xa[i][2] = sema * (1 + ecce);        
        }
        sl.swi_polcart(xq[i], xq[i]);
        sl.swi_polcart(xa[i], xa[i]);
        
        ny = sl.swi_mod2PI(ny - uu);
        ny2 = sl.swi_mod2PI(ny + SwephData.PI);
        
        cosE = Math.cos(2 * Math.atan(Math.tan(ny / 2) /
                                             Math.sqrt((1+ecce) / (1-ecce))));
        cosE2 = Math.cos(2 * Math.atan(Math.tan(ny2 / 2) /
                                             Math.sqrt((1+ecce) / (1-ecce))));
        
        rn = sema * (1 - ecce * cosE);
        rn2 = sema * (1 - ecce * cosE2);
        
        ro = Math.sqrt(sl.square_sum(xn[i]));
        ro2 = Math.sqrt(sl.square_sum(xs[i]));
        
        for (j = 0; j <= 2; j++) {
          xn[i][j] *= rn / ro;
          xs[i][j] *= rn2 / ro2;
        }
      }
      for (i = 0; i <= 2; i++) {
        if ((iflag & SweConst.SEFLG_SPEED)!=0) {
          xpe[i+xpeOffs] = xq[1][i];
          xpe[i+3+xpeOffs] = (xq[2][i] - xq[0][i]) / dt / 2;
          xap[i+xapOffs] = xa[1][i];
          xap[i+3+xapOffs] = (xa[2][i] - xa[0][i]) / dt / 2;
          xna[i] = xn[1][i];
          xna[i+3] = (xn[2][i] - xn[0][i]) / dt / 2;
          xnd[i+xndOffs] = xs[1][i];
          xnd[i+3+xndOffs] = (xs[2][i] - xs[0][i]) / dt / 2;
        } else {
          xpe[i+xpeOffs] = xq[0][i];
          xpe[i+3+xpeOffs] = 0;
          xap[i+xapOffs] = xa[0][i];
          xap[i+3+xapOffs] = 0;
          xna[i] = xn[0][i];
          xna[i+3] = 0;
          xnd[i+xndOffs] = xs[0][i];
          xnd[i+3+xndOffs] = 0;
        }
      }
      is_true_nodaps = true;
    }
    
    if (ipli == SweConst.SE_MOON &&
        (iflag & (SweConst.SEFLG_HELCTR | SweConst.SEFLG_BARYCTR))!=0) {
      sw.swi_force_app_pos_etc();
      if (sw.swe_calc(tjd_et, SweConst.SE_SUN, iflg0, x, serr) == SweConst.ERR) {
        return SweConst.ERR;
      }
    } else {
      if (sw.swe_calc(tjd_et, ipli,
                   iflg0 | (iflag & SweConst.SEFLG_TOPOCTR), x, serr) ==
                                                                SweConst.ERR) {
        return SweConst.ERR;
      }
    }
    
    if ((iflag & SweConst.SEFLG_TOPOCTR)!=0) {
      
      if (sw.swi_get_observer(tjd_et, iflag, false, xobs, serr) != SweConst.OK) {
        return SweConst.ERR;
      }
      
    } else {
      for (i = 0; i <= 5; i++)
        xobs[i] = 0;
    }
    if ((iflag & (SweConst.SEFLG_HELCTR | SweConst.SEFLG_BARYCTR))!=0) {
      if ((iflag & SweConst.SEFLG_HELCTR)!=0 &&
          (iflag & SweConst.SEFLG_MOSEPH)==0) {
        for (i = 0; i <= 5; i++)
          xobs[i] = xsun[i];
      }
    } else if (ipl == SweConst.SE_SUN && (iflag & SweConst.SEFLG_MOSEPH)==0) {
      for (i = 0; i <= 5; i++)
        xobs[i] = xsun[i];
    } else {
      
      for (i = 0; i <= 5; i++)
        xobs[i] += xear[i];
    }
    
    if ((iflag & SweConst.SEFLG_J2000)!=0) {
      oe = swed.oec2000;
    } else {
      oe = swed.oec;
    }
    
    for (ij = 0, xp = xx, xpOffs = 0; ij < 4; ij++, xpOffs += 6) {
      
      if (ipli == SweConst.SE_EARTH && ij <= 1) {
        for (i = 0; i <= 5; i++)
              xp[i+xpOffs] = 0;
        continue;
      }
      
      if (is_true_nodaps && (iflag & SweConst.SEFLG_NONUT)==0) {
        sl.swi_coortrf2(xp, xpOffs, xp, xpOffs, -swed.nut.snut, swed.nut.cnut);
        if ((iflag & SweConst.SEFLG_SPEED)!=0) {
          sl.swi_coortrf2(xp, 3+xpOffs, xp, 3+xpOffs, -swed.nut.snut, swed.nut.cnut);
        }
      }
      sl.swi_coortrf2(xp, xpOffs, xp, xpOffs, -oe.seps, oe.ceps);
      sl.swi_coortrf2(xp, 3+xpOffs, xp, 3+xpOffs, -oe.seps, oe.ceps);
      if (is_true_nodaps) {
        
        if ((iflag & SweConst.SEFLG_NONUT)==0) {
          sw.swi_nutate(xp, xpOffs, iflag, true);
        }
      }
      
      sl.swi_precess(xp, xpOffs, tjd_et, SwephData.J_TO_J2000);
      if ((iflag & SweConst.SEFLG_SPEED)!=0) {
        sw.swi_precess_speed(xp, xpOffs, tjd_et, SwephData.J_TO_J2000);
      }
      
      if (ipli == SweConst.SE_MOON) {
        for (i = 0; i <= 5; i++)
          xp[i+xpOffs] += xear[i];
      } else {
        if ((iflag & SweConst.SEFLG_MOSEPH)==0 && !ellipse_is_bary) {
          for (j = 0; j <= 5; j++)
            xp[j+xpOffs] += xsun[j];
        }
      }
      
      for (j = 0; j <= 5; j++)
        xp[j+xpOffs] -= xobs[j];
          
      if (ipl == SweConst.SE_SUN &&
          (iflag & (SweConst.SEFLG_HELCTR | SweConst.SEFLG_BARYCTR))==0) {
        for (j = 0; j <= 5; j++)
          xp[j+xpOffs] = -xp[j+xpOffs];
      }
      
      dt = Math.sqrt(sl.square_sum(xp, xpOffs)) * SweConst.AUNIT / SwephData.CLIGHT / 86400.0;
      if (do_defl) {
        sw.swi_deflect_light(xp, xpOffs, dt, iflag);
      }
      
      if (do_aberr) {
        sw.swi_aberr_light(xp, xpOffs, xobs, iflag);
        
        if ((iflag & SweConst.SEFLG_SPEED)!=0) {
          
          if (sw.swe_calc(tjd_et - dt, ipli,
                       iflg0 | (iflag & SweConst.SEFLG_TOPOCTR), x2, serr) ==
                                                                SweConst.ERR) {
            return SweConst.ERR;
          }
          if ((iflag & SweConst.SEFLG_TOPOCTR)!=0) {
            
            
            for (i = 0; i <= 5; i++)
              xobs2[i] = swed.topd.xobs[i];
          } else {
            for (i = 0; i <= 5; i++)
              xobs2[i] = 0;
          }
          if ((iflag & (SweConst.SEFLG_HELCTR | SweConst.SEFLG_BARYCTR))!=0) {
            if ((iflag & SweConst.SEFLG_HELCTR)!=0 &&
                (iflag & SweConst.SEFLG_MOSEPH)==0) {
              for (i = 0; i <= 5; i++)
                xobs2[i] = xsun[i];
            }
          } else if (ipl == SweConst.SE_SUN && (iflag & SweConst.SEFLG_MOSEPH)==0) {
            for (i = 0; i <= 5; i++)
              xobs2[i] = xsun[i];
          } else {
            
            for (i = 0; i <= 5; i++)
              xobs2[i] += xear[i];
          }
          for (i = 3; i <= 5; i++)
            xp[i+xpOffs] += xobs[i] - xobs2[i];
          
          if (sw.swe_calc(tjd_et, SweConst.SE_SUN,
                       iflg0 | (iflag & SweConst.SEFLG_TOPOCTR), x2, serr) ==
                                                                SweConst.ERR) {
            return SweConst.ERR;
          }
        }
      }
      
      
      for (j = 0; j <= 5; j++)
        x2000[j] = xp[j+xpOffs];
      if ((iflag & SweConst.SEFLG_J2000)==0) {
        sl.swi_precess(xp, xpOffs, tjd_et, SwephData.J2000_TO_J);
        if ((iflag & SweConst.SEFLG_SPEED)!=0) {
          sw.swi_precess_speed(xp, xpOffs, tjd_et, SwephData.J2000_TO_J);
        }
      }
      
      if ((iflag & SweConst.SEFLG_NONUT)==0) {
        sw.swi_nutate(xp, xpOffs, iflag, false);
      }
      
      for (j = 0; j <= 5; j++)
        pldat.xreturn[18+j] = xp[j+xpOffs];
      
      sl.swi_coortrf2(xp, xpOffs, xp, xpOffs, oe.seps, oe.ceps);
      if ((iflag & SweConst.SEFLG_SPEED)!=0) {
        sl.swi_coortrf2(xp, 3+xpOffs, xp, 3+xpOffs, oe.seps, oe.ceps);
      }
      if ((iflag & SweConst.SEFLG_NONUT)==0) {
        sl.swi_coortrf2(xp, xpOffs, xp, xpOffs, swed.nut.snut, swed.nut.cnut);
        if ((iflag & SweConst.SEFLG_SPEED)!=0) {
          sl.swi_coortrf2(xp, 3+xpOffs, xp, 3+xpOffs,
                          swed.nut.snut, swed.nut.cnut);
        }
      }
        
        for (j = 0; j <= 5; j++)
          pldat.xreturn[6+j] = xp[j+xpOffs];
      
      if ((iflag & SweConst.SEFLG_SIDEREAL)!=0) {
        
        if ((swed.sidd.sid_mode & SweConst.SE_SIDBIT_ECL_T0)!=0) {
          if (sw.swi_trop_ra2sid_lon(x2000, pldat.xreturn, 6, pldat.xreturn, 18, iflag, serr) != SweConst.OK) {
            return SweConst.ERR;
          }
        
        } else if ((swed.sidd.sid_mode & SweConst.SE_SIDBIT_SSY_PLANE)!=0) {
          if (sw.swi_trop_ra2sid_lon_sosy(x2000, pldat.xreturn, 6, pldat.xreturn, 18, iflag, serr) != SweConst.OK) {
            return SweConst.ERR;
        }
        } else {
        
        sl.swi_cartpol_sp(pldat.xreturn, 6, pldat.xreturn, 0);
        pldat.xreturn[0] -= sw.swe_get_ayanamsa(tjd_et) * SwissData.DEGTORAD;
        sl.swi_polcart_sp(pldat.xreturn, 0, pldat.xreturn, 6);
        }
      }
      if ((iflag & SweConst.SEFLG_XYZ)!=0 &&
          (iflag & SweConst.SEFLG_EQUATORIAL)!=0) {
        for (j = 0; j <= 5; j++)
          xp[j+xpOffs] = pldat.xreturn[18+j];
        continue;
      }
      if ((iflag & SweConst.SEFLG_XYZ)!=0) {
        for (j = 0; j <= 5; j++)
          xp[j+xpOffs] = pldat.xreturn[6+j];
        continue;
      }
      
      sl.swi_cartpol_sp(pldat.xreturn, 18, pldat.xreturn, 12);
      sl.swi_cartpol_sp(pldat.xreturn, 6, pldat.xreturn, 0);
      
      for (j = 0; j < 2; j++) {
        pldat.xreturn[j] *= SwissData.RADTODEG;                
        pldat.xreturn[j+3] *= SwissData.RADTODEG;
        pldat.xreturn[j+12] *= SwissData.RADTODEG;        
        pldat.xreturn[j+15] *= SwissData.RADTODEG;
      }
      if ((iflag & SweConst.SEFLG_EQUATORIAL)!=0) {
        for (j = 0; j <= 5; j++)
          xp[j+xpOffs] = pldat.xreturn[12+j];
        continue;
      } else {
        for (j = 0; j <= 5; j++)
          xp[j+xpOffs] = pldat.xreturn[j];
        continue;
      }
    }
    for (i = 0; i <= 5; i++) {
      if (i > 2 && (iflag & SweConst.SEFLG_SPEED)==0) {
        xna[i] = xnd[i+xndOffs] = xpe[i+xpeOffs] = xap[i+xapOffs] = 0;
      }
      if (xnasc != null) {
        xnasc[i] = xna[i];
      }
      if (xndsc != null) {
        xndsc[i] = xnd[i+xndOffs];
      }
      if (xperi != null) {
        xperi[i] = xpe[i+xpeOffs];
      }
      if (xaphe != null) {
        xaphe[i] = xap[i+xapOffs];
      }
    }
    return SweConst.OK;
  }
  
  int swe_nod_aps_ut(double tjd_ut, int ipl, int iflag,
                     int  method,
                     double[] xnasc, double[] xndsc,
                     double[] xperi, double[] xaphe,
                     StringBuffer serr) {
    return swe_nod_aps(tjd_ut + SweDate.getDeltaT(tjd_ut),
                        ipl, iflag, method, xnasc, xndsc, xperi, xaphe,
                        serr);
  }
  
  int swe_gauquelin_sector(double t_ut, int ipl, StringBuffer starname, int iflag, int imeth, double[] geopos, double atpress, double attemp, DblObj dgsect, StringBuffer serr) {
    DblObj dtmp=new DblObj();
    boolean rise_found = true;
    boolean set_found = true;
    int retval;
    double tret[]=new double[3];
    double t_et, t;
    double x0[]=new double[6];
    double eps, nutlo[]=new double[2], armc;
    int epheflag = iflag & SweConst.SEFLG_EPHMASK;
    boolean do_fixstar = (starname != null && starname.length() > 0);
    int risemeth = SweConst.SE_BIT_DISC_CENTER;
    boolean above_horizon = false;
    
    if ((imeth & 2)==0) {
      t_et = t_ut + SweDate.getDeltaT(t_ut);
      eps = sl.swi_epsiln(t_et) * SwissData.RADTODEG;
      sl.swi_nutation(t_et, nutlo);
      nutlo[0] *= SwissData.RADTODEG;
      nutlo[1] *= SwissData.RADTODEG;
      armc = sl.swe_degnorm(sl.swe_sidtime0(t_ut, eps + nutlo[1], nutlo[0]) * 15 + geopos[0]);
      if (do_fixstar) {
        if (sw.swe_fixstar(starname, t_et, iflag, x0, serr) == SweConst.ERR)
  	return SweConst.ERR;
      } else {
        if (sw.swe_calc(t_et, ipl, iflag, x0, serr) == SweConst.ERR)
  	return SweConst.ERR;
      }
      if ((imeth & 1)!=0) 
        x0[1] = 0;
      dgsect.val = sw.swe_house_pos(armc, geopos[1], eps + nutlo[1], 'G', x0, null);
      return SweConst.OK;
    }
    
    if (imeth == 2) 
      risemeth |= SweConst.SE_BIT_NO_REFRACTION;
    
    dtmp.val=tret[0];
    retval = swe_rise_trans(t_ut, ipl, starname, epheflag,
                            SweConst.SE_CALC_RISE|risemeth, geopos, atpress, attemp,
                            dtmp, serr);
    tret[0]=dtmp.val;
    if (retval == SweConst.ERR) {
      return SweConst.ERR; 
    } else if (retval == -2) {
      
      rise_found = false;    
    }
    
    dtmp.val=tret[1];
    retval = swe_rise_trans(t_ut, ipl, starname, epheflag,
                            SweConst.SE_CALC_SET|risemeth, geopos, atpress, attemp,
                            dtmp, serr);
    tret[1]=dtmp.val;
    if (retval == SweConst.ERR) {
      return SweConst.ERR; 
    } else if (retval == -2) {
      set_found = false;
    }
    if (tret[0] < tret[1] && rise_found == true) {
      above_horizon = false;
      
      t = t_ut - 1.2;
      if (set_found) t = tret[1] - 1.2;
      set_found = true;
      dtmp.val=tret[1];
      retval = swe_rise_trans(t, ipl, starname, epheflag,
                            SweConst.SE_CALC_SET|risemeth, geopos, atpress, attemp,
                            dtmp, serr);
      tret[1]=dtmp.val;
      if (retval == SweConst.ERR) {
        return SweConst.ERR; 
      } else if (retval == -2) {
        set_found = false;
      }
    } else if (tret[0] >= tret[1] && set_found == true) {
      above_horizon = true;
      
      t = t_ut - 1.2;
      if (rise_found) t = tret[0] - 1.2;
      rise_found = true;
      dtmp.val=tret[0];
      retval = swe_rise_trans(t, ipl, starname, epheflag,
                            SweConst.SE_CALC_RISE|risemeth, geopos, atpress, attemp,
                            dtmp, serr);
      tret[0]=dtmp.val;
      if (retval == SweConst.ERR) {
        return SweConst.ERR; 
      } else if (retval == -2) {
        rise_found = false;
      }
    }
    if (rise_found && set_found) {
      if (above_horizon) {
        dgsect.val = (t_ut - tret[0]) / (tret[1] - tret[0]) * 18 + 1;
      } else {
        dgsect.val = (t_ut - tret[1]) / (tret[0] - tret[1]) * 18 + 19;
      }
      return SweConst.OK;
    } else {
      dgsect.val = 0;
      if (serr!=null)
        serr.append("rise or set not found for planet ").append(ipl);
      return SweConst.ERR;
    }
  }
} // End of class Swecl
class SweConst {
  
  public static final int OK=0;
  
  public static final int ERR=-1;  
  
  public static final int SE_ECL_NUT=-1;
  
  public static final int SE_SUN=0;
  
  public static final int SE_MOON=1;
  
  public static final int SE_MERCURY=2;
  
  public static final int SE_VENUS=3;
  
  public static final int SE_MARS=4;
  
  public static final int SE_JUPITER=5;
  
  public static final int SE_SATURN=6;
  
  public static final int SE_URANUS=7;
  
  public static final int SE_NEPTUNE=8;
  
  public static final int SE_PLUTO=9;
  
  public static final int SE_MEAN_NODE=10;
  
  public static final int SE_TRUE_NODE=11;
  
  public static final int SE_MEAN_APOG=12;
  
  public static final int SE_OSCU_APOG=13;
  
  public static final int SE_EARTH=14;
  
  public static final int SE_CHIRON=15;
  
  public static final int SE_PHOLUS=16;
  
  public static final int SE_CERES=17;
  
  public static final int SE_PALLAS=18;
  
  public static final int SE_JUNO=19;
  
  public static final int SE_VESTA=20;
  
  public static final int SE_INTP_APOG=21;
  
  public static final int SE_INTP_PERG=22;
  
  static final int SE_NPLANETS=23;
  
  public static final int SE_AST_OFFSET=10000;
  public static final int SE_VARUNA  =(SE_AST_OFFSET + 20000);
  static final int SE_FICT_OFFSET=40;
  public static final int SE_FICT_OFFSET_1=39;
  static final int SE_FICT_MAX=999;
  static final int SE_NFICT_ELEM=15;
  static final int SE_COMET_OFFSET=2000;
  static final int SE_NALL_NAT_POINTS=(SE_NPLANETS + SE_NFICT_ELEM);
  
  
  public static final int SE_CUPIDO=40;
  
  public static final int SE_HADES=41;
  
  public static final int SE_ZEUS=42;
  
  public static final int SE_KRONOS=43;
  
  public static final int SE_APOLLON=44;
  
  public static final int SE_ADMETOS=45;
  
  public static final int SE_VULKANUS=46;
  
  public static final int SE_POSEIDON=47;
  
  
  public static final int SE_ISIS=48;
  
  public static final int SE_NIBIRU=49;
  
  public static final int SE_HARRINGTON=50;
  
  public static final int SE_NEPTUNE_LEVERRIER=51;
  
  public static final int SE_NEPTUNE_ADAMS=52;
  
  public static final int SE_PLUTO_LOWELL=53;
  
  public static final int SE_PLUTO_PICKERING=54;
  
  public static final int SE_VULCAN=55;
  
  public static final int SE_WHITE_MOON=56;
  
  public static final int SE_PROSERPINA=57;
  
  public static final int SE_WALDEMATH=58;
  public static final int SE_FIXSTAR=-10;
  
  static final int SE_ASC   =0;
  
  static final int SE_MC    =1;
  
  static final int SE_ARMC  =2;
  
  static final int SE_VERTEX=3;
  
  static final int SE_EQUASC=4;
  
  static final int SE_COASC1=5;
  
  static final int SE_COASC2=6;
  
  static final int SE_POLASC=7;
  
  static final int SE_NASCMC=8;
  
  public static final String SE_FNAME_DE406="de406.eph";
  public static final String SE_FNAME_DE200="de200.eph";
  public static final String SE_FNAME_DFT=SE_FNAME_DE406;
  
  
  public static final int SEFLG_HELCTR=8;     // return heliocentric position
  
  public static final int SEFLG_TRUEPOS=16;   // return true positions, not apparent
  
  public static final int SEFLG_J2000=32;     // no precession, i.e. give J2000 equinox
  
  public static final int SEFLG_NONUT=64;     // no nutation, i.e. mean equinox of date
  
  public static final int SEFLG_SPEED3=128;   // speed from 3 positions (do not use
                                       // it, SEFLG_SPEED is faster and more
                                       // precise.)
  
  public static final int SEFLG_SPEED=256;    // high precision speed
  
  public static final int SEFLG_NOGDEFL=512;  // turn off gravitational deflection
  
  public static final int SEFLG_NOABERR=1024; // turn off 'annual' aberration of light
  
  public static final int SEFLG_EQUATORIAL=2*1024; // equatorial positions are wanted
  
  public static final int SEFLG_XYZ=4*1024;     // cartesian, not polar, coordinates
  
  public static final int SEFLG_RADIANS=8*1024; // coordinates in radians, not degrees
  
  public static final int SEFLG_BARYCTR=16*1024; // barycentric positions
  
  public static final int SEFLG_TOPOCTR=32*1024; // topocentric positions
  
  public static final int SEFLG_SIDEREAL=64*1024; // sidereal positions
  
  public static final int SEFLG_ICRS=128*1024; // ICRS (DE406 reference frame)
  
  public static final int SEFLG_TRANSIT_LONGITUDE =  128*1024;
  
  public static final int SEFLG_TRANSIT_LATITUDE  =  256*1024;
  
  public static final int SEFLG_TRANSIT_DISTANCE  =  512*1024;
  
  public static final int SEFLG_TRANSIT_SPEED     = 1024*1024;
  
  public static final int SEFLG_YOGA_TRANSIT      = 2048*1024;
  
  public static final int SEFLG_JPLEPH=1;
  
  public static final int SEFLG_SWIEPH=2;
  
  public static final int SEFLG_MOSEPH=4;
  
  public static final int SEFLG_DEFAULTEPH=SEFLG_SWIEPH;
  public static final int SEFLG_EPHMASK=SEFLG_JPLEPH|SEFLG_SWIEPH|SEFLG_MOSEPH;
  public static final int SE_SIDBITS             =256;
  
  
  public static final int SE_SIDBIT_ECL_T0       =256;
  
  
  public static final int SE_SIDBIT_SSY_PLANE    =512;
  
  
  public static final int SE_SIDM_FAGAN_BRADLEY  = 0;
  
  public static final int SE_SIDM_LAHIRI         = 1;
  
  public static final int SE_SIDM_DELUCE         = 2;
  
  public static final int SE_SIDM_RAMAN          = 3;
  
  public static final int SE_SIDM_USHASHASHI     = 4;
  
  public static final int SE_SIDM_KRISHNAMURTI   = 5;
  
  public static final int SE_SIDM_DJWHAL_KHUL    = 6;
  
  public static final int SE_SIDM_YUKTESHWAR     = 7;
  
  public static final int SE_SIDM_JN_BHASIN      = 8;
  
  public static final int SE_SIDM_BABYL_KUGLER1  = 9;
  
  public static final int SE_SIDM_BABYL_KUGLER2  =10;
  
  public static final int SE_SIDM_BABYL_KUGLER3  =11;
  
  public static final int SE_SIDM_BABYL_HUBER    =12;
  
  public static final int SE_SIDM_BABYL_ETPSC    =13;
  
  public static final int SE_SIDM_ALDEBARAN_15TAU=14;
  
  public static final int SE_SIDM_HIPPARCHOS     =15;
  
  public static final int SE_SIDM_SASSANIAN      =16;
  
  public static final int SE_SIDM_GALCENT_0SAG   =17;
  
  public static final int SE_SIDM_J2000          =18;
  
  public static final int SE_SIDM_J1900          =19;
  
  public static final int SE_SIDM_B1950          =20;
  
  public static final int SE_SIDM_USER          =255;
  static final int SE_MAX_STNAME=20;    // maximum size of fixstar name;
                                        // the parameter star in swe_fixstar
					// must allow twice this space for
				        // the returned star name.
  
  
  public static final int SE_NODBIT_MEAN    =1; // mean nodes/apsides
  
  public static final int SE_NODBIT_OSCU    =2; // osculating nodes/apsides
  
  public static final int SE_NODBIT_OSCU_BAR=4; // same, but motion about solar
                                             // system barycenter is considered
  
  public static final int SE_NODBIT_FOPOINT =256; // focal point of orbit
                                                  // instead of aphelion
  
  public static final int SE_SPLIT_DEG_ROUND_SEC =  1;
  public static final int SE_SPLIT_DEG_ROUND_MIN =  2;
  public static final int SE_SPLIT_DEG_ROUND_DEG =  4;
  public static final int SE_SPLIT_DEG_ZODIACAL  =  8;
  public static final int SE_SPLIT_DEG_KEEP_SIGN = 16;
  public static final int SE_SPLIT_DEG_KEEP_DEG  = 32;
  
  
  public static final String SE_EPHE_PATH=".:./ephe:/users/ephe2/:/users/ephe/";
                        
  static final String SE_STARFILE="fixstars.cat";
  static final String SE_ASTNAMFILE="seasnam.txt";
  
  static final String SE_FICTFILE="seorbel.txt";
  
  public static final int SE_ECL_CENTRAL=1;
  public static final int SE_ECL_NONCENTRAL=2;
  public static final int SE_ECL_TOTAL=4;
  
  public static final int SE_ECL_ANNULAR=8;
  public static final int SE_ECL_PARTIAL=16;
  public static final int SE_ECL_ANNULAR_TOTAL=32;
  public static final int SE_ECL_PENUMBRAL=64;
  public static final int SE_ECL_VISIBLE=128;
  public static final int SE_ECL_MAX_VISIBLE=256;
  
  public static final int SE_ECL_1ST_VISIBLE=512;
  
  public static final int SE_ECL_2ND_VISIBLE=1024;
  
  public static final int SE_ECL_3RD_VISIBLE=2048;
  
  public static final int SE_ECL_4TH_VISIBLE=4096;
  
  public static final int SE_ECL_ONE_TRY=32*1024;
  
  
  public static final int SE_CALC_RISE          = 1;
  
  public static final int SE_CALC_SET           = 2;
  
  public static final int SE_CALC_MTRANSIT      = 4;
  
  public static final int SE_CALC_ITRANSIT      = 8;
  
  public static final int SE_BIT_DISC_CENTER   = 256;
                                    
                                    
                                    
  
  public static final int SE_BIT_NO_REFRACTION = 512;
                                    
                                    
  
  
  public static final int SE_ECL2HOR            = 0;
  
  public static final int SE_EQU2HOR            = 1;
  
  public static final int SE_HOR2ECL            = 0;
  
  public static final int SE_HOR2EQU            = 1;
  
  
  public static final int SE_TRUE_TO_APP =0;
  
  public static final int SE_APP_TO_TRUE =1;
//
  public static final double AUNIT=1.4959787066e+11;        // au in meters,
                                                            // AA 1996 K6
  
  private SweConst() {
  }
}
class SweDate {
  private static SwissEph sw = new SwissEph();
  
  public static final int SUNDAY=0;
  
  public static final int MONDAY=1;
  
  public static final int TUESDAY=2;
  
  public static final int WEDNESDAY=3;
  
  public static final int THURSDAY=4;
  
  public static final int FRIDAY=5;
  
  public static final int SATURDAY=6;
  public static final boolean SE_JUL_CAL=false;
  public static final boolean SE_GREG_CAL=true;
  public static final boolean SE_KEEP_DATE=true;
  public static final boolean SE_KEEP_JD=false;
  
  public static final double SE_TIDAL_DE403=-25.8;
  
  public static final double SE_TIDAL_DE404=-25.8;
  
  public static final double SE_TIDAL_DE405=-25.7376;
  
  public static final double SE_TIDAL_DE406=-25.7376;
  
  public static final double SE_TIDAL_DE200=-23.8946;
  
  public static final double SE_TIDAL_26=-26.0;
  
  public static final double SE_TIDAL_DEFAULT=SE_TIDAL_DE406;
  
  public static final double JD0=2440587.5;          
  private double tid_acc = SE_TIDAL_DEFAULT;
  private static boolean init_dt_done = false;
  private double jd;
  // JD for the start of the Gregorian calendar system (October 15, 1582):
  private double jdCO = 2299160.5;
  private boolean calType;
  private int year;
  private int month;
  private int day;
  private double hour;
  private double deltaT;
  private boolean deltatIsValid=false;
  
  public SweDate() {
    Calendar cal = Calendar.getInstance(TimeZone.getTimeZone("GMT+0"));
    setFields(cal.get(Calendar.YEAR),
          cal.get(Calendar.MONTH) + 1,
          cal.get(Calendar.DAY_OF_MONTH),
          cal.get(Calendar.HOUR_OF_DAY) +
                cal.get(Calendar.MINUTE)/60. +
                cal.get(Calendar.SECOND)/3600. +
                cal.get(Calendar.MILLISECOND)/3600000.,
          SE_GREG_CAL);
  }
  
  public SweDate(double jd) {
    initDateFromJD(jd, jdCO<=jd?SE_GREG_CAL:SE_JUL_CAL);
  }
  
  public SweDate(double jd, boolean calType) {
    initDateFromJD(jd, calType);
  }
  
  public SweDate(int year, int month, int day, double hour) {
    setFields(year, month, day, hour);
  }
  
  public SweDate(int year, int month, int day, double hour, boolean calType) {
     setFields(year, month, day, hour, calType);
   }
  
  public double getJulDay() {
    return this.jd;
  }
  
  public static double getJulDay(int year, int month, int day, double hour) {
    double sjd = swe_julday(year, month, day, hour, SE_GREG_CAL);
    return sjd;
  }
  
  public static double getJulDay(int year, int month, int day, double hour,
                                 boolean calType) {
    double sjd = swe_julday(year, month, day, hour, calType);
    return sjd;
  }
  
  public int getDayOfWeekNr() {
    return ((int)(this.jd-5.5))%7;
  }
  
  public static synchronized int getDayOfWeekNr(double jd) {
    return ((int)(jd-5.5))%7;
  }
  
  public static int getDayOfWeekNr(int year, int month, int day) {
    int sdow = ((int)(swe_julday(year, month, day, 0.0, SE_GREG_CAL)-5.5))%7;
    return sdow;
  }
  
  public static int getDayOfWeekNr(int year, int month, int day,
                                   boolean calType) {
    int sdow = ((int)(swe_julday(year, month, day, 0.0, calType)-5.5))%7;
    return sdow;
  }
  
  public boolean getCalendarType() {
    return this.calType;
  }
  
  public int getYear() {
    return this.year;
  }
  
  public int getMonth() {
    return this.month;
  }
  
  public int getDay() {
    return this.day;
  }
  
  public double getHour() {
    return this.hour;
  }
  
  public double getDeltaT() {
    if (deltatIsValid) { return this.deltaT; }
    this.deltaT=calc_deltaT(this.getJulDay());
    deltatIsValid=true;
    return this.deltaT;
  }
  
  static public double getDeltaT(double tjd) {
    double sdt = calc_deltaT(tjd, SE_TIDAL_DEFAULT);
    return sdt;
  }
  
  public Date getDate(long offset) {
    long millis=(long)((getJulDay()-JD0)*24L*3600L*1000L)+offset;
    return new Date(millis);
  }
  
  public static Date getDate(double jd) {
    long millis=(long)((jd-JD0)*24L*3600L*1000L);
    return new Date(millis);
  }
  
  public void setJulDay(double newJD) {
    this.jd=newJD;
    deltatIsValid=false;
    IDate dt=swe_revjul(newJD,this.calType);
    this.year=dt.year;
    this.month=dt.month;
    this.day=dt.day;
    this.hour=dt.hour;
  }
  
  public void setCalendarType(boolean newCalType, boolean keepDate) {
    if (this.calType != newCalType) {
      this.calType=newCalType;
      deltatIsValid=false;
      if (keepDate) {
        this.jd=swe_julday(this.year, this.month, this.day,
                           this.hour, this.calType);
      } else {
        IDate dt=swe_revjul(this.jd,newCalType);
        this.year=dt.year;
        this.month=dt.month;
        this.day=dt.day;
        this.hour=dt.hour;
      }
    }
  }
  
  public void updateCalendarType() {
    this.calType=(this.jdCO<=this.jd?SE_GREG_CAL:SE_JUL_CAL);;
  }
  // Date:
  
  public boolean setDate(int newYear, int newMonth, int newDay,
                         double newHour) {
    this.year=newYear;
    this.month=newMonth;
    this.day=newDay;
    this.hour=newHour;
    deltatIsValid=false;
    this.jd=swe_julday(this.year, this.month, this.day,
                       this.hour, this.calType);  // -> erzeugt JD
    return true;
  }
  
  public boolean setDate(int newYear, int newMonth, int newDay, double newHour,
                         boolean check) {
    this.year=newYear;
    double oldMonth=this.month;
    double oldDay=this.day;
    this.month=newMonth;
    this.day=newDay;
    this.hour=newHour;
    deltatIsValid=false;
    this.jd=swe_julday(this.year, this.month, this.day,
                       this.hour, this.calType);  // -> erzeugt JD
    if (check) {
      IDate dt=swe_revjul(this.jd,this.calType);  // -> erzeugt neues Datum
      this.year=dt.year;
      this.month=dt.month;
      this.day=dt.day;
      this.hour=dt.hour;
      return (this.year==newYear && this.month==oldMonth && this.day==oldDay);
    }
    return true;
  }
  // Year:
  
  public boolean setYear(int newYear) {
    this.year=newYear;
    deltatIsValid=false;
    this.jd=swe_julday(this.year, this.month, this.day,
                       this.hour, this.calType);  // -> erzeugt JD
    return true;
  }
  
  public boolean setYear(int newYear, boolean check) {
    this.year=newYear;
    deltatIsValid=false;
    this.jd=swe_julday(this.year, this.month, this.day,
                       this.hour, this.calType);  // -> erzeugt JD
    if (check) {
      double oldMonth=this.month;
      double oldDay=this.day;
      IDate dt=swe_revjul(this.jd,this.calType);  // -> erzeugt neues Datum
      this.year=dt.year;
      this.month=dt.month;
      this.day=dt.day;
      this.hour=dt.hour;
      return (this.year==newYear && this.month==oldMonth && this.day==oldDay);
    }
    return true;
  }
  
  // Monat:
  public boolean setMonth(int newMonth) {
    this.month=newMonth;
    deltatIsValid=false;
    this.jd=swe_julday(this.year, this.month, this.day,
                       this.hour, this.calType);  // -> erzeugt JD
    return true;
  }
  
  public boolean setMonth(int newMonth, boolean check) {
    this.month=newMonth;
    deltatIsValid=false;
    this.jd=swe_julday(this.year, this.month, this.day,
                       this.hour, this.calType);  // -> erzeugt JD
    if (check) {
      double oldYear=this.year;
      double oldDay=this.day;
      IDate dt=swe_revjul(this.jd,this.calType);  // -> erzeugt neues Datum
      this.year=dt.year;
      this.month=dt.month;
      this.day=dt.day;
      this.hour=dt.hour;
      return (this.year==oldYear && this.month==newMonth && this.day==oldDay);
    }
    return true;
  }
  // Tag:
  
  public boolean setDay(int newDay) {
    this.day=newDay;
    deltatIsValid=false;
    this.jd=swe_julday(this.year, this.month, this.day,
                       this.hour, this.calType);
    return true;
  }
  
  public boolean setDay(int newDay, boolean check) {
    this.day=newDay;
    deltatIsValid=false;
    this.jd=swe_julday(this.year, this.month, this.day,
                       this.hour, this.calType);  // -> erzeugt JD
    if (check) {
      double oldYear=this.year;
      double oldMonth=this.month;
      IDate dt=swe_revjul(this.jd,this.calType);  // -> erzeugt neues Datum
      this.year=dt.year;
      this.month=dt.month;
      this.day=dt.day;
      this.hour=dt.hour;
      return (this.year==oldYear && this.month==oldMonth && this.day==newDay);
    }
    return true;
  }
  // Time:
  
  public boolean setHour(double newHour) {
    this.hour=newHour;
    this.jd=swe_julday(this.year, this.month, this.day,
                       this.hour, this.calType);
    return true;
  }
  // Datum ueberpruefen:
  
  public boolean checkDate() {
    boolean cd = checkDate(this.year, this.month, this.day, this.hour);
    return cd;
  }
  
  public boolean checkDate(int year, int month, int day) {
    boolean cd = checkDate(year, month, day, 0.0);
    return cd;
  }
  
  public boolean checkDate(int year, int month, int day, double hour) {
    double jd=swe_julday(year,month,day,hour,SE_GREG_CAL);
    IDate dt=swe_revjul(jd,SE_GREG_CAL);
    return (dt.year==year && dt.month==month && dt.day==day);
  }
  
  public void makeValidDate() {
    double jd=swe_julday(this.year,this.month,this.day,this.hour,SE_GREG_CAL);
    IDate dt=swe_revjul(jd,SE_GREG_CAL);
    this.year=dt.year;
    this.month=dt.month;
    this.day=dt.day;
    this.hour=dt.hour;
  }
  
  public double getGregorianChange() {
    return this.jdCO;
  }
  
  public void setGregorianChange(int year, int month, int day) {
    this.year = year;
    this.month = month;
    this.day = day;
    deltatIsValid = false;
    this.calType = SE_GREG_CAL;
    if (this.year < year ||
        (this.year == year && this.month < month) ||
        (this.year == year && this.month == month && this.day < day)) {
      this.calType = SE_JUL_CAL;
    }
    this.jdCO = swe_julday(year, month, day, 0., SE_GREG_CAL);
    this.jd = swe_julday(this.year, this.month, this.day, this.hour,
                         this.calType);
  }
  
  public void setGregorianChange(double newJDCO) {
    this.jdCO = newJDCO;
    this.calType = (this.jd>=this.jdCO?SE_GREG_CAL:SE_JUL_CAL);
    IDate dt = swe_revjul(this.jd,this.calType);
    this.year = dt.year;
    this.month = dt.month;
    this.day = dt.day;
    this.hour = dt.hour;
  }
  
  public double getTidalAcc() {
    return this.tid_acc;
  }
  
  public void setTidalAcc(double tid_acc) {
    this.tid_acc=tid_acc;
  }
  
  public String toString() {
    double hour = getHour();
    String h = (int)hour + ":";
    hour = 60 * (hour - (int)hour);
    h += (int)hour + ":";
    hour = 60 * (hour - (int)hour);
    h += hour ;
               
    return "(YYYY/MM/DD) " +
           getYear() + "/" +
           (getMonth()<10?"0":"") + getMonth() + "/" +
           (getDay()<10?"0":"") + getDay() + ", " +
           h + "h " +
           (getCalendarType()?"(greg)":"(jul)") + "\n" +
           "Jul. Day: " + getJulDay() + "; " +
           "DeltaT: " + getDeltaT();
  }
  private static synchronized double swe_julday(int year, int month, int day,
                                                double hour, boolean calType) {
    double jd;
    double u,u0,u1,u2;
    u = year;
    if (month < 3) { u -=1; }
    u0 = u + 4712.0;
    u1 = month + 1.0;
    if (u1 < 4) { u1 += 12.0; }
    jd = Math.floor(u0*365.25)
       + Math.floor(30.6*u1+0.000001)
       + day + hour/24.0 - 63.5;
    if (calType == SE_GREG_CAL) {
      u2 = Math.floor(Math.abs(u) / 100) - Math.floor(Math.abs(u) / 400);
      if (u < 0.0) {
        u2 = -u2;
      }
      jd = jd - u2 + 2;
      if ((u < 0.0) && (u/100 == Math.floor(u/100)) &&
                          (u/400 != Math.floor(u/400))) {
        jd -=1;
      }
    }
    return jd;
  }
  private synchronized IDate swe_revjul (double jd, boolean calType) {
    IDate dt=new IDate();
    double u0,u1,u2,u3,u4;
    u0 = jd + 32082.5;
    if (calType == SE_GREG_CAL) {
      u1 = u0 + Math.floor (u0/36525.0) - Math.floor (u0/146100.0) - 38.0;
      if (jd >= 1830691.5) {
        u1 +=1;
      }
      u0 = u0 + Math.floor (u1/36525.0) - Math.floor (u1/146100.0) - 38.0;
    }
    u2 = Math.floor (u0 + 123.0);
    u3 = Math.floor ( (u2 - 122.2) / 365.25);
    u4 = Math.floor ( (u2 - Math.floor (365.25 * u3) ) / 30.6001);
    dt.month = (int) (u4 - 1.0);
    if (dt.month > 12) {
      dt.month -= 12;
    }
    dt.day = (int) (u2 - Math.floor (365.25 * u3) - Math.floor (30.6001 * u4));
    dt.year = (int) (u3 + Math.floor ( (u4 - 2.0) / 12.0) - 4800);
    dt.hour = (jd - Math.floor (jd + 0.5) + 0.5) * 24.0;
    return dt;
  }
  
  private static final int TABSTART=1620;
  private static final int TABEND=2014;
  private static final int TABSIZ=TABEND-TABSTART+1;
  
  private static final int TABSIZ_SPACE=TABSIZ+50;
  private static short dt[]=new short[] {
  
  12400, 11900, 11500, 11000, 10600, 10200, 9800, 9500, 9100, 8800,
  8500, 8200, 7900, 7700, 7400, 7200, 7000, 6700, 6500, 6300,
  6200, 6000, 5800, 5700, 5500, 5400, 5300, 5100, 5000, 4900,
  4800, 4700, 4600, 4500, 4400, 4300, 4200, 4100, 4000, 3800,
  
  3700, 3600, 3500, 3400, 3300, 3200, 3100, 3000, 2800, 2700,
  2600, 2500, 2400, 2300, 2200, 2100, 2000, 1900, 1800, 1700,
  1600, 1500, 1400, 1400, 1300, 1200, 1200, 1100, 1100, 1000,
  1000, 1000, 900, 900, 900, 900, 900, 900, 900, 900,
  
  900, 900, 900, 900, 900, 900, 900, 900, 1000, 1000,
  1000, 1000, 1000, 1000, 1000, 1000, 1000, 1100, 1100, 1100,
  1100, 1100, 1100, 1100, 1100, 1100, 1100, 1100, 1100, 1100,
  1100, 1100, 1100, 1100, 1200, 1200, 1200, 1200, 1200, 1200,
  
  1200, 1200, 1200, 1200, 1300, 1300, 1300, 1300, 1300, 1300,
  1300, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1500, 1500,
  1500, 1500, 1500, 1500, 1500, 1600, 1600, 1600, 1600, 1600,
  1600, 1600, 1600, 1600, 1600, 1700, 1700, 1700, 1700, 1700,
  
  1700, 1700, 1700, 1700, 1700, 1700, 1700, 1700, 1700, 1700,
  1700, 1700, 1600, 1600, 1600, 1600, 1500, 1500, 1400, 1400,
  
  1370, 1340, 1310, 1290, 1270, 1260, 1250, 1250, 1250, 1250,
  1250, 1250, 1250, 1250, 1250, 1250, 1250, 1240, 1230, 1220,
  
  1200, 1170, 1140, 1110, 1060, 1020, 960, 910, 860, 800,
  750, 700, 660, 630, 600, 580, 570, 560, 560, 560,
  570, 580, 590, 610, 620, 630, 650, 660, 680, 690,
  710, 720, 730, 740, 750, 760, 770, 770, 780, 780,
  
  788, 782, 754, 697, 640, 602, 541, 410, 292, 182,
  161, 10, -102, -128, -269, -324, -364, -454, -471, -511,
  -540, -542, -520, -546, -546, -579, -563, -564, -580, -566,
  -587, -601, -619, -664, -644, -647, -609, -576, -466, -374,
  
  -272, -154, -2, 124, 264, 386, 537, 614, 775, 913,
  1046, 1153, 1336, 1465, 1601, 1720, 1824, 1906, 2025, 2095,
  2116, 2225, 2241, 2303, 2349, 2362, 2386, 2449, 2434, 2408,
  2402, 2400, 2387, 2395, 2386, 2393, 2373, 2392, 2396, 2402,
  
   2433, 2483, 2530, 2570, 2624, 2677, 2728, 2778, 2825, 2871,
   2915, 2957, 2997, 3036, 3072, 3107, 3135, 3168, 3218, 3268,
   3315, 3359, 3400, 3447, 3503, 3573, 3654, 3743, 3829, 3920,
   4018, 4117, 4223, 4337, 4449, 4548, 4646, 4752, 4853, 4959,
  
   5054, 5138, 5217, 5296, 5379, 5434, 5487, 5532, 5582, 5630,
   5686, 5757, 5831, 5912, 5998, 6078, 6163, 6230, 6297, 6347,
  
   6383, 6409, 6430, 6447, 6457, 6469,       
  
                                       6481, 6500, 6520, 6550,
   6600, 6650, 6700, 6750, 6800,
  // Add 50 empty elements, see constant TABSIZ_SPACE above!
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
  };
  
//C only://  private static final int TAB2_SIZ=43;
  private static final int TAB2_START=-500;
  private static final int TAB2_END=1600;
  private static short dt2[]=new short[] {
  
    16800,16000,15300,14600,14000,13400,12800,12200,11600,11100,
  
    10600,10100, 9600, 9100, 8600, 8200, 7700, 7200, 6700, 6200,
  
     5700, 5200, 4700, 4300, 3800, 3400, 3000, 2600, 2200, 1900,
  
     1600, 1350, 1100,  900,  750,  600,  470,  380,  300,  230,
  
      180,  140,  110,
  };
  
  private synchronized double calc_deltaT(double tjd) {
    double sdt = calc_deltaT(tjd, this.tid_acc);
    return sdt;
  }
  private static synchronized double calc_deltaT(double tjd, double tid_acc) {
    double ans = 0., ans2, ans3;
    double p, B=0., Y=0., dd; // To remove Java warning of "maybe" not initialized
    int d[]=new int[6];
    int i, iy, k;
    
    int tabsiz = init_dt();
    int tabend = TABSTART + tabsiz - 1;
    Y = 2000.0 + (tjd - SwephData.J2000)/365.25;
    
    if( Y < TAB2_START ) {
      B = (Y - 1735) * 0.01;
      ans = -20 + 35 * B * B;
      ans = adjust_for_tidacc(tid_acc, ans, Y);
      
      if (Y >= TAB2_START - 100) {
        
        ans2 = adjust_for_tidacc(tid_acc, dt2[0], TAB2_START);
        
        B = (TAB2_START - 1735) * 0.01;
        ans3 = -20 + 35 * B * B;
        ans3 = adjust_for_tidacc(tid_acc, ans3, Y);
        dd = ans3 - ans2;
        B = (Y - (TAB2_START - 100)) * 0.01;
        
        ans = ans - dd * B;
      }
    }
    
    if (Y >= TAB2_START && Y < TAB2_END) {
      p = Math.floor(Y);
      iy = (int) ((p - TAB2_START) / 50.0);
      dd = (Y - (TAB2_START + 50 * iy)) / 50.0;
      ans = dt2[iy] + (dt2[iy+1] - dt2[iy]) * dd;
      
      ans = adjust_for_tidacc(tid_acc, ans, Y);
    }
    
    if (Y >= TAB2_END && Y < TABSTART) { 
      B = TABSTART - TAB2_END;
      iy = (TAB2_END - TAB2_START) / 50;
      dd = (Y - TAB2_END) / B;
      ans = dt2[iy] + dd * (dt[0] / 100.0 - dt2[iy]);
      ans = adjust_for_tidacc(tid_acc, ans, Y);
    }
    
    if (Y >= TABSTART && Y <= tabend) {
      
      p = Math.floor(Y);
      iy = (int) (p - TABSTART);
      
      ans = dt[iy];
      k = iy + 1;
      if( k >= tabsiz )
        return deltatIsDone(ans, Y, B, tid_acc, tabsiz, tabend); 
      
      p = Y - p;
      
      ans += p*(dt[k] - dt[iy]);
      if( (iy-1 < 0) || (iy+2 >= tabsiz) )
        return deltatIsDone(ans, Y, B, tid_acc, tabsiz, tabend); 
      
      k = iy - 2;
      for( i=0; i<5; i++ ) {
        if( (k < 0) || (k+1 >= tabsiz) ) 
          d[i] = 0;
        else
          d[i] = dt[k+1] - dt[k];
        k += 1;
      }
      
      for( i=0; i<4; i++ )
        d[i] = d[i+1] - d[i];
      B = 0.25*p*(p-1.0);
      ans += B*(d[1] + d[2]);
      if( iy+2 >= tabsiz )
        return deltatIsDone(ans, Y, B, tid_acc, tabsiz, tabend);
      
      for( i=0; i<3; i++ )
        d[i] = d[i+1] - d[i];
      B = 2.0*B/3.0;
      ans += (p-0.5)*B*d[1];
      if( (iy-2 < 0) || (iy+3 > tabsiz) )
        return deltatIsDone(ans, Y, B, tid_acc, tabsiz, tabend);
      
      for( i=0; i<2; i++ )
        d[i] = d[i+1] - d[i];
      B = 0.125*B*(p+1.0)*(p-2.0);
      ans += B*(d[0] + d[1]);
    }
    return deltatIsDone(ans, Y, B, tid_acc, tabsiz, tabend);
  }
  private synchronized static double deltatIsDone(double ans, double Y,
                                                  double B, double tid_acc, int tabsiz, int tabend) {
    double ans2, ans3, B2, dd;
    if (Y >= TABSTART && Y <= tabend) {
      ans *= 0.01;
      ans = adjust_for_tidacc(tid_acc, ans, Y);
    }
    
    if (Y > tabend) {
      B = 0.01 * (Y - 1820);
      ans = -20 + 31 * B * B;
      
      if (Y <= tabend+100) {
        B2 = 0.01 * (tabend - 1820);
        ans2 = -20 + 31 * B2 * B2;
        ans3 = dt[tabsiz-1] * 0.01;
        dd = (ans2 - ans3);
        ans += dd * (Y - (tabend + 100)) * 0.01;
      }
    }
    return ans / 86400.0;
  }
  
  private static int init_dt() {
    FilePtr fp = null;
    int year;
    int tab_index;
    int tabsiz;
    int i;
    String s;
    if (!init_dt_done) {
      init_dt_done = true;
      
      try {
        if ((fp = sw.swi_fopen(-1, "sedeltat.txt", sw.swed.ephepath, null)) == null) {
          return TABSIZ;  // I think, I could miss this one...
        }
      } catch (SwissephException se) {
        return TABSIZ;
      }
      try {
        while ((s=fp.readLine()) != null) {
          s.trim();
          if (s.length() == 0 || s.charAt(0) == '#') {
            continue;
          }
          year = SwissLib.atoi(s);
          tab_index = year - TABSTART;
          
          if (tab_index >= TABSIZ_SPACE)
            continue;
          if (s.length() > 4) {
            s = s.substring(4).trim();
          }
          dt[tab_index] = (short)(SwissLib.atoi(s) * 100 + 0.5);
        }
      } catch (java.io.IOException e) {
      }
      try { fp.close(); } catch (java.io.IOException e) {}
    }
    
    tabsiz = 2001 - TABSTART + 1;
    for (i = tabsiz - 1; i < TABSIZ_SPACE; i++) {
      if (dt[i] == 0)
        break;
      else
        tabsiz++;
    }
    tabsiz--;
    return tabsiz;
  }
 
  
  private static double adjust_for_tidacc(double tid_acc_local, double ans, double Y) {
    double B;
    if( Y < 1955.0 ) {
      B = (Y - 1955.0);
      ans += -0.000091 * (tid_acc_local + 26.0) * B * B;
    }
    return ans;
  }
  
  private void initDateFromJD(double jd, boolean calType) {
    this.jd=jd;
    this.calType=calType;
    IDate dt=swe_revjul(jd, calType);
    this.year=dt.year;
    this.month=dt.month;
    this.day=dt.day;
    this.hour=dt.hour;
  }
  
  private void setFields(int year, int month, int day, double hour) {
    // Get year, month, day of jdCO and compare to given date to
    // find out about the calendar system:
    IDate dt=swe_revjul(jdCO,SE_GREG_CAL);
    boolean calType = SE_GREG_CAL;
    if (dt.year > year ||
        (dt.year == year && dt.month > month) ||
        (dt.year == year && dt.month == month && dt.day > day)) {
      calType = SE_JUL_CAL;
    }
    setFields(year, month, day, hour, calType);
  }
  
  private void setFields(int year, int month, int day, double hour,
        boolean calType) {
    this.year=year;
    this.month=month;
    this.day=day;
    this.hour=hour;
    this.calType=calType;
    this.jd=swe_julday(year, month, day, hour, calType);
  }
} // end of class SweDate
class IDate {
  public int year;
  public int month;
  public int day;
  public double hour;
}
class SweHouse {
  static final double MILLIARCSEC=1.0 / 3600000.0;
  SwissLib sl=null;
  SwissEph sw=null;
  SwissData swed=null;
  
  SweHouse() {
    sl   = new SwissLib();
    sw   = new SwissEph();
    swed = new SwissData();
  }
  
  SweHouse(SwissLib sl, SwissEph sw, SwissData swed) {
    this.sl   = sl;
    this.sw   = sw;
    this.swed = swed;
    if (this.sl   ==null) { this.sl   =new SwissLib(); }
    if (this.sw   ==null) { this.sw   =new SwissEph(); }
    if (this.swed ==null) { this.swed =new SwissData(); }
  }
  static final double VERY_SMALL=1E-10;
  private double sind(double x) {
    return Math.sin(x * SwissData.DEGTORAD);
  }
  private double cosd(double x) {
    return Math.cos(x * SwissData.DEGTORAD);
  }
  private double tand(double x) {
    return Math.tan(x * SwissData.DEGTORAD);
  }
  private double asind(double x) {
    return (Math.asin(x) * SwissData.RADTODEG);
  }
  private double atand(double x) {
    return (Math.atan(x) * SwissData.RADTODEG);
  }
  
  
  int swe_houses(double tjd_ut,
                 int iflag,
                 double geolat,
                 double geolon,
                 int hsys,
                 double[] cusp,
                 double[] ascmc) {
    return swe_houses(tjd_ut, iflag, geolat, geolon, hsys, cusp, ascmc, 0);
  }
  int swe_houses(double tjd_ut,
                 int iflag,
                 double geolat,
                 double geolon,
                 int hsys,
                 double[] cusp,
                 double[] ascmc,
                 int aOffs) {
    int i, retc = 0;
    double armc, eps_mean, nutlo[]=new double[2];
    double tjde = tjd_ut + SweDate.getDeltaT(tjd_ut);
    SidData sip = swed.sidd;
    int ito;
    if (Character.toUpperCase((char)hsys) == 'G') {
      ito = 36;
    } else {
      ito = 12;
    }
    if ((iflag & SweConst.SEFLG_SIDEREAL)!=0 && !swed.ayana_is_set) {
      sw.swe_set_sid_mode(SweConst.SE_SIDM_FAGAN_BRADLEY, 0, 0);
    }
    eps_mean = sl.swi_epsiln(tjde) * SwissData.RADTODEG;
    sl.swi_nutation(tjde, nutlo);
    for (i = 0; i < 2; i++)
      nutlo[i] *= SwissData.RADTODEG;
      
    armc = sl.swe_degnorm(sl.swe_sidtime0(tjd_ut, eps_mean + nutlo[1], nutlo[0]) * 15 + geolon);
    if ((iflag & SweConst.SEFLG_SIDEREAL)!=0) {
      if ((sip.sid_mode & SweConst.SE_SIDBIT_ECL_T0)!=0) {
        retc = sidereal_houses_ecl_t0(tjde, armc, eps_mean + nutlo[1], nutlo, geolat, hsys, cusp, ascmc, aOffs);
      } else if ((sip.sid_mode & SweConst.SE_SIDBIT_SSY_PLANE)!=0) {
        retc = sidereal_houses_ssypl(tjde, armc, eps_mean + nutlo[1], nutlo, geolat, hsys, cusp, ascmc, aOffs);
      } else {
        retc = sidereal_houses_trad(tjde, armc, eps_mean + nutlo[1], nutlo[0], geolat, hsys, cusp, ascmc, aOffs);
      }
    } else {
      retc = swe_houses_armc(armc, geolat, eps_mean + nutlo[1], hsys, cusp, ascmc, aOffs);
    }
    if ((iflag & SweConst.SEFLG_RADIANS)!=0) {
      for (i = 1; i <= ito; i++)
        cusp[i] *= SwissData.DEGTORAD;
      for (i = 0; i < SweConst.SE_NASCMC; i++)
        ascmc[i+aOffs] *= SwissData.DEGTORAD;
    }
    return retc;
  }
  
  private int sidereal_houses_ecl_t0(double tjde,
                                     double armc,
                                     double eps,
                                     double[] nutlo,
                                     double lat,
                                     int hsys,
                                     double[] cusp,
                                     double[] ascmc,
                                     int aOffs) {
    int i, j, retc = SweConst.OK;
    double x[]=new double[6], xvpx[]=new double[6], x2[]=new double[6], epst0,
           xnorm[]=new double[6];
    double rxy, rxyz, c2, epsx, sgn, fac, dvpx, dvpxe;
    double armcx;
    SidData sip = swed.sidd;
    int ito;
    if (Character.toUpperCase((char)hsys) == 'G') {
      ito = 36;
    } else {
      ito = 12;
    }
    
    epst0 = sl.swi_epsiln(sip.t0);
    
    x[0] = x[4] = 1;
    x[1] = x[2] = x[3] = x[5] = 0;
    
    sl.swi_coortrf(x, x, -epst0);
    sl.swi_coortrf(x, 3, x, 3, -epst0);
    
    sl.swi_precess(x, sip.t0, SwephData.J_TO_J2000);
    sl.swi_precess(x, tjde, SwephData.J2000_TO_J);
    sl.swi_precess(x, 3, sip.t0, SwephData.J_TO_J2000);
    sl.swi_precess(x, 3, tjde, SwephData.J2000_TO_J);
    
    sl.swi_coortrf(x, x, (eps - nutlo[1]) * SwissData.DEGTORAD);
    sl.swi_coortrf(x, 3, x, 3, (eps - nutlo[1]) * SwissData.DEGTORAD);
    sl.swi_cartpol_sp(x, 0, x, 0);
    x[0] += nutlo[0] * SwissData.DEGTORAD;
    sl.swi_polcart_sp(x, x);
    sl.swi_coortrf(x, x, -eps * SwissData.DEGTORAD);
    sl.swi_coortrf(x, 3, x, 3, -eps * SwissData.DEGTORAD);
    
    sl.swi_cross_prod(x, 0, x, 3, xnorm, 0);
    rxy =  xnorm[0] * xnorm[0] + xnorm[1] * xnorm[1];
    c2 = (rxy + xnorm[2] * xnorm[2]);
    rxyz = Math.sqrt(c2);
    rxy = Math.sqrt(rxy);
    epsx = Math.asin(rxy / rxyz) * SwissData.RADTODEG;           
    
    if (Math.abs(x[5]) < 1e-15) {
      x[5] = 1e-15;
    }
    fac = x[2] / x[5];
    sgn = x[5] / Math.abs(x[5]);
    for (j = 0; j <= 2; j++)
      xvpx[j] = (x[j] - fac * x[j+3]) * sgn;      
    
    sl.swi_cartpol(xvpx, x2);
    dvpx = x2[0] * SwissData.RADTODEG;                      
    
    armcx = sl.swe_degnorm(armc - dvpx);        
    
    retc = swe_houses_armc(armcx, lat, epsx, hsys, cusp, ascmc, aOffs);  
    
    dvpxe = Math.acos(sl.swi_dot_prod_unit(x, xvpx)) * SwissData.RADTODEG;  
    if (tjde < sip.t0) {
      dvpxe = -dvpxe;
    }
    for (i = 1; i <= ito; i++)                     
      cusp[i] = sl.swe_degnorm(cusp[i] - dvpxe - sip.ayan_t0);
    for (i = 0; i <= SweConst.SE_NASCMC; i++)
      ascmc[aOffs+i] = sl.swe_degnorm(ascmc[aOffs+i] - dvpxe - sip.ayan_t0);
    return retc;
  }
  
  private int sidereal_houses_ssypl(double tjde,
                                    double armc,
                                    double eps,
                                    double[] nutlo,
                                    double lat,
                                    int hsys,
                                    double[] cusp,
                                    double[] ascmc,
                                    int aOffs) {
    int i, j, retc = SweConst.OK;
    double x[]=new double[6], x0[]=new double[6], xvpx[]=new double[6],
           x2[]=new double[6], epst0, xnorm[]=new double[6];
    double rxy, rxyz, c2, epsx, eps2000, sgn, fac, dvpx, dvpxe, x00;
    double armcx;
    SidData sip = swed.sidd;
    int ito;
    if (Character.toUpperCase((char)hsys) == 'G') {
      ito = 36;
    } else {
      ito = 12;
    }
    
    epst0 = sl.swi_epsiln(sip.t0);
    eps2000 = sl.swi_epsiln(SwephData.J2000);
    
    x[0] = x[4] = 1;
    x[1] = x[2] = x[3] = x[5] = 0;
    
    sl.swi_coortrf(x, x, -SwephData.SSY_PLANE_INCL);
    sl.swi_coortrf(x, 3, x, 3, -SwephData.SSY_PLANE_INCL);
    sl.swi_cartpol_sp(x, 0, x, 0);
    x[0] += SwephData.SSY_PLANE_NODE_E2000;
    sl.swi_polcart_sp(x, x);
    
    sl.swi_coortrf(x, x, -eps2000);
    sl.swi_coortrf(x, 3, x, 3, -eps2000);
    
    sl.swi_precess(x, tjde, SwephData.J2000_TO_J);
    sl.swi_precess(x, 3, tjde, SwephData.J2000_TO_J);
    
    sl.swi_coortrf(x, x, (eps - nutlo[1]) * SwissData.DEGTORAD);
    sl.swi_coortrf(x, 3, x, 3, (eps - nutlo[1]) * SwissData.DEGTORAD);
    sl.swi_cartpol_sp(x, 0, x, 0);
    x[0] += nutlo[0] * SwissData.DEGTORAD;
    sl.swi_polcart_sp(x, x);
    sl.swi_coortrf(x, x, -eps * SwissData.DEGTORAD);
    sl.swi_coortrf(x, 3, x, 3, -eps * SwissData.DEGTORAD);
    
    sl.swi_cross_prod(x, 0, x, 3, xnorm, 0);
    rxy =  xnorm[0] * xnorm[0] + xnorm[1] * xnorm[1];
    c2 = (rxy + xnorm[2] * xnorm[2]);
    rxyz = Math.sqrt(c2);
    rxy = Math.sqrt(rxy);
    epsx = Math.asin(rxy / rxyz) * SwissData.RADTODEG;           
    
    if (Math.abs(x[5]) < 1e-15) {
      x[5] = 1e-15;
    }
    fac = x[2] / x[5];
    sgn = x[5] / Math.abs(x[5]);
    for (j = 0; j <= 2; j++)
      xvpx[j] = (x[j] - fac * x[j+3]) * sgn;      
    
    sl.swi_cartpol(xvpx, x2);
    dvpx = x2[0] * SwissData.RADTODEG;                      
    
    armcx = sl.swe_degnorm(armc - dvpx);        
    
    retc = swe_houses_armc(armcx, lat, epsx, hsys, cusp, ascmc, aOffs);  
    
    dvpxe = Math.acos(sl.swi_dot_prod_unit(x, xvpx)) * SwissData.RADTODEG;  
                  
    dvpxe -= SwephData.SSY_PLANE_NODE * SwissData.RADTODEG;
    
    
    x0[0] = 1;
    x0[1] = x0[2] = 0;
    
    if (sip.t0 != SwephData.J2000) {
      sl.swi_precess(x0, sip.t0, SwephData.J_TO_J2000);
    }
    
    sl.swi_coortrf(x0, x0, eps2000);
    
    sl.swi_cartpol(x0, x0);
    x0[0] -= SwephData.SSY_PLANE_NODE_E2000;
    sl.swi_polcart(x0, x0);
    sl.swi_coortrf(x0, x0, SwephData.SSY_PLANE_INCL);
    sl.swi_cartpol(x0, x0);
    x0[0] += SwephData.SSY_PLANE_NODE;
    x00 = x0[0] * SwissData.RADTODEG;                       
    for (i = 1; i <= ito; i++)                     
      cusp[i] = sl.swe_degnorm(cusp[i] - dvpxe - sip.ayan_t0 - x00);
    for (i = 0; i <= SweConst.SE_NASCMC; i++)
      ascmc[aOffs+i] = sl.swe_degnorm(ascmc[aOffs+i] - dvpxe - sip.ayan_t0 - x00);
    return retc;
  }
  
  private int sidereal_houses_trad(double tjde,
                                   double armc,
                                   double eps,
                                   double nutl,
                                   double lat,
                                   int hsys,
                                   double[] cusp,
                                   double[] ascmc,
                                   int aOffs) {
    int i, retc = SweConst.OK;
    double ay;
    int ito;
    if (Character.toUpperCase((char)hsys) == 'G') {
      ito = 36;
    } else {
      ito = 12;
    }
    retc = swe_houses_armc(armc, lat, eps, hsys, cusp, ascmc, aOffs);
    ay = sw.swe_get_ayanamsa(tjde);
    for (i = 1; i <= ito; i++)
      cusp[i] = sl.swe_degnorm(cusp[i] - ay - nutl);
    for (i = 0; i < SweConst.SE_NASCMC; i++) {
      if (i == 2)  {
        continue;
      }
      ascmc[aOffs+i] = sl.swe_degnorm(ascmc[aOffs+i] - ay - nutl);
    }
    return retc;
  }
  
  
  int swe_houses_armc(double armc,
                      double geolat,
                      double eps,
                      int hsys,
                      double cusp[],
                      double ascmc[],
                      int aOffs) {
    Houses h=new Houses();
    int i, retc = 0;
    int ito;
    if (Character.toUpperCase((char)hsys) == 'G') {
      ito = 36;
    } else {
      ito = 12;
    }
    armc = sl.swe_degnorm(armc);
    retc = CalcH(armc,
                 geolat,
                 eps,
                 (char)hsys, 2, h);
    cusp[0] = 0;
    for (i = 1; i <= ito; i++) {
      cusp[i] = h.cusp[i];
    }
    ascmc[aOffs+0] = h.ac;        
    ascmc[aOffs+1] = h.mc;        
    ascmc[aOffs+2] = armc;
    ascmc[aOffs+3] = h.vertex;
    ascmc[aOffs+4] = h.equasc;
    ascmc[aOffs+5] = h.coasc1;  
    ascmc[aOffs+6] = h.coasc2;  
    ascmc[aOffs+7] = h.polasc;  
    for (i = SweConst.SE_NASCMC; i < 10; i++)
      ascmc[aOffs+i] = 0;
    return retc;
  }
  private int CalcH(double th, double fi, double ekl, char hsy,
                    int iteration_count, Houses hsp )
  
  {
    double tane, tanfi, cosfi, tant, sina, cosa, th2;
    double a, c, f, fh1, fh2, xh1, xh2, rectasc, ad3, acmc, vemc;
    int i, ih, ih2, retc = SweConst.OK;
    double sine, cose;
    double x[] = new double[3], krHorizonLon; 
    cose  = cosd(ekl);
    sine  = sind(ekl);
    tane  = tand(ekl);
    
    if (Math.abs(Math.abs(fi) - 90) < VERY_SMALL) {
      if (fi < 0) {
        fi = -90 + VERY_SMALL;
      } else {
        fi = 90 - VERY_SMALL;
      }
    }
    tanfi = tand(fi);
    
    if (Math.abs(th - 90) > VERY_SMALL
      && Math.abs(th - 270) > VERY_SMALL) {
      tant = tand(th);
      hsp.mc = atand(tant / cose);
      if (th > 90 && th <= 270) {
        hsp.mc = sl.swe_degnorm(hsp.mc + 180);
      }
    } else {
      if (Math.abs(th - 90) <= VERY_SMALL) {
        hsp.mc = 90;
      } else {
        hsp.mc = 270;
      }
    } 
    hsp.mc = sl.swe_degnorm(hsp.mc);
    
    hsp.ac = Asc1 (th + 90, fi, sine, cose);
    hsp.cusp[1] = hsp.ac;
    hsp.cusp[10] = hsp.mc;
    hsy=Character.toUpperCase(hsy);
    switch (hsy) {
      case (int)'A':   
      case (int)'E':
        
        acmc = sl.swe_difdeg2n(hsp.ac, hsp.mc);
        if (acmc < 0) {
          hsp.ac = sl.swe_degnorm(hsp.ac + 180);
          hsp.cusp[1] = hsp.ac;
        }
        for (i = 2; i <=12; i++)
          hsp.cusp [i] = sl.swe_degnorm(hsp.cusp [1] + (i-1) * 30);
        break;
      case 'C': 
      case 'H':
        if (hsy == 'H') {
          if (fi > 0) {
            fi = 90 - fi;
          } else {
            fi = -90 - fi;
          }
          
          if (Math.abs(Math.abs(fi) - 90) < VERY_SMALL) {
            if (fi < 0) {
              fi = -90 + VERY_SMALL;
            } else {
              fi = 90 - VERY_SMALL;
            }
          }
          th = sl.swe_degnorm(th + 180);
        }
        fh1 = asind(sind (fi) / 2);
        fh2 = asind(Math.sqrt (3.0) / 2 * sind(fi));
        cosfi = cosd(fi);
        if (Math.abs(cosfi) == 0) {        
          if (fi > 0) {
            xh1 = xh2 = 90; 
          } else {
            xh1 = xh2 = 270; 
          }
        } else {
          xh1 = atand(Math.sqrt (3.0) / cosfi);
          xh2 = atand(1 / Math.sqrt (3.0) / cosfi);
        }
        hsp.cusp [11] = Asc1 (th + 90 - xh1, fh1, sine, cose);
        hsp.cusp [12] = Asc1 (th + 90 - xh2, fh2, sine, cose);
        if (hsy == 'H') {
          hsp.cusp [1] = Asc1 (th + 90, fi, sine, cose);
        }
        hsp.cusp [2] = Asc1 (th + 90 + xh2, fh2, sine, cose);
        hsp.cusp [3] = Asc1 (th + 90 + xh1, fh1, sine, cose);
        
        if (Math.abs(fi) >= 90 - ekl) {  
          acmc = sl.swe_difdeg2n(hsp.ac, hsp.mc);
          if (acmc < 0) {
            hsp.ac = sl.swe_degnorm(hsp.ac + 180);
            hsp.mc = sl.swe_degnorm(hsp.mc + 180);
            for (i = 1; i <= 12; i++)
              hsp.cusp[i] = sl.swe_degnorm(hsp.cusp[i] + 180);
          }
        }
        if (hsy == 'H') {
          for (i = 1; i <= 3; i++)
            hsp.cusp[i] = sl.swe_degnorm(hsp.cusp[i] + 180);
          for (i = 11; i <= 12; i++)
            hsp.cusp[i] = sl.swe_degnorm(hsp.cusp[i] + 180);
          
          if (fi > 0) {
            fi = 90 - fi;
          } else {
            fi = -90 - fi;
          }
          th = sl.swe_degnorm(th + 180);
        }
        break;
      case (int)'K': 
        if (Math.abs(fi) >= 90 - ekl) {  
          retc = SweConst.ERR;
          makePorphyry(hsp);
          break;
        }
        sina = sind(hsp.mc) * sine / cosd(fi);      
        cosa = Math.sqrt(1 - sina * sina);          
        c = atand(tanfi / cosa);
        ad3 = asind(sind(c) * sina) / 3.0;
        hsp.cusp [11] = Asc1 (th + 30 - 2 * ad3, fi, sine, cose);
        hsp.cusp [12] = Asc1 (th + 60 - ad3, fi, sine, cose);
        hsp.cusp [2] = Asc1 (th + 120 + ad3, fi, sine, cose);
        hsp.cusp [3] = Asc1 (th + 150 + 2 * ad3, fi, sine, cose);
        break;
      case (int)'O':   
//porphyry:
        makePorphyry(hsp);
        break;
      case (int)'R':   
        fh1 = atand (tanfi * 0.5);
        fh2 = atand (tanfi * cosd(30));
        hsp.cusp [11] =  Asc1 (30 + th, fh1, sine, cose);
        hsp.cusp [12] =  Asc1 (60 + th, fh2, sine, cose);
        hsp.cusp [2] =  Asc1 (120 + th, fh2, sine, cose);
        hsp.cusp [3] =  Asc1 (150 + th, fh1, sine, cose);
        
        if (Math.abs(fi) >= 90 - ekl) {  
          acmc = sl.swe_difdeg2n(hsp.ac, hsp.mc);
          if (acmc < 0) {
            hsp.ac = sl.swe_degnorm(hsp.ac + 180);
            hsp.mc = sl.swe_degnorm(hsp.mc + 180);
            for (i = 1; i <= 12; i++)
              hsp.cusp[i] = sl.swe_degnorm(hsp.cusp[i] + 180);
          }
        }
        break;
      case (int)'T':   
        fh1 = atand (tanfi / 3.0);
        fh2 = atand (tanfi * 2.0 / 3.0);
        hsp.cusp [11] =  Asc1 (30 + th, fh1, sine, cose);
        hsp.cusp [12] =  Asc1 (60 + th, fh2, sine, cose);
        hsp.cusp [2] =  Asc1 (120 + th, fh2, sine, cose);
        hsp.cusp [3] =  Asc1 (150 + th, fh1, sine, cose);
        
        if (Math.abs(fi) >= 90 - ekl) {  
          acmc = sl.swe_difdeg2n(hsp.ac, hsp.mc);
          if (acmc < 0) {
            hsp.ac = sl.swe_degnorm(hsp.ac + 180);
            hsp.mc = sl.swe_degnorm(hsp.mc + 180);
            for (i = 1; i <= 12; i++)
              hsp.cusp[i] = sl.swe_degnorm(hsp.cusp[i] + 180);
          }
        }
        break;
      case 'V':   
        
        acmc = sl.swe_difdeg2n(hsp.ac, hsp.mc);
        if (acmc < 0) {
          hsp.ac = sl.swe_degnorm(hsp.ac + 180);
          hsp.cusp[1] = hsp.ac;
        }
        hsp.cusp [1] = sl.swe_degnorm(hsp.ac - 15);
        for (i = 2; i <=12; i++)
          hsp.cusp [i] = sl.swe_degnorm(hsp.cusp [1] + (i-1) * 30);
        break;
      case (int)'X': {
        
        int j;
        double a2 = th;
        for (i = 1; i <= 12; i++) {
          j = i + 10;
          if (j > 12) {
            j -= 12;
          }
          a2 = sl.swe_degnorm(a2 + 30);
          if (Math.abs(a2 - 90) > VERY_SMALL
            && Math.abs(a2 - 270) > VERY_SMALL) {
            tant = tand(a2);
            hsp.cusp[j] = atand(tant / cose);
            if (a2 > 90 && a2 <= 270) {
              hsp.cusp[j] = sl.swe_degnorm(hsp.cusp[j] + 180);
            }
          } else {
            if (Math.abs(a2 - 90) <= VERY_SMALL) {
              hsp.cusp[j] = 90;
            } else {
              hsp.cusp[j] = 270;
            }
          } 
          hsp.cusp[j] = sl.swe_degnorm(hsp.cusp[j]);
        }
        break;
        }
      case (int)'M': {
        
        int j;
        double am = th;
        double xm[] = new double[3];
        for (i = 1; i <= 12; i++) {
          j = i + 10;
          if (j > 12) j -= 12;
          am = sl.swe_degnorm(am + 30);
          xm[0] = am;
          xm[1] = 0;
          sl.swe_cotrans(xm, 0, xm, 0, ekl);
          hsp.cusp[j] = xm[0];
        }
        break;
        }
      case (int)'B': { 
        
        double dek, r, sna, sda, sn3, sd3;
        acmc = sl.swe_difdeg2n(hsp.ac, hsp.mc);
        if (acmc < 0) {
          hsp.ac = sl.swe_degnorm(hsp.ac + 180);
          hsp.cusp[1] = hsp.ac;
          acmc = sl.swe_difdeg2n(hsp.ac, hsp.mc);
        }
        dek = asind(sind(hsp.ac) * sine);        
        
        r = -tanfi * tand(dek);
        
        sda = Math.acos(r) * SwissData.RADTODEG; 
        sna = 180 - sda;          
        sd3 = sda / 3;
        sn3 = sna / 3;
        rectasc = sl.swe_degnorm(th + sd3);            
        
        hsp.cusp [11] = Asc1 (rectasc, 0, sine, cose);
        rectasc = sl.swe_degnorm(th + 2 * sd3);        
        hsp.cusp [12] = Asc1 (rectasc, 0, sine, cose);
        rectasc = sl.swe_degnorm(th + 180 - 2 * sn3);  
        hsp.cusp [2] = Asc1 (rectasc, 0, sine, cose);
        rectasc = sl.swe_degnorm(th + 180 -  sn3);     
        hsp.cusp [3] = Asc1 (rectasc, 0, sine, cose);
        }
        break;
      case (int)'G': {   
        for (i = 1; i <= 36; i++) {
          hsp.cusp[i] = 0;
        }
        if (Math.abs(fi) >= 90 - ekl) {  
          retc = SweConst.ERR;
          // goto porphyry;
          makePorphyry(hsp);
        }
        
        
        a = asind(tand(fi) * tane);
        for (ih = 2; ih <= 9; ih++) {
          ih2 = 10 - ih;
          fh1 = atand(sind(a * ih2 / 9) / tane);
          rectasc = sl.swe_degnorm((90 / 9) * ih2 + th);
          tant = tand(asind(sine * sind(Asc1 (rectasc, fh1, sine, cose))));
          if (Math.abs(tant) < VERY_SMALL) {
            hsp.cusp[ih] = rectasc;
          } else {
            
            f = atand(sind(asind(tanfi * tant) * ih2 / 9)  /tant);
            hsp.cusp [ih] = Asc1 (rectasc, f, sine, cose);
            for (i = 1; i <= iteration_count; i++) {
            tant = tand(asind(sine * sind(hsp.cusp[ih])));
            if (Math.abs(tant) < VERY_SMALL) {
              hsp.cusp[ih] = rectasc;
              break;
            }
            
            f = atand(sind(asind(tanfi * tant) * ih2 / 9) / tant);
            hsp.cusp[ih] = Asc1 (rectasc, f, sine, cose);
            }
          }
          hsp.cusp[ih+18] = sl.swe_degnorm(hsp.cusp[ih] + 180);
        }
        
        for (ih = 29; ih <= 36; ih++) {
          ih2 = ih - 28;
          fh1 = atand(sind(a * ih2 / 9) / tane);
          rectasc = sl.swe_degnorm(180 - ih2 * 90 / 9 + th);
          tant = tand(asind(sine * sind(Asc1 (rectasc, fh1, sine, cose))));
          if (Math.abs(tant) < VERY_SMALL) {
            hsp.cusp[ih] = rectasc;
          } else {
            f = atand(sind(asind(tanfi * tant) * ih2 / 9) / tant);
            
            hsp.cusp[ih] = Asc1 (rectasc, f, sine, cose);
            for (i = 1; i <= iteration_count; i++) {
            tant = tand(asind(sine * sind(hsp.cusp[ih])));
            if (Math.abs(tant) < VERY_SMALL) {
              hsp.cusp[ih] = rectasc;
              break;
            }
            f = atand(sind(asind(tanfi * tant) * ih2 / 9) / tant);
            
            hsp.cusp[ih] = Asc1 (rectasc, f, sine, cose);
            }
          }
          hsp.cusp[ih-18] = sl.swe_degnorm(hsp.cusp[ih] + 180);
        }
        hsp.cusp[1] = hsp.ac;
        hsp.cusp[10] = hsp.mc;
        hsp.cusp[19] = sl.swe_degnorm(hsp.ac + 180);
        hsp.cusp[28] = sl.swe_degnorm(hsp.mc + 180);
        break;
        }
      case 'U': 
        
        
        acmc = sl.swe_difdeg2n(hsp.ac, hsp.mc);
        if (acmc < 0) {
          hsp.ac = sl.swe_degnorm(hsp.ac + 180);
        }
        
        x[0] = hsp.ac; 
        x[1] = 0.0;     
        x[2] = 1.0;     
        sl.swe_cotrans(x, x, -ekl);      
        x[0] = x[0] - (th-90);        
        sl.swe_cotrans(x, x, -(90-fi));  
        krHorizonLon = x[0];          
        x[0] = x[0] - x[0];           
        sl.swe_cotrans(x, x, -90);       
        
        for(i = 0; i < 6; i++) {
          
          x[0] = 30.0*i;
          x[1] = 0.0;
          sl.swe_cotrans(x, x, 90);                 
          x[0] = x[0] + krHorizonLon;            
          sl.swe_cotrans(x, x, 90-fi);              
          x[0] = sl.swe_degnorm(x[0] + (th-90));    
          
          
          hsp.cusp[i+1] = atand(tand(x[0])/cosd(ekl));
          if (x[0] > 90 && x[0] <= 270)
            hsp.cusp[i+1] = sl.swe_degnorm(hsp.cusp[i+1] + 180);
          hsp.cusp[i+1] = sl.swe_degnorm(hsp.cusp[i+1]);
          hsp.cusp[i+7] = sl.swe_degnorm(hsp.cusp[i+1]+180);
        }
        break;
      default:    
        if (hsy != 'P') {
          System.err.println("swe_houses: make Placidus, unknown key "+hsy);
        }
        if (Math.abs(fi) >= 90 - ekl) {  
          retc = SweConst.ERR;
          makePorphyry(hsp);
          break;
        }
        a = asind(tand(fi) * tane);
        fh1 = atand(sind(a / 3) / tane);
        fh2 = atand(sind(a * 2 / 3) / tane);
        
        rectasc = sl.swe_degnorm(30 + th);
        tant = tand(asind(sine * sind(Asc1 (rectasc, fh1, sine, cose))));
        if (Math.abs(tant) < VERY_SMALL) {
          hsp.cusp [11] = rectasc;
        } else {
          
          f = atand(sind(asind(tanfi * tant) / 3)  /tant);
          hsp.cusp [11] = Asc1 (rectasc, f, sine, cose);
          for (i = 1; i <= iteration_count; i++) {
            tant = tand(asind(sine * sind(hsp.cusp [11])));
            if (Math.abs(tant) < VERY_SMALL) {
              hsp.cusp [11] = rectasc;
              break;
            }
            
            f = atand(sind(asind(tanfi * tant) / 3) / tant);
            hsp.cusp [11] = Asc1 (rectasc, f, sine, cose);
          }
        }
        
        rectasc = sl.swe_degnorm(60 + th);
        tant = tand(asind(sine*sind(Asc1 (rectasc,  fh2, sine, cose))));
        if (Math.abs(tant) < VERY_SMALL) {
          hsp.cusp [12] = rectasc;
        } else {
          f = atand(sind(asind(tanfi * tant) / 1.5) / tant);
          
          hsp.cusp [12] = Asc1 (rectasc, f, sine, cose);
          for (i = 1; i <= iteration_count; i++) {
            tant = tand(asind(sine * sind(hsp.cusp [12])));
            if (Math.abs(tant) < VERY_SMALL) {
              hsp.cusp [12] = rectasc;
              break;
            }
            f = atand(sind(asind(tanfi * tant) / 1.5) / tant);
            
            hsp.cusp [12] = Asc1 (rectasc, f, sine, cose);
          }
        }
        
        rectasc = sl.swe_degnorm(120 + th);
        tant = tand(asind(sine * sind(Asc1 (rectasc, fh2, sine, cose))));
        if (Math.abs(tant) < VERY_SMALL) {
          hsp.cusp [2] = rectasc;
        } else {
          f = atand(sind(asind(tanfi * tant) / 1.5) / tant);
          
          hsp.cusp [2] = Asc1 (rectasc, f, sine, cose);
          for (i = 1; i <= iteration_count; i++) {
            tant = tand(asind(sine * sind(hsp.cusp [2])));
            if (Math.abs(tant) < VERY_SMALL) {
              hsp.cusp [2] = rectasc;
              break;
            }
            f = atand(sind(asind(tanfi * tant) / 1.5) / tant);
            
            hsp.cusp [2] = Asc1 (rectasc, f, sine, cose);
          }
        }
        
        rectasc = sl.swe_degnorm(150 + th);
        tant = tand(asind(sine * sind(Asc1 (rectasc, fh1, sine, cose))));
        if (Math.abs(tant) < VERY_SMALL) {
          hsp.cusp [3] = rectasc;
        } else {
          f = atand(sind(asind(tanfi * tant) / 3) / tant);
          
          hsp.cusp [3] = Asc1(rectasc, f, sine, cose);
          for (i = 1; i <= iteration_count; i++) {
            tant = tand(asind(sine * sind(hsp.cusp [3])));
            if (Math.abs(tant) < VERY_SMALL) {
              hsp.cusp [3] = rectasc;
              break;
            }
            f = atand(sind(asind(tanfi * tant) / 3) / tant);
            
            hsp.cusp [3] = Asc1 (rectasc, f, sine, cose);
          }
        }
        break;
    } 
    if (hsy != 'G') {
      hsp.cusp [4] = sl.swe_degnorm(hsp.cusp [10] + 180);
      hsp.cusp [5] = sl.swe_degnorm(hsp.cusp [11] + 180);
      hsp.cusp [6] = sl.swe_degnorm(hsp.cusp [12] + 180);
      hsp.cusp [7] = sl.swe_degnorm(hsp.cusp [1] + 180);
      hsp.cusp [8] = sl.swe_degnorm(hsp.cusp [2] + 180);
      hsp.cusp [9] = sl.swe_degnorm(hsp.cusp [3] + 180);
    }
    
    if (fi >= 0) {
      f = 90 - fi;
    } else {
      f = -90 - fi;
    }
    hsp.vertex = Asc1 (th - 90, f, sine, cose);
    
    if (Math.abs(fi) <= ekl) {
      vemc = sl.swe_difdeg2n(hsp.vertex, hsp.mc);
      if (vemc > 0) {
        hsp.vertex = sl.swe_degnorm(hsp.vertex + 180);
      }
    }
    
    
    th2 = sl.swe_degnorm(th + 90);
    if (Math.abs(th2 - 90) > VERY_SMALL
      && Math.abs(th2 - 270) > VERY_SMALL) {
      tant = tand(th2);
      hsp.equasc = atand(tant / cose);
      if (th2 > 90 && th2 <= 270) {
        hsp.equasc = sl.swe_degnorm(hsp.equasc + 180);
      }
    } else {
      if (Math.abs(th2 - 90) <= VERY_SMALL) {
        hsp.equasc = 90;
      } else {
        hsp.equasc = 270;
      }
    } 
    hsp.equasc = sl.swe_degnorm(hsp.equasc);
    
    hsp.coasc1 = sl.swe_degnorm(Asc1 (th - 90, fi, sine, cose) + 180);
    
    if (fi >= 0) {
      hsp.coasc2 = Asc1 (th + 90, 90 - fi, sine, cose);
    } else  {
      hsp.coasc2 = Asc1 (th + 90, -90 - fi, sine, cose);
    }
    
    hsp.polasc = Asc1 (th - 90, fi, sine, cose);
    return retc;
  } 
  
  private void makePorphyry(Houses hsp) {
    
    double acmc = sl.swe_difdeg2n(hsp.ac, hsp.mc);
    if (acmc < 0) {
      hsp.ac = sl.swe_degnorm(hsp.ac + 180);
      hsp.cusp[1] = hsp.ac;
      acmc = sl.swe_difdeg2n(hsp.ac, hsp.mc);
    }
    hsp.cusp [2] = sl.swe_degnorm(hsp.ac + (180 - acmc) / 3);
    hsp.cusp [3] = sl.swe_degnorm(hsp.ac + (180 - acmc) / 3 * 2);
    hsp.cusp [11] = sl.swe_degnorm(hsp.mc + acmc / 3);
    hsp.cusp [12] = sl.swe_degnorm(hsp.mc + acmc / 3 * 2);
  }
  
  private double Asc1 (double x1, double f, double sine, double cose) {
    int n;
    double ass;
    x1 = sl.swe_degnorm(x1);
    n  = (int) ((x1 / 90) + 1);
    if (n == 1) {
      ass = ( Asc2 (x1, f, sine, cose));
    } else if (n == 2) {
      ass = (180 - Asc2 (180 - x1, - f, sine, cose));
    } else if (n == 3) {
      ass = (180 + Asc2 (x1 - 180, - f, sine, cose));
    } else {
      ass = (360 - Asc2 (360- x1,  f, sine, cose));
    }
    ass = sl.swe_degnorm(ass);
    if (Math.abs(ass - 90) < VERY_SMALL)         {
      ass = 90;                           
    }
    if (Math.abs(ass - 180) < VERY_SMALL) {
      ass = 180;
    }
    if (Math.abs(ass - 270) < VERY_SMALL)         {
      ass = 270;                          
    }
    if (Math.abs(ass - 360) < VERY_SMALL) {
      ass = 0;
    }
    return ass;
  }  
  private double Asc2 (double x, double f, double sine, double cose) {
    int n;
    double ass, sinx;
    ass = - tand(f) * sine + cose * cosd(x);
    if (Math.abs(ass) < VERY_SMALL) {
      ass = 0;
    }
    sinx = sind(x);
    if (Math.abs(sinx) < VERY_SMALL) {
      sinx = 0;
    }
    if (sinx == 0) {
      if (ass < 0) {
        ass = -VERY_SMALL;
      } else {
        ass = VERY_SMALL;
      }
    } else if (ass == 0) {
      if (sinx < 0) {
        ass = -90;
      } else {
        ass = 90;
      }
    } else {
      ass = atand(sinx / ass);
    }
    if (ass < 0) {
      ass = 180 + ass;
    }
    return (ass);
  } 
  
  
  double swe_house_pos(double armc, double geolat, double eps,
                       int hsys, double xpin[], StringBuffer serr) {
    double xp[]=new double[6], xeq[]=new double[6], ra, de, mdd, mdn, sad, san;
    double hpos, sinad, ad, a, admc, adp, samc, demc, asc, mc, acmc, tant;
    double fh, ra0, tanfi, fac;
    double x[] = new double[3], xasc[] = new double[3], raep, raaz, oblaz, xtemp; 
    double sine = sind(eps);
    double cose = cosd(eps);
    boolean is_above_hor = false;
    if (serr != null) { serr.setLength(0); }
    hsys = Character.toUpperCase((char)hsys);
    xeq[0] = xpin[0];
    xeq[1] = xpin[1];
    xeq[2] = 1;
    sl.swe_cotrans(xpin, 0, xeq, 0, -eps);
    ra = xeq[0];
    de = xeq[1];
    mdd = sl.swe_degnorm(ra - armc);
    mdn = sl.swe_degnorm(mdd + 180);
    if (mdd >= 180) {
      mdd -= 360;
    }
    if (mdn >= 180) {
      mdn -= 360;
    }
    
    switch(hsys) {
      case (int)'A':
      case (int)'E':
      case (int)'V':
        asc = Asc1 (sl.swe_degnorm(armc + 90), geolat, sine, cose);
        demc = atand(sind(armc) * tand(eps));
        if (geolat >= 0 && 90 - geolat + demc < 0) {
          asc = sl.swe_degnorm(asc + 180);
        }
        if (geolat < 0 && -90 - geolat + demc > 0) {
          asc = sl.swe_degnorm(asc + 180);
        }
        xp[0] = sl.swe_degnorm(xpin[0] - asc);
        if (hsys == 'V') {
          xp[0] = sl.swe_degnorm(xp[0] + 15);
        }
        
        xp[0] = sl.swe_degnorm(xp[0] + MILLIARCSEC);
        hpos = xp[0] / 30.0 + 1;
      break;
      case 'O':
        asc = Asc1 (sl.swe_degnorm(armc + 90), geolat, sine, cose);
        demc = atand(sind(armc) * tand(eps));
        
        if (Math.abs(armc - 90) > VERY_SMALL
                && Math.abs(armc - 270) > VERY_SMALL) {
          tant = tand(armc);
          mc = sl.swe_degnorm(atand(tant / cose));
          if (armc > 90 && armc <= 270) {
            mc = sl.swe_degnorm(mc + 180);
          }
        } else {
          if (Math.abs(armc - 90) <= VERY_SMALL) {
            mc = 90;
          } else {
            mc = 270;
          }
        }
        
        if (geolat >= 0 && 90 - geolat + demc < 0) {
          asc = sl.swe_degnorm(asc + 180);
        }
        if (geolat < 0 && -90 - geolat + demc > 0) {
          asc = sl.swe_degnorm(asc + 180);
        }
        xp[0] = sl.swe_degnorm(xpin[0] - asc);
        
        xp[0] = sl.swe_degnorm(xp[0] + MILLIARCSEC);
        if (xp[0] < 180) {
          hpos = 1;
        } else {
          hpos = 7;
          xp[0] -= 180;
        }
        acmc = sl.swe_difdeg2n(asc, mc);
        if (xp[0] < 180 - acmc) {
          hpos += xp[0] * 3 / (180 - acmc);
        } else {
          hpos += 3 + (xp[0] - 180 + acmc) * 3 / acmc;
        }
      break;
      case 'X': 
        hpos = sl.swe_degnorm(mdd - 90) / 30.0 + 1;
      break;
      case (int)'M': { 
        double am = xpin[0];
        if (Math.abs(am - 90) > VERY_SMALL
          && Math.abs(am - 270) > VERY_SMALL) {
          tant = tand(am);
          hpos = atand(tant / cose);
          if (am > 90 && am <= 270) {
            hpos = sl.swe_degnorm(hpos + 180);
          }
        } else {
          if (Math.abs(am - 90) <= VERY_SMALL) {
            hpos = 90;
          } else {
            hpos = 270;
          }
        } 
        hpos = sl.swe_degnorm(hpos - armc - 90);
        hpos = hpos / 30.0 + 1;
      }
      break;
      case (int)'K':
       demc = atand(sind(armc) * tand(eps));
       
       if (90 - Math.abs(geolat) <= Math.abs(de)) {
         if (serr != null) {
           serr.append("no Koch house position, because planet is circumpolar.");
         }
         xp[0] = 0;
         hpos = 0;        
       } else if (90 - Math.abs(geolat) <= Math.abs(demc)) {
         if (serr != null) {
           serr.append("no Koch house position, because mc is circumpolar.");
         }
         xp[0] = 0;
         hpos = 0;        
        } else {
          admc = asind(tand(eps) * tand(geolat) * sind(armc));
          adp = asind(tand(geolat) * tand(de));
            samc = 90 + admc;
          if (mdd >= 0) {        
            xp[0] = sl.swe_degnorm(((mdd - adp + admc) / samc - 1) * 90);
          } else {
            xp[0] = sl.swe_degnorm(((mdd + 180 + adp + admc) / samc + 1) * 90);
          }
          
          xp[0] = sl.swe_degnorm(xp[0] + MILLIARCSEC);
          hpos = xp[0] / 30.0 + 1;
        }
        break;
      case (int)'C':
        xeq[0] = sl.swe_degnorm(mdd - 90);
        sl.swe_cotrans(xeq, 0, xp, 0, -geolat);
        
        xp[0] = sl.swe_degnorm(xp[0] + MILLIARCSEC);
        hpos = xp[0] / 30.0 + 1;
        break;
      case 'U': 
        
        asc = Asc1 (sl.swe_degnorm(armc + 90), geolat, sine, cose);
        demc = atand(sind(armc) * tand(eps));
        
        if (geolat >= 0 && 90 - geolat + demc < 0) {
          asc = sl.swe_degnorm(asc + 180);
        }
        if (geolat < 0 && -90 - geolat + demc > 0) {
          asc = sl.swe_degnorm(asc + 180);
        }
        
        
        
        x[0] = asc; x[1] = 0.0; x[2] = 1.0;          
        sl.swe_cotrans(x, x, -eps);                     
        raep = sl.swe_degnorm(armc + 90);               
        x[0] = sl.swe_degnorm(raep - x[0]);             
        sl.swe_cotrans(x, x, -(90-geolat));             
        xtemp = atand(tand(x[0])/cosd((90-geolat))); 
        if (x[0] > 90 && x[0] <= 270)
        xtemp = sl.swe_degnorm(xtemp + 180);
        x[0] = sl.swe_degnorm(xtemp);        
        raaz = sl.swe_degnorm(raep - x[0]); 
        
        x[0] = raaz; x[1] = 0.0; 
        x[0] = sl.swe_degnorm(raep - x[0]);  
        sl.swe_cotrans(x, x, -(90-geolat));  
        x[1] = x[1] + 90;                 
        sl.swe_cotrans(x, x, 90-geolat);     
        oblaz = x[1];                     
        
        
        xasc[0] = asc; xasc[1] = 0.0; xasc[2] = 1.0;
        sl.swe_cotrans(xasc, xasc, -eps);
        xasc[0] = sl.swe_degnorm(xasc[0] - raaz);
        xtemp = atand(tand(xasc[0])/cosd(oblaz));
        if (xasc[0] > 90 && xasc[0] <= 270)
        xtemp = sl.swe_degnorm(xtemp + 180);
        xasc[0] = sl.swe_degnorm(xtemp);
        
        xp[0] = sl.swe_degnorm(xeq[0] - raaz);        
        xtemp = atand(tand(xp[0])/cosd(oblaz));    
        if (xp[0] > 90 && xp[0] <= 270)
          xtemp = sl.swe_degnorm(xtemp + 180);
        xp[0] = sl.swe_degnorm(xtemp);
        xp[0] = sl.swe_degnorm(xp[0]-xasc[0]); 
        
        x[0] = xeq[0];
        x[1] = xeq[1];
        sl.swe_cotrans(x, x, oblaz);
        xp[1] = xeq[1] - x[1]; 
        
        xp[0] = sl.swe_degnorm(xp[0] + MILLIARCSEC);
        hpos = xp[0] / 30.0 + 1;
        break;
      case (int)'H':
        xeq[0] = sl.swe_degnorm(mdd - 90);
        sl.swe_cotrans(xeq, 0, xp, 0, 90 - geolat);
        
        xp[0] = sl.swe_degnorm(xp[0] + MILLIARCSEC);
        hpos = xp[0] / 30.0 + 1;
        break;
      case (int)'R':
        if (Math.abs(mdd) < VERY_SMALL) {
          xp[0] = 270;
        } else if (180 - Math.abs(mdd) < VERY_SMALL) {
          xp[0] = 90;
        } else {
          if (90 - Math.abs(geolat) < VERY_SMALL) {
            if (geolat > 0) {
              geolat = 90 - VERY_SMALL;
            } else {
              geolat = -90 + VERY_SMALL;
            }
          }
          if (90 - Math.abs(de) < VERY_SMALL) {
            if (de > 0) {
              de = 90 - VERY_SMALL;
            } else {
              de = -90 + VERY_SMALL;
            }
          }
          a = tand(geolat) * tand(de) + cosd(mdd);
          xp[0] = sl.swe_degnorm(atand(-a / sind(mdd)));
          if (mdd < 0) {
            xp[0] += 180;
          }
          xp[0] = sl.swe_degnorm(xp[0]);
          
          xp[0] = sl.swe_degnorm(xp[0] + MILLIARCSEC);
        }
        hpos = xp[0] / 30.0 + 1;
        break;
      case (int)'T':
        mdd = sl.swe_degnorm(mdd);
        if (de > 90 - VERY_SMALL) {
          de = 90 - VERY_SMALL;
        }
        if (de < -90 + VERY_SMALL) {
          de = -90 + VERY_SMALL;
        }
        sinad = tand(de) * tand(geolat);
        ad = asind(sinad);
        a = sinad + cosd(mdd);
        if (a >= 0) {
          is_above_hor = true;
        }
        
        if (!is_above_hor) {
          ra = sl.swe_degnorm(ra + 180);
          de = -de;
          mdd = sl.swe_degnorm(mdd + 180);
        }
        
        if (mdd > 180) {
          ra = sl.swe_degnorm(armc - mdd);
        }
        
        tanfi = tand(geolat);
        fh = geolat;
        ra0 = sl.swe_degnorm(armc + 90);
        xp[1] = 1;
        xeq[1] = de;
        fac = 2;
        while (Math.abs(xp[1]) > 0.000001) {
          if (xp[1] > 0) {
            fh = atand(tand(fh) - tanfi / fac);
            ra0 -= 90 / fac;
          } else {
            fh = atand(tand(fh) + tanfi / fac);
            ra0 += 90 / fac;
          }
          xeq[0] = sl.swe_degnorm(ra - ra0);
          sl.swe_cotrans(xeq, 0, xp, 0, 90 - fh);
          fac *= 2;
        }
        hpos = sl.swe_degnorm(ra0 - armc);
        
        if (mdd > 180) {
          hpos = sl.swe_degnorm(-hpos);
        }
        
        if (!is_above_hor) {
          hpos = sl.swe_degnorm(hpos + 180);
        }
        hpos = sl.swe_degnorm(hpos - 90) / 30 + 1;
        break;
      case (int)'P':
      case (int)'G':
      default:
         
        if (90 - Math.abs(de) <= Math.abs(geolat)) {
          if (de * geolat < 0) {
            xp[0] = sl.swe_degnorm(90 + mdn / 2);
          } else {
            xp[0] = sl.swe_degnorm(270 + mdd / 2);
          }
          if (serr != null) {
            serr.append("Otto Ludwig procedure within circumpolar regions.");
          }
        } else {
          sinad = tand(de) * tand(geolat);
          ad = asind(sinad);
          a = sinad + cosd(mdd);
          if (a >= 0) {
            is_above_hor = true;
          }
          sad = 90 + ad;
          san = 90 - ad;
          if (is_above_hor) {
            xp[0] =  (mdd / sad + 3) * 90;
          } else {
            xp[0] = (mdn / san + 1) * 90;
          }
          
          xp[0] = sl.swe_degnorm(xp[0] + MILLIARCSEC);
        }
        if ((char)hsys == 'G') {
          xp[0] = 360 - xp[0]; 
          hpos = xp[0] / 10.0 + 1;
        } else {
          hpos = xp[0] / 30.0 + 1;
        }
      break;
    }
    return hpos;
  }
}
class Swemmoon {
 
  SwissData swed;
  SwissLib sl;
  Swemmoon() {
    this(null,null);
  }
  Swemmoon(SwissData swed, SwissLib sl) {
    this.swed=swed;
    this.sl=sl;
    if (this.swed ==null) { this.swed =new SwissData(); }
    if (this.sl   ==null) { this.sl   =new SwissLib(); }
  }
  
  static final double z[] = {
    
    -1.312045233711e+01, 
    -1.138215912580e-03, 
    -9.646018347184e-06, 
     3.146734198839e+01, 
     4.768357585780e-02, 
    -3.421689790404e-04, 
    -6.847070905410e+00, 
    -5.834100476561e-03, 
    -2.905334122698e-04, 
    -5.663161722088e+00, 
     5.722859298199e-03, 
    -8.466472828815e-05, 
    
    -8.429817796435e+01, 
    -2.072552484689e+02, 
     7.876842214863e+00, 
     1.836463749022e+00, 
    -1.557471855361e+01, 
    -2.006969124724e+01, 
     2.152670284757e+01, 
    -6.179946916139e+00, 
    -9.070028191196e-01, 
    -1.270848233038e+01, 
    -2.145589319058e+00, 
     1.381936399935e+01, 
    -1.999840061168e+00, 
  };
  
  static final int NLR=118;
  static final short LR[]={
  
   0, 0, 1, 0, 22639, 5858,-20905,-3550,
   2, 0,-1, 0,  4586, 4383, -3699,-1109,
   2, 0, 0, 0,  2369, 9139, -2955,-9676,
   0, 0, 2, 0,   769,  257,  -569,-9251,
   0, 1, 0, 0,  -666,-4171,    48, 8883,
   0, 0, 0, 2,  -411,-5957,    -3,-1483,
   2, 0,-2, 0,   211, 6556,   246, 1585,
   2,-1,-1, 0,   205, 4358,  -152,-1377,
   2, 0, 1, 0,   191, 9562,  -170,-7331,
   2,-1, 0, 0,   164, 7285,  -204,-5860,
   0, 1,-1, 0,  -147,-3213,  -129,-6201,
   1, 0, 0, 0,  -124,-9881,   108, 7427,
   0, 1, 1, 0,  -109,-3803,   104, 7552,
   2, 0, 0,-2,    55, 1771,    10, 3211,
   0, 0, 1, 2,   -45, -996,     0,    0,
   0, 0, 1,-2,    39, 5333,    79, 6606,
   4, 0,-1, 0,    38, 4298,   -34,-7825,
   0, 0, 3, 0,    36, 1238,   -23,-2104,
   4, 0,-2, 0,    30, 7726,   -21,-6363,
   2, 1,-1, 0,   -28,-3971,    24, 2085,
   2, 1, 0, 0,   -24,-3582,    30, 8238,
   1, 0,-1, 0,   -18,-5847,    -8,-3791,
   1, 1, 0, 0,    17, 9545,   -16,-6747,
   2,-1, 1, 0,    14, 5303,   -12,-8314,
   2, 0, 2, 0,    14, 3797,   -10,-4448,
   4, 0, 0, 0,    13, 8991,   -11,-6500,
   2, 0,-3, 0,    13, 1941,    14, 4027,
   0, 1,-2, 0,    -9,-6791,    -7,  -27,
   2, 0,-1, 2,    -9,-3659,     0, 7740,
   2,-1,-2, 0,     8, 6055,    10,  562,
   1, 0, 1, 0,    -8,-4531,     6, 3220,
   2,-2, 0, 0,     8,  502,    -9,-8845,
   0, 1, 2, 0,    -7,-6302,     5, 7509,
   0, 2, 0, 0,    -7,-4475,     1,  657,
   2,-2,-1, 0,     7, 3712,    -4,-9501,
   2, 0, 1,-2,    -6,-3832,     4, 1311,
   2, 0, 0, 2,    -5,-7416,     0,    0,
   4,-1,-1, 0,     4, 3740,    -3,-9580,
   0, 0, 2, 2,    -3,-9976,     0,    0,
   3, 0,-1, 0,    -3,-2097,     3, 2582,
   2, 1, 1, 0,    -2,-9145,     2, 6164,
   4,-1,-2, 0,     2, 7319,    -1,-8970,
   0, 2,-1, 0,    -2,-5679,    -2,-1171,
   2, 2,-1, 0,    -2,-5212,     2, 3536,
   2, 1,-2, 0,     2, 4889,     0, 1437,
   2,-1, 0,-2,     2, 1461,     0, 6571,
   4, 0, 1, 0,     1, 9777,    -1,-4226,
   0, 0, 4, 0,     1, 9337,    -1,-1169,
   4,-1, 0, 0,     1, 8708,    -1,-5714,
   1, 0,-2, 0,    -1,-7530,    -1,-7385,
   2, 1, 0,-2,    -1,-4372,     0,-1357,
   0, 0, 2,-2,    -1,-3726,    -4,-4212,
   1, 1, 1, 0,     1, 2618,     0,-9333,
   3, 0,-2, 0,    -1,-2241,     0, 8624,
   4, 0,-3, 0,     1, 1868,     0,-5142,
   2,-1, 2, 0,     1, 1770,     0,-8488,
   0, 2, 1, 0,    -1,-1617,     1, 1655,
   1, 1,-1, 0,     1,  777,     0, 8512,
   2, 0, 3, 0,     1,  595,     0,-6697,
   2, 0, 1, 2,     0,-9902,     0,    0,
   2, 0,-4, 0,     0, 9483,     0, 7785,
   2,-2, 1, 0,     0, 7517,     0,-6575,
   0, 1,-3, 0,     0,-6694,     0,-4224,
   4, 1,-1, 0,     0,-6352,     0, 5788,
   1, 0, 2, 0,     0,-5840,     0, 3785,
   1, 0, 0,-2,     0,-5833,     0,-7956,
   6, 0,-2, 0,     0, 5716,     0,-4225,
   2, 0,-2,-2,     0,-5606,     0, 4726,
   1,-1, 0, 0,     0,-5569,     0, 4976,
   0, 1, 3, 0,     0,-5459,     0, 3551,
   2, 0,-2, 2,     0,-5357,     0, 7740,
   2, 0,-1,-2,     0, 1790,     8, 7516,
   3, 0, 0, 0,     0, 4042,    -1,-4189,
   2,-1,-3, 0,     0, 4784,     0, 4950,
   2,-1, 3, 0,     0,  932,     0, -585,
   2, 0, 2,-2,     0,-4538,     0, 2840,
   2,-1,-1, 2,     0,-4262,     0,  373,
   0, 0, 0, 4,     0, 4203,     0,    0,
   0, 1, 0, 2,     0, 4134,     0,-1580,
   6, 0,-1, 0,     0, 3945,     0,-2866,
   2,-1, 0, 2,     0,-3821,     0,    0,
   2,-1, 1,-2,     0,-3745,     0, 2094,
   4, 1,-2, 0,     0,-3576,     0, 2370,
   1, 1,-2, 0,     0, 3497,     0, 3323,
   2,-3, 0, 0,     0, 3398,     0,-4107,
   0, 0, 3, 2,     0,-3286,     0,    0,
   4,-2,-1, 0,     0,-3087,     0,-2790,
   0, 1,-1,-2,     0, 3015,     0,    0,
   4, 0,-1,-2,     0, 3009,     0,-3218,
   2,-2,-2, 0,     0, 2942,     0, 3430,
   6, 0,-3, 0,     0, 2925,     0,-1832,
   2, 1, 2, 0,     0,-2902,     0, 2125,
   4, 1, 0, 0,     0,-2891,     0, 2445,
   4,-1, 1, 0,     0, 2825,     0,-2029,
   3, 1,-1, 0,     0, 2737,     0,-2126,
   0, 1, 1, 2,     0, 2634,     0,    0,
   1, 0, 0, 2,     0, 2543,     0,    0,
   3, 0, 0,-2,     0,-2530,     0, 2010,
   2, 2,-2, 0,     0,-2499,     0,-1089,
   2,-3,-1, 0,     0, 2469,     0,-1481,
   3,-1,-1, 0,     0,-2314,     0, 2556,
   4, 0, 2, 0,     0, 2185,     0,-1392,
   4, 0,-1, 2,     0,-2013,     0, 0,
   0, 2,-2, 0,     0,-1931,     0, 0,
   2, 2, 0, 0,     0,-1858,     0, 0,
   2, 1,-3, 0,     0, 1762,     0, 0,
   4, 0,-2, 2,     0,-1698,     0, 0,
   4,-2,-2, 0,     0, 1578,     0,-1083,
   4,-2, 0, 0,     0, 1522,     0,-1281,
   3, 1, 0, 0,     0, 1499,     0,-1077,
   1,-1,-1, 0,     0,-1364,     0, 1141,
   1,-3, 0, 0,     0,-1281,     0, 0,
   6, 0, 0, 0,     0, 1261,     0, -859,
   2, 0, 2, 2,     0,-1239,     0, 0,
   1,-1, 1, 0,     0,-1207,     0, 1100,
   0, 0, 5, 0,     0, 1110,     0, -589,
   0, 3, 0, 0,     0,-1013,     0,  213,
   4,-1,-3, 0,     0,  998,     0, 0,
  };
  static final int NMB=77;
  static final short MB[]={
  
   0, 0, 0, 1,18461, 2387,
   0, 0, 1, 1, 1010, 1671,
   0, 0, 1,-1,  999, 6936,
   2, 0, 0,-1,  623, 6524,
   2, 0,-1, 1,  199, 4837,
   2, 0,-1,-1,  166, 5741,
   2, 0, 0, 1,  117, 2607,
   0, 0, 2, 1,   61, 9120,
   2, 0, 1,-1,   33, 3572,
   0, 0, 2,-1,   31, 7597,
   2,-1, 0,-1,   29, 5766,
   2, 0,-2,-1,   15, 5663,
   2, 0, 1, 1,   15, 1216,
   2, 1, 0,-1,  -12, -941,
   2,-1,-1, 1,    8, 8681,
   2,-1, 0, 1,    7, 9586,
   2,-1,-1,-1,    7, 4346,
   0, 1,-1,-1,   -6,-7314,
   4, 0,-1,-1,    6, 5796,
   0, 1, 0, 1,   -6,-4601,
   0, 0, 0, 3,   -6,-2965,
   0, 1,-1, 1,   -5,-6324,
   1, 0, 0, 1,   -5,-3684,
   0, 1, 1, 1,   -5,-3113,
   0, 1, 1,-1,   -5, -759,
   0, 1, 0,-1,   -4,-8396,
   1, 0, 0,-1,   -4,-8057,
   0, 0, 3, 1,    3, 9841,
   4, 0, 0,-1,    3, 6745,
   4, 0,-1, 1,    2, 9985,
   0, 0, 1,-3,    2, 7986,
   4, 0,-2, 1,    2, 4139,
   2, 0, 0,-3,    2, 1863,
   2, 0, 2,-1,    2, 1462,
   2,-1, 1,-1,    1, 7660,
   2, 0,-2, 1,   -1,-6244,
   0, 0, 3,-1,    1, 5813,
   2, 0, 2, 1,    1, 5198,
   2, 0,-3,-1,    1, 5156,
   2, 1,-1, 1,   -1,-3178,
   2, 1, 0, 1,   -1,-2643,
   4, 0, 0, 1,    1, 1919,
   2,-1, 1, 1,    1, 1346,
   2,-2, 0,-1,    1,  859,
   0, 0, 1, 3,   -1, -194,
   2, 1, 1,-1,    0,-8227,
   1, 1, 0,-1,    0, 8042,
   1, 1, 0, 1,    0, 8026,
   0, 1,-2,-1,    0,-7932,
   2, 1,-1,-1,    0,-7910,
   1, 0, 1, 1,    0,-6674,
   2,-1,-2,-1,    0, 6502,
   0, 1, 2, 1,    0,-6388,
   4, 0,-2,-1,    0, 6337,
   4,-1,-1,-1,    0, 5958,
   1, 0, 1,-1,    0,-5889,
   4, 0, 1,-1,    0, 4734,
   1, 0,-1,-1,    0,-4299,
   4,-1, 0,-1,    0, 4149,
   2,-2, 0, 1,    0, 3835,
   3, 0, 0,-1,    0,-3518,
   4,-1,-1, 1,    0, 3388,
   2, 0,-1,-3,    0, 3291,
   2,-2,-1, 1,    0, 3147,
   0, 1, 2,-1,    0,-3129,
   3, 0,-1,-1,    0,-3052,
   0, 1,-2, 1,    0,-3013,
   2, 0, 1,-3,    0,-2912,
   2,-2,-1,-1,    0, 2686,
   0, 0, 4, 1,    0, 2633,
   2, 0,-3, 1,    0, 2541,
   2, 0,-1, 3,    0,-2448,
   2, 1, 1, 1,    0,-2370,
   4,-1,-2, 1,    0, 2138,
   4, 0, 1, 1,    0, 2126,
   3, 0,-1, 1,    0,-2059,
   4, 1,-1,-1,    0,-1719,
  };
  static final int NLRT=38;
  static final short LRT[]={
  
   0, 1, 0, 0,    16, 7680,    -1,-2302,
   2,-1,-1, 0,    -5,-1642,     3, 8245,
   2,-1, 0, 0,    -4,-1383,     5, 1395,
   0, 1,-1, 0,     3, 7115,     3, 2654,
   0, 1, 1, 0,     2, 7560,    -2,-6396,
   2, 1,-1, 0,     0, 7118,     0,-6068,
   2, 1, 0, 0,     0, 6128,     0,-7754,
   1, 1, 0, 0,     0,-4516,     0, 4194,
   2,-2, 0, 0,     0,-4048,     0, 4970,
   0, 2, 0, 0,     0, 3747,     0, -540,
   2,-2,-1, 0,     0,-3707,     0, 2490,
   2,-1, 1, 0,     0,-3649,     0, 3222,
   0, 1,-2, 0,     0, 2438,     0, 1760,
   2,-1,-2, 0,     0,-2165,     0,-2530,
   0, 1, 2, 0,     0, 1923,     0,-1450,
   0, 2,-1, 0,     0, 1292,     0, 1070,
   2, 2,-1, 0,     0, 1271,     0,-6070,
   4,-1,-1, 0,     0,-1098,     0,  990,
   2, 0, 0, 0,     0, 1073,     0,-1360,
   2, 0,-1, 0,     0,  839,     0, -630,
   2, 1, 1, 0,     0,  734,     0, -660,
   4,-1,-2, 0,     0, -688,     0,  480,
   2, 1,-2, 0,     0, -630,     0,    0,
   0, 2, 1, 0,     0,  587,     0, -590,
   2,-1, 0,-2,     0, -540,     0, -170,
   4,-1, 0, 0,     0, -468,     0,  390,
   2,-2, 1, 0,     0, -378,     0,  330,
   2, 1, 0,-2,     0,  364,     0,    0,
   1, 1, 1, 0,     0, -317,     0,  240,
   2,-1, 2, 0,     0, -295,     0,  210,
   1, 1,-1, 0,     0, -270,     0, -210,
   2,-3, 0, 0,     0, -256,     0,  310,
   2,-3,-1, 0,     0, -187,     0,  110,
   0, 1,-3, 0,     0,  169,     0,  110,
   4, 1,-1, 0,     0,  158,     0, -150,
   4,-2,-1, 0,     0, -155,     0,  140,
   0, 0, 1, 0,     0,  155,     0, -250,
   2,-2,-2, 0,     0, -148,     0, -170,
  };
  static final int NBT=16;
  static final short BT[]={
  
   2,-1, 0,-1, -7430,
   2, 1, 0,-1,  3043,
   2,-1,-1, 1, -2229,
   2,-1, 0, 1, -1999,
   2,-1,-1,-1, -1869,
   0, 1,-1,-1,  1696,
   0, 1, 0, 1,  1623,
   0, 1,-1, 1,  1418,
   0, 1, 1, 1,  1339,
   0, 1, 1,-1,  1278,
   0, 1, 0,-1,  1217,
   2,-2, 0,-1,  -547,
   2,-1, 1,-1,  -443,
   2, 1,-1, 1,   331,
   2, 1, 0, 1,   317,
   2, 0, 0,-1,   295,
  };
  static final int NLRT2=25;
  static final short LRT2[]={
  
   0, 1, 0, 0,  487,   -36,
   2,-1,-1, 0, -150,   111,
   2,-1, 0, 0, -120,   149,
   0, 1,-1, 0,  108,    95,
   0, 1, 1, 0,   80,   -77,
   2, 1,-1, 0,   21,   -18,
   2, 1, 0, 0,   20,   -23,
   1, 1, 0, 0,  -13,    12,
   2,-2, 0, 0,  -12,    14,
   2,-1, 1, 0,  -11,     9,
   2,-2,-1, 0,  -11,     7,
   0, 2, 0, 0,   11,     0,
   2,-1,-2, 0,   -6,    -7,
   0, 1,-2, 0,    7,     5,
   0, 1, 2, 0,    6,    -4,
   2, 2,-1, 0,    5,    -3,
   0, 2,-1, 0,    5,     3,
   4,-1,-1, 0,   -3,     3,
   2, 0, 0, 0,    3,    -4,
   4,-1,-2, 0,   -2,     0,
   2, 1,-2, 0,   -2,     0,
   2,-1, 0,-2,   -2,     0,
   2, 1, 1, 0,    2,    -2,
   2, 0,-1, 0,    2,     0,
   0, 2, 1, 0,    2,     0,
  };
  static final int NBT2=12;
  static final short BT2[]={
  
   2,-1, 0,-1,  -22,
   2, 1, 0,-1,    9,
   2,-1, 0, 1,   -6,
   2,-1,-1, 1,   -6,
   2,-1,-1,-1,   -5,
   0, 1, 0, 1,    5,
   0, 1,-1,-1,    5,
   0, 1, 1, 1,    4,
   0, 1, 1,-1,    4,
   0, 1, 0,-1,    4,
   0, 1,-1, 1,    4,
   2,-2, 0,-1,   -2,
  };
  
  double ss[][]=new double[5][8];
  double cc[][]=new double[5][8];
  double l;                
  double B;                
  double moonpol[]=new double[3];
  
  double SWELP;
  double M;
  double MP;
  double D;
  double NF;
  double T;
  double T2;
  static double T3;
  static double T4;
  static double f;
  static double g;
  static double Ve;
  static double Ea;
  static double Ma;
  static double Ju;
  static double Sa;
  static double cg;
  static double sg;
  static double l1;
  static double l2;
  static double l3;
  static double l4;
  
  int swi_moshmoon2(double J, double[] pol) {
    int i;
    T = (J-SwephData.J2000)/36525.0;
    T2 = T*T;
    mean_elements();
    mean_elements_pl();
    moon1();
    moon2();
    moon3();
    moon4();
    for( i=0; i<3; i++ )
      pol[i] = moonpol[i];
    return(0);
  }
  
  int swi_moshmoon(double tjd, boolean do_save, double[] xpmret,
                   StringBuffer serr) {
    int i;
    double a, b, x1[]=new double[6], x2[]=new double[6], t;
    double xx[]=new double[6], xpm[];
    PlanData pdp = swed.pldat[SwephData.SEI_MOON];
    String s;
    if (do_save) {
      xpm = pdp.x;
    } else {
      xpm = xx;
    }
    
    if (tjd < SwephData.MOSHLUEPH_START - 0.2 || tjd > SwephData.MOSHLUEPH_END + 0.2) {
      if (serr != null) {
        s="jd "+tjd+" outside Moshier's Moon range "+
          SwephData.MOSHLUEPH_START+" .. "+
          SwephData.MOSHLUEPH_END+" ";
        if (serr.length() + s.length() < SwissData.AS_MAXCH) {
          serr.append(s);
        }
      }
      return(SweConst.ERR);
    }
    
    if (tjd == pdp.teval && pdp.iephe == SweConst.SEFLG_MOSEPH) {
      if (xpmret != null) {
        for (i = 0; i <= 5; i++) {
          xpmret[i] = pdp.x[i];
        }
      }
      return(SweConst.OK);
    }
    
    swi_moshmoon2(tjd, xpm);
    if (do_save) {
      pdp.teval = tjd;
      pdp.xflgs = -1;
      pdp.iephe = SweConst.SEFLG_MOSEPH;
    }
    
    ecldat_equ2000(tjd, xpm);
    
    
    
    t = tjd + SwephData.MOON_SPEED_INTV;
    swi_moshmoon2(t, x1);
    ecldat_equ2000(t, x1);
    t = tjd - SwephData.MOON_SPEED_INTV;
    swi_moshmoon2(t, x2);
    ecldat_equ2000(t, x2);
    for (i = 0; i <= 2; i++) {
      b = (x1[i] - x2[i]) / 2;
      a = (x1[i] + x2[i]) / 2 - xpm[i];
      xpm[i+3] = (2 * a + b) / SwephData.MOON_SPEED_INTV;
    }
    if (xpmret != null) {
      for (i = 0; i <= 5; i++) {
        xpmret[i] = xpm[i];
      }
    }
    return(SweConst.OK);
  }
  private void moon1() {
    double a;
    sscc( 0, SwephData.STR*D, 6 );
    sscc( 1, SwephData.STR*M,  4 );
    sscc( 2, SwephData.STR*MP, 4 );
    sscc( 3, SwephData.STR*NF, 4 );
    moonpol[0] = 0.0;
    moonpol[1] = 0.0;
    moonpol[2] = 0.0;
    
    chewm( LRT2, NLRT2, 4, 2, moonpol );
    chewm( BT2, NBT2, 4, 4, moonpol );
    f = 18 * Ve - 16 * Ea;
    g = SwephData.STR*(f - MP );  
    cg = Math.cos(g);
    sg = Math.sin(g);
    l = 6.367278 * cg + 12.747036 * sg;  
    l1 = 23123.70 * cg - 10570.02 * sg;  
    l2 = z[12] * cg + z[13] * sg;        
    moonpol[2] += 5.01 * cg + 2.72 * sg;
    g = SwephData.STR * (10.*Ve - 3.*Ea - MP);
    cg = Math.cos(g);
    sg = Math.sin(g);
    l += -0.253102 * cg + 0.503359 * sg;
    l1 += 1258.46 * cg + 707.29 * sg;
    l2 += z[14] * cg + z[15] * sg;
    g = SwephData.STR*(8.*Ve - 13.*Ea);
    cg = Math.cos(g);
    sg = Math.sin(g);
    l += -0.187231 * cg - 0.127481 * sg;
    l1 += -319.87 * cg - 18.34 * sg;
    l2 += z[16] * cg + z[17] * sg;
    a = 4.0*Ea - 8.0*Ma + 3.0*Ju;
    g = SwephData.STR * a;
    cg = Math.cos(g);
    sg = Math.sin(g);
    l += -0.866287 * cg + 0.248192 * sg;
    l1 += 41.87 * cg + 1053.97 * sg;
    l2 += z[18] * cg + z[19] * sg;
    g = SwephData.STR*(a - MP);
    cg = Math.cos(g);
    sg = Math.sin(g);
    l += -0.165009 * cg + 0.044176 * sg;
    l1 += 4.67 * cg + 201.55 * sg;
    g = SwephData.STR*f;  
    cg = Math.cos(g);
    sg = Math.sin(g);
    l += 0.330401 * cg + 0.661362 * sg;
    l1 += 1202.67 * cg - 555.59 * sg;
    l2 += z[20] * cg + z[21] * sg;
    g = SwephData.STR*(f - 2.0*MP );  
    cg = Math.cos(g);
    sg = Math.sin(g);
    l += 0.352185 * cg + 0.705041 * sg;
    l1 += 1283.59 * cg - 586.43 * sg;
    g = SwephData.STR * (2.0*Ju - 5.0*Sa);
    cg = Math.cos(g);
    sg = Math.sin(g);
    l += -0.034700 * cg + 0.160041 * sg;
    l2 += z[22] * cg + z[23] * sg;
    g = SwephData.STR * (SWELP - NF);
    cg = Math.cos(g);
    sg = Math.sin(g);
    l += 0.000116 * cg + 7.063040 * sg;
    l1 +=  298.8 * sg;
    
    sg = Math.sin( SwephData.STR * M );
    
    l3 =  z[24] * sg;
    l4 = 0;
    g = SwephData.STR * (2.0*D - M);
    sg = Math.sin(g);
    cg = Math.cos(g);
    moonpol[2] +=  -0.2655 * cg * T;
    g = SwephData.STR * (M - MP);
    moonpol[2] +=  -0.1568 * Math.cos( g ) * T;
    g = SwephData.STR * (M + MP);
    moonpol[2] +=  0.1309 * Math.cos( g ) * T;
    g = SwephData.STR * (2.0*(D + M) - MP);
    sg = Math.sin(g);
    cg = Math.cos(g);
    moonpol[2] +=   0.5568 * cg * T;
    l2 += moonpol[0];
    g = SwephData.STR*(2.0*D - M - MP);
    moonpol[2] +=  -0.1910 * Math.cos( g ) * T;
    moonpol[1] *= T;
    moonpol[2] *= T;
    
    moonpol[0] = 0.0;
    chewm( BT, NBT, 4, 4, moonpol );
    chewm( LRT, NLRT, 4, 1, moonpol );
    g = SwephData.STR*(f - MP - NF - 2355767.6); 
    moonpol[1] +=  -1127. * Math.sin(g);
    g = SwephData.STR*(f - MP + NF - 235353.6); 
    moonpol[1] +=  -1123. * Math.sin(g);
    g = SwephData.STR*(Ea + D + 51987.6);
    moonpol[1] +=  1303. * Math.sin(g);
    g = SwephData.STR*SWELP;
    moonpol[1] +=  342. * Math.sin(g);
    g = SwephData.STR*(2.*Ve - 3.*Ea);
    cg = Math.cos(g);
    sg = Math.sin(g);
    l +=  -0.343550 * cg - 0.000276 * sg;
    l1 +=  105.90 * cg + 336.53 * sg;
    g = SwephData.STR*(f - 2.*D); 
    cg = Math.cos(g);
    sg = Math.sin(g);
    l += 0.074668 * cg + 0.149501 * sg;
    l1 += 271.77 * cg - 124.20 * sg;
    g = SwephData.STR*(f - 2.*D - MP);
    cg = Math.cos(g);
    sg = Math.sin(g);
    l += 0.073444 * cg + 0.147094 * sg;
    l1 += 265.24 * cg - 121.16 * sg;
    g = SwephData.STR*(f + 2.*D - MP);
    cg = Math.cos(g);
    sg = Math.sin(g);
    l += 0.072844 * cg + 0.145829 * sg;
    l1 += 265.18 * cg - 121.29 * sg;
    g = SwephData.STR*(f + 2.*(D - MP));
    cg = Math.cos(g);
    sg = Math.sin(g);
    l += 0.070201 * cg + 0.140542 * sg;
    l1 += 255.36 * cg - 116.79 * sg;
    g = SwephData.STR*(Ea + D - NF);
    cg = Math.cos(g);
    sg = Math.sin(g);
    l += 0.288209 * cg - 0.025901 * sg;
    l1 += -63.51 * cg - 240.14 * sg;
    g = SwephData.STR*(2.*Ea - 3.*Ju + 2.*D - MP);
    cg = Math.cos(g);
    sg = Math.sin(g);
    l += 0.077865 * cg + 0.438460 * sg;
    l1 += 210.57 * cg + 124.84 * sg;
    g = SwephData.STR*(Ea - 2.*Ma);
    cg = Math.cos(g);
    sg = Math.sin(g);
    l += -0.216579 * cg + 0.241702 * sg;
    l1 += 197.67 * cg + 125.23 * sg;
    g = SwephData.STR*(a + MP);
    cg = Math.cos(g);
    sg = Math.sin(g);
    l += -0.165009 * cg + 0.044176 * sg;
    l1 += 4.67 * cg + 201.55 * sg;
    g = SwephData.STR*(a + 2.*D - MP);
    cg = Math.cos(g);
    sg = Math.sin(g);
    l += -0.133533 * cg + 0.041116 * sg;
    l1 +=  6.95 * cg + 187.07 * sg;
    g = SwephData.STR*(a - 2.*D + MP);
    cg = Math.cos(g);
    sg = Math.sin(g);
    l += -0.133430 * cg + 0.041079 * sg;
    l1 +=  6.28 * cg + 169.08 * sg;
    g = SwephData.STR*(3.*Ve - 4.*Ea);
    cg = Math.cos(g);
    sg = Math.sin(g);
    l += -0.175074 * cg + 0.003035 * sg;
    l1 +=  49.17 * cg + 150.57 * sg;
    g = SwephData.STR*(2.*(Ea + D - MP) - 3.*Ju + 213534.);
    l1 +=  158.4 * Math.sin(g);
    l1 += moonpol[0];
    a = 0.1 * T; 
    moonpol[1] *= a;
    moonpol[2] *= a;
  }
  void moon2() {
    
    g = SwephData.STR*(2*(Ea-Ju+D)-MP+648431.172);
    l += 1.14307 * Math.sin(g);
    g = SwephData.STR*(Ve-Ea+648035.568);
    l += 0.82155 * Math.sin(g);
    g = SwephData.STR*(3*(Ve-Ea)+2*D-MP+647933.184);
    l += 0.64371 * Math.sin(g);
    g = SwephData.STR*(Ea-Ju+4424.04);
    l += 0.63880 * Math.sin(g);
    g = SwephData.STR*(SWELP + MP - NF + 4.68);
    l += 0.49331 * Math.sin(g);
    g = SwephData.STR*(SWELP - MP - NF + 4.68);
    l += 0.4914 * Math.sin(g);
    g = SwephData.STR*(SWELP+NF+2.52);
    l += 0.36061 * Math.sin(g);
    g = SwephData.STR*(2.*Ve - 2.*Ea + 736.2);
    l += 0.30154 * Math.sin(g);
    g = SwephData.STR*(2.*Ea - 3.*Ju + 2.*D - 2.*MP + 36138.2);
    l += 0.28282 * Math.sin(g);
    g = SwephData.STR*(2.*Ea - 2.*Ju + 2.*D - 2.*MP + 311.0);
    l += 0.24516 * Math.sin(g);
    g = SwephData.STR*(Ea - Ju - 2.*D + MP + 6275.88);
    l += 0.21117 * Math.sin(g);
    g = SwephData.STR*(2.*(Ea - Ma) - 846.36);
    l += 0.19444 * Math.sin(g);
    g = SwephData.STR*(2.*(Ea - Ju) + 1569.96);
    l -= 0.18457 * Math.sin(g);
    g = SwephData.STR*(2.*(Ea - Ju) - MP - 55.8);
    l += 0.18256 * Math.sin(g);
    g = SwephData.STR*(Ea - Ju - 2.*D + 6490.08);
    l += 0.16499 * Math.sin(g);
    g = SwephData.STR*(Ea - 2.*Ju - 212378.4);
    l += 0.16427 * Math.sin(g);
    g = SwephData.STR*(2.*(Ve - Ea - D) + MP + 1122.48);
    l += 0.16088 * Math.sin(g);
    g = SwephData.STR*(Ve - Ea - MP + 32.04);
    l -= 0.15350 * Math.sin(g);
    g = SwephData.STR*(Ea - Ju - MP + 4488.88);
    l += 0.14346 * Math.sin(g);
    g = SwephData.STR*(2.*(Ve - Ea + D) - MP - 8.64);
    l += 0.13594 * Math.sin(g);
    g = SwephData.STR*(2.*(Ve - Ea - D) + 1319.76);
    l += 0.13432 * Math.sin(g);
    g = SwephData.STR*(Ve - Ea - 2.*D + MP - 56.16);
    l -= 0.13122 * Math.sin(g);
    g = SwephData.STR*(Ve - Ea + MP + 54.36);
    l -= 0.12722 * Math.sin(g);
    g = SwephData.STR*(3.*(Ve - Ea) - MP + 433.8);
    l += 0.12539 * Math.sin(g);
    g = SwephData.STR*(Ea - Ju + MP + 4002.12);
    l += 0.10994 * Math.sin(g);
    g = SwephData.STR*(20.*Ve - 21.*Ea - 2.*D + MP - 317511.72);
    l += 0.10652 * Math.sin(g);
    g = SwephData.STR*(26.*Ve - 29.*Ea - MP + 270002.52);
    l += 0.10490 * Math.sin(g);
    g = SwephData.STR*(3.*Ve - 4.*Ea + D - MP - 322765.56);
    l += 0.10386 * Math.sin(g);
    g = SwephData.STR*(SWELP+648002.556);
    B =  8.04508 * Math.sin(g);
    g = SwephData.STR*(Ea+D+996048.252);
    B += 1.51021 * Math.sin(g);
    g = SwephData.STR*(f - MP + NF + 95554.332);
    B += 0.63037 * Math.sin(g);
    g = SwephData.STR*(f - MP - NF + 95553.792);
    B += 0.63014 * Math.sin(g);
    g = SwephData.STR*(SWELP - MP + 2.9);
    B +=  0.45587 * Math.sin(g);
    g = SwephData.STR*(SWELP + MP + 2.5);
    B +=  -0.41573 * Math.sin(g);
    g = SwephData.STR*(SWELP - 2.0*NF + 3.2);
    B +=  0.32623 * Math.sin(g);
    g = SwephData.STR*(SWELP - 2.0*D + 2.5);
    B +=  0.29855 * Math.sin(g);
  }
  void moon3() {
    
    moonpol[0] = 0.0;
    chewm( LR, NLR, 4, 1, moonpol );
    chewm( MB, NMB, 4, 3, moonpol );
    l += (((l4 * T + l3) * T + l2) * T + l1) * T * 1.0e-5;
    moonpol[0] = SWELP + l + 1.0e-4 * moonpol[0];
    moonpol[1] = 1.0e-4 * moonpol[1] + B;
    moonpol[2] = 1.0e-4 * moonpol[2] + 385000.52899; 
  }
  
  void moon4() {
    moonpol[2] /= SweConst.AUNIT / 1000;
    moonpol[0] = SwephData.STR * mods3600( moonpol[0] );
    moonpol[1] = SwephData.STR * moonpol[1];
    B = moonpol[1];
  }
  
  int swi_mean_node(double J, double pol[], StringBuffer serr) {
    return swi_mean_node(J, pol, 0, serr);
  }
  int swi_mean_node(double J, double pol[], int offs, StringBuffer serr) {
    String s;
    T = (J-SwephData.J2000)/36525.0;
    T2 = T*T;
    T3 = T*T2;
    T4 = T2*T2;
    
    if (J < SwephData.MOSHNDEPH_START || J > SwephData.MOSHNDEPH_END) {
      if (serr != null) {
        s="jd "+J+" outside mean node range "+
                SwephData.MOSHNDEPH_START+" .. "+
                SwephData.MOSHNDEPH_END+" ";
        serr.append(s);
      }
      return SweConst.ERR;
    }
    mean_elements();
    
    pol[offs] = sl.swi_mod2PI((SWELP - NF) * SwephData.STR);
    
    pol[offs+1] = 0.0;
    
    pol[offs+2] = SwephData.MOON_MEAN_DIST / SweConst.AUNIT; 
    return SweConst.OK;
  }
  
  int swi_mean_apog(double J, double pol[], StringBuffer serr) {
    return swi_mean_apog(J, pol, 0, serr);
  }
  int swi_mean_apog(double J, double pol[], int offs, StringBuffer serr) {
    double node;
    String s;
    T = (J-SwephData.J2000)/36525.0;
    T2 = T*T;
    T3 = T*T2;
    T4 = T2*T2;
    
    if (J < SwephData.MOSHNDEPH_START || J > SwephData.MOSHNDEPH_END) {
      if (serr != null) {
        s="jd "+J+" outside mean apogee range "+
                SwephData.MOSHNDEPH_START+" .. "+
                SwephData.MOSHNDEPH_END+" ";
        if (serr.length()+s.length() < SwissData.AS_MAXCH) {
          serr.append(s);
        }
      }
      return SweConst.ERR;
    }
    mean_elements();
    pol[offs] = sl.swi_mod2PI((SWELP - MP) * SwephData.STR + SwephData.PI);
    pol[offs+1] = 0;
    pol[offs+2] = SwephData.MOON_MEAN_DIST * (1 + SwephData.MOON_MEAN_ECC) /
                                                 SweConst.AUNIT; 
    
    
    node = (SWELP - NF) * SwephData.STR;
    pol[offs] = sl.swi_mod2PI(pol[offs] - node);
    sl.swi_polcart(pol, offs, pol, offs);
    sl.swi_coortrf(pol, offs, pol, offs, -SwephData.MOON_MEAN_INCL * SwissData.DEGTORAD);
    sl.swi_cartpol(pol, offs, pol, offs);
    pol[offs] = sl.swi_mod2PI(pol[offs] + node);
    return SweConst.OK;
  }
  
  void chewm(short[] pt, int nlines, int nangles, int typflg, double[] ans ) {
    int npt=0;
    int i, j, k, k1, m;
    double cu, su, cv, sv, ff;
    for( i=0; i<nlines; i++ ) {
      k1 = 0;
      sv = 0.0;
      cv = 0.0;
      for( m=0; m<nangles; m++ ) {
        j = pt[npt++]; 
        if( j!=0 ) {
          k = j;
          if( j < 0 ) {
            k = -k; 
          }
          
          su = ss[m][k-1];
          cu = cc[m][k-1];
          if( j < 0 ) {
            su = -su; 
          }
          if( k1 == 0 ) {
            
            sv = su;
            cv = cu;
            k1 = 1;
          }
          else {
            
            ff =  su*cv + cu*sv;
            cv = cu*cv - su*sv;
            sv = ff;
          }
        }
      }
      
      switch( typflg ) {
      
      case 1:
        j = pt[npt++];
        k = pt[npt++];
        ans[0] += (10000.0 * j  + k) * sv;
        j = pt[npt++];
        k = pt[npt++];
        if( k!=0 ) {
          ans[2] += (10000.0 * j  + k) * cv;
        }
        break;
      
      case 2:
        j = pt[npt++];
        k = pt[npt++];
        ans[0] += j * sv;
        ans[2] += k * cv;
        break;
      
      case 3:
        j = pt[npt++];
        k = pt[npt++];
        ans[1] += ( 10000.0*j + k)*sv;
        break;
      
      case 4:
        j = pt[npt++];
        ans[1] += j * sv;
        break;
      }
    }
  }
  
  void sscc(int k, double arg, int n ) {
    double cu, su, cv, sv, s;
    int i;
    su = Math.sin(arg);
    cu = Math.cos(arg);
    ss[k][0] = su;                        
    cc[k][0] = cu;                        
    sv = 2.0*su*cu;
    cv = cu*cu - su*su;
    ss[k][1] = sv;                        
    cc[k][1] = cv;
    for( i=2; i<n; i++ ) {
      s =  su*cv + cu*sv;
      cv = cu*cv - su*sv;
      sv = s;
      ss[k][i] = sv;              
      cc[k][i] = cv;
    }
  }
  
  void ecldat_equ2000(double tjd, double[] xpm) {
    
    sl.swi_polcart(xpm, xpm);
    
    sl.swi_coortrf2(xpm, xpm, -swed.oec.seps, swed.oec.ceps);
    
    sl.swi_precess(xpm, tjd, SwephData.J_TO_J2000);
  }
  
  double mods3600(double x) {
    double lx;
    lx = x;
    lx = lx - 1296000.0 * Math.floor( lx/1296000.0 );
    return( lx );
  }
  void swi_mean_lunar_elements(double tjd,
                               DblObj node, DblObj dnode,
                               DblObj peri, DblObj dperi) {
    T = (tjd - SwephData.J2000) / 36525.0;
    T2 = T*T;
    mean_elements();
    node.val = sl.swe_degnorm((SWELP - NF) * SwephData.STR * SwissData.RADTODEG);
    peri.val = sl.swe_degnorm((SWELP - MP) * SwephData.STR * SwissData.RADTODEG);
    T -= 1.0 / 36525;
    mean_elements();
    dnode.val = sl.swe_degnorm(node.val - (SWELP-NF) * SwephData.STR * SwissData.RADTODEG);
    dnode.val -= 360;
    dperi.val = sl.swe_degnorm(peri.val - (SWELP-MP) * SwephData.STR * SwissData.RADTODEG);
  }
  void mean_elements() {
    double fracT = T%1.;
    
    M =  mods3600(129600000.0 * fracT - 3418.961646 * T +  1287104.76154);
    M += ((((((((
      1.62e-20 * T
    - 1.0390e-17 ) * T
    - 3.83508e-15 ) * T
    + 4.237343e-13 ) * T
    + 8.8555011e-11 ) * T
    - 4.77258489e-8 ) * T
    - 1.1297037031e-5 ) * T
    + 1.4732069041e-4 ) * T
    - 0.552891801772 ) * T2;
    
    
    NF = mods3600(1739232000.0 * fracT + 295263.0983 * T -
                  2.079419901760e-01 * T + 335779.55755);
    
    MP = mods3600(1717200000.0 * fracT + 715923.4728 * T -
                  2.035946368532e-01 * T + 485868.28096);
    
    D = mods3600(1601856000.0 * fracT + 1105601.4603 * T +
                 3.962893294503e-01 * T + 1072260.73512);
    
    SWELP = mods3600(1731456000.0 * fracT + 1108372.83264 * T - 6.784914260953e-01 * T +  785939.95571);
    
    NF += ((z[2]*T + z[1])*T + z[0])*T2;
    MP += ((z[5]*T + z[4])*T + z[3])*T2;
    D  += ((z[8]*T + z[7])*T + z[6])*T2;
    SWELP += ((z[11]*T + z[10])*T + z[9])*T2;
    
  }
  
  void mean_elements_pl() {
    
    Ve = mods3600( 210664136.4335482 * T + 655127.283046 );
    Ve += ((((((((
      -9.36e-023 * T
     - 1.95e-20 ) * T
     + 6.097e-18 ) * T
     + 4.43201e-15 ) * T
     + 2.509418e-13 ) * T
     - 3.0622898e-10 ) * T
     - 2.26602516e-9 ) * T
     - 1.4244812531e-5 ) * T
     + 0.005871373088 ) * T2;
    Ea = mods3600( 129597742.26669231  * T +  361679.214649 );
    Ea += (((((((( -1.16e-22 * T
     + 2.976e-19 ) * T
     + 2.8460e-17 ) * T
     - 1.08402e-14 ) * T
     - 1.226182e-12 ) * T
     + 1.7228268e-10 ) * T
     + 1.515912254e-7 ) * T
     + 8.863982531e-6 ) * T
     - 2.0199859001e-2 ) * T2;
    Ma = mods3600(  68905077.59284 * T + 1279559.78866 );
    Ma += (-1.043e-5*T + 9.38012e-3)*T2;
    Ju = mods3600( 10925660.428608 * T +  123665.342120 );
    Ju += (1.543273e-5*T - 3.06037836351e-1)*T2;
    Sa = mods3600( 4399609.65932 * T + 180278.89694 );
    Sa += (( 4.475946e-8*T - 6.874806E-5 ) * T + 7.56161437443E-1)*T2;
  }
  
  
  int swi_intp_apsides(double J, double[] pol, int ipli) {
    double dd;
    double rsv[] = new double[3];
    double sNF, sD, sLP, sMP, sM, sVe, sEa, sMa, sJu, sSa, fM, fVe, fEa, fMa, fJu, fSa, cMP, zMP, fNF, fD, fLP;
    double dMP, mLP, mNF, mD, mMP;
    int i, ii, iii, niter = 4;    
    ii=1;
    zMP=27.55454988;
    fNF = 27.212220817/zMP;
    fD  = 29.530588835/zMP;
    fLP = 27.321582/zMP;
    fM  = 365.2596359/zMP;
    fVe = 224.7008001/zMP;
    fEa = 365.2563629/zMP;
    fMa = 686.9798519/zMP;
    fJu = 4332.589348/zMP;
    fSa = 10759.22722/zMP;
    T = (J-SwephData.J2000)/36525.0;
    T2 = T*T;
    T4 = T2*T2;
    mean_elements();
    mean_elements_pl();
    sNF = NF;
    sD  = D;
    sLP = SWELP;
    sMP = MP;
    sM  = M ;
    sVe = Ve;
    sEa = Ea;
    sMa = Ma;
    sJu = Ju;
    sSa = Sa;
    sNF = mods3600(NF);
    sD  = mods3600(D);
    sLP = mods3600(SWELP);
    sMP = mods3600(MP);
    if (ipli == SwephData.SEI_INTP_PERG) {MP = 0.0; niter = 5;}
    if (ipli == SwephData.SEI_INTP_APOG) {MP = 648000.0; niter = 4;}
    cMP = 0;
    dd = 18000.0;
    for (iii= 0; iii<=niter; iii++) {
      dMP = sMP - MP;
      mLP = sLP - dMP;
      mNF = sNF - dMP;
      mD  = sD  - dMP;
      mMP = sMP - dMP;
      for (ii = 0; ii <=2; ii++) {
        MP = mMP + (ii-1)*dd;       
        NF = mNF + (ii-1)*dd/fNF;
        D  = mD  + (ii-1)*dd/fD;
        SWELP = mLP + (ii-1)*dd/fLP;
        M  = sM  + (ii-1)*dd/fM ;
        Ve = sVe + (ii-1)*dd/fVe;
        Ea = sEa + (ii-1)*dd/fEa;
        Ma = sMa + (ii-1)*dd/fMa;
        Ju = sJu + (ii-1)*dd/fJu;
        Sa = sSa + (ii-1)*dd/fSa;
        moon1();
        moon2();
        moon3();
        moon4();
        if (ii==1) {
          for( i=0; i<3; i++ ) pol[i] = moonpol[i];
        }
        rsv[ii] = moonpol[2];
      }
      cMP = (1.5*rsv[0] - 2*rsv[1] + 0.5*rsv[2]) / (rsv[0] + rsv[2] - 2*rsv[1]);
      cMP *= dd;
      cMP = cMP - dd;
      mMP += cMP;
      MP = mMP;
      dd /= 10;
    }
    return(0);
  }
} // End of class Swemmoon
class SwemptabEar {
  
  static final double eartabl[] = {
         -65.54655,        -232.74963, 12959774227.57587,      361678.59587,
           2.52679,          -4.93511,           2.46852,          -8.88928,
           6.66257,          -1.94502,
           0.66887,          -0.06141,           0.08893,           0.18971,
           0.00068,          -0.00307,
           0.03092,           0.03214,          -0.14321,           0.22548,
           0.00314,          -0.00221,
           8.98017,           7.25747,          -1.06655,           1.19671,
          -2.42276,           0.29621,           1.55635,           0.99167,
          -0.00026,           0.00187,
           0.00189,           0.02742,
           0.00158,           0.01475,
           0.00353,          -0.02048,
          -0.01775,          -0.01023,           0.01927,          -0.03122,
          -1.55440,          -4.97423,           2.14765,          -2.77045,
           1.02707,           0.55507,          -0.08066,           0.18479,
           0.00750,           0.00583,
          -0.16977,           0.35555,           0.32036,           0.01309,
           0.54625,           0.08167,           0.10681,           0.17231,
          -0.02287,           0.01631,
          -0.00866,          -0.00190,
           0.00016,          -0.01514,
          -0.00073,           0.04205,
          -0.00072,           0.01490,
          -0.38831,           0.41043,          -1.11857,          -0.84329,
           1.15123,          -1.34167,
           0.01026,          -0.00432,
          -0.02833,          -0.00705,          -0.00285,           0.01645,
          -0.01234,           0.05609,          -0.01893,          -0.00171,
          -0.30527,           0.45390,           0.56713,           0.70030,
           1.27125,          -0.76481,           0.34857,          -2.60318,
          -0.00160,           0.00643,
           0.28492,          -0.37998,           0.23347,           0.00540,
           0.00342,           0.04406,
           0.00037,          -0.02449,
           0.01469,           1.59358,           0.24956,           0.71066,
           0.25477,          -0.98371,
          -0.69412,           0.19687,          -0.44423,          -0.83331,
           0.49647,          -0.31021,
           0.05696,          -0.00802,          -0.14423,          -0.04719,
           0.16762,          -0.01234,           0.02481,           0.03465,
           0.01091,           0.02123,
           0.08212,          -0.07375,           0.01524,          -0.07388,
           0.06673,          -0.22486,           0.10026,          -0.00559,
           0.14711,          -0.11680,           0.05460,           0.02749,
          -1.04467,           0.34273,          -0.67582,          -2.15117,
           2.47372,          -0.04332,
           0.05016,          -0.03991,           0.01908,           0.00943,
           0.07321,          -0.23637,           0.10564,          -0.00446,
          -0.09523,          -0.30710,           0.17400,          -0.10681,
           0.05104,          -0.14078,           0.01390,           0.07288,
          -0.26308,          -0.20717,           0.20773,          -0.37096,
          -0.00205,          -0.27274,
          -0.00792,          -0.00183,
           0.02985,           0.04895,           0.03785,          -0.14731,
           0.02976,          -0.02495,          -0.02644,          -0.04085,
          -0.00843,           0.00027,
           0.00090,           0.00611,
           0.00040,           4.83425,
           0.01692,          -0.01335,
           0.04482,          -0.03602,           0.01672,           0.00838,
           0.03682,          -0.11206,           0.05163,          -0.00219,
          -0.08381,          -0.20911,           0.16400,          -0.13325,
          -0.05945,           0.02114,          -0.00710,          -0.04695,
          -0.01657,          -0.00513,
          -0.06999,          -0.23054,           0.13128,          -0.07975,
           0.00054,          -0.00699,
          -0.01253,          -0.04007,           0.00658,          -0.00607,
          -0.48696,           0.31859,          -0.84292,          -0.87950,
           1.30507,          -0.94042,
          -0.00234,           0.00339,
          -0.30647,          -0.24605,           0.24948,          -0.43369,
          -0.64033,           0.20754,          -0.43829,          -1.31801,
           1.55412,          -0.02893,
          -0.02323,           0.02181,          -0.00398,          -0.01548,
          -0.08005,          -0.01537,          -0.00362,          -0.02033,
           0.00028,          -0.03732,          -0.14083,          -7.21175,
          -0.07430,           0.01886,          -0.00223,           0.01915,
          -0.02270,          -0.03702,           0.10167,          -0.02917,
           0.00879,          -2.04198,
          -0.00433,          -0.41764,
           0.00671,          -0.00030,
           0.00070,          -0.01066,
           0.01144,          -0.03190,
          -0.29653,           0.38638,          -0.16611,          -0.07661,
           0.22071,           0.14665,           0.02487,           0.13524,
        -275.60942,        -335.52251,        -413.89009,         359.65390,
        1396.49813,        1118.56095,        2559.41622,       -3393.39088,
       -6717.66079,       -1543.17403,
          -1.90405,          -0.22958,          -0.57989,          -0.36584,
          -0.04547,          -0.14164,
           0.00749,          -0.03973,
           0.00033,           0.01842,
          -0.08301,          -0.03523,          -0.00408,          -0.02008,
           0.00008,           0.00778,
          -0.00046,           0.02760,
          -0.03135,           0.07710,           0.06130,           0.04003,
          -0.04703,           0.00671,          -0.00754,          -0.01000,
          -0.01902,          -0.00125,
          -0.00264,          -0.00903,
          -0.02672,           0.12765,
          -0.03872,           0.03532,          -0.01534,          -0.00710,
          -0.01087,           0.01124,
          -0.01664,           0.06304,          -0.02779,           0.00214,
          -0.01279,          -5.51814,
           0.05847,          -0.02093,           0.03950,           0.06696,
          -0.04064,           0.02687,
           0.01478,          -0.02169,           0.05821,           0.03301,
          -0.03861,           0.07535,
           0.00290,          -0.00644,
           0.00631,           0.12905,
           0.02400,           0.13194,          -0.14339,           0.00529,
           0.00343,           0.00819,
           0.02692,          -0.03332,          -0.07284,          -0.02064,
           0.07038,           0.03999,           0.02759,           0.07599,
           0.00033,           0.00641,
           0.00128,           0.02032,          -0.00852,           0.00680,
           0.23019,           0.17100,           0.09861,           0.55013,
          -0.00192,           0.00953,
          -0.00943,           0.01783,
           0.05975,           0.01486,           0.00160,           0.01558,
          -0.01629,          -0.02035,           0.01533,           2.73176,
           0.05858,          -0.01327,           0.00209,          -0.01506,
           0.00755,           0.03300,
          -0.00796,          -0.65270,
           0.02305,           0.00165,
          -0.02512,           0.06560,           0.16108,          -0.02087,
           0.00016,           0.10729,
           0.04175,           0.00559,
           0.01176,           0.00110,
          15.15730,          -0.52460,         -37.16535,         -25.85564,
         -60.94577,           4.29961,          57.11617,          67.96463,
          31.41414,         -64.75731,
           0.00848,           0.02971,          -0.03690,          -0.00010,
          -0.03568,           0.06325,           0.11311,           0.02431,
          -0.00383,           0.00421,
          -0.00140,           0.00680,
           0.00069,          -0.21036,
           0.00386,           0.04210,
          -0.01324,           0.16454,
          -0.01398,          -0.00109,
           0.02548,          -0.03842,          -0.06504,          -0.02204,
           0.01359,           0.00232,
           0.07634,          -1.64648,          -1.73103,           0.89176,
           0.81398,           0.65209,
           0.00021,          -0.08441,
          -0.00012,           0.01262,
          -0.00666,          -0.00050,
          -0.00130,           0.01596,
          -0.00485,          -0.00213,
           0.00009,          -0.03941,
          -0.02266,          -0.04421,          -0.01341,           0.01083,
          -0.00011,           0.00004,           0.00003,          -0.02017,
           0.00003,          -0.01096,
           0.00002,          -0.00623,
  };
  static final double eartabb[] = {
         -41.97860,         -48.43539,          74.72897,           0.00075,
          -0.12774,          -0.10188,          -0.00943,          -0.04574,
           0.00265,          -0.00217,
           0.00254,           0.00168,           0.00008,           0.00026,
          -0.00000,          -0.00000,
           0.00004,          -0.00003,           0.00001,          -0.00003,
          -0.00002,          -0.00006,
           0.03351,          -0.02699,           0.00896,          -0.01315,
          -0.00019,          -0.00054,          -0.00020,          -0.00003,
           0.00002,           0.00001,
          -0.00000,           0.00000,
          -0.00002,          -0.00001,
          -0.00001,           0.00003,
           0.00017,          -0.00008,           0.00000,          -0.00003,
           0.00501,          -0.00083,           0.00414,           0.00202,
           0.00051,           0.00060,           0.00002,           0.00000,
          -0.00002,           0.00002,
          -0.00016,          -0.00443,          -0.00083,          -0.00031,
          -0.00394,           0.00148,          -0.00035,           0.00099,
           0.00005,           0.00009,
           0.00004,          -0.00002,
          -0.00001,          -0.00002,
           0.00012,          -0.00005,
           0.00001,           0.00001,
          -0.00577,          -0.00631,          -0.00017,           0.01993,
          -0.00234,          -0.00218,
          -0.00001,           0.00002,
          -0.00101,          -0.00044,          -0.00036,           0.00041,
           0.00294,          -0.00109,           0.00043,          -0.00006,
           0.09650,           0.15003,           0.01087,           0.04905,
           0.00093,          -0.06986,          -0.01471,          -0.00221,
          -0.00002,          -0.00003,
           0.00440,          -0.00083,           0.00102,          -0.00024,
           0.00005,          -0.00002,
          -0.00004,           0.00001,
           0.00505,           0.00930,          -0.01609,          -0.00183,
          -0.00113,           0.00214,
           0.00439,          -0.00295,          -0.00280,           0.00402,
          -0.00047,          -0.00145,
          -0.00114,          -0.00178,           0.00097,           0.00022,
           0.00019,           0.00002,           0.00009,          -0.00005,
          -0.00002,           0.00006,
          -0.01618,          -0.01033,          -0.00372,           0.00301,
          -0.00199,           0.00003,           0.00012,          -0.00068,
          -0.00027,          -0.00011,           0.00009,          -0.00020,
          -0.00618,           0.00129,           0.00452,           0.00620,
          -0.06411,          -0.01524,
          -0.00207,          -0.00140,           0.00005,          -0.00036,
          -0.00009,           0.00005,           0.00012,          -0.00053,
           0.00050,          -0.00068,          -0.00059,          -0.00132,
           0.00719,          -0.13368,          -0.08789,          -0.02072,
           0.00031,          -0.00360,          -0.00241,          -0.00182,
           0.00284,           0.00196,
           0.00083,           0.00008,
           0.00203,          -0.00097,          -0.00120,           0.00748,
           0.00326,          -0.00145,          -0.00276,           0.00236,
          -0.00048,          -0.00258,
           0.00011,           0.00001,
          -0.00284,           0.00795,
          -0.00156,           0.00106,
          -0.00040,          -0.00069,           0.00026,          -0.00039,
          -0.00102,          -0.00098,           0.00017,          -0.00125,
          -0.00180,          -0.01103,          -0.01854,           0.00742,
          -0.02751,          -0.00773,          -0.00263,           0.01059,
           0.00152,           0.00047,
          -0.00106,          -0.00034,          -0.00126,          -0.00291,
          -0.00014,           0.00006,
           0.00069,           0.00316,          -0.00087,           0.00022,
           0.05381,           0.03791,           0.05011,          -0.15168,
          -0.16315,           0.03037,
           0.00068,          -0.00067,
          -0.00457,          -0.00146,          -0.00643,          -0.00451,
           0.07806,           0.00729,           0.03356,          -0.16465,
          -0.20388,          -0.04854,
          -0.00163,          -0.00178,           0.00185,           0.00405,
          -0.00009,           0.00068,          -0.00003,           0.00005,
          -0.01186,           0.00347,          -0.01776,           0.00258,
           0.00081,          -0.00014,           0.00003,          -0.00021,
          -0.01218,          -0.03048,          -0.03109,           0.01387,
          -0.00740,          -0.00113,
          -0.00155,           0.00679,
          -0.00053,          -0.00007,
          -0.00004,          -0.00002,
           0.00248,           0.00127,
          -0.00386,           0.00394,           0.01213,           0.00748,
          -0.04669,          -0.00319,           0.00315,           0.00010,
          85.02966,         -55.85765,         215.62111,         519.00334,
       -1941.10461,         508.68393,        -419.80123,       -4679.60117,
          -0.00916,           0.00204,
          -0.13900,          -0.08473,          -0.07614,          -0.03445,
           0.00359,          -0.00136,
          -0.00111,           0.01028,
           0.00021,          -0.00002,
           0.00039,           0.00246,          -0.00084,          -0.00007,
          -0.00191,           0.00491,
           0.00474,          -0.00676,
          -0.00549,           0.02234,           0.02087,           0.00575,
          -0.00011,           0.00079,          -0.00060,           0.00029,
          -0.00239,          -0.00257,
           0.00020,           0.00163,
           0.00301,          -0.01723,
           0.00049,           0.00086,          -0.00046,           0.00057,
          -0.00049,           0.00024,
           0.00103,          -0.00072,          -0.00005,           0.00095,
           0.00598,          -0.01127,
          -0.00538,           0.00317,          -0.00178,          -0.00010,
           0.00061,           0.00132,
          -0.00001,           0.00318,          -0.00206,           0.00113,
           0.00153,           0.00097,
           0.00161,          -0.00363,
           0.00142,          -0.00047,
          -0.00281,           0.03085,           0.02895,           0.00688,
           0.00025,          -0.00016,
          -0.00197,          -0.08112,           0.02859,          -0.00683,
           0.00004,           0.00016,           0.00158,          -0.00065,
           0.00004,          -0.00001,
           0.00002,          -0.00008,           0.00019,           0.00039,
          -0.00344,           0.00364,           0.00579,          -0.00144,
           0.00031,          -0.00190,
           0.00066,           0.00025,
           0.00011,          -0.00069,           0.00001,          -0.00011,
          -0.01202,           0.00842,           0.00067,          -0.00297,
          -0.00000,           0.00008,           0.00005,           0.00000,
           0.00086,          -0.00057,
           0.00354,          -0.00548,
           0.00009,          -0.00003,
           0.00179,           0.07922,           0.00490,           0.00065,
          -0.00005,          -0.00059,
           0.00061,          -0.00319,
           0.00007,          -0.00048,
           3.49661,          -1.52414,          -6.26431,          -1.76193,
         -26.45666,           7.62583,          77.77395,          10.67040,
           0.00032,           0.00090,
          -0.00026,           0.00680,           0.00827,           0.00199,
          -0.00271,           0.04278,           0.02257,          -0.00532,
           0.00006,           0.00011,
           0.00006,           0.00010,
          -0.00017,          -0.00081,
           0.00050,           0.00001,
           0.00012,           0.00082,
           0.00326,           0.00040,
          -0.00003,          -0.03209,           0.00042,           0.00008,
           0.01059,          -0.00218,
          -0.87557,          -1.06369,          -0.52928,           1.38498,
           0.00082,          -0.00040,
           0.00009,          -0.00047,
           0.00007,           0.00007,
           0.00155,           0.00019,
           0.00002,           0.00008,
           0.00001,           0.00023,
           0.00010,          -0.00029,
          -0.03336,          -0.00987,           0.00012,          -0.00006,
          -0.00198,           0.00333,          -0.00004,           0.00026,
           0.00042,           0.00006,
           0.00025,           0.00021,
  };
  static final double eartabr[] = {
           0.64577,          -2.90183,         -14.50280,          28.85196,
           0.08672,          -0.05643,           0.02353,          -0.00404,
           0.00019,          -0.00137,
           0.00128,          -0.00310,           0.00143,           0.00050,
           0.00000,           0.00000,
          -0.00023,          -0.00003,          -0.00057,          -0.00032,
          -0.00002,           0.00009,
          -0.09716,           0.04111,          -0.03108,           0.00633,
          -0.00220,          -0.00595,          -0.00279,           0.00491,
          -0.00004,          -0.00003,
          -0.00010,          -0.00004,
          -0.00013,          -0.00010,
           0.00017,          -0.00010,
          -0.00075,           0.00002,          -0.00054,          -0.00025,
           0.12572,           0.00948,           0.05937,           0.04900,
          -0.00785,           0.01815,          -0.00303,          -0.00120,
          -0.00010,           0.00010,
          -0.00317,          -0.00143,           0.00068,           0.00213,
          -0.00043,          -0.00420,           0.00406,          -0.00041,
           0.00048,           0.00062,
          -0.00005,           0.00029,
           0.00043,          -0.00002,
          -0.00126,          -0.00009,
          -0.00040,           0.00000,
           0.03557,           0.02143,          -0.02196,           0.04671,
          -0.05571,          -0.03425,
           0.00016,           0.00031,
           0.00020,          -0.00153,          -0.00142,          -0.00051,
          -0.00214,           0.00001,           0.00002,          -0.00061,
          -0.06824,           0.00030,          -0.05717,           0.04196,
           0.05887,           0.07531,           0.12313,          -0.04113,
           0.00025,           0.00021,
           0.02218,           0.01747,           0.00011,           0.01367,
          -0.00247,           0.00029,
           0.00120,          -0.00003,
           0.13373,          -0.02072,           0.06706,          -0.01009,
          -0.09515,          -0.01901,
           0.01767,           0.06939,          -0.06702,           0.04159,
          -0.02809,          -0.03968,
           0.00257,           0.00553,           0.00411,          -0.01309,
           0.00139,           0.01591,          -0.00322,           0.00245,
          -0.00202,           0.00093,
           0.01845,          -0.00018,          -0.00247,          -0.00771,
          -0.02834,          -0.00691,          -0.00154,          -0.01244,
           0.01512,           0.01884,          -0.00359,           0.00731,
          -0.05395,          -0.18108,           0.36303,          -0.12751,
           0.01877,           0.43653,
          -0.00725,          -0.00692,           0.00115,          -0.00327,
           0.04030,           0.01171,           0.00107,           0.01793,
           0.06335,          -0.02171,           0.02229,           0.03533,
          -0.06038,          -0.00356,           0.01325,          -0.03798,
           0.04963,          -0.06258,           0.08931,           0.04904,
           0.07115,          -0.00073,
          -0.00104,           0.00354,
          -0.01549,           0.00647,           0.04418,           0.01061,
           0.00568,           0.00957,           0.01102,          -0.00819,
          -0.00089,           0.00368,
          -0.00214,           0.00031,
          -1.11935,          -0.00029,
           0.00457,           0.00550,
           0.01409,           0.01664,          -0.00306,           0.00629,
           0.04531,           0.01460,           0.00092,           0.02074,
           0.07900,          -0.03241,           0.05122,           0.06151,
           0.01319,           0.03075,          -0.02814,           0.00329,
           0.00208,          -0.00681,
           0.09887,          -0.02956,           0.03410,           0.05617,
           0.00295,           0.00022,
           0.01727,          -0.00666,           0.00255,           0.00256,
          -0.14161,          -0.20656,           0.36936,          -0.35793,
           0.40122,           0.54675,
          -0.00109,          -0.00135,
           0.11179,          -0.13803,           0.19591,           0.11327,
          -0.08785,          -0.29929,           0.60319,          -0.20484,
           0.01418,           0.71392,
          -0.01039,          -0.01041,           0.00694,          -0.00183,
           0.00707,          -0.03745,           0.00943,          -0.00174,
           0.01781,           0.00069,           3.35806,          -0.06731,
          -0.01015,          -0.03402,          -0.00913,          -0.00094,
           0.01682,          -0.01066,           0.01361,           0.04752,
           0.97349,           0.00504,
           0.20303,          -0.00206,
           0.00012,           0.00327,
           0.00504,           0.00040,
          -0.01599,          -0.00570,
          -0.19375,          -0.14714,           0.03820,          -0.08283,
          -0.07716,           0.10543,          -0.06772,           0.01131,
         163.23023,        -126.90743,        -183.43441,        -201.49515,
        -559.82622,         698.28238,        1696.58461,        1279.45831,
         771.51923,       -3358.57619,
          -0.05911,           0.89279,          -0.15861,           0.28577,
          -0.06958,           0.02406,
           0.01999,           0.00382,
          -0.00934,           0.00014,
           0.01792,          -0.04249,           0.01019,          -0.00210,
          -0.00386,           0.00009,
          -0.01353,           0.00101,
          -0.03828,          -0.01677,          -0.02026,           0.03079,
          -0.00285,          -0.02484,           0.00537,          -0.00397,
          -0.00064,           0.00906,
          -0.00411,           0.00100,
          -0.06940,          -0.01482,
          -0.01966,          -0.02171,           0.00388,          -0.00840,
          -0.00621,          -0.00597,
          -0.03690,          -0.00959,          -0.00115,          -0.01557,
           3.24906,          -0.00580,
           0.00745,           0.03347,          -0.04023,           0.02174,
          -0.01544,          -0.02389,
           0.00935,          -0.00141,          -0.02018,           0.03258,
          -0.04479,          -0.02360,
          -0.00542,          -0.00194,
          -0.07906,           0.00273,
          -0.08439,           0.01534,          -0.00264,          -0.09205,
          -0.00539,           0.00220,
           0.01263,           0.01593,           0.01103,          -0.03324,
          -0.02720,           0.04749,          -0.05099,           0.01807,
          -0.00443,           0.00024,
          -0.01386,           0.00029,          -0.00443,          -0.00591,
          -0.11899,           0.15817,          -0.37728,           0.06552,
          -0.00669,          -0.00140,
          -0.01168,          -0.00690,
          -0.01032,           0.04315,          -0.01082,           0.00123,
           0.01192,          -0.01071,          -1.90746,           0.00700,
           0.00779,           0.04261,           0.01052,           0.00173,
          -0.02138,           0.00307,
           0.50118,          -0.00330,
          -0.00111,           0.01624,
          -0.02601,           0.00305,           0.02348,           0.07058,
          -0.07622,           0.00006,
          -0.00183,           0.01636,
          -0.00037,           0.00564,
           4.72127,           3.53639,          13.37363,          -6.68745,
         -12.29946,         -22.51893,         -27.18616,          22.85033,
          25.89912,          12.56594,
          -0.02566,           0.00307,          -0.00064,          -0.02727,
          -0.02634,          -0.01101,          -0.01029,           0.04755,
          -0.00372,          -0.00292,
          -0.00582,          -0.00053,
           0.17840,           0.00027,
          -0.03400,           0.00357,
          -0.13428,          -0.00611,
           0.00099,          -0.01169,
           0.01909,           0.01338,           0.01302,          -0.03071,
          -0.00051,           0.00577,
           0.61945,          -0.32627,          -0.30811,          -0.60197,
          -0.22597,           0.28183,
           0.07739,           0.00011,
           0.01336,          -0.00010,
           0.00049,          -0.00592,
          -0.01407,          -0.00081,
           0.00146,          -0.00280,
           0.03795,           0.00003,
           0.01173,          -0.00655,          -0.00344,          -0.00403,
           0.00036,          -0.00047,           0.02000,           0.00001,
           0.01105,           0.00002,
           0.00620,          -0.00052,
  };
  static final byte earargs[] = {
  (byte)0,  (byte)3,
  (byte)3,  (byte)4,  (byte)3, (byte)-8,  (byte)4,  (byte)3,  (byte)5,  (byte)2,
  (byte)2,  (byte)2,  (byte)5, (byte)-5,  (byte)6,  (byte)1,
  (byte)3,  (byte)2,  (byte)2,  (byte)1,  (byte)3, (byte)-8,  (byte)4,  (byte)0,
  (byte)3,  (byte)3,  (byte)2, (byte)-7,  (byte)3,  (byte)4,  (byte)4,  (byte)1,
  (byte)3,  (byte)7,  (byte)3,(byte)-13,  (byte)4, (byte)-1,  (byte)5,  (byte)0,
  (byte)2,  (byte)8,  (byte)2,(byte)-13,  (byte)3,  (byte)3,
  (byte)3,  (byte)1,  (byte)2, (byte)-8,  (byte)3, (byte)12,  (byte)4,  (byte)0,
  (byte)1,  (byte)1,  (byte)8,  (byte)0,
  (byte)1,  (byte)1,  (byte)7,  (byte)0,
  (byte)2,  (byte)1,  (byte)5, (byte)-2,  (byte)6,  (byte)0,
  (byte)3,  (byte)3,  (byte)3, (byte)-6,  (byte)4,  (byte)2,  (byte)5,  (byte)1,
  (byte)2,  (byte)8,  (byte)3,(byte)-15,  (byte)4,  (byte)3,
  (byte)2,  (byte)2,  (byte)5, (byte)-4,  (byte)6,  (byte)0,
  (byte)1,  (byte)1,  (byte)6,  (byte)1,
  (byte)2,  (byte)9,  (byte)3,(byte)-17,  (byte)4,  (byte)2,
  (byte)3,  (byte)3,  (byte)2, (byte)-5,  (byte)3,  (byte)1,  (byte)5,  (byte)0,
  (byte)3,  (byte)2,  (byte)3, (byte)-4,  (byte)4,  (byte)2,  (byte)5,  (byte)0,
  (byte)3,  (byte)3,  (byte)2, (byte)-5,  (byte)3,  (byte)2,  (byte)5,  (byte)0,
  (byte)2,  (byte)1,  (byte)5, (byte)-1,  (byte)6,  (byte)0,
  (byte)2,  (byte)1,  (byte)3, (byte)-2,  (byte)4,  (byte)2,
  (byte)2,  (byte)2,  (byte)5, (byte)-3,  (byte)6,  (byte)0,
  (byte)1,  (byte)2,  (byte)6,  (byte)1,
  (byte)2,  (byte)3,  (byte)5, (byte)-5,  (byte)6,  (byte)1,
  (byte)1,  (byte)1,  (byte)5,  (byte)3,
  (byte)2,  (byte)1,  (byte)5, (byte)-5,  (byte)6,  (byte)0,
  (byte)2,  (byte)7,  (byte)3,(byte)-13,  (byte)4,  (byte)2,
  (byte)2,  (byte)2,  (byte)5, (byte)-2,  (byte)6,  (byte)0,
  (byte)2,  (byte)3,  (byte)2, (byte)-5,  (byte)3,  (byte)2,
  (byte)2,  (byte)2,  (byte)3, (byte)-4,  (byte)4,  (byte)2,
  (byte)2,  (byte)5,  (byte)2, (byte)-8,  (byte)3,  (byte)1,
  (byte)2,  (byte)6,  (byte)3,(byte)-11,  (byte)4,  (byte)1,
  (byte)2,  (byte)1,  (byte)1, (byte)-4,  (byte)3,  (byte)0,
  (byte)1,  (byte)2,  (byte)5,  (byte)1,
  (byte)2,  (byte)3,  (byte)3, (byte)-6,  (byte)4,  (byte)1,
  (byte)2,  (byte)5,  (byte)3, (byte)-9,  (byte)4,  (byte)1,
  (byte)2,  (byte)2,  (byte)2, (byte)-3,  (byte)3,  (byte)2,
  (byte)2,  (byte)4,  (byte)3, (byte)-8,  (byte)4,  (byte)1,
  (byte)2,  (byte)4,  (byte)3, (byte)-7,  (byte)4,  (byte)1,
  (byte)2,  (byte)3,  (byte)3, (byte)-5,  (byte)4,  (byte)1,
  (byte)2,  (byte)1,  (byte)2, (byte)-2,  (byte)3,  (byte)1,
  (byte)2,  (byte)2,  (byte)3, (byte)-3,  (byte)4,  (byte)1,
  (byte)2,  (byte)1,  (byte)3, (byte)-1,  (byte)4,  (byte)0,
  (byte)2,  (byte)4,  (byte)2, (byte)-7,  (byte)3,  (byte)0,
  (byte)2,  (byte)4,  (byte)2, (byte)-6,  (byte)3,  (byte)1,
  (byte)1,  (byte)1,  (byte)4,  (byte)1,
  (byte)2,  (byte)1,  (byte)3, (byte)-3,  (byte)4,  (byte)0,
  (byte)2,  (byte)7,  (byte)3,(byte)-12,  (byte)4,  (byte)0,
  (byte)2,  (byte)1,  (byte)2, (byte)-1,  (byte)3,  (byte)0,
  (byte)2,  (byte)1,  (byte)3, (byte)-4,  (byte)5,  (byte)0,
  (byte)2,  (byte)6,  (byte)3,(byte)-10,  (byte)4,  (byte)1,
  (byte)2,  (byte)5,  (byte)3, (byte)-8,  (byte)4,  (byte)1,
  (byte)2,  (byte)1,  (byte)3, (byte)-3,  (byte)5,  (byte)1,
  (byte)2,  (byte)2,  (byte)2, (byte)-4,  (byte)3,  (byte)1,
  (byte)2,  (byte)6,  (byte)2, (byte)-9,  (byte)3,  (byte)0,
  (byte)2,  (byte)4,  (byte)3, (byte)-6,  (byte)4,  (byte)1,
  (byte)3,  (byte)1,  (byte)3, (byte)-3,  (byte)5,  (byte)2,  (byte)6,  (byte)0,
  (byte)2,  (byte)1,  (byte)3, (byte)-5,  (byte)6,  (byte)1,
  (byte)2,  (byte)1,  (byte)3, (byte)-2,  (byte)5,  (byte)2,
  (byte)3,  (byte)1,  (byte)3, (byte)-4,  (byte)5,  (byte)5,  (byte)6,  (byte)0,
  (byte)2,  (byte)3,  (byte)3, (byte)-4,  (byte)4,  (byte)1,
  (byte)2,  (byte)3,  (byte)2, (byte)-4,  (byte)3,  (byte)2,
  (byte)2,  (byte)1,  (byte)3, (byte)-3,  (byte)6,  (byte)1,
  (byte)3,  (byte)1,  (byte)3,  (byte)1,  (byte)5, (byte)-5,  (byte)6,  (byte)1,
  (byte)2,  (byte)1,  (byte)3, (byte)-1,  (byte)5,  (byte)1,
  (byte)3,  (byte)1,  (byte)3, (byte)-3,  (byte)5,  (byte)5,  (byte)6,  (byte)1,
  (byte)2,  (byte)1,  (byte)3, (byte)-2,  (byte)6,  (byte)1,
  (byte)2,  (byte)2,  (byte)3, (byte)-2,  (byte)4,  (byte)0,
  (byte)2,  (byte)1,  (byte)3, (byte)-1,  (byte)6,  (byte)0,
  (byte)2,  (byte)1,  (byte)3, (byte)-2,  (byte)7,  (byte)0,
  (byte)2,  (byte)1,  (byte)3, (byte)-1,  (byte)7,  (byte)0,
  (byte)2,  (byte)8,  (byte)2,(byte)-14,  (byte)3,  (byte)0,
  (byte)3,  (byte)1,  (byte)3,  (byte)2,  (byte)5, (byte)-5,  (byte)6,  (byte)1,
  (byte)3,  (byte)5,  (byte)3, (byte)-8,  (byte)4,  (byte)3,  (byte)5,  (byte)1,
  (byte)1,  (byte)1,  (byte)3,  (byte)4,
  (byte)3,  (byte)3,  (byte)3, (byte)-8,  (byte)4,  (byte)3,  (byte)5,  (byte)2,
  (byte)2,  (byte)8,  (byte)2,(byte)-12,  (byte)3,  (byte)0,
  (byte)3,  (byte)1,  (byte)3,  (byte)1,  (byte)5, (byte)-2,  (byte)6,  (byte)0,
  (byte)2,  (byte)9,  (byte)3,(byte)-15,  (byte)4,  (byte)1,
  (byte)2,  (byte)1,  (byte)3,  (byte)1,  (byte)6,  (byte)0,
  (byte)1,  (byte)2,  (byte)4,  (byte)0,
  (byte)2,  (byte)1,  (byte)3,  (byte)1,  (byte)5,  (byte)1,
  (byte)2,  (byte)8,  (byte)3,(byte)-13,  (byte)4,  (byte)1,
  (byte)2,  (byte)3,  (byte)2, (byte)-6,  (byte)3,  (byte)0,
  (byte)2,  (byte)1,  (byte)3, (byte)-4,  (byte)4,  (byte)0,
  (byte)2,  (byte)5,  (byte)2, (byte)-7,  (byte)3,  (byte)0,
  (byte)2,  (byte)7,  (byte)3,(byte)-11,  (byte)4,  (byte)1,
  (byte)2,  (byte)1,  (byte)1, (byte)-3,  (byte)3,  (byte)0,
  (byte)2,  (byte)6,  (byte)3, (byte)-9,  (byte)4,  (byte)1,
  (byte)2,  (byte)2,  (byte)2, (byte)-2,  (byte)3,  (byte)0,
  (byte)2,  (byte)5,  (byte)3, (byte)-7,  (byte)4,  (byte)2,
  (byte)2,  (byte)4,  (byte)3, (byte)-5,  (byte)4,  (byte)2,
  (byte)2,  (byte)1,  (byte)2, (byte)-3,  (byte)3,  (byte)0,
  (byte)2,  (byte)3,  (byte)3, (byte)-3,  (byte)4,  (byte)0,
  (byte)2,  (byte)4,  (byte)2, (byte)-5,  (byte)3,  (byte)1,
  (byte)2,  (byte)2,  (byte)3, (byte)-5,  (byte)5,  (byte)0,
  (byte)1,  (byte)1,  (byte)2,  (byte)1,
  (byte)2,  (byte)2,  (byte)3, (byte)-4,  (byte)5,  (byte)1,
  (byte)3,  (byte)2,  (byte)3, (byte)-4,  (byte)5,  (byte)2,  (byte)6,  (byte)0,
  (byte)2,  (byte)6,  (byte)3, (byte)-8,  (byte)4,  (byte)1,
  (byte)2,  (byte)2,  (byte)3, (byte)-3,  (byte)5,  (byte)1,
  (byte)2,  (byte)6,  (byte)2, (byte)-8,  (byte)3,  (byte)0,
  (byte)2,  (byte)5,  (byte)3, (byte)-6,  (byte)4,  (byte)0,
  (byte)2,  (byte)2,  (byte)3, (byte)-5,  (byte)6,  (byte)1,
  (byte)2,  (byte)2,  (byte)3, (byte)-2,  (byte)5,  (byte)1,
  (byte)3,  (byte)2,  (byte)3, (byte)-4,  (byte)5,  (byte)5,  (byte)6,  (byte)1,
  (byte)2,  (byte)4,  (byte)3, (byte)-4,  (byte)4,  (byte)0,
  (byte)2,  (byte)3,  (byte)2, (byte)-3,  (byte)3,  (byte)0,
  (byte)2,  (byte)2,  (byte)3, (byte)-3,  (byte)6,  (byte)0,
  (byte)2,  (byte)2,  (byte)3, (byte)-1,  (byte)5,  (byte)1,
  (byte)2,  (byte)2,  (byte)3, (byte)-2,  (byte)6,  (byte)0,
  (byte)2,  (byte)3,  (byte)3, (byte)-2,  (byte)4,  (byte)0,
  (byte)2,  (byte)2,  (byte)3, (byte)-1,  (byte)6,  (byte)0,
  (byte)1,  (byte)2,  (byte)3,  (byte)4,
  (byte)2,  (byte)5,  (byte)2, (byte)-6,  (byte)3,  (byte)1,
  (byte)2,  (byte)2,  (byte)2, (byte)-1,  (byte)3,  (byte)1,
  (byte)2,  (byte)6,  (byte)3, (byte)-7,  (byte)4,  (byte)0,
  (byte)2,  (byte)5,  (byte)3, (byte)-5,  (byte)4,  (byte)0,
  (byte)2,  (byte)4,  (byte)2, (byte)-4,  (byte)3,  (byte)0,
  (byte)2,  (byte)3,  (byte)3, (byte)-4,  (byte)5,  (byte)0,
  (byte)2,  (byte)3,  (byte)3, (byte)-3,  (byte)5,  (byte)0,
  (byte)2,  (byte)6,  (byte)2, (byte)-7,  (byte)3,  (byte)0,
  (byte)2,  (byte)3,  (byte)3, (byte)-2,  (byte)5,  (byte)1,
  (byte)2,  (byte)3,  (byte)2, (byte)-2,  (byte)3,  (byte)0,
  (byte)1,  (byte)3,  (byte)3,  (byte)2,
  (byte)2,  (byte)5,  (byte)2, (byte)-5,  (byte)3,  (byte)0,
  (byte)2,  (byte)1,  (byte)1, (byte)-1,  (byte)3,  (byte)0,
  (byte)2,  (byte)7,  (byte)2, (byte)-8,  (byte)3,  (byte)0,
  (byte)2,  (byte)4,  (byte)3, (byte)-4,  (byte)5,  (byte)0,
  (byte)2,  (byte)4,  (byte)3, (byte)-3,  (byte)5,  (byte)0,
  (byte)2,  (byte)6,  (byte)2, (byte)-6,  (byte)3,  (byte)0,
  (byte)1,  (byte)4,  (byte)3,  (byte)1,
  (byte)2,  (byte)7,  (byte)2, (byte)-7,  (byte)3,  (byte)1,
  (byte)2,  (byte)8,  (byte)2, (byte)-8,  (byte)3,  (byte)0,
  (byte)2,  (byte)9,  (byte)2, (byte)-9,  (byte)3,  (byte)0,
 (byte)-1
  };
  
  static Plantbl ear404 = new Plantbl(
                               new short[]{1,  9, 14, 17,  5,  5,  2,  1,  0},
                               (short)4,
                               earargs,
                               eartabl,
                               eartabb,
                               eartabr,
                               1.0
                              );
  
}
class SwemptabJup {
  
  static final double juptabl[] = {
      153429.13855,      130818.16897,       18120.42948,       -8463.12663,
       -5058.91447,  1092566021.02148,      123671.25097,
          -5.43364,          12.06012,
       30428.31077,      -74667.61443,       46848.16236,      -66373.44474,
       24312.54264,      -26045.64766,       18353.92564,       -4022.13679,
        4037.97936,       10059.82468,       -4622.55896,        1383.21617,
        -187.25468,       -1171.66028,
          -0.00062,          -0.21713,
       -1198.83945,        1178.62445,       -1492.07393,         153.07155,
        -245.57966,        -391.94010,          82.26400,         -40.92104,
           3.72520,          10.57242,
          -0.04720,          -0.04448,          -0.04329,          -0.06043,
          -0.03905,           0.15712,
          -0.05644,          -0.00129,
          -0.00342,           0.02473,
           0.00434,          -0.01862,
           0.00431,          -0.03993,
          -0.03159,          -0.15982,
          -0.09928,           0.04430,          -0.00357,           0.31312,
          -0.01346,          -0.00180,
          -0.09107,           0.01215,
           0.02485,           0.01024,
          27.29869,           2.70896,          12.91956,          19.21726,
          -6.91384,           5.12954,          -1.07533,          -1.71691,
          -0.01423,           0.03121,
         -32.48652,         -26.13483,          46.78162,         -62.02701,
          94.96809,          81.73791,         -20.13673,         131.05065,
          -0.00798,           0.01786,
          13.99591,          16.87756,          -8.51726,          21.59490,
         -14.28833,          -9.45530,           7.73954,          -6.53078,
           0.03175,          -0.04295,
           3.06742,          -0.11838,           1.03630,           0.94004,
          -0.14085,           0.14434,
          -0.03363,           0.00993,
          -0.00007,          -0.02748,
          26.01507,          -7.37178,          16.96955,           6.24203,
          -0.40481,           3.72456,          -0.53597,          -0.14938,
          37.82081,          26.15887,          -2.82115,          78.26478,
         -63.39155,          -5.52419,          13.11482,         -43.54977,
          15.64940,           6.67505,
         -10.25616,          -7.39672,         -12.37441,          12.24417,
           8.54922,           9.68451,
          -0.03658,          -0.00963,
           1.65523,           0.43093,           0.32023,           0.71365,
          -0.12226,           0.03759,
           0.10388,           0.47212,          -0.02791,           0.09929,
          -0.04116,          -0.03125,
          -0.10240,          -0.23199,          -0.03524,          -0.13625,
           7.52726,           6.86314,           0.01239,          13.46530,
          -5.22256,           1.56116,          -0.15925,          -1.19571,
           3.26302,           0.06097,          -0.14444,          -0.20301,
           1.93822,         -80.12566,
           0.98665,          -7.52986,           3.86703,          -2.43028,
           0.64180,           0.78351,
           0.00190,          -0.00633,
          -0.00321,          -0.04403,
           0.19018,           0.14335,           0.10315,           0.53154,
          -0.00062,          -0.00464,
          -0.00109,           0.02150,
           1.19993,          47.21638,         -24.56067,          25.06332,
          -7.50751,          -6.36250,           1.39443,          -1.23806,
           0.04951,           0.02176,
           0.02802,          -0.01665,
          -0.10698,          -0.13635,
          73.54797,         -52.34968,          74.98754,          86.56283,
         -69.01463,          44.56866,
           0.04387,          -0.05925,
          -0.03732,          -0.03264,
           0.00967,           0.02143,
          10.59429,          26.48226,          34.03470,           3.96160,
           4.15919,         -20.22616,          -5.25903,          -3.40177,
           0.05111,          -0.06788,
           0.06497,           1.21024,          -0.29607,           0.49991,
          -0.06055,          -0.03464,
           0.02950,           0.16429,
           0.00722,          -0.90806,
          -0.02161,           0.00902,
          -0.00261,           0.00077,
           0.00434,          -0.29231,
           0.00456,           0.04781,
           1.33214,          -2.62015,           0.79761,          -0.81850,
           0.06371,           0.00119,
           0.03049,          -0.03553,           0.02373,          -0.01411,
        -189.06132,        -169.17940,           5.27464,        -227.72664,
          83.72511,         -12.04794,           0.23965,          23.75496,
          -3.43532,          -0.34276,
          -1.35880,           0.45053,          -0.34298,          -0.11441,
          -0.16328,           0.07423,
         481.48150,          79.82461,         453.82764,         941.94205,
        -635.83924,         397.29087,         -81.54066,        -417.22420,
         149.91822,          10.53490,
          -0.13210,           0.36740,
           0.33777,           0.15893,
       -2562.04968,        2442.77844,       -2602.66709,        2838.87348,
         723.50715,       -1284.58208,       -4557.23362,       -4514.61100,
       -8960.81693,        4663.55087,       -4947.61530,       19377.42027,
          -0.16786,          -0.19514,
           0.32100,           0.91502,
           4.96600,          -1.11836,
         307.38057,         175.14618,          16.02093,         444.42376,
        -219.80047,          62.39286,         -18.14266,         -52.23698,
           0.02111,           0.00469,
         -20.97409,         -34.48296,          -2.03906,         -27.07560,
           3.73818,          -3.00599,           0.24112,           0.41430,
          -0.03552,           0.00394,
          -0.00217,           0.02307,
           0.03686,           0.00510,
          34.46537,          10.23293,           9.99520,          28.88781,
         -11.31210,           3.52646,          -0.48062,          -2.93641,
          -0.00987,          -0.05310,
         -38.39539,           0.04568,         -31.73684,          -1.83151,
         -24.97332,          -1.71244,           0.33498,           7.03899,
          -4.15247,         200.43434,
          -0.00800,           0.04462,
          37.83113,         -13.40661,           9.49434,         -35.41588,
         -14.72767,          -3.84674,          -0.31412,           3.97734,
           0.02908,          -0.00353,
           1.89935,         -14.31774,           7.77051,          -7.08945,
           1.90915,           1.78908,          -0.41445,           0.30506,
         -14.43121,           7.30707,         -11.97842,         -17.64121,
          13.38962,          -7.20982,
          -5.23362,           2.11364,          -0.45605,           4.08835,
           1.42683,           0.24838,
          -0.00605,           0.03199,
          -0.17609,          -1.43091,           0.32444,          -0.51371,
           0.06182,           0.03733,
           0.00696,          -0.13438,
           4.67581,           4.42379,          -1.52602,           4.20659,
          -1.31757,          -0.72910,
           1.29012,           0.97780,           2.25895,          -0.85306,
           1.74120,          -5.09507,
           0.28107,          -0.05040,           0.05508,          -0.06349,
          -0.00061,           0.48249,
          -2.37749,           1.78180,          -1.67423,          -0.35618,
           0.05789,          -0.35287,
           0.56252,          -0.66584,           0.61979,           4.84016,
          -4.64462,          17.48002,
           0.40982,          -4.19214,          -1.55252,          -1.87505,
          -0.31070,           0.15554,
          -0.00034,           0.11102,
           0.01116,          -0.04166,
           9.27689,          -4.32090,           6.84888,           1.78741,
          -0.09306,           1.68391,          -0.27482,          -0.04197,
          -7.83068,          37.71086,         -37.53346,           7.18559,
           0.74427,         -24.29751,          10.87837,           1.35503,
           0.00998,          -0.03395,
        -133.52206,        -150.11329,           4.27494,        -173.79469,
         150.87961,        -356.29181,        -330.17873,        -426.29809,
        -607.98186,         126.35464,        -299.69623,         556.41055,
          -0.00342,           0.04411,
          44.65946,          42.07312,          85.71397,           5.95130,
          24.98064,         -41.20026,         -14.05970,         -10.46101,
          -2.24038,           2.89211,
           0.06175,           0.08128,           0.00705,           0.01939,
          -1.08361,          -0.08213,          -0.20868,          -0.36268,
          -4.96489,          -2.05966,          -6.16586,           3.65514,
          -3.12555,          12.20821,
          -1.11236,          -1.73772,          -1.34045,          -0.22774,
          -0.08639,           0.27355,
          -0.07700,           1.06260,          -0.46013,           0.31916,
          -0.04969,          -0.09488,
          -1.54000,           0.04949,          -0.07616,          -0.95933,
           0.93303,           3.43183,
          -0.82917,          -0.82042,          -0.68158,           0.17083,
           0.06942,           0.17491,
          -0.02699,          -0.01051,
           0.00657,           0.03063,
          -0.52595,           0.84035,          -0.88323,          -0.70188,
           0.60928,          -0.48179,
           0.38290,           0.04482,           0.26456,          -0.32369,
          -0.00615,           0.03218,
          -0.32943,           0.14675,          -0.10782,          -0.09036,
          -0.58003,           0.72888,          -0.46654,           1.17977,
           0.00222,           0.01541,
          -0.19226,          -0.07770,          -0.01829,          -0.05070,
          -1.75385,          -1.32969,           0.52361,          -1.36036,
           0.67222,           1.34612,
           6.96841,         -29.24025,         -23.76900,         -39.91647,
         -41.01215,          -2.23638,         -18.81024,          20.77095,
          -0.68592,          -2.26212,          -1.14065,          -0.76493,
          -0.18044,           0.15193,
          -0.20669,          -0.44387,           0.25697,          -0.17880,
          -0.53097,           0.43181,          -0.35187,           0.71934,
          -0.14962,           0.09220,          -0.05031,          -0.03924,
           0.06571,           0.29487,
           0.05170,           0.36847,
           0.02754,          -0.00411,
          -0.08313,          -0.16907,           0.10273,          -0.07315,
          -0.02312,           0.04912,
          -0.01062,          -0.02713,
           0.03806,           0.13401,
          -1.79865,          -2.04540,          -2.69965,          -0.65706,
          -1.17916,           0.79292,
           0.02415,           0.14001,
          -0.01767,           0.04209,
           0.05212,          -0.01795,
           0.01285,           0.04028,
           0.01075,           0.05533,
           0.02323,          -0.00864,
          -0.04691,           0.03128,
           0.00548,           0.02254,
           0.00011,           0.12033,
  };
  static final double juptabb[] = {
         548.59659,         594.29629,         219.97664,          59.71822,
          23.62157,          40.77732,         227.07380,
           0.00293,          -0.00745,
        -307.33226,        -347.92807,        -309.49383,        -428.18929,
         -96.59506,        -191.36254,           2.11014,         -34.44145,
           2.23085,           6.77110,          -5.43468,          -0.28391,
           0.28355,          -1.81690,
           0.00036,           0.00078,
          -1.83259,           1.17464,          -2.66976,          -0.92339,
          -0.23645,          -1.20623,           0.25248,          -0.04958,
           0.00064,           0.03599,
          -0.00079,           0.00004,          -0.00005,          -0.00010,
          -0.00024,           0.00051,
           0.00001,           0.00005,
           0.00015,           0.00010,
           0.00017,          -0.00004,
           0.00113,          -0.00011,
           0.00021,           0.00087,
           0.00120,          -0.00114,          -0.00881,          -0.00020,
          -0.00005,           0.00009,
           0.00005,           0.00007,
           0.00002,          -0.00033,
          -0.00554,          -0.32274,           0.23695,          -0.11184,
           0.04050,           0.09929,          -0.02189,           0.00305,
          -0.00142,          -0.00055,
           0.66623,           0.34590,           0.74913,          -0.23202,
          -1.08316,          -1.40407,           1.72287,          -0.07604,
           0.00024,           0.00004,
           0.03592,           0.91143,          -1.11848,          -0.17473,
           0.91500,          -1.34912,           0.85229,           0.69029,
          -0.00019,           0.00075,
           0.03615,           0.30768,          -0.08733,           0.12016,
          -0.01716,          -0.01138,
           0.00021,           0.00004,
           0.00531,           0.00098,
          -0.14354,          -0.02364,          -0.05559,          -0.07561,
           0.01419,          -0.01141,           0.00014,           0.00218,
          -0.36564,           0.13498,          -0.13283,          -0.11462,
           0.23741,           0.14960,          -0.23173,           0.25148,
           0.00763,          -0.05987,
          -0.00857,           0.20312,          -0.29399,           0.34831,
          -1.33166,          -0.46808,
          -0.00027,           0.00046,
           0.15729,           0.01367,           0.04093,           0.07447,
          -0.01598,           0.00785,
           0.00583,           0.00324,           0.00053,           0.00160,
          -0.00030,           0.00043,
          -0.00208,           0.00334,          -0.00316,           0.00136,
           0.23086,           0.05711,           0.19558,           0.05897,
           0.01070,           0.05021,          -0.00818,          -0.02242,
           0.06301,          -0.26483,           0.66177,           0.02125,
           0.13477,           0.19376,
          -0.36520,           0.83588,          -0.69848,          -0.00877,
           0.01626,          -0.23878,
          -0.00373,           0.00044,
           0.00008,          -0.00004,
          -0.00374,          -0.00283,           0.01104,          -0.00619,
           0.00004,           0.00015,
           0.00026,           0.00013,
           0.04630,          -0.11815,           0.00773,           0.03796,
          -0.05172,           0.00149,           0.00444,          -0.01493,
          -0.00064,          -0.00044,
          -0.00033,           0.00002,
          -0.00012,           0.00284,
          -0.15622,          -0.92158,          -0.82690,          -1.52101,
          -0.55934,           0.69375,
          -0.00171,           0.00031,
           0.00129,          -0.00013,
          -0.00024,          -0.00083,
           0.66101,          -0.21764,          -0.43967,           0.30157,
           0.53389,           1.59141,           1.94286,           0.14146,
          -0.00064,          -0.00006,
           0.21850,          -0.02912,           0.08594,           0.08734,
          -0.01678,           0.01629,
           0.00133,           0.00562,
           0.00128,          -0.00025,
          -0.00005,           0.00027,
           0.00032,           0.00001,
           0.00037,           0.00042,
           0.00070,           0.00003,
           0.00275,          -0.13096,           0.02329,          -0.05582,
           0.00405,          -0.00251,
           0.01316,          -0.01165,           0.00279,          -0.00374,
         -39.62783,          20.91467,         -28.97236,           3.77560,
          -3.30029,           0.11472,          -0.48216,           1.05814,
          -0.21607,          -0.03055,
          -0.64162,          -0.57355,          -0.05861,          -0.18592,
          -0.12207,          -0.06279,
         -38.55325,        -125.74207,         -47.22357,          41.75842,
        -119.38841,          18.88515,         -11.04830,         -50.98851,
          16.64895,           1.76553,
           0.09474,           0.03714,
           0.02593,           0.07967,
       -1187.61854,       -1094.91786,       -1011.21939,       -1102.25998,
        -575.88672,        -107.84860,        -890.58889,        -807.06589,
         971.78461,       -1287.24560,       -4601.44669,        -849.54329,
          -0.00904,           0.06233,
          -0.19456,          -0.05521,
          -0.36915,           1.15363,
          32.64763,         -85.19705,         114.34437,         -13.37747,
          15.92865,          55.84857,         -13.10538,           3.07629,
          -0.00327,           0.00104,
          -7.81035,           6.19960,          -6.36096,           1.00493,
          -0.66971,          -0.84572,           0.09943,          -0.04583,
           0.00200,          -0.00032,
          -0.00265,           0.00047,
          -0.00053,           0.00046,
          -0.24396,           0.20664,          -0.30820,          -0.04917,
           0.06184,          -0.12642,           0.03053,           0.05054,
           0.00035,           0.00012,
           0.42063,          -0.58254,           0.90517,          -0.66276,
           0.64765,           0.39338,          -1.40645,           0.33017,
          -1.43377,          -0.67089,
          -0.00045,          -0.00036,
           0.23690,           0.07185,           0.28386,          -0.04397,
           0.02836,          -0.13082,          -0.00978,           0.00108,
           0.00046,           0.00083,
          -0.01665,           0.32499,          -0.09980,           0.18611,
          -0.02561,           0.00239,          -0.00084,          -0.00110,
           0.46854,          -0.35113,           0.69908,           0.53244,
           0.12875,           0.01115,
           0.13930,           0.02747,          -0.10587,          -0.17759,
          -0.26850,           0.04400,
           0.00010,          -0.00015,
           0.00164,          -0.01308,           0.00488,          -0.01046,
           0.00170,           0.00024,
           0.00084,           0.00014,
          -0.08481,          -0.02547,          -0.02290,          -0.02281,
          -0.03946,          -0.02810,
           0.01298,           0.08658,           0.05575,          -0.01081,
           1.09695,           0.35441,
          -0.03127,           0.07946,           0.01245,           0.02578,
          -0.00524,          -0.00027,
           0.08217,          -0.31742,           0.15273,          -0.07804,
           0.01197,           0.03053,
           0.81596,           0.38640,          -0.89777,           0.59499,
          -0.39581,          -0.87375,
           0.02096,           0.49772,           0.29986,           0.24210,
           0.14038,          -0.03016,
          -0.00208,           0.00045,
           0.01024,           0.00114,
           1.23010,           1.75663,          -0.12741,           1.44996,
          -0.31607,           0.03151,           0.00259,          -0.04741,
         -11.57091,           8.00331,          -9.24028,          -6.36906,
           4.71248,          -2.43695,           0.38630,           1.90625,
           0.01401,           0.00114,
          33.56690,         -55.17784,          33.21425,         -52.57002,
          27.04138,          13.78610,          69.60307,         -81.16312,
          27.53960,        -158.28336,        -205.94418,         -95.08051,
          -0.01407,          -0.00364,
         -18.56128,           6.02270,         -10.11059,          24.69471,
          12.31878,           9.94393,           3.81994,          -4.84109,
          -1.08440,          -0.72136,
           0.03731,          -0.02094,           0.00789,          -0.00176,
           0.09673,          -0.11181,           0.03112,          -0.00065,
          -0.29167,          -0.82083,           0.40866,          -0.77487,
          -2.23349,          -0.46973,
           0.41024,          -0.14274,           0.07755,          -0.24895,
          -0.04965,          -0.01197,
          -0.02264,           0.05917,          -0.02817,           0.01242,
          -0.00250,          -0.00247,
          -0.14414,          -0.03739,           0.14708,          -0.07908,
           0.05843,           0.15173,
          -0.01601,          -0.07844,          -0.05957,          -0.03143,
          -0.01830,           0.01257,
          -0.00109,          -0.00000,
           0.00174,           0.00050,
          -0.02119,           0.06918,          -0.02470,           0.00185,
           0.02372,          -0.02417,
           0.01081,           0.05222,           0.09820,           0.05931,
          -0.00588,          -0.00086,
           0.01688,          -0.00133,          -0.00073,           0.00041,
          -0.02280,          -0.05706,          -0.17694,          -0.12027,
           0.00196,          -0.00060,
           0.00051,          -0.02426,           0.00314,          -0.00302,
           0.17923,          -0.78343,           0.52073,          -0.02398,
          -0.03978,           0.20841,
           6.51325,           3.37139,          12.88844,          -6.72098,
           3.40949,         -14.34313,          -9.68278,          -7.85143,
           1.06886,          -0.21727,           0.36675,          -0.49815,
          -0.07289,          -0.07537,
           0.01107,          -0.00644,           0.01013,          -0.00306,
          -0.00708,          -0.13488,          -0.23041,          -0.10698,
          -0.00049,          -0.00692,          -0.00142,          -0.00211,
          -0.04021,           0.01805,
           0.00479,           0.00620,
           0.00739,           0.00566,
          -0.00101,          -0.00022,           0.00261,          -0.00188,
          -0.01812,          -0.01205,
          -0.00061,          -0.00061,
          -0.02479,           0.01157,
           0.91642,          -0.65781,           0.39969,          -1.13699,
          -0.43337,          -0.57828,
           0.00145,           0.00281,
          -0.01675,          -0.00975,
           0.00119,          -0.00074,
          -0.00343,           0.00139,
           0.00061,           0.00086,
           0.00054,          -0.00046,
          -0.01996,          -0.02689,
           0.00034,           0.00037,
          -0.00006,           0.00001,
  };
  static final double juptabr[] = {
        -734.58857,       -1081.04460,        -551.65750,        -148.79782,
         -25.23171,         164.64781,         248.64813,
          -0.05163,          -0.02413,
       -1306.61004,         560.02437,       -1622.58047,         589.92513,
        -812.39674,         166.85340,        -157.92826,        -107.14755,
          68.98900,         -18.95875,          -0.16183,          36.24345,
          -9.19972,          -2.29315,
          -0.00316,           0.00222,
          10.95234,          21.37177,          -6.29550,          21.83656,
          -7.70755,           1.38228,          -0.21770,          -1.49525,
           0.17951,           0.01043,
           0.00062,           0.00208,          -0.00066,           0.00050,
           0.00313,           0.00187,
           0.00010,           0.00131,
           0.00102,           0.00047,
           0.00102,           0.00012,
           0.00012,          -0.00037,
           0.00808,           0.00027,
          -0.01219,          -0.00961,          -0.04166,          -0.00327,
          -0.00001,          -0.00146,
          -0.00092,          -0.00989,
          -0.00135,           0.00196,
           0.19216,           2.48442,          -1.43599,           1.39651,
          -0.48549,          -0.53272,           0.14066,          -0.10352,
           0.00141,           0.00066,
           2.96838,          -3.09575,           6.27741,           5.24306,
          -8.77080,           9.03247,         -10.98350,          -3.58579,
          -0.00168,          -0.00100,
           0.20234,          -0.75737,           0.36838,          -0.58241,
           0.41430,          -0.35784,           0.47038,          -0.10586,
           0.00539,           0.00490,
          -0.01375,          -0.01950,           0.00145,           0.00723,
          -0.00391,           0.00391,
          -0.00131,          -0.00568,
           0.01317,           0.00319,
           1.31006,           5.89394,          -1.61753,           3.68814,
          -0.80644,          -0.14747,           0.04481,          -0.11361,
          -4.36130,           7.92488,         -16.29047,          -1.52163,
           2.14492,         -14.38028,           9.65573,           3.56881,
          -1.87208,           3.36213,
           1.84499,          -2.41575,          -2.77076,          -3.23915,
          -3.34573,           1.40979,
           0.00217,          -0.00841,
           0.29313,          -0.36246,           0.22043,           0.02328,
          -0.01182,           0.04074,
          -0.15728,           0.02468,          -0.03185,          -0.01099,
           0.01059,          -0.01274,
           0.07362,          -0.02642,           0.04035,          -0.00968,
          -2.14457,           2.53297,          -4.34196,          -0.11421,
          -0.38757,          -1.73872,           0.39784,          -0.01397,
          -0.03311,           0.97723,           0.16060,          -0.07486,
          25.96413,           0.75088,
          -3.04736,           0.30340,          -1.43451,          -1.35136,
           0.26526,          -0.40247,
          -0.00460,          -0.00056,
           0.01633,          -0.00128,
          -0.05197,           0.07002,          -0.19450,           0.03737,
           0.00188,          -0.00037,
          -0.00903,          -0.00059,
         -19.73809,           0.58424,         -10.42034,         -10.14579,
           2.65990,          -3.07889,           0.50884,           0.58508,
          -0.00970,           0.02099,
           0.00716,           0.01161,
           0.05751,          -0.04515,
          22.08042,          30.82415,         -36.27430,          31.40265,
         -18.30150,         -29.16403,
           0.02454,           0.01834,
          -0.01312,           0.01576,
          -0.00928,           0.00330,
         -11.78094,           4.06738,          -2.51590,          15.05277,
           9.12747,           2.88088,           2.32916,          -2.08271,
           0.02872,           0.02194,
           0.60494,          -0.04597,           0.24749,           0.15971,
          -0.02185,           0.03384,
          -0.07075,           0.01287,
           0.40201,           0.00347,
          -0.00410,          -0.00998,
          -0.00005,          -0.00121,
           0.13770,           0.00186,
          -0.02268,           0.00210,
           1.26291,           0.65546,           0.38885,           0.38880,
          -0.00184,           0.03067,
           0.01273,           0.01136,           0.00557,           0.01117,
          94.13171,         -88.37882,         120.53292,           8.32903,
           7.77313,          43.46523,         -11.66698,           0.44639,
           0.15092,          -1.68367,
          -0.30833,          -0.49030,           0.01971,          -0.14144,
          -0.04019,          -0.05110,
         -39.70024,         272.91667,        -468.46263,         256.77696,
        -200.63130,        -307.98554,         206.56301,         -41.76039,
          -4.74242,          74.19909,
           0.18474,           0.05547,
          -0.06732,           0.16515,
       -1156.31285,       -1102.97666,       -1346.99288,       -1121.01090,
         666.84550,         421.92305,        2259.49740,       -2268.69758,
       -2325.87639,       -4476.46256,       -9683.77583,       -2472.92565,
          -0.10400,           0.08075,
          -0.45225,           0.16621,
           0.57789,           2.43804,
          85.21675,        -154.17208,         219.91042,          -9.71116,
          31.13240,         108.60117,         -25.85622,           8.98402,
          -0.00233,           0.01030,
         -17.01324,          10.41588,         -13.34449,           1.08782,
          -1.48199,          -1.81734,           0.20334,          -0.11734,
          -0.00230,          -0.01869,
          -0.01182,          -0.00129,
          -0.00281,           0.02021,
          -5.75973,          19.13309,         -16.13690,           5.53382,
          -1.96585,          -6.29211,           1.63105,          -0.26089,
           0.02935,          -0.00555,
           0.30700,         -19.96182,           0.99825,         -16.32664,
           0.83052,         -13.76201,          -3.15609,           0.17360,
        -111.81423,          -2.05419,
          -0.02455,          -0.00478,
           7.45114,          21.53296,          19.90263,           5.69420,
           2.31253,          -8.15116,          -2.17440,          -0.23014,
           0.00168,           0.01590,
           8.78005,           0.71418,           4.48561,           4.50680,
          -1.05713,           1.17880,          -0.19327,          -0.24877,
          -5.00870,          -8.66354,          10.51902,          -7.71011,
           4.65486,           8.05673,
          -1.39635,          -3.07669,          -2.40347,          -0.11167,
          -0.04064,           0.83512,
          -0.02041,          -0.00351,
           0.97375,          -0.15795,           0.36361,           0.19913,
          -0.02142,           0.04193,
           0.08801,           0.00475,
          -2.81010,           3.11341,          -2.79191,          -0.93313,
           0.44570,          -0.88287,
          -0.51815,           0.54776,           0.29736,           0.99779,
           2.28957,           0.82183,
           0.03386,           0.12855,           0.03124,           0.02454,
          -0.31958,           0.00070,
          -1.48184,          -1.28195,           0.03965,          -1.12026,
           0.23910,           0.01293,
           0.36146,          -0.64483,          -1.88470,           0.21469,
         -11.79819,          -1.87287,
           2.65699,          -0.36287,           0.88148,          -1.26883,
          -0.19657,          -0.14279,
          -0.07536,          -0.00004,
           0.01496,           0.00537,
           2.48352,           3.75581,          -0.34909,           3.26696,
          -0.82105,           0.11287,          -0.00755,          -0.13764,
         -15.34429,          -2.79957,          -3.22976,         -15.46084,
          10.66793,          -0.26054,          -0.12188,           5.06211,
           0.01313,           0.00424,
          84.34332,         -57.05646,          92.68150,          -0.02024,
         149.62698,          59.14407,         174.04569,        -129.26785,
         -55.99789,        -238.01484,        -212.51618,        -115.94914,
          -0.01720,          -0.00158,
         -13.65602,          17.47396,           0.16714,          32.66367,
          16.30095,           9.18345,           3.98555,          -5.39985,
          -1.09958,          -0.86072,
           0.02752,          -0.02474,           0.00671,          -0.00278,
          -0.21030,          -0.73658,           0.20708,          -0.21378,
           0.78462,          -2.14051,          -1.60070,          -2.60915,
          -5.02441,          -1.19246,
           0.67622,          -0.41889,           0.07430,          -0.53204,
          -0.11214,          -0.03417,
          -0.72636,          -0.15535,          -0.16815,          -0.35603,
           0.07530,          -0.02521,
          -0.01261,          -0.94883,           0.39930,          -0.05370,
          -2.77309,           0.38431,
           0.72127,          -0.52030,          -0.01804,          -0.51188,
          -0.11993,           0.02189,
           0.00928,          -0.02129,
          -0.02760,           0.00441,
          -0.56832,          -0.48114,           0.64192,          -0.65656,
           0.37483,           0.51883,
          -0.08474,           0.20324,           0.12783,           0.13041,
          -0.01545,          -0.00282,
          -0.16196,          -0.26980,           0.06584,          -0.09987,
          -0.36305,          -0.27610,          -0.57074,          -0.13607,
          -0.00824,           0.00369,
           0.06094,          -0.12214,           0.03581,          -0.00876,
           0.49346,          -0.74596,           0.47814,           0.18201,
          -1.00640,           0.24465,
          10.09808,           2.30496,          13.63359,          -7.94007,
           0.29792,         -13.55724,          -6.48556,          -5.99581,
           0.69686,          -0.22434,           0.23198,          -0.35579,
          -0.04736,          -0.05683,
           0.36710,          -0.16571,           0.14876,           0.21824,
          -0.18940,          -0.15063,          -0.23692,          -0.09990,
          -0.08923,          -0.12222,           0.02998,          -0.04560,
          -0.16229,           0.04552,
          -0.33051,           0.02585,
          -0.00622,           0.01583,
           0.15436,          -0.07109,           0.06429,           0.09218,
          -0.01277,          -0.00019,
           0.02345,          -0.01057,
          -0.07294,           0.02506,
           0.62063,          -0.52533,           0.16814,          -0.77168,
          -0.20614,          -0.31828,
          -0.12856,           0.01316,
          -0.01522,          -0.00126,
           0.01558,           0.04765,
          -0.02776,           0.01166,
          -0.05185,           0.00674,
           0.00754,           0.02183,
          -0.00645,          -0.01050,
          -0.02155,           0.00375,
           0.12040,          -0.00004,
  };
  static byte jupargs[] = {
  (byte)0,  (byte)6,
  (byte)3,  (byte)2,  (byte)5, (byte)-6,  (byte)6,  (byte)3,  (byte)7,  (byte)0,
  (byte)2,  (byte)2,  (byte)5, (byte)-5,  (byte)6,  (byte)6,
  (byte)3,  (byte)1,  (byte)5, (byte)-2,  (byte)6, (byte)-3,  (byte)8,  (byte)0,
  (byte)2,  (byte)4,  (byte)5,(byte)-10,  (byte)6,  (byte)4,
  (byte)3,  (byte)2,  (byte)5, (byte)-4,  (byte)6, (byte)-3,  (byte)7,  (byte)1,
  (byte)3,  (byte)3,  (byte)5,(byte)-10,  (byte)6,  (byte)7,  (byte)7,  (byte)0,
  (byte)2,  (byte)6,  (byte)5,(byte)-15,  (byte)6,  (byte)0,
  (byte)3,  (byte)1,  (byte)5, (byte)-4,  (byte)6,  (byte)4,  (byte)7,  (byte)0,
  (byte)3,  (byte)3,  (byte)5, (byte)-8,  (byte)6,  (byte)2,  (byte)7,  (byte)0,
  (byte)3,  (byte)1,  (byte)5, (byte)-3,  (byte)6,  (byte)1,  (byte)7,  (byte)0,
  (byte)3,  (byte)1,  (byte)5, (byte)-3,  (byte)6,  (byte)2,  (byte)7,  (byte)0,
  (byte)1,  (byte)1,  (byte)7,  (byte)1,
  (byte)2,  (byte)5,  (byte)5,(byte)-12,  (byte)6,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-7,  (byte)6,  (byte)7,  (byte)7,  (byte)0,
  (byte)3,  (byte)1,  (byte)5, (byte)-1,  (byte)6, (byte)-3,  (byte)7,  (byte)0,
  (byte)2,  (byte)3,  (byte)5, (byte)-7,  (byte)6,  (byte)3,
  (byte)3,  (byte)1,  (byte)5, (byte)-4,  (byte)6,  (byte)3,  (byte)7,  (byte)0,
  (byte)2,  (byte)1,  (byte)5, (byte)-2,  (byte)6,  (byte)3,
  (byte)3,  (byte)3,  (byte)5, (byte)-8,  (byte)6,  (byte)3,  (byte)7,  (byte)0,
  (byte)2,  (byte)1,  (byte)5, (byte)-3,  (byte)6,  (byte)3,
  (byte)3,  (byte)1,  (byte)5, (byte)-3,  (byte)6,  (byte)3,  (byte)7,  (byte)0,
  (byte)2,  (byte)3,  (byte)5, (byte)-8,  (byte)6,  (byte)2,
  (byte)3,  (byte)2,  (byte)5, (byte)-5,  (byte)6,  (byte)2,  (byte)7,  (byte)0,
  (byte)1,  (byte)2,  (byte)7,  (byte)0,
  (byte)2,  (byte)4,  (byte)5, (byte)-9,  (byte)6,  (byte)3,
  (byte)2,  (byte)2,  (byte)5, (byte)-4,  (byte)6,  (byte)4,
  (byte)1,  (byte)1,  (byte)6,  (byte)2,
  (byte)3,  (byte)2,  (byte)5, (byte)-5,  (byte)6,  (byte)3,  (byte)7,  (byte)0,
  (byte)2,  (byte)2,  (byte)5, (byte)-6,  (byte)6,  (byte)2,
  (byte)2,  (byte)5,  (byte)5,(byte)-11,  (byte)6,  (byte)1,
  (byte)3,  (byte)1,  (byte)5, (byte)-2,  (byte)7, (byte)-2,  (byte)8,  (byte)0,
  (byte)2,  (byte)1,  (byte)5, (byte)-3,  (byte)7,  (byte)1,
  (byte)2,  (byte)3,  (byte)5, (byte)-6,  (byte)6,  (byte)3,
  (byte)2,  (byte)1,  (byte)5, (byte)-1,  (byte)6,  (byte)2,
  (byte)2,  (byte)1,  (byte)5, (byte)-4,  (byte)6,  (byte)2,
  (byte)2,  (byte)3,  (byte)5, (byte)-9,  (byte)6,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-4,  (byte)6,  (byte)2,  (byte)7,  (byte)0,
  (byte)2,  (byte)1,  (byte)5, (byte)-2,  (byte)7,  (byte)1,
  (byte)2,  (byte)6,  (byte)5,(byte)-13,  (byte)6,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-2,  (byte)6, (byte)-3,  (byte)7,  (byte)0,
  (byte)2,  (byte)4,  (byte)5, (byte)-8,  (byte)6,  (byte)3,
  (byte)2,  (byte)3,  (byte)6, (byte)-3,  (byte)7,  (byte)0,
  (byte)3,  (byte)6,  (byte)5,(byte)-14,  (byte)6,  (byte)3,  (byte)7,  (byte)0,
  (byte)3,  (byte)1,  (byte)5, (byte)-2,  (byte)7,  (byte)1,  (byte)8,  (byte)0,
  (byte)2,  (byte)2,  (byte)5, (byte)-3,  (byte)6,  (byte)2,
  (byte)3,  (byte)1,  (byte)5, (byte)-4,  (byte)7,  (byte)5,  (byte)8,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-8,  (byte)6,  (byte)3,  (byte)7,  (byte)0,
  (byte)3,  (byte)4,  (byte)5, (byte)-9,  (byte)6,  (byte)3,  (byte)7,  (byte)0,
  (byte)1,  (byte)2,  (byte)6,  (byte)3,
  (byte)3,  (byte)2,  (byte)5, (byte)-4,  (byte)6,  (byte)3,  (byte)7,  (byte)0,
  (byte)2,  (byte)2,  (byte)5, (byte)-7,  (byte)6,  (byte)2,
  (byte)2,  (byte)1,  (byte)5, (byte)-2,  (byte)8,  (byte)0,
  (byte)2,  (byte)1,  (byte)5, (byte)-1,  (byte)7,  (byte)0,
  (byte)3,  (byte)3,  (byte)5, (byte)-6,  (byte)6,  (byte)2,  (byte)7,  (byte)0,
  (byte)3,  (byte)4,  (byte)5, (byte)-8,  (byte)6,  (byte)2,  (byte)8,  (byte)0,
  (byte)2,  (byte)1,  (byte)5, (byte)-1,  (byte)8,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-3,  (byte)6,  (byte)1,  (byte)7,  (byte)0,
  (byte)2,  (byte)7,  (byte)5,(byte)-15,  (byte)6,  (byte)2,
  (byte)3,  (byte)3,  (byte)5, (byte)-4,  (byte)6, (byte)-3,  (byte)7,  (byte)1,
  (byte)2,  (byte)5,  (byte)5,(byte)-10,  (byte)6,  (byte)4,
  (byte)3,  (byte)1,  (byte)5,  (byte)1,  (byte)6, (byte)-3,  (byte)7,  (byte)1,
  (byte)3,  (byte)7,  (byte)5,(byte)-16,  (byte)6,  (byte)3,  (byte)7,  (byte)0,
  (byte)2,  (byte)3,  (byte)5, (byte)-5,  (byte)6,  (byte)4,
  (byte)3,  (byte)1,  (byte)5, (byte)-6,  (byte)6,  (byte)3,  (byte)7,  (byte)0,
  (byte)3,  (byte)5,  (byte)5,(byte)-11,  (byte)6,  (byte)3,  (byte)7,  (byte)0,
  (byte)1,  (byte)1,  (byte)5,  (byte)5,
  (byte)3,  (byte)3,  (byte)5,(byte)-11,  (byte)6,  (byte)3,  (byte)7,  (byte)0,
  (byte)3,  (byte)3,  (byte)5, (byte)-6,  (byte)6,  (byte)3,  (byte)7,  (byte)0,
  (byte)2,  (byte)2,  (byte)5, (byte)-7,  (byte)7,  (byte)0,
  (byte)2,  (byte)1,  (byte)5, (byte)-5,  (byte)6,  (byte)3,
  (byte)3,  (byte)1,  (byte)5, (byte)-1,  (byte)6,  (byte)3,  (byte)7,  (byte)0,
  (byte)2,  (byte)3,  (byte)5,(byte)-10,  (byte)6,  (byte)3,
  (byte)3,  (byte)2,  (byte)5, (byte)-3,  (byte)6,  (byte)2,  (byte)7,  (byte)0,
  (byte)2,  (byte)1,  (byte)5,  (byte)1,  (byte)7,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-1,  (byte)6, (byte)-3,  (byte)7,  (byte)0,
  (byte)2,  (byte)4,  (byte)5, (byte)-7,  (byte)6,  (byte)3,
  (byte)2,  (byte)4,  (byte)6, (byte)-3,  (byte)7,  (byte)0,
  (byte)2,  (byte)2,  (byte)5, (byte)-2,  (byte)6,  (byte)4,
  (byte)3,  (byte)4,  (byte)5, (byte)-8,  (byte)6,  (byte)3,  (byte)7,  (byte)0,
  (byte)1,  (byte)3,  (byte)6,  (byte)3,
  (byte)3,  (byte)2,  (byte)5, (byte)-3,  (byte)6,  (byte)3,  (byte)7,  (byte)0,
  (byte)2,  (byte)5,  (byte)5, (byte)-9,  (byte)6,  (byte)3,
  (byte)2,  (byte)3,  (byte)5, (byte)-4,  (byte)6,  (byte)2,
  (byte)2,  (byte)1,  (byte)5,  (byte)1,  (byte)6,  (byte)2,
  (byte)2,  (byte)2,  (byte)5, (byte)-4,  (byte)7,  (byte)0,
  (byte)2,  (byte)6,  (byte)5,(byte)-11,  (byte)6,  (byte)2,
  (byte)2,  (byte)2,  (byte)5, (byte)-3,  (byte)7,  (byte)0,
  (byte)2,  (byte)4,  (byte)5, (byte)-6,  (byte)6,  (byte)2,
  (byte)2,  (byte)2,  (byte)5, (byte)-1,  (byte)6,  (byte)2,
  (byte)1,  (byte)4,  (byte)6,  (byte)1,
  (byte)2,  (byte)2,  (byte)5, (byte)-2,  (byte)7,  (byte)0,
  (byte)2,  (byte)5,  (byte)5, (byte)-8,  (byte)6,  (byte)2,
  (byte)2,  (byte)3,  (byte)5, (byte)-3,  (byte)6,  (byte)2,
  (byte)2,  (byte)1,  (byte)5,  (byte)2,  (byte)6,  (byte)2,
  (byte)2,  (byte)2,  (byte)5, (byte)-2,  (byte)8,  (byte)0,
  (byte)2,  (byte)2,  (byte)5, (byte)-1,  (byte)7,  (byte)0,
  (byte)2,  (byte)6,  (byte)5,(byte)-10,  (byte)6,  (byte)3,
  (byte)2,  (byte)4,  (byte)5, (byte)-5,  (byte)6,  (byte)3,
  (byte)2,  (byte)6,  (byte)6, (byte)-3,  (byte)7,  (byte)0,
  (byte)1,  (byte)2,  (byte)5,  (byte)5,
  (byte)3,  (byte)4,  (byte)5, (byte)-6,  (byte)6,  (byte)3,  (byte)7,  (byte)0,
  (byte)1,  (byte)5,  (byte)6,  (byte)4,
  (byte)2,  (byte)2,  (byte)5,(byte)-10,  (byte)6,  (byte)1,
  (byte)2,  (byte)5,  (byte)5, (byte)-7,  (byte)6,  (byte)1,
  (byte)2,  (byte)3,  (byte)5, (byte)-2,  (byte)6,  (byte)2,
  (byte)2,  (byte)1,  (byte)5,  (byte)3,  (byte)6,  (byte)2,
  (byte)2,  (byte)6,  (byte)5, (byte)-9,  (byte)6,  (byte)2,
  (byte)2,  (byte)4,  (byte)5, (byte)-4,  (byte)6,  (byte)2,
  (byte)2,  (byte)2,  (byte)5,  (byte)1,  (byte)6,  (byte)2,
  (byte)2,  (byte)7,  (byte)5,(byte)-11,  (byte)6,  (byte)0,
  (byte)2,  (byte)3,  (byte)5, (byte)-3,  (byte)7,  (byte)0,
  (byte)2,  (byte)5,  (byte)5, (byte)-6,  (byte)6,  (byte)2,
  (byte)2,  (byte)3,  (byte)5, (byte)-1,  (byte)6,  (byte)1,
  (byte)2,  (byte)3,  (byte)5, (byte)-2,  (byte)7,  (byte)0,
  (byte)2,  (byte)6,  (byte)5, (byte)-8,  (byte)6,  (byte)1,
  (byte)2,  (byte)4,  (byte)5, (byte)-3,  (byte)6,  (byte)1,
  (byte)2,  (byte)2,  (byte)5,  (byte)2,  (byte)6,  (byte)0,
  (byte)2,  (byte)7,  (byte)5,(byte)-10,  (byte)6,  (byte)1,
  (byte)2,  (byte)5,  (byte)5, (byte)-5,  (byte)6,  (byte)2,
  (byte)1,  (byte)3,  (byte)5,  (byte)3,
  (byte)2,  (byte)1,  (byte)5,  (byte)5,  (byte)6,  (byte)2,
  (byte)2,  (byte)6,  (byte)5, (byte)-7,  (byte)6,  (byte)1,
  (byte)2,  (byte)4,  (byte)5, (byte)-2,  (byte)6,  (byte)1,
  (byte)2,  (byte)7,  (byte)5, (byte)-9,  (byte)6,  (byte)1,
  (byte)2,  (byte)5,  (byte)5, (byte)-4,  (byte)6,  (byte)0,
  (byte)2,  (byte)6,  (byte)5, (byte)-6,  (byte)6,  (byte)0,
  (byte)2,  (byte)4,  (byte)5, (byte)-1,  (byte)6,  (byte)0,
  (byte)2,  (byte)7,  (byte)5, (byte)-8,  (byte)6,  (byte)1,
  (byte)2,  (byte)5,  (byte)5, (byte)-3,  (byte)6,  (byte)0,
  (byte)2,  (byte)8,  (byte)5,(byte)-10,  (byte)6,  (byte)0,
  (byte)2,  (byte)6,  (byte)5, (byte)-5,  (byte)6,  (byte)0,
  (byte)1,  (byte)4,  (byte)5,  (byte)2,
  (byte)2,  (byte)7,  (byte)5, (byte)-7,  (byte)6,  (byte)0,
  (byte)2,  (byte)5,  (byte)5, (byte)-2,  (byte)6,  (byte)0,
  (byte)2,  (byte)8,  (byte)5, (byte)-9,  (byte)6,  (byte)0,
  (byte)2,  (byte)7,  (byte)5, (byte)-6,  (byte)6,  (byte)0,
  (byte)2,  (byte)8,  (byte)5, (byte)-8,  (byte)6,  (byte)0,
  (byte)2,  (byte)9,  (byte)5,(byte)-10,  (byte)6,  (byte)0,
  (byte)1,  (byte)5,  (byte)5,  (byte)0,
  (byte)2,  (byte)9,  (byte)5, (byte)-9,  (byte)6,  (byte)0,
  (byte)2,  (byte)1,  (byte)3, (byte)-1,  (byte)5,  (byte)0,
 (byte)-1
  };
  
  static Plantbl jup404 = new Plantbl(
                               new short[]{0,  0,  1,  0,  9, 16,  7,  5,  0},
                               (short)6,
                               jupargs,
                               juptabl,
                               juptabb,
                               juptabr,
                               5.2026032092000003e+00
  );
}
class SwemptabMar {
  
  static final double martabl[] = {
       43471.66140,       21291.11063,        2033.37848,  6890507597.78366,
     1279543.73631,
         317.74183,         730.69258,         -15.26502,         277.56960,
         -62.96711,          20.96285,
           1.01857,          -2.19395,
           3.75708,           3.65854,           0.01049,           1.09183,
          -0.00605,          -0.04769,
           0.41839,           0.10091,           0.03887,           0.11666,
          -0.03301,           0.02664,
           0.38777,          -0.56974,
           0.02974,          -0.15041,           0.02179,          -0.00808,
           0.08594,           0.09773,
          -0.00902,          -0.04597,           0.00762,          -0.03858,
          -0.00139,           0.01562,
           0.02019,           0.01878,
          -0.01244,           0.00795,
           0.00815,           0.03501,
          -0.00335,          -0.02970,
          -0.00518,          -0.01763,
           0.17257,           0.14698,          -0.14417,           0.26028,
           0.00062,          -0.00180,
          13.35262,          39.38771,         -15.49558,          22.00150,
          -7.71321,          -4.20035,           0.62074,          -1.42376,
           0.07043,          -0.06670,           0.16960,          -0.06859,
           0.07787,           0.01845,
          -0.01608,          -0.00914,
           5.60438,          -3.44436,           5.88876,           6.77238,
          -5.29704,           3.48944,
           0.01291,           0.01280,
          -0.53532,           0.86584,           0.79604,           0.31635,
          -3.92977,          -0.94829,          -0.74254,          -1.37947,
           0.17871,          -0.12477,
           0.00171,           0.11537,
           0.02281,          -0.03922,
          -0.00165,           0.02965,
           1.59773,           1.24565,          -0.35802,           1.37272,
          -0.44811,          -0.08611,
           3.04184,          -3.39729,           8.86270,           6.65967,
          -9.10580,          10.66103,
           0.02015,          -0.00902,
          -0.01166,          -0.23957,          -0.12128,          -0.04640,
          -0.07114,           0.14053,          -0.04966,          -0.01665,
           0.28411,          -0.37754,          -1.26265,           1.01377,
           3.70433,          -0.21025,
          -0.00972,           0.00350,
           0.00997,           0.00450,
          -2.15305,           3.18147,          -1.81957,          -0.02321,
          -0.02560,          -0.35188,
           0.00003,          -0.01110,
           0.00244,          -0.05083,
          -0.00216,          -0.02026,
           0.05179,           0.04188,
           5.92031,          -1.61316,           3.72001,           6.98783,
          -4.17690,           2.61250,
           0.04157,           2.76453,          -1.34043,           0.74586,
          -0.20258,          -0.30467,
           0.00733,           0.00376,
           1.72800,           0.76593,           1.26577,          -2.02682,
          -1.14637,          -0.91894,
          -0.00002,           0.00036,
           2.54213,           0.89533,          -0.04166,           2.36838,
          -0.97069,           0.05486,
           0.46927,           0.04500,           0.23388,           0.35005,
           1.61402,           2.30209,          -0.99859,           1.63349,
          -0.51490,          -0.26112,
           0.27848,          -0.26100,          -0.07645,          -0.22001,
           0.92901,           1.12627,          -0.39829,           0.77120,
          -0.23716,          -0.11245,
          -0.02387,           0.03960,
          -0.00802,           0.02179,
           2.86448,           1.00246,          -0.14647,           2.80278,
          -1.14143,           0.05177,
           1.68671,          -1.23451,           3.16285,           0.70070,
           0.25817,           3.17416,
           0.07447,          -0.08116,          -0.03029,          -0.02795,
           0.00816,           0.01023,
           0.00685,          -0.01075,
          -0.34268,           0.03680,          -0.05488,          -0.07430,
          -0.00041,          -0.02968,
           3.13228,          -0.83209,           1.95765,           3.78394,
          -2.26196,           1.38520,
          -0.00401,          -0.01397,
           1.01604,          -0.99485,           0.62465,           0.22431,
          -0.05076,           0.12025,
           4.35229,          -5.04483,          14.87533,           9.00826,
         -10.37595,          19.26596,
           0.40352,           0.19895,           0.09463,          -0.10774,
          -0.17809,          -0.08979,          -0.00796,          -0.04313,
           0.01520,          -0.03538,
           1.53301,          -1.75553,           4.87236,           3.23662,
          -3.62305,           6.42351,
          -0.00439,          -0.01305,
           0.17194,          -0.64003,           0.26609,           0.06600,
           0.01767,          -0.00251,
          -0.08871,          -0.15523,           0.01201,          -0.03408,
          -0.29126,          -0.07093,          -0.00998,          -0.07876,
           1.05932,         -25.38650,
          -0.29354,           0.04179,          -0.01726,           0.07473,
          -0.07607,          -0.08859,           0.00842,          -0.02359,
           0.47858,          -0.39809,           1.25061,           0.87017,
          -0.82453,           1.56864,
          -0.00463,           0.02385,
          -0.29070,           8.56535,
          -0.12495,           0.06580,          -0.03395,          -0.02465,
          -1.06759,           0.47004,          -0.40281,          -0.23957,
           0.03572,          -0.07012,
           0.00571,          -0.00731,
           0.18601,          -1.34068,
           0.03798,          -0.00532,           0.00448,          -0.01147,
           1.41208,          -0.00668,           0.25883,           1.23788,
          -0.57774,           0.09166,
          -2.49664,          -0.25235,          -0.53582,          -0.80126,
           0.10827,          -0.08861,
          -0.03577,           0.06825,
          -0.00143,           0.04633,
           0.01586,          -0.01056,
          -0.02106,           0.03804,
          -0.00088,          -0.03458,
          -0.00033,          -0.01079,
           0.05821,          -0.02445,
           0.00602,           0.00721,
          -0.00315,          -0.01021,
          -0.65454,           1.08478,          -0.44593,          -0.21492,
          -1.35004,           4.47299,          -4.19170,           3.51236,
        1946.04629,       13960.88247,         576.24572,        8023.81797,
        2402.48512,        -753.87007,       -6376.99217,      -10278.88014,
      -25743.89874,       15506.87748,       15609.59853,       35173.63133,
          -3.70370,           6.29538,          -4.84183,          -0.76942,
          -0.02465,          -0.03840,
           0.00565,          -0.06071,
           0.01174,           0.00253,
          -0.00230,           0.05252,
          -0.02813,           0.01359,
           0.23208,           0.03393,           0.01734,           0.04838,
          -0.46340,          -0.18941,           0.25428,          -0.56925,
           0.05213,           0.24704,           0.12922,          -0.01531,
           0.06885,          -0.08510,           0.01853,          -0.00390,
           0.01196,          -0.30530,           0.13117,          -0.03533,
           1.79597,          -0.42743,           0.98545,           2.13503,
          -1.32942,           0.68005,
          -0.01226,           0.00571,
           0.31081,           0.34932,           0.34531,          -0.32947,
          -0.00548,           0.00186,          -0.00157,          -0.00065,
           0.30877,          -0.03864,           0.04921,           0.06693,
           0.01761,          -0.04119,
           1.28318,           0.38546,           0.06462,           1.18337,
          -0.48698,           0.07086,
           0.26031,          -0.22813,           0.10272,           0.04737,
          -0.04506,          -0.38581,          -0.16624,          -0.04588,
           0.00992,           0.00722,
          -0.21041,           0.20560,          -0.09267,          -0.03438,
           0.32264,          -0.07383,
           0.09553,          -0.38730,           0.17109,          -0.01342,
          -0.02336,          -0.01286,
           0.00230,           0.04626,
           0.01176,           0.01868,
          -0.15411,          -0.32799,           0.22083,          -0.14077,
           1.98392,           1.68058,
          -0.02526,          -0.13164,          -0.04447,          -0.00153,
           0.01277,           0.00553,
          -0.26035,          -0.11362,           0.14672,          -0.32242,
           0.16686,          -0.69957,           0.40091,          -0.06721,
           0.00837,           0.09635,
          -0.08545,           0.25178,          -0.22486,          16.03256,
           0.34130,          -0.06313,           0.01469,          -0.09012,
          -0.00744,          -0.02510,
          -0.08492,          -0.13733,
          -0.07620,          -0.15329,           0.13716,          -0.03769,
           2.01176,          -1.35991,          -1.04319,          -2.97226,
          -0.01433,           0.61219,
          -0.55522,           0.38579,           0.31831,           0.81843,
          -0.04583,          -0.14585,
          -0.10218,           0.16039,          -0.06552,          -0.01802,
           0.06480,          -0.06641,           0.01672,          -0.00287,
           0.00308,           0.09982,          -0.05679,          -0.00249,
          -0.36034,           0.52385,          -0.29759,           0.59539,
          -3.59641,          -1.02499,
        -547.53774,         734.11470,         441.86760,        -626.68255,
       -2255.81376,       -1309.01028,       -2025.69590,        2774.69901,
        1711.21478,        1509.99797,
          -0.99274,           0.61858,          -0.47634,          -0.33034,
           0.00261,           0.01183,
          -0.00038,           0.11687,
           0.00994,          -0.01122,
           0.03482,          -0.01942,
          -0.11557,           0.38237,          -0.17826,           0.00830,
           0.01193,          -0.05469,
           0.01557,           0.01747,
           0.02730,          -0.01182,
          -0.11284,           0.12939,          -0.05621,          -0.01615,
           0.04258,           0.01058,
          -0.01723,           0.00963,
           0.20666,           0.11742,
           0.07830,          -0.02922,
          -0.10659,          -0.05407,           0.07254,          -0.13005,
          -0.02365,           0.24583,           0.31915,           1.27060,
           0.00009,          -0.21541,
          -0.55324,          -0.45999,          -1.45885,           0.86530,
           0.85932,           1.92999,
          -0.00755,          -0.00715,
          -0.02004,          -0.00788,
           0.01539,           0.00837,
           0.27652,          -0.50297,          -0.26703,          -0.28159,
           0.03950,           0.07182,
          -0.07177,           0.14140,           0.07693,           0.07564,
          -0.01316,          -0.01259,
           0.01529,           0.07773,
         -90.74225,        -378.15784,        -510.30190,         -52.35396,
         -89.15267,         415.56828,         181.52119,          54.01570,
          -0.01093,          -0.05931,
          -0.01344,          -0.02390,
           0.01432,          -0.02470,
          -0.01509,          -0.01346,
           0.03352,           0.02248,
           0.02588,          -0.00948,
           0.03610,           0.17238,
           0.02909,          -0.04065,
           0.00155,          -0.07025,
          -0.09508,           0.14487,           0.12441,           0.16451,
           0.00001,          -0.00005,
          -0.00982,          -0.01895,
          -0.16968,           0.36565,           0.20234,           0.17789,
          -0.04519,          -0.00588,
           0.01268,           0.00107,
         -56.32137,         -58.22145,         -80.55270,          28.14532,
          11.43301,          52.05752,          17.79480,          -2.61997,
          -0.00005,          -0.02629,
           0.01080,          -0.00390,
           0.00744,           0.03132,
           0.01156,          -0.01621,
           0.02162,           0.02552,
           0.00075,          -0.02497,
           0.02495,           0.00830,
           0.03230,           0.00103,
         -14.84965,          -4.50200,          -9.73043,           9.40426,
           4.08054,           5.38571,           1.53731,          -1.01288,
           0.21076,           1.74227,           0.79760,           0.39583,
           0.09879,          -0.16736,
          -0.00723,          -0.01536,
  };
  static final double martabb[] = {
        -364.49380,         -47.17612,        -554.97858,        -430.63121,
         596.44312,
          -3.94434,          -7.43169,          -0.06665,          -2.23987,
           0.10366,          -0.05567,
          -0.01463,           0.01908,
          -0.02611,          -0.00350,          -0.01057,          -0.00610,
          -0.00015,           0.00002,
           0.00010,           0.00033,           0.00007,          -0.00000,
          -0.00010,          -0.00004,
           0.00012,           0.00002,
          -0.00014,          -0.00048,          -0.00003,          -0.00007,
           0.00008,          -0.00005,
          -0.00043,          -0.00003,          -0.00010,          -0.00004,
           0.00001,           0.00001,
          -0.00003,          -0.00003,
           0.00004,           0.00007,
          -0.00041,           0.00031,
           0.00076,           0.00062,
           0.00001,          -0.00002,
           0.00035,           0.00053,           0.00026,           0.00019,
           0.00020,           0.00010,
           0.02936,           0.09624,          -0.01153,           0.01386,
           0.00551,          -0.00690,           0.00196,           0.00148,
          -0.00408,          -0.00673,          -0.00067,          -0.00152,
          -0.00014,          -0.00005,
           0.00000,           0.00005,
          -0.00116,           0.00276,          -0.00391,           0.00983,
          -0.01327,          -0.01986,
          -0.00003,           0.00001,
           0.01104,           0.00631,          -0.01364,           0.01152,
          -0.00439,           0.01103,          -0.00546,           0.00181,
          -0.00039,          -0.00083,
           0.00007,           0.00002,
          -0.00010,          -0.00008,
           0.00005,           0.00002,
          -0.00584,           0.00512,          -0.00722,          -0.00174,
           0.00101,          -0.00316,
          -0.02229,          -0.02797,          -0.10718,           0.05741,
           0.11403,           0.10033,
           0.00036,          -0.00022,
           0.00787,           0.01191,           0.01756,          -0.02121,
          -0.00169,          -0.00364,           0.00070,          -0.00051,
           0.01850,          -0.06836,           0.21471,           0.00162,
          -0.29165,           0.16799,
          -0.00002,           0.00011,
          -0.00075,          -0.00077,
          -0.00675,          -0.00814,           0.00029,          -0.00599,
           0.00107,           0.00013,
           0.00010,          -0.00002,
           0.00005,           0.00020,
           0.00355,           0.00306,
          -0.00013,          -0.00061,
          -0.02950,          -0.00847,           0.01037,          -0.04783,
           0.04237,           0.11662,
          -0.00331,           0.00207,          -0.00107,          -0.00264,
           0.00072,          -0.00023,
          -0.00151,           0.00146,
          -0.12847,           0.02294,           0.03611,           0.19705,
           0.16855,          -0.28279,
          -0.00000,          -0.00002,
          -0.00525,          -0.03619,           0.05048,          -0.00481,
          -0.00745,           0.04618,
           0.00286,           0.00443,           0.00521,          -0.00351,
           0.00200,           0.00474,          -0.00149,           0.00031,
          -0.00003,           0.00029,
           0.00686,           0.02467,           0.04275,          -0.02223,
           0.02282,          -0.04228,           0.03312,           0.01847,
          -0.01253,           0.01601,
           0.00076,           0.00091,
           0.00045,           0.00035,
           0.00658,           0.01586,          -0.00310,           0.00628,
          -0.00045,           0.00316,
          -0.01602,          -0.00340,          -0.01744,           0.04907,
           0.06426,           0.02275,
          -0.00217,          -0.00377,          -0.00091,           0.00037,
           0.00040,          -0.00003,
          -0.00017,          -0.00027,
           0.00366,           0.02693,          -0.00934,           0.00386,
           0.00616,          -0.00037,
           0.02028,           0.02120,          -0.01768,           0.02421,
           0.00102,           0.00877,
           0.00012,           0.00030,
          -0.00019,          -0.02165,           0.01245,          -0.00742,
           0.00172,           0.00320,
          -0.17117,          -0.12908,          -0.43134,           0.15617,
           0.21216,           0.56432,
           0.01139,          -0.00937,          -0.00058,          -0.00337,
          -0.00999,           0.01862,          -0.00621,          -0.00080,
          -0.00025,          -0.00140,
           0.09250,           0.01173,          -0.03549,           0.14651,
          -0.01784,           0.00945,
           0.00000,          -0.00006,
          -0.00500,           0.00086,           0.01079,          -0.00002,
          -0.00012,          -0.00029,
          -0.02661,           0.00140,          -0.00524,          -0.00460,
          -0.00352,          -0.00563,          -0.00277,          -0.00052,
          -0.10171,          -0.02001,
           0.00045,           0.00265,          -0.00082,           0.00160,
          -0.00302,          -0.00434,          -0.00022,          -0.00134,
           0.03285,           0.02964,          -0.05612,          -0.00668,
          -0.01821,           0.06590,
           0.00039,           0.00061,
          -0.13531,          -0.03831,
           0.02553,           0.02130,          -0.00336,           0.00468,
          -0.04522,          -0.05540,           0.00129,          -0.01767,
           0.00181,           0.00031,
          -0.00011,          -0.00034,
          -0.00146,           0.01101,
          -0.00030,           0.00240,          -0.00039,           0.00072,
          -0.01954,          -0.03822,           0.09682,          -0.04541,
          -0.01567,           0.09617,
          -0.03371,           0.33028,          -0.12102,           0.05874,
          -0.00990,          -0.02236,
           0.00109,           0.00158,
          -0.00482,           0.00019,
          -0.00036,           0.00004,
           0.00024,           0.00201,
           0.00017,           0.00011,
          -0.00012,           0.00002,
          -0.00323,          -0.01062,
          -0.00130,           0.00091,
           0.00056,          -0.00017,
           0.00774,           0.00601,           0.02550,           0.01700,
          -0.84327,           0.77533,          -0.71414,          -0.50643,
        -473.30877,       -1504.79179,        -458.52274,        -865.82237,
        -417.34994,        -681.03976,         765.50697,       -1653.67165,
        4427.33176,         710.53895,       -5016.39367,        4280.60361,
           0.33957,           0.38390,          -0.38631,           0.81193,
           0.00154,          -0.00043,
           0.01103,          -0.00017,
          -0.00046,           0.00221,
           0.00059,           0.00014,
           0.00160,           0.00475,
           0.06191,          -0.13289,           0.02884,          -0.00566,
          -0.01572,           0.23780,          -0.05140,          -0.03228,
          -0.00716,          -0.00978,          -0.01048,           0.01317,
          -0.01267,          -0.01198,           0.00037,          -0.00330,
          -0.02305,           0.00355,          -0.00121,          -0.00496,
          -0.04369,          -0.01343,           0.05347,          -0.12433,
           0.02090,           0.17683,
           0.00028,          -0.00490,
          -0.02778,          -0.05587,          -0.01658,           0.05655,
           0.00204,          -0.00092,           0.00020,           0.00014,
          -0.00603,          -0.03829,           0.00778,          -0.00588,
          -0.00266,           0.00097,
          -0.02158,          -0.07742,           0.09306,          -0.01827,
          -0.01048,           0.07885,
          -0.02485,          -0.02505,           0.00471,          -0.01026,
           0.06663,           0.01110,           0.00469,          -0.05347,
          -0.00016,          -0.00013,
           0.02622,           0.02273,          -0.01009,           0.01391,
          -0.01042,          -0.00444,
          -0.04293,          -0.00767,          -0.00154,          -0.01739,
           0.00353,          -0.00763,
          -0.00060,           0.00010,
          -0.00053,          -0.00146,
          -0.05317,           0.05760,          -0.01801,          -0.02099,
          -0.02611,          -0.01836,
          -0.00256,           0.00812,          -0.00145,           0.00054,
          -0.00008,           0.00015,
          -0.04087,           0.08860,          -0.05385,          -0.02134,
           0.02771,           0.02441,          -0.00234,           0.01571,
          -0.00260,           0.00097,
           0.10151,           0.49378,          -0.28555,           0.11428,
          -0.00286,           0.01224,           0.00160,           0.00069,
           0.00000,          -0.00040,
          -0.13286,           0.00448,
           0.01225,          -0.00568,           0.00341,           0.00224,
          -0.23483,          -0.07859,           0.30733,          -0.21548,
          -0.02608,           0.00756,
           0.09789,           0.02878,          -0.11968,           0.08981,
           0.02046,          -0.00888,
           0.02955,           0.01486,          -0.00981,           0.01542,
          -0.01674,          -0.01540,           0.00019,          -0.00449,
          -0.02140,           0.00638,           0.00112,          -0.00730,
          -0.08571,           0.13811,          -0.16951,          -0.02917,
          -0.03931,          -0.32643,
         -68.64541,         -81.00521,         -47.97737,          15.75290,
         181.76392,         -36.00647,         -48.32098,        -259.02226,
        -265.57466,         554.05904,
           0.09017,           0.18803,          -0.12459,           0.10852,
           0.00211,           0.00002,
           0.00304,          -0.00370,
           0.00174,           0.00279,
           0.00139,           0.00095,
           0.04881,           0.00262,          -0.01020,           0.03762,
           0.00987,           0.00612,
           0.00054,          -0.00036,
           0.00009,          -0.00094,
           0.02279,           0.01785,          -0.00778,           0.01263,
           0.00040,          -0.00112,
          -0.00452,          -0.00662,
           0.00483,          -0.00030,
          -0.00054,          -0.00205,
          -0.00052,          -0.00362,          -0.00215,          -0.00247,
           0.02893,          -0.01965,          -0.00004,           0.04114,
          -0.00284,          -0.00103,
           0.01827,          -0.07822,           0.18010,           0.04805,
          -0.21702,           0.18808,
           0.00095,          -0.00132,
          -0.01488,           0.00746,
           0.00198,           0.00190,
           0.01032,           0.03392,           0.04318,          -0.07332,
          -0.01004,           0.00787,
          -0.00308,          -0.01177,          -0.01431,           0.02659,
           0.00273,          -0.00374,
          -0.02545,           0.00644,
          28.68376,          13.74978,          29.60401,         -47.98255,
         -65.91944,         -18.48404,          -1.73580,          64.67487,
          -0.02492,           0.00104,
          -0.00829,          -0.00134,
           0.00077,           0.00005,
          -0.00513,           0.00403,
           0.00071,          -0.00047,
          -0.00023,          -0.00063,
           0.00120,           0.00370,
          -0.00038,          -0.00037,
           0.00080,          -0.00018,
           0.00866,           0.00156,          -0.01064,           0.02131,
           0.00000,          -0.00001,
           0.00038,          -0.00068,
          -0.00909,          -0.02187,          -0.02599,           0.05507,
          -0.00022,          -0.01468,
           0.00032,           0.00500,
           9.86233,          -2.85314,          -2.25791,         -13.83444,
         -12.38794,           3.79861,           2.76343,           6.63505,
           0.00066,           0.00007,
          -0.00016,          -0.00039,
           0.00014,           0.00059,
          -0.00031,          -0.00024,
          -0.00168,           0.00259,
           0.00007,          -0.00005,
          -0.00052,           0.00558,
           0.00110,           0.01037,
           1.59224,          -2.37284,          -2.00023,          -2.28280,
          -1.49571,           1.48293,           0.60041,           0.56376,
          -0.54386,           0.03568,          -0.10392,           0.31005,
           0.09104,           0.03015,
           0.00826,          -0.00524,
  };
  static final double martabr[] = {
        -816.07287,        -381.41365,         -33.69436,         177.22955,
           0.18630,
          -8.29605,         -11.15519,          -0.57407,          -3.53642,
           0.16663,          -0.06334,
          -0.03056,           0.02767,
          -0.04161,           0.03917,          -0.02425,           0.00204,
          -0.00034,           0.00023,
           0.00058,          -0.00111,           0.00039,          -0.00015,
           0.00006,          -0.00023,
           0.00237,           0.00191,
           0.00154,          -0.00029,           0.00009,           0.00011,
          -0.00041,           0.00037,
          -0.00010,          -0.00064,           0.00015,          -0.00005,
           0.00012,          -0.00003,
          -0.00034,           0.00026,
           0.00011,          -0.00007,
          -0.00158,           0.00087,
           0.00278,           0.00137,
           0.00024,          -0.00020,
           0.00530,          -0.00448,           0.00780,           0.00408,
           0.00062,           0.00035,
          -1.35261,           0.79891,          -0.81597,          -0.43774,
           0.14713,          -0.27415,           0.05298,           0.02230,
          -0.02089,          -0.01070,          -0.00374,           0.00342,
          -0.00142,           0.00270,
          -0.00039,           0.00063,
           0.16024,           0.27088,          -0.32127,           0.27467,
          -0.16615,          -0.24460,
          -0.00073,           0.00032,
          -0.05710,          -0.05265,          -0.06025,           0.05120,
          -0.05295,           0.23477,          -0.08211,           0.04575,
          -0.00769,          -0.01067,
          -0.00570,           0.00015,
          -0.00251,          -0.00140,
          -0.00131,          -0.00018,
          -0.12246,           0.15836,          -0.13065,          -0.03222,
           0.00795,          -0.04232,
          -0.36585,          -0.31154,           0.68504,          -0.96006,
           1.19304,           0.88631,
           0.00132,           0.00046,
           0.13105,           0.04252,           0.05164,          -0.06837,
          -0.01351,          -0.01458,           0.00376,          -0.00557,
           0.28532,          -0.17290,          -0.53946,          -0.79365,
          -0.95246,           0.74984,
           0.00019,           0.00132,
          -0.00163,          -0.00295,
          -0.40106,          -0.26573,          -0.00155,          -0.22655,
           0.04349,          -0.00376,
           0.00149,          -0.00001,
           0.00523,           0.00078,
           0.01203,           0.00558,
          -0.00708,           0.00520,
          -0.36428,          -1.28827,           1.50845,          -0.83063,
           0.58802,           0.89998,
          -0.55256,           0.01255,          -0.15169,          -0.26715,
           0.06061,          -0.04122,
          -0.00397,           0.00534,
          -0.52576,           1.22031,           1.44098,           0.92406,
           0.67214,          -0.85486,
          -0.00010,           0.00001,
           0.28820,          -0.84198,           0.78291,           0.00251,
           0.02398,           0.32093,
          -0.02331,           0.10109,          -0.07555,           0.03557,
          -0.61580,           0.43399,          -0.43779,          -0.26390,
           0.06885,          -0.13803,
           0.17694,           0.19245,           0.15119,          -0.05100,
           0.49469,          -0.45028,           0.33590,           0.15677,
          -0.04702,           0.10265,
          -0.00942,          -0.00580,
          -0.00555,          -0.00252,
          -0.32933,           0.92539,          -0.91004,          -0.04490,
          -0.01812,          -0.37121,
           0.34695,           0.50855,          -0.24721,           0.86063,
          -0.84747,           0.01983,
           0.01948,           0.02039,           0.00748,          -0.00727,
          -0.00271,           0.00220,
           0.00309,           0.00196,
           0.02030,           0.17201,          -0.03716,           0.02801,
           0.01871,           0.00002,
           0.31736,           1.17319,          -1.42245,           0.73416,
          -0.52302,          -0.85056,
           0.00522,          -0.00126,
           0.33571,           0.34594,          -0.07709,           0.21114,
          -0.04066,          -0.01742,
           1.72228,           1.46934,          -3.06437,           5.06723,
          -6.53800,          -3.55839,
          -0.06933,           0.13815,           0.03684,           0.03284,
          -0.04841,           0.09571,          -0.02350,           0.00418,
           0.01302,           0.00579,
           0.73408,           0.64718,          -1.37437,           2.04816,
          -2.70756,          -1.52808,
           0.00523,          -0.00166,
           0.25915,           0.06900,          -0.02758,           0.10707,
           0.00062,           0.00744,
          -0.08117,           0.04840,          -0.01806,          -0.00637,
           0.03034,          -0.12414,           0.03419,          -0.00388,
          10.92603,           0.48169,
          -0.01753,          -0.12853,          -0.03207,          -0.00801,
           0.03904,          -0.03326,           0.01033,           0.00366,
           0.17249,           0.20846,          -0.38157,           0.54639,
          -0.68518,          -0.36121,
          -0.01043,          -0.00186,
          -3.33843,          -0.16353,
           0.03462,           0.06669,          -0.01305,           0.01803,
          -0.22703,          -0.52219,           0.11709,          -0.19628,
           0.03410,           0.01741,
           0.00338,           0.00265,
           0.63213,           0.08944,
           0.00236,           0.01829,           0.00546,           0.00218,
           0.00073,          -0.72570,           0.63698,          -0.13340,
           0.04698,           0.29716,
          -0.13126,           1.27705,          -0.40980,           0.27400,
          -0.04525,          -0.05529,
          -0.03249,          -0.01696,
          -0.02314,          -0.00076,
           0.00510,           0.00764,
          -0.01847,          -0.01021,
           0.01688,          -0.00044,
           0.00531,          -0.00016,
          -0.01219,          -0.02903,
          -0.00361,           0.00299,
           0.00504,          -0.00153,
          -0.53625,          -0.32460,           0.10642,          -0.22070,
          -2.21651,          -0.66036,          -1.74652,          -2.08198,
       -6810.78679,         967.02869,       -3915.97140,         291.65905,
         372.99563,        1196.01966,        5108.01033,       -3172.64698,
       -7685.78246,      -12789.43898,      -17474.50562,        7757.84703,
           3.13224,           1.84743,          -0.38257,           2.40590,
           0.01860,          -0.01217,
           0.03004,           0.00278,
          -0.00125,           0.00579,
          -0.02673,          -0.00112,
           0.00662,           0.01374,
          -0.02729,           0.13109,          -0.02836,           0.00877,
           0.12171,          -0.27475,           0.34765,           0.15882,
          -0.12548,           0.02603,           0.00710,           0.06538,
          -0.04039,          -0.03257,          -0.00186,          -0.00880,
           0.16643,           0.00707,           0.01918,           0.07156,
          -0.20459,          -0.85107,           1.01832,          -0.47158,
           0.32582,           0.63002,
          -0.00282,          -0.00711,
          -0.19695,           0.15053,           0.15676,           0.17847,
           0.00071,           0.00286,          -0.00039,           0.00083,
           0.02009,           0.17859,          -0.03894,           0.02805,
           0.02379,           0.00752,
           0.17529,          -0.57783,           0.53257,          -0.02829,
           0.03211,           0.21777,
           0.13813,           0.16305,          -0.02996,           0.06303,
           0.21058,          -0.02659,           0.02596,          -0.08808,
          -0.00389,           0.00586,
           0.08986,           0.09204,          -0.01480,           0.04031,
           0.06115,           0.18366,
           0.25636,           0.06905,           0.00719,           0.11391,
           0.00636,          -0.01113,
          -0.02808,           0.00150,
          -0.01219,           0.00832,
           0.28626,          -0.09573,           0.10481,           0.16559,
          -0.94578,           1.26394,
           0.08846,          -0.01623,           0.00082,          -0.02640,
          -0.00347,           0.00798,
           0.12873,          -0.21248,           0.27999,           0.14348,
           0.44082,           0.10453,           0.04362,           0.25332,
          -0.06077,           0.00555,
          -0.06947,          -0.05511,         -10.08703,          -0.10614,
           0.04059,           0.21355,           0.05632,           0.00871,
           0.01599,          -0.00531,
           0.36835,          -0.03530,
           0.09519,          -0.04961,           0.02568,           0.08613,
           0.57033,           0.84599,           1.27123,          -0.41266,
          -0.36937,          -0.00655,
          -0.16547,          -0.24000,          -0.35213,           0.13345,
           0.05870,          -0.01524,
           0.06419,           0.04136,          -0.00681,           0.02606,
          -0.02519,          -0.02732,          -0.00105,          -0.00677,
          -0.03891,           0.00106,           0.00087,          -0.02256,
          -0.20834,          -0.14624,          -0.23178,          -0.11786,
           0.32479,          -1.41222,
        -303.74549,        -202.79324,         260.20290,         184.84320,
         536.68016,        -881.56427,       -1125.64824,        -791.09928,
        -596.61162,         659.35664,
           0.24561,           0.39519,          -0.12601,           0.18709,
          -0.00700,           0.00136,
           0.30750,           0.00009,
           0.00443,           0.00384,
           0.01170,           0.02078,
           0.15043,           0.04802,           0.00386,           0.06942,
           0.02107,           0.00495,
          -0.01067,           0.00951,
           0.00937,           0.01996,
           0.04922,           0.04337,          -0.00583,           0.02110,
          -0.00691,           0.02793,
          -0.00364,          -0.00682,
          -0.09143,           0.15369,
           0.02043,           0.05451,
           0.04053,          -0.08179,           0.09645,           0.05330,
          -0.10149,          -0.01594,          -0.96773,           0.13660,
           0.17326,           0.00013,
           0.20990,          -0.23184,          -0.38407,          -0.64733,
          -0.84754,           0.38889,
           0.00310,          -0.00340,
           0.00970,          -0.00788,
          -0.01111,           0.00677,
           0.18147,           0.09968,           0.10170,          -0.09233,
          -0.03165,           0.01790,
          -0.04727,          -0.02364,          -0.02546,           0.02451,
           0.00442,          -0.00426,
          -0.02540,           0.00471,
         130.42585,         -31.30051,          17.99957,        -174.75585,
        -142.96798,         -27.89752,         -19.42122,          59.14872,
          -0.01899,           0.00388,
          -0.01265,           0.00694,
           0.01966,           0.01140,
          -0.00439,           0.00503,
          -0.01867,           0.02826,
           0.00752,           0.02012,
          -0.14734,           0.01909,
           0.03312,           0.02327,
           0.05843,           0.00061,
          -0.06958,          -0.05798,          -0.09174,           0.06242,
           0.00003,           0.00001,
           0.00670,          -0.00305,
          -0.13637,          -0.06058,          -0.06372,           0.07257,
           0.00209,          -0.01369,
          -0.00044,           0.00355,
          17.90079,         -17.48270,          -8.77915,         -24.54483,
         -15.67123,           3.62668,           0.52038,           5.13220,
           0.02574,           0.00003,
           0.00339,           0.00919,
          -0.02778,           0.00464,
           0.01429,           0.01003,
          -0.01661,           0.01327,
           0.02216,           0.00034,
          -0.00389,           0.01076,
          -0.00035,           0.00983,
           1.23731,          -4.18017,          -2.61932,          -2.66346,
          -1.45540,           1.10310,           0.23322,           0.40775,
          -0.43623,           0.06212,          -0.09900,           0.19456,
           0.03639,           0.02566,
           0.00309,          -0.00116,
  };
  static final byte marargs[] = {
  (byte)0,  (byte)4,
  (byte)3,  (byte)4,  (byte)3, (byte)-8,  (byte)4,  (byte)3,  (byte)5,  (byte)2,
  (byte)3,  (byte)5,  (byte)2, (byte)-6,  (byte)3, (byte)-4,  (byte)4,  (byte)0,
  (byte)2,  (byte)2,  (byte)5, (byte)-5,  (byte)6,  (byte)1,
  (byte)3, (byte)12,  (byte)3,(byte)-24,  (byte)4,  (byte)9,  (byte)5,  (byte)0,
  (byte)3,  (byte)2,  (byte)2,  (byte)1,  (byte)3, (byte)-8,  (byte)4,  (byte)1,
  (byte)3, (byte)11,  (byte)3,(byte)-21,  (byte)4,  (byte)2,  (byte)5,  (byte)0,
  (byte)3,  (byte)3,  (byte)2, (byte)-7,  (byte)3,  (byte)4,  (byte)4,  (byte)0,
  (byte)3,  (byte)7,  (byte)3,(byte)-13,  (byte)4, (byte)-1,  (byte)5,  (byte)1,
  (byte)3,  (byte)1,  (byte)3, (byte)-2,  (byte)4,  (byte)2,  (byte)6,  (byte)0,
  (byte)3,  (byte)1,  (byte)2, (byte)-8,  (byte)3, (byte)12,  (byte)4,  (byte)1,
  (byte)3,  (byte)1,  (byte)4, (byte)-8,  (byte)5,  (byte)4,  (byte)6,  (byte)0,
  (byte)3,  (byte)1,  (byte)4, (byte)-7,  (byte)5,  (byte)2,  (byte)6,  (byte)0,
  (byte)3,  (byte)1,  (byte)4, (byte)-9,  (byte)5,  (byte)7,  (byte)6,  (byte)0,
  (byte)1,  (byte)1,  (byte)7,  (byte)0,
  (byte)2,  (byte)1,  (byte)5, (byte)-2,  (byte)6,  (byte)0,
  (byte)3,  (byte)1,  (byte)3, (byte)-2,  (byte)4,  (byte)1,  (byte)5,  (byte)0,
  (byte)3,  (byte)3,  (byte)3, (byte)-6,  (byte)4,  (byte)2,  (byte)5,  (byte)1,
  (byte)3, (byte)12,  (byte)3,(byte)-23,  (byte)4,  (byte)3,  (byte)5,  (byte)0,
  (byte)2,  (byte)8,  (byte)3,(byte)-15,  (byte)4,  (byte)3,
  (byte)2,  (byte)1,  (byte)4, (byte)-6,  (byte)5,  (byte)2,
  (byte)3,  (byte)2,  (byte)2, (byte)-7,  (byte)3,  (byte)7,  (byte)4,  (byte)0,
  (byte)2,  (byte)1,  (byte)2, (byte)-3,  (byte)4,  (byte)2,
  (byte)2,  (byte)2,  (byte)5, (byte)-4,  (byte)6,  (byte)0,
  (byte)1,  (byte)1,  (byte)6,  (byte)1,
  (byte)2,  (byte)9,  (byte)3,(byte)-17,  (byte)4,  (byte)2,
  (byte)3,  (byte)2,  (byte)3, (byte)-4,  (byte)4,  (byte)2,  (byte)5,  (byte)0,
  (byte)3,  (byte)2,  (byte)3, (byte)-4,  (byte)4,  (byte)1,  (byte)5,  (byte)0,
  (byte)2,  (byte)1,  (byte)5, (byte)-1,  (byte)6,  (byte)0,
  (byte)2,  (byte)2,  (byte)2, (byte)-6,  (byte)4,  (byte)2,
  (byte)2,  (byte)1,  (byte)3, (byte)-2,  (byte)4,  (byte)2,
  (byte)2,  (byte)2,  (byte)5, (byte)-3,  (byte)6,  (byte)0,
  (byte)1,  (byte)2,  (byte)6,  (byte)1,
  (byte)2,  (byte)3,  (byte)5, (byte)-5,  (byte)6,  (byte)1,
  (byte)1,  (byte)1,  (byte)5,  (byte)2,
  (byte)3,  (byte)4,  (byte)3, (byte)-8,  (byte)4,  (byte)2,  (byte)5,  (byte)0,
  (byte)2,  (byte)1,  (byte)5, (byte)-5,  (byte)6,  (byte)0,
  (byte)2,  (byte)7,  (byte)3,(byte)-13,  (byte)4,  (byte)2,
  (byte)2,  (byte)3,  (byte)2, (byte)-9,  (byte)4,  (byte)0,
  (byte)2,  (byte)2,  (byte)5, (byte)-2,  (byte)6,  (byte)0,
  (byte)1,  (byte)3,  (byte)6,  (byte)0,
  (byte)2,  (byte)1,  (byte)4, (byte)-5,  (byte)5,  (byte)0,
  (byte)2,  (byte)2,  (byte)3, (byte)-4,  (byte)4,  (byte)2,
  (byte)2,  (byte)6,  (byte)3,(byte)-11,  (byte)4,  (byte)2,
  (byte)2,  (byte)4,  (byte)5, (byte)-5,  (byte)6,  (byte)0,
  (byte)1,  (byte)2,  (byte)5,  (byte)2,
  (byte)3,  (byte)1,  (byte)4, (byte)-3,  (byte)5, (byte)-3,  (byte)6,  (byte)0,
  (byte)2,  (byte)3,  (byte)3, (byte)-6,  (byte)4,  (byte)2,
  (byte)2,  (byte)1,  (byte)4, (byte)-4,  (byte)5,  (byte)1,
  (byte)2,  (byte)5,  (byte)3, (byte)-9,  (byte)4,  (byte)2,
  (byte)1,  (byte)3,  (byte)5,  (byte)1,
  (byte)2,  (byte)4,  (byte)3, (byte)-8,  (byte)4,  (byte)2,
  (byte)3,  (byte)1,  (byte)4, (byte)-4,  (byte)5,  (byte)2,  (byte)6,  (byte)0,
  (byte)3,  (byte)1,  (byte)4, (byte)-1,  (byte)5, (byte)-5,  (byte)6,  (byte)0,
  (byte)2,  (byte)4,  (byte)3, (byte)-7,  (byte)4,  (byte)2,
  (byte)2,  (byte)1,  (byte)4, (byte)-3,  (byte)5,  (byte)2,
  (byte)3,  (byte)1,  (byte)4, (byte)-5,  (byte)5,  (byte)5,  (byte)6,  (byte)1,
  (byte)3,  (byte)1,  (byte)4, (byte)-4,  (byte)5,  (byte)3,  (byte)6,  (byte)0,
  (byte)3,  (byte)1,  (byte)4, (byte)-3,  (byte)5,  (byte)1,  (byte)6,  (byte)0,
  (byte)2,  (byte)5,  (byte)3,(byte)-10,  (byte)4,  (byte)1,
  (byte)1,  (byte)4,  (byte)5,  (byte)0,
  (byte)2,  (byte)3,  (byte)3, (byte)-5,  (byte)4,  (byte)2,
  (byte)3,  (byte)1,  (byte)4, (byte)-3,  (byte)5,  (byte)2,  (byte)6,  (byte)0,
  (byte)2,  (byte)1,  (byte)4, (byte)-5,  (byte)6,  (byte)2,
  (byte)2,  (byte)1,  (byte)4, (byte)-2,  (byte)5,  (byte)2,
  (byte)3,  (byte)1,  (byte)4, (byte)-4,  (byte)5,  (byte)5,  (byte)6,  (byte)1,
  (byte)2,  (byte)6,  (byte)3,(byte)-12,  (byte)4,  (byte)1,
  (byte)2,  (byte)1,  (byte)4, (byte)-4,  (byte)6,  (byte)0,
  (byte)2,  (byte)2,  (byte)3, (byte)-3,  (byte)4,  (byte)2,
  (byte)2, (byte)10,  (byte)3,(byte)-18,  (byte)4,  (byte)0,
  (byte)2,  (byte)1,  (byte)4, (byte)-3,  (byte)6,  (byte)1,
  (byte)3,  (byte)1,  (byte)4, (byte)-2,  (byte)5,  (byte)2,  (byte)6,  (byte)0,
  (byte)2,  (byte)7,  (byte)3,(byte)-14,  (byte)4,  (byte)1,
  (byte)3,  (byte)1,  (byte)4,  (byte)1,  (byte)5, (byte)-5,  (byte)6,  (byte)1,
  (byte)2,  (byte)1,  (byte)4, (byte)-1,  (byte)5,  (byte)0,
  (byte)3,  (byte)1,  (byte)4, (byte)-3,  (byte)5,  (byte)5,  (byte)6,  (byte)1,
  (byte)3,  (byte)1,  (byte)4,  (byte)2,  (byte)5, (byte)-7,  (byte)6,  (byte)1,
  (byte)2,  (byte)1,  (byte)4, (byte)-2,  (byte)6,  (byte)2,
  (byte)3,  (byte)1,  (byte)4, (byte)-2,  (byte)5,  (byte)3,  (byte)6,  (byte)0,
  (byte)2,  (byte)1,  (byte)3, (byte)-1,  (byte)4,  (byte)0,
  (byte)2,  (byte)2,  (byte)2, (byte)-7,  (byte)4,  (byte)1,
  (byte)2,  (byte)9,  (byte)3,(byte)-16,  (byte)4,  (byte)2,
  (byte)2,  (byte)1,  (byte)4, (byte)-3,  (byte)7,  (byte)0,
  (byte)2,  (byte)1,  (byte)4, (byte)-1,  (byte)6,  (byte)0,
  (byte)3,  (byte)1,  (byte)4, (byte)-2,  (byte)5,  (byte)4,  (byte)6,  (byte)1,
  (byte)2,  (byte)1,  (byte)2, (byte)-4,  (byte)4,  (byte)2,
  (byte)2,  (byte)8,  (byte)3,(byte)-16,  (byte)4,  (byte)2,
  (byte)2,  (byte)1,  (byte)4, (byte)-2,  (byte)7,  (byte)0,
  (byte)3,  (byte)3,  (byte)3, (byte)-5,  (byte)4,  (byte)2,  (byte)5,  (byte)0,
  (byte)3,  (byte)1,  (byte)4,  (byte)1,  (byte)5, (byte)-3,  (byte)6,  (byte)0,
  (byte)2,  (byte)1,  (byte)4, (byte)-2,  (byte)8,  (byte)0,
  (byte)2,  (byte)1,  (byte)4, (byte)-1,  (byte)7,  (byte)0,
  (byte)2,  (byte)1,  (byte)4, (byte)-1,  (byte)8,  (byte)0,
  (byte)3,  (byte)3,  (byte)2, (byte)-7,  (byte)3,  (byte)3,  (byte)4,  (byte)0,
  (byte)3,  (byte)2,  (byte)2,  (byte)1,  (byte)3, (byte)-7,  (byte)4,  (byte)0,
  (byte)3,  (byte)1,  (byte)4,  (byte)1,  (byte)6, (byte)-3,  (byte)7,  (byte)0,
  (byte)3,  (byte)1,  (byte)4,  (byte)2,  (byte)5, (byte)-5,  (byte)6,  (byte)1,
  (byte)3,  (byte)4,  (byte)3, (byte)-7,  (byte)4,  (byte)3,  (byte)5,  (byte)1,
  (byte)1,  (byte)1,  (byte)4,  (byte)5,
  (byte)3,  (byte)4,  (byte)3, (byte)-9,  (byte)4,  (byte)3,  (byte)5,  (byte)1,
  (byte)3,  (byte)1,  (byte)4, (byte)-2,  (byte)5,  (byte)5,  (byte)6,  (byte)0,
  (byte)3,  (byte)3,  (byte)2, (byte)-7,  (byte)3,  (byte)5,  (byte)4,  (byte)0,
  (byte)3,  (byte)1,  (byte)3, (byte)-1,  (byte)4,  (byte)2,  (byte)6,  (byte)0,
  (byte)3,  (byte)1,  (byte)4,  (byte)1,  (byte)5, (byte)-2,  (byte)6,  (byte)0,
  (byte)3,  (byte)3,  (byte)3, (byte)-7,  (byte)4,  (byte)2,  (byte)5,  (byte)0,
  (byte)2,  (byte)8,  (byte)3,(byte)-14,  (byte)4,  (byte)1,
  (byte)2,  (byte)1,  (byte)2, (byte)-2,  (byte)4,  (byte)1,
  (byte)2,  (byte)1,  (byte)4,  (byte)1,  (byte)6,  (byte)1,
  (byte)2,  (byte)9,  (byte)3,(byte)-18,  (byte)4,  (byte)1,
  (byte)2,  (byte)2,  (byte)2, (byte)-5,  (byte)4,  (byte)1,
  (byte)2,  (byte)1,  (byte)3, (byte)-3,  (byte)4,  (byte)2,
  (byte)2,  (byte)1,  (byte)4,  (byte)2,  (byte)6,  (byte)0,
  (byte)2,  (byte)1,  (byte)4,  (byte)1,  (byte)5,  (byte)1,
  (byte)3,  (byte)4,  (byte)3, (byte)-9,  (byte)4,  (byte)2,  (byte)5,  (byte)1,
  (byte)2,  (byte)7,  (byte)3,(byte)-12,  (byte)4,  (byte)1,
  (byte)2,  (byte)2,  (byte)4, (byte)-5,  (byte)5,  (byte)0,
  (byte)2,  (byte)2,  (byte)3, (byte)-5,  (byte)4,  (byte)2,
  (byte)2,  (byte)6,  (byte)3,(byte)-10,  (byte)4,  (byte)1,
  (byte)2,  (byte)1,  (byte)4,  (byte)2,  (byte)5,  (byte)1,
  (byte)3,  (byte)2,  (byte)4, (byte)-5,  (byte)5,  (byte)2,  (byte)6,  (byte)0,
  (byte)2,  (byte)3,  (byte)3, (byte)-7,  (byte)4,  (byte)1,
  (byte)2,  (byte)2,  (byte)4, (byte)-4,  (byte)5,  (byte)0,
  (byte)2,  (byte)5,  (byte)3, (byte)-8,  (byte)4,  (byte)1,
  (byte)2,  (byte)1,  (byte)4,  (byte)3,  (byte)5,  (byte)0,
  (byte)3,  (byte)2,  (byte)4, (byte)-4,  (byte)5,  (byte)2,  (byte)6,  (byte)0,
  (byte)3,  (byte)2,  (byte)4, (byte)-1,  (byte)5, (byte)-5,  (byte)6,  (byte)0,
  (byte)2,  (byte)4,  (byte)3, (byte)-6,  (byte)4,  (byte)1,
  (byte)2,  (byte)2,  (byte)4, (byte)-3,  (byte)5,  (byte)0,
  (byte)3,  (byte)2,  (byte)4, (byte)-5,  (byte)5,  (byte)5,  (byte)6,  (byte)1,
  (byte)3,  (byte)2,  (byte)4, (byte)-4,  (byte)5,  (byte)3,  (byte)6,  (byte)0,
  (byte)2,  (byte)3,  (byte)3, (byte)-4,  (byte)4,  (byte)1,
  (byte)2,  (byte)2,  (byte)4, (byte)-5,  (byte)6,  (byte)2,
  (byte)2,  (byte)2,  (byte)4, (byte)-2,  (byte)5,  (byte)1,
  (byte)3,  (byte)2,  (byte)4, (byte)-4,  (byte)5,  (byte)5,  (byte)6,  (byte)1,
  (byte)2,  (byte)2,  (byte)4, (byte)-4,  (byte)6,  (byte)0,
  (byte)2,  (byte)2,  (byte)3, (byte)-2,  (byte)4,  (byte)0,
  (byte)2,  (byte)2,  (byte)4, (byte)-3,  (byte)6,  (byte)1,
  (byte)2,  (byte)2,  (byte)4, (byte)-1,  (byte)5,  (byte)1,
  (byte)2,  (byte)2,  (byte)4, (byte)-2,  (byte)6,  (byte)0,
  (byte)1,  (byte)1,  (byte)3,  (byte)1,
  (byte)2,  (byte)2,  (byte)4, (byte)-1,  (byte)6,  (byte)0,
  (byte)2,  (byte)1,  (byte)2, (byte)-5,  (byte)4,  (byte)1,
  (byte)2,  (byte)8,  (byte)3,(byte)-17,  (byte)4,  (byte)1,
  (byte)3,  (byte)2,  (byte)4,  (byte)2,  (byte)5, (byte)-5,  (byte)6,  (byte)1,
  (byte)3,  (byte)4,  (byte)3, (byte)-6,  (byte)4,  (byte)3,  (byte)5,  (byte)1,
  (byte)3, (byte)10,  (byte)3,(byte)-17,  (byte)4,  (byte)3,  (byte)6,  (byte)0,
  (byte)1,  (byte)2,  (byte)4,  (byte)4,
  (byte)3,  (byte)4,  (byte)3,(byte)-10,  (byte)4,  (byte)3,  (byte)5,  (byte)1,
  (byte)2,  (byte)8,  (byte)3,(byte)-13,  (byte)4,  (byte)0,
  (byte)2,  (byte)1,  (byte)2, (byte)-1,  (byte)4,  (byte)0,
  (byte)2,  (byte)2,  (byte)4,  (byte)1,  (byte)6,  (byte)0,
  (byte)2,  (byte)2,  (byte)2, (byte)-4,  (byte)4,  (byte)0,
  (byte)2,  (byte)1,  (byte)3, (byte)-4,  (byte)4,  (byte)1,
  (byte)2,  (byte)2,  (byte)4,  (byte)1,  (byte)5,  (byte)0,
  (byte)2,  (byte)7,  (byte)3,(byte)-11,  (byte)4,  (byte)0,
  (byte)2,  (byte)3,  (byte)4, (byte)-5,  (byte)5,  (byte)0,
  (byte)2,  (byte)2,  (byte)3, (byte)-6,  (byte)4,  (byte)1,
  (byte)2,  (byte)6,  (byte)3, (byte)-9,  (byte)4,  (byte)0,
  (byte)2,  (byte)2,  (byte)4,  (byte)2,  (byte)5,  (byte)0,
  (byte)2,  (byte)3,  (byte)4, (byte)-4,  (byte)5,  (byte)0,
  (byte)2,  (byte)5,  (byte)3, (byte)-7,  (byte)4,  (byte)0,
  (byte)2,  (byte)4,  (byte)3, (byte)-5,  (byte)4,  (byte)1,
  (byte)2,  (byte)3,  (byte)4, (byte)-3,  (byte)5,  (byte)1,
  (byte)2,  (byte)3,  (byte)3, (byte)-3,  (byte)4,  (byte)0,
  (byte)2,  (byte)3,  (byte)4, (byte)-2,  (byte)5,  (byte)2,
  (byte)3,  (byte)3,  (byte)4, (byte)-4,  (byte)5,  (byte)5,  (byte)6,  (byte)0,
  (byte)2,  (byte)2,  (byte)3, (byte)-1,  (byte)4,  (byte)0,
  (byte)2,  (byte)3,  (byte)4, (byte)-3,  (byte)6,  (byte)0,
  (byte)2,  (byte)3,  (byte)4, (byte)-1,  (byte)5,  (byte)1,
  (byte)2,  (byte)3,  (byte)4, (byte)-2,  (byte)6,  (byte)0,
  (byte)2,  (byte)1,  (byte)3,  (byte)1,  (byte)4,  (byte)1,
  (byte)2,  (byte)3,  (byte)4, (byte)-1,  (byte)6,  (byte)0,
  (byte)3,  (byte)4,  (byte)3, (byte)-5,  (byte)4,  (byte)3,  (byte)5,  (byte)0,
  (byte)1,  (byte)3,  (byte)4,  (byte)3,
  (byte)3,  (byte)4,  (byte)3,(byte)-11,  (byte)4,  (byte)3,  (byte)5,  (byte)0,
  (byte)1,  (byte)1,  (byte)2,  (byte)0,
  (byte)2,  (byte)2,  (byte)2, (byte)-3,  (byte)4,  (byte)0,
  (byte)2,  (byte)1,  (byte)3, (byte)-5,  (byte)4,  (byte)0,
  (byte)2,  (byte)4,  (byte)4, (byte)-5,  (byte)5,  (byte)0,
  (byte)2,  (byte)6,  (byte)3, (byte)-8,  (byte)4,  (byte)0,
  (byte)2,  (byte)4,  (byte)4, (byte)-4,  (byte)5,  (byte)0,
  (byte)2,  (byte)5,  (byte)3, (byte)-6,  (byte)4,  (byte)0,
  (byte)2,  (byte)4,  (byte)3, (byte)-4,  (byte)4,  (byte)0,
  (byte)2,  (byte)4,  (byte)4, (byte)-3,  (byte)5,  (byte)1,
  (byte)3,  (byte)6,  (byte)3, (byte)-8,  (byte)4,  (byte)2,  (byte)5,  (byte)0,
  (byte)2,  (byte)3,  (byte)3, (byte)-2,  (byte)4,  (byte)0,
  (byte)2,  (byte)4,  (byte)4, (byte)-2,  (byte)5,  (byte)1,
  (byte)2,  (byte)4,  (byte)4, (byte)-1,  (byte)5,  (byte)0,
  (byte)2,  (byte)1,  (byte)3,  (byte)2,  (byte)4,  (byte)0,
  (byte)1,  (byte)4,  (byte)4,  (byte)3,
  (byte)2,  (byte)2,  (byte)2, (byte)-2,  (byte)4,  (byte)0,
  (byte)2,  (byte)7,  (byte)3, (byte)-9,  (byte)4,  (byte)0,
  (byte)2,  (byte)5,  (byte)4, (byte)-5,  (byte)5,  (byte)0,
  (byte)2,  (byte)6,  (byte)3, (byte)-7,  (byte)4,  (byte)0,
  (byte)2,  (byte)5,  (byte)4, (byte)-4,  (byte)5,  (byte)0,
  (byte)2,  (byte)5,  (byte)3, (byte)-5,  (byte)4,  (byte)0,
  (byte)2,  (byte)5,  (byte)4, (byte)-3,  (byte)5,  (byte)0,
  (byte)2,  (byte)5,  (byte)4, (byte)-2,  (byte)5,  (byte)0,
  (byte)1,  (byte)5,  (byte)4,  (byte)3,
  (byte)1,  (byte)6,  (byte)4,  (byte)2,
  (byte)1,  (byte)7,  (byte)4,  (byte)0,
 (byte)-1
  };
  
  static Plantbl mar404 = new Plantbl(
                               new short[]{0,  5, 12, 24,  9,  7,  3,  2,  0},
                               (short)5,
                               marargs,
                               martabl,
                               martabb,
                               martabr,
                               1.5303348827100001e+00
                              );
}
class SwemptabMer {
  
  static final double mertabl[] = {
          35.85255,        -163.26379, 53810162857.56026,      908082.18475,
           0.05214,          -0.07712,
           1.07258,           0.04008,           0.49259,           0.00230,
           0.02324,           0.05869,
           0.24516,           0.22898,          -0.06037,           0.13023,
           0.00331,          -0.03576,
           0.06464,           0.00089,
           0.03103,           0.05078,
          -0.01133,           0.01520,
           0.14654,           0.07538,           0.25112,          -0.24473,
          -0.17928,          -0.53366,
          -0.06367,           0.20458,          -0.42985,           0.14848,
          -0.35317,          -0.61364,
           0.00325,          -0.08617,          -0.23180,           0.08576,
           0.22995,           0.43569,
           1.92114,           2.89319,          -5.55637,           4.70329,
          -4.91411,          -5.45521,
           0.02607,           0.04468,
          -0.05439,           0.13476,          -0.07329,          -0.00985,
          -0.00278,           0.05377,
           0.07474,          -0.09658,           0.29818,           0.20422,
          -0.29074,           0.44962,
          -0.15411,          -0.04287,           0.29907,          -1.02948,
           3.62183,           0.84869,
          -0.08157,           0.02754,
          -0.03610,          -0.12909,           0.09195,          -0.04424,
          -0.08845,           0.09347,
          -0.27140,           0.08185,
           0.24783,           0.19543,          -0.25154,           0.41371,
          -0.00046,           0.01524,
           0.04127,           0.06663,
           0.43023,           0.11790,
           0.04427,           0.05329,
           0.00411,          -0.71074,
          -0.07111,          -0.09824,
           0.01264,          -0.02075,
          -0.00068,          -0.01678,
           0.01186,           0.00181,
           0.00302,          -0.21963,
          -0.06412,          -0.10155,          -0.36856,           0.20240,
           0.32282,           0.65133,
          -0.07178,          -0.01876,           0.13399,          -0.39522,
           1.28413,           0.33790,
           0.05040,          -0.01679,
          -0.00794,           0.01117,
           0.02630,           0.00575,
          -0.07113,          -0.11414,           0.16422,          -0.23060,
           0.35198,           0.05409,
           1.11486,          -0.35833,           0.87313,           1.66304,
          -1.28434,           0.72067,
           0.01400,           0.00971,
           0.21044,          -0.87385,           3.20820,           0.67957,
          -0.01716,           0.00111,
          -0.13776,          -0.02650,
          -0.06778,           0.00908,           0.00616,          -0.04520,
          -0.31625,          -0.61913,
           0.36184,           0.09373,
           0.00984,          -0.03292,
           0.01944,           0.00530,
           0.00243,          -0.00123,
           0.01589,           0.02223,
          -0.02992,          -0.01086,
        4356.04809,       -5859.86328,        2918.27323,       -4796.67315,
         510.24783,       -1220.02233,         127.48927,         250.10654,
        3250.43013,        -904.27614,       -5667.40042,      -22634.00922,
      -82471.79425,       18615.92342,
           0.01941,           0.00372,
           0.01830,          -0.00652,
          -0.02548,          -0.01157,
           0.00635,           0.02343,
          -0.00980,           0.00961,
           0.12137,           0.10068,           0.16676,          -0.07257,
          -0.07267,          -0.13761,           0.25305,          -0.28112,
          -0.07974,           0.07866,
          -0.41726,           0.49991,          -1.55187,          -1.14150,
           1.54754,          -2.35141,
          -0.00862,           0.00808,
           0.00218,          -0.03726,
           0.06914,          -0.08986,
          -0.00501,           2.09577,
          -0.01409,          -0.01842,
           0.04138,           0.05961,
          -0.12276,          -0.04929,
          -0.03963,          -0.06080,
          -0.27697,          -0.09329,
          -0.01011,           0.00295,
          -0.01374,           0.01328,
          -0.00171,           0.25815,
           0.01446,           0.00782,
           0.17909,          -0.04683,
           0.03765,          -0.04990,
           0.00036,           0.00528,
           0.05508,          -0.01369,
          -0.11751,          -0.10624,          -0.14448,           0.10522,
          -0.00884,           0.43006,
           0.01162,           0.01659,
          -0.00076,           0.10143,
           0.55779,           0.05510,           0.12350,          -0.34025,
           0.01320,           0.92985,
          -0.00026,          -0.03426,
           0.01305,           0.00041,
           0.13187,          -0.11903,
           0.00058,           0.09877,
         -33.10230,         -41.96782,        -268.28908,         174.29259,
         731.20089,        1508.07639,        5223.99114,       -3008.08849,
       -3909.34957,       -9646.69156,
           0.02988,           0.03182,
           0.07149,           0.04513,
          -0.02356,          -0.01641,
          -0.03188,          -0.03711,           0.15084,          -0.22436,
           0.61987,           0.25706,
           0.02425,           0.01200,
          -0.05543,          -0.14435,          -0.53398,           0.10997,
           0.00465,          -0.01893,
           0.01260,          -0.01314,
           0.00650,          -0.05499,
          -0.06804,           0.01608,
           0.02134,           0.04160,
           0.00636,           0.01293,
          -0.03470,          -0.02697,
          -0.11323,           0.02409,
          -0.02618,           0.00827,
           0.01879,           0.16838,           0.08978,           0.01934,
          -0.23564,           0.05565,
           0.03686,           0.02644,
          -0.02471,           0.00558,
        -140.22669,        -120.40692,        -501.88143,         434.05868,
        1044.54998,        1162.72084,        1527.78437,        -882.37371,
          -0.00768,           0.02213,
          -0.04090,           0.16718,
          -0.05923,          -0.12595,
           0.01154,          -0.00025,
          -0.00776,          -0.01653,
          -0.01213,          -0.02773,
           0.00344,           0.02180,
          -0.02558,          -0.05682,
          -0.00490,           0.01050,
          38.75496,         -78.17502,        -189.90700,        -136.33371,
        -249.94062,         319.76423,         205.73478,         272.64549,
          -0.01132,          -0.01071,          -0.04607,          -0.00390,
           0.02903,          -0.02070,
           0.01326,          -0.00901,
          35.38435,           7.45358,          31.08987,         -70.52685,
         -92.13879,         -51.58876,         -51.80016,          48.98102,
          -0.00124,          -0.01159,
           0.47335,          13.71886,          23.71637,           5.55804,
          10.06850,         -25.65292,         -11.85300,         -10.20802,
          -4.72861,           1.27151,          -0.47322,           7.46754,
           6.99528,           1.79089,           2.05336,          -2.90866,
          -1.97528,           0.72236,          -0.25084,           1.90269,
           0.72127,           0.41354,
          -0.30286,          -0.53125,          -0.50883,          -0.01200,
          -0.08301,           0.18083,
          -0.04286,          -0.10963,          -0.04544,          -0.01645,
          -0.00013,          -0.00986,
  };
  static final double mertabb[] = {
          68.33369,         422.77623,       -2057.26405,       -2522.29068,
          -0.00030,          -0.00009,
           0.02400,          -0.06471,           0.02074,          -0.00904,
           0.00044,           0.00261,
          -0.00174,          -0.00088,          -0.00027,           0.00003,
           0.00005,          -0.00004,
          -0.00036,           0.00200,
           0.01432,           0.01199,
           0.00006,          -0.00004,
           0.00236,           0.00803,           0.01235,           0.00406,
          -0.03253,           0.00179,
          -0.00243,           0.00132,          -0.00352,           0.00011,
          -0.00146,          -0.01154,
           0.00824,          -0.01195,          -0.01829,          -0.00465,
           0.12540,           0.09997,
           0.00400,           0.00288,          -0.02848,           0.01094,
          -0.02273,          -0.07051,
           0.01305,           0.01078,
          -0.00119,           0.00136,          -0.00107,          -0.00066,
           0.00097,          -0.00315,
           0.00120,           0.00430,          -0.00710,          -0.00157,
           0.06052,          -0.04777,
           0.00192,          -0.00229,          -0.02077,           0.00647,
           0.06907,           0.07644,
          -0.00717,           0.00451,
           0.00052,          -0.00262,           0.00345,           0.00039,
          -0.00674,           0.00346,
          -0.02880,           0.00807,
           0.00054,           0.00206,          -0.01745,           0.00517,
          -0.00044,           0.00049,
           0.01749,           0.01230,
           0.01703,           0.01563,
           0.00934,           0.02372,
           0.01610,          -0.01136,
           0.00186,          -0.00503,
           0.00082,          -0.00673,
           0.00170,          -0.00539,
           0.00042,           0.00037,
           0.00415,          -0.00430,
           0.00258,          -0.00914,          -0.01761,          -0.00251,
           0.15909,           0.13276,
           0.02436,          -0.00791,           0.00491,           0.03890,
          -0.02982,           0.05645,
          -0.00003,           0.00427,
          -0.00363,           0.00221,
           0.00077,           0.00130,
           0.00131,          -0.00071,           0.00796,           0.00453,
           0.01186,           0.01631,
           0.12949,          -0.02546,           0.03613,           0.32854,
          -0.43001,           0.01417,
           0.00034,           0.00095,
          -0.03268,           0.04034,           0.11407,           0.15049,
          -0.00079,          -0.00052,
          -0.04009,           0.00988,
          -0.00259,          -0.00085,           0.00221,          -0.00133,
           0.00003,          -0.01733,
           0.01055,           0.01976,
           0.00222,           0.00085,
           0.00089,           0.00087,
           0.00014,           0.00001,
           0.00145,           0.00802,
           0.00122,           0.00068,
         947.79367,       -1654.39690,         542.00864,       -1281.09901,
          90.02068,        -318.36115,         -87.67090,          92.91960,
         376.98232,        -419.10705,        5094.60412,        2476.97098,
      -18160.57888,       16010.48165,
           0.00621,          -0.00128,
           0.00186,          -0.00153,
          -0.00790,           0.00011,
          -0.00032,           0.00165,
          -0.00277,           0.00539,
           0.00552,           0.00682,           0.01086,          -0.00978,
          -0.02292,          -0.01300,           0.02940,          -0.04427,
          -0.02051,           0.04860,
          -0.05020,           0.29089,          -0.50763,          -0.04900,
           0.11177,          -0.41357,
          -0.00222,           0.00504,
          -0.00006,          -0.00459,
          -0.00175,          -0.02691,
           0.05921,           0.18938,
          -0.00181,          -0.00154,
           0.00322,           0.00586,
          -0.01098,          -0.00520,
          -0.00861,          -0.01342,
          -0.02694,          -0.00706,
          -0.00103,           0.00012,
          -0.00284,           0.00797,
           0.00743,           0.02523,
           0.00872,           0.00096,
           0.03155,          -0.01644,
           0.00414,          -0.00583,
           0.00029,           0.00066,
           0.00935,          -0.00619,
          -0.02498,          -0.01600,          -0.03545,           0.07623,
           0.01649,           0.06498,
           0.00148,           0.00209,
           0.00621,           0.02014,
           0.17407,          -0.05022,          -0.03485,          -0.17012,
           0.06164,           0.20059,
          -0.00804,          -0.01475,
           0.00296,          -0.00068,
           0.01880,          -0.03797,
           0.00608,           0.02270,
           5.89651,          -6.62562,         -37.41057,         -10.51542,
         -47.22373,          95.76862,         494.45951,          -5.37252,
       -3991.04809,       -2886.97750,
           0.01232,           0.00487,
           0.03163,           0.00561,
          -0.01847,          -0.00207,
          -0.10138,           0.01430,          -0.04269,          -0.22338,
           0.24955,          -0.02066,
           0.01119,          -0.00186,
           0.03416,           0.01805,          -0.12498,           0.10385,
          -0.00210,          -0.01011,
           0.00346,          -0.00682,
          -0.00683,          -0.02227,
          -0.01649,           0.01259,
           0.01392,           0.01174,
           0.00440,           0.00351,
          -0.02871,          -0.00375,
          -0.03170,           0.02246,
          -0.00833,           0.00596,
           0.04081,           0.06666,           0.05400,          -0.02387,
          -0.07852,           0.05781,
           0.01881,           0.00324,
          -0.00868,           0.00606,
          -6.52157,         -19.74446,         -72.46009,          43.12366,
         321.78233,         215.45201,         452.61804,       -1025.05619,
           0.00119,           0.01169,
           0.02239,           0.09003,
          -0.05329,          -0.03974,
           0.00688,          -0.00421,
          -0.00676,          -0.00515,
          -0.01171,          -0.00952,
           0.01337,           0.01270,
          -0.02791,          -0.02184,
           0.00058,           0.00679,
           8.42102,         -11.87757,         -49.07247,         -25.34584,
         -43.54829,         161.26509,         261.70993,          56.25777,
           0.00568,           0.00871,          -0.02656,           0.01582,
           0.00875,          -0.02114,
           0.00464,          -0.01075,
           9.08966,           1.37810,           3.44548,         -27.44651,
         -59.62749,          -0.73611,          -0.77613,          65.72607,
          -0.00664,          -0.00723,
           1.04214,           4.78920,          11.67397,          -1.84524,
          -4.16685,         -19.14211,         -16.14483,           3.02496,
          -1.98140,           1.16261,           1.81526,           4.21224,
           5.59020,          -2.55741,          -1.54151,          -3.85817,
          -1.08723,           1.23372,           1.12378,           1.51554,
           0.88937,          -0.57631,
          -0.50549,          -0.25617,          -0.37618,           0.42163,
           0.18902,           0.19575,
          -0.15402,          -0.04062,          -0.04017,           0.05717,
          -0.01665,          -0.00199,
  };
  static final double mertabr[] = {
          -8.30490,         -11.68232,          86.54880,        4361.05018,
           0.00002,          -0.00001,
          -0.01102,           0.00410,           0.00007,          -0.00276,
           0.00117,           0.00082,
           0.00049,           0.00007,           0.00003,          -0.00001,
           0.00012,           0.00005,
          -0.00186,          -0.00534,
          -0.03301,           0.01808,
           0.00008,           0.00005,
          -0.00394,           0.00202,           0.02362,          -0.00359,
           0.00638,          -0.06767,
           0.00422,          -0.00493,           0.00660,           0.00513,
          -0.00417,           0.00708,
           0.05849,          -0.00213,          -0.07647,          -0.16162,
          -0.30551,           0.13856,
          -0.02789,           0.01811,          -0.04155,          -0.06229,
           0.05729,          -0.03694,
          -0.03087,           0.01610,
          -0.00297,          -0.00167,           0.00041,          -0.00157,
          -0.00115,           0.00058,
           0.00796,           0.00436,          -0.01393,           0.02921,
          -0.05902,          -0.02363,
           0.00459,          -0.01512,           0.10038,           0.02964,
          -0.08369,           0.34570,
          -0.00749,          -0.02653,
           0.01361,          -0.00326,           0.00406,           0.00952,
          -0.00594,          -0.00829,
          -0.02763,          -0.09933,
          -0.04143,           0.05152,          -0.08436,          -0.05294,
          -0.00329,          -0.00016,
          -0.04340,           0.02566,
          -0.03027,           0.10904,
           0.03665,          -0.03070,
           0.23525,           0.00182,
           0.03092,          -0.02212,
           0.01255,           0.00777,
          -0.01025,           0.00042,
          -0.00065,           0.00440,
           0.08688,           0.00136,
           0.05700,          -0.03616,          -0.11272,          -0.20838,
          -0.37048,           0.18314,
           0.00717,          -0.02911,           0.15848,           0.05266,
          -0.13451,           0.51639,
           0.00688,           0.02029,
           0.00596,           0.00423,
          -0.00253,           0.01196,
           0.05264,          -0.03301,           0.10669,           0.07558,
          -0.02461,           0.16282,
          -0.18481,          -0.57118,           0.85303,          -0.44876,
           0.37090,           0.65915,
          -0.00458,           0.00660,
           0.41186,           0.09829,          -0.31999,           1.51149,
          -0.00052,          -0.00809,
           0.01384,          -0.07114,
          -0.00435,          -0.03237,           0.02162,           0.00294,
           0.29742,          -0.15430,
          -0.04508,           0.17436,
           0.01577,           0.00485,
          -0.00258,           0.00946,
           0.00061,           0.00119,
           0.01095,          -0.00788,
           0.00530,          -0.01478,
        2885.06380,        2152.76256,        2361.91098,        1442.28586,
         602.45147,         251.18991,        -121.68155,          71.20167,
         404.94753,        1607.37580,       11211.04090,       -2905.37340,
       -9066.27933,      -40747.62807,
          -0.00189,           0.00957,
           0.00332,           0.00907,
           0.00574,          -0.01255,
          -0.01134,           0.00291,
          -0.00666,          -0.00615,
          -0.04947,           0.06182,           0.03965,           0.08091,
           0.06846,          -0.03612,           0.13966,           0.12543,
          -0.05494,          -0.05043,
          -0.24454,          -0.20507,           0.56201,          -0.75997,
           1.15728,           0.76203,
          -0.00559,          -0.00536,
           0.01872,           0.00104,
           0.03044,           0.02504,
          -1.07241,          -0.00288,
           0.00950,          -0.00760,
          -0.03211,           0.02261,
           0.02678,          -0.06868,
           0.03008,          -0.02062,
           0.04997,          -0.15164,
          -0.00176,          -0.00580,
          -0.00730,          -0.00676,
          -0.13906,          -0.00089,
          -0.00362,           0.00817,
           0.02021,           0.07719,
           0.02788,           0.02061,
          -0.00274,           0.00016,
           0.00566,           0.02293,
           0.04691,          -0.05005,          -0.05095,          -0.06225,
          -0.19770,          -0.00456,
          -0.00848,           0.00595,
          -0.04506,          -0.00172,
          -0.01960,           0.22971,           0.14459,           0.04362,
          -0.40199,           0.00386,
           0.01442,          -0.00088,
          -0.00020,           0.00544,
           0.04768,           0.05222,
          -0.04069,          -0.00003,
          15.71084,         -12.28846,         -66.23443,        -109.83758,
        -586.31996,         311.09606,        1070.75040,        2094.34080,
        3839.04103,       -1797.34193,
          -0.01216,           0.01244,
          -0.01666,           0.02627,
           0.00687,          -0.01291,
           0.00939,          -0.01905,           0.09401,           0.05027,
          -0.09398,           0.23942,
          -0.00379,           0.00834,
           0.05632,          -0.01907,          -0.04654,          -0.21243,
           0.00255,           0.00179,
           0.00540,           0.00497,
           0.01427,           0.00243,
          -0.00697,          -0.02792,
          -0.01524,           0.00810,
          -0.00461,           0.00238,
           0.00899,          -0.01515,
          -0.01011,          -0.04390,
          -0.00447,          -0.00992,
          -0.06110,           0.00975,          -0.00261,           0.03415,
          -0.02336,          -0.08776,
          -0.00883,           0.01346,
          -0.00229,          -0.00895,
          42.18049,         -48.21316,        -148.61588,        -171.57236,
        -414.27195,         343.09118,         394.59044,         511.79914,
          -0.00911,          -0.00220,
          -0.06315,          -0.00988,
           0.04357,          -0.02389,
           0.00004,           0.00232,
           0.00581,          -0.00317,
           0.00948,          -0.00497,
          -0.00734,           0.00300,
           0.01883,          -0.01055,
          -0.00365,          -0.00126,
          24.18074,          12.28004,          43.18187,         -58.69806,
        -102.40566,         -79.48349,         -74.81060,          89.71332,
           0.00241,          -0.00135,          -0.00136,          -0.01617,
           0.00818,           0.00873,
           0.00368,           0.00383,
          -2.25893,          10.18542,          20.73104,           9.07389,
          13.73458,         -29.10491,         -20.62071,         -10.63404,
           0.00382,          -0.00143,
          -3.77385,           0.12725,          -1.30842,           6.75795,
           7.94463,           1.79092,           1.24458,          -4.73211,
          -0.36978,          -1.25710,          -2.06373,           0.06194,
          -0.00509,           2.08851,           1.07491,           0.04112,
          -0.28582,          -0.51413,          -0.53312,           0.11936,
           0.04447,           0.23945,
           0.12450,          -0.11821,          -0.06100,          -0.12924,
          -0.05193,           0.02219,
           0.01977,          -0.02933,          -0.00771,          -0.01077,
           0.00109,          -0.00273,
  };
  static final byte[] merargs={
    (byte)0,  (byte)3,
    (byte)3,  (byte)1,  (byte)1,(byte)-10,  (byte)3, (byte)11,  (byte)4,(byte)0,
    (byte)2,  (byte)2,  (byte)5, (byte)-5,  (byte)6,  (byte)2,
    (byte)3,  (byte)5,  (byte)1,(byte)-14,  (byte)2,  (byte)2,  (byte)3,(byte)1,
    (byte)3,  (byte)1,  (byte)1, (byte)-5,  (byte)2,  (byte)4,  (byte)3,(byte)0,
    (byte)1,  (byte)1,  (byte)6,  (byte)0,
    (byte)1,  (byte)2,  (byte)6,  (byte)0,
    (byte)3,  (byte)2,  (byte)1, (byte)-7,  (byte)2,  (byte)3,  (byte)3,(byte)0,
    (byte)1,  (byte)1,  (byte)5,  (byte)2,
    (byte)2,  (byte)1,  (byte)1, (byte)-4,  (byte)3,  (byte)2,
    (byte)1,  (byte)2,  (byte)5,  (byte)2,
    (byte)2,  (byte)2,  (byte)1, (byte)-5,  (byte)2,  (byte)2,
    (byte)1,  (byte)3,  (byte)5,  (byte)0,
    (byte)2,  (byte)4,  (byte)1,(byte)-10,  (byte)2,  (byte)1,
    (byte)2,  (byte)3,  (byte)1, (byte)-8,  (byte)2,  (byte)0,
    (byte)2,  (byte)1,  (byte)1, (byte)-3,  (byte)2,  (byte)2,
    (byte)2,  (byte)1,  (byte)1, (byte)-2,  (byte)2,  (byte)2,
    (byte)1,  (byte)1,  (byte)3,  (byte)0,
    (byte)2,  (byte)3,  (byte)1, (byte)-7,  (byte)2,  (byte)1,
    (byte)2,  (byte)1,  (byte)1, (byte)-3,  (byte)3,  (byte)0,
    (byte)1,  (byte)1,  (byte)2,  (byte)0,
    (byte)2,  (byte)2,  (byte)1, (byte)-4,  (byte)2,  (byte)1,
    (byte)2,  (byte)4,  (byte)1, (byte)-9,  (byte)2,  (byte)0,
    (byte)1,  (byte)2,  (byte)3,  (byte)0,
    (byte)2,  (byte)1,  (byte)1, (byte)-2,  (byte)3,  (byte)0,
    (byte)2,  (byte)1,  (byte)1, (byte)-4,  (byte)2,  (byte)0,
    (byte)2,  (byte)1,  (byte)1, (byte)-1,  (byte)2,  (byte)0,
    (byte)2,  (byte)3,  (byte)1, (byte)-6,  (byte)2,  (byte)0,
    (byte)1,  (byte)3,  (byte)3,  (byte)0,
    (byte)2,  (byte)2,  (byte)1, (byte)-7,  (byte)2,  (byte)0,
    (byte)2,  (byte)1,  (byte)1, (byte)-2,  (byte)4,  (byte)0,
    (byte)2,  (byte)1,  (byte)1, (byte)-1,  (byte)3,  (byte)0,
    (byte)1,  (byte)2,  (byte)2,  (byte)2,
    (byte)2,  (byte)2,  (byte)1, (byte)-3,  (byte)2,  (byte)2,
    (byte)2,  (byte)4,  (byte)1, (byte)-8,  (byte)2,  (byte)0,
    (byte)2,  (byte)3,  (byte)1,(byte)-10,  (byte)2,  (byte)0,
    (byte)2,  (byte)1,  (byte)1, (byte)-4,  (byte)5,  (byte)0,
    (byte)2,  (byte)1,  (byte)1, (byte)-3,  (byte)5,  (byte)2,
    (byte)2,  (byte)1,  (byte)1, (byte)-5,  (byte)2,  (byte)2,
    (byte)2,  (byte)1,  (byte)1, (byte)-5,  (byte)6,  (byte)0,
    (byte)2,  (byte)1,  (byte)1, (byte)-2,  (byte)5,  (byte)1,
    (byte)3,  (byte)1,  (byte)1, (byte)-4,  (byte)5,  (byte)5,  (byte)6,(byte)0,
    (byte)1,  (byte)4,  (byte)3,  (byte)0,
    (byte)2,  (byte)1,  (byte)1, (byte)-3,  (byte)6,  (byte)1,
    (byte)2,  (byte)1,  (byte)1, (byte)-1,  (byte)5,  (byte)0,
    (byte)2,  (byte)1,  (byte)1, (byte)-2,  (byte)6,  (byte)0,
    (byte)2,  (byte)1,  (byte)1, (byte)-1,  (byte)6,  (byte)0,
    (byte)2,  (byte)1,  (byte)1, (byte)-2,  (byte)7,  (byte)0,
    (byte)2,  (byte)1,  (byte)1, (byte)-1,  (byte)7,  (byte)0,
    (byte)3,  (byte)4,  (byte)1,(byte)-14,  (byte)2,  (byte)2,  (byte)3,(byte)0,
    (byte)3,  (byte)1,  (byte)1,  (byte)2,  (byte)5, (byte)-5,  (byte)6,(byte)0,
    (byte)1,  (byte)1,  (byte)1,  (byte)6,
    (byte)3,  (byte)2,  (byte)1,(byte)-10,  (byte)3, (byte)11,  (byte)4,(byte)0,
    (byte)3,  (byte)1,  (byte)1, (byte)-2,  (byte)5,  (byte)5,  (byte)6,(byte)0,
    (byte)3,  (byte)6,  (byte)1,(byte)-14,  (byte)2,  (byte)2,  (byte)3,(byte)0,
    (byte)2,  (byte)1,  (byte)1,  (byte)1,  (byte)6,  (byte)0,
    (byte)2,  (byte)1,  (byte)1,  (byte)2,  (byte)6,  (byte)0,
    (byte)2,  (byte)1,  (byte)1,  (byte)1,  (byte)5,  (byte)1,
    (byte)2,  (byte)2,  (byte)1, (byte)-4,  (byte)3,  (byte)1,
    (byte)2,  (byte)1,  (byte)1,  (byte)2,  (byte)5,  (byte)0,
    (byte)2,  (byte)3,  (byte)1, (byte)-5,  (byte)2,  (byte)2,
    (byte)2,  (byte)1,  (byte)1,  (byte)3,  (byte)5,  (byte)0,
    (byte)2,  (byte)5,  (byte)1,(byte)-10,  (byte)2,  (byte)0,
    (byte)1,  (byte)3,  (byte)2,  (byte)0,
    (byte)2,  (byte)2,  (byte)1, (byte)-2,  (byte)2,  (byte)0,
    (byte)2,  (byte)1,  (byte)1,  (byte)1,  (byte)3,  (byte)0,
    (byte)2,  (byte)4,  (byte)1, (byte)-7,  (byte)2,  (byte)0,
    (byte)2,  (byte)2,  (byte)1, (byte)-3,  (byte)3,  (byte)0,
    (byte)2,  (byte)1,  (byte)1,  (byte)1,  (byte)2,  (byte)0,
    (byte)2,  (byte)3,  (byte)1, (byte)-4,  (byte)2,  (byte)0,
    (byte)2,  (byte)5,  (byte)1, (byte)-9,  (byte)2,  (byte)0,
    (byte)2,  (byte)1,  (byte)1,  (byte)2,  (byte)3,  (byte)0,
    (byte)2,  (byte)2,  (byte)1, (byte)-2,  (byte)3,  (byte)0,
    (byte)1,  (byte)4,  (byte)2,  (byte)0,
    (byte)2,  (byte)2,  (byte)1, (byte)-1,  (byte)2,  (byte)0,
    (byte)2,  (byte)4,  (byte)1, (byte)-6,  (byte)2,  (byte)0,
    (byte)2,  (byte)2,  (byte)1, (byte)-2,  (byte)4,  (byte)0,
    (byte)2,  (byte)2,  (byte)1, (byte)-1,  (byte)3,  (byte)0,
    (byte)2,  (byte)1,  (byte)1,  (byte)2,  (byte)2,  (byte)1,
    (byte)2,  (byte)3,  (byte)1, (byte)-3,  (byte)2,  (byte)0,
    (byte)2,  (byte)5,  (byte)1, (byte)-8,  (byte)2,  (byte)0,
    (byte)2,  (byte)2,  (byte)1, (byte)-3,  (byte)5,  (byte)0,
    (byte)1,  (byte)5,  (byte)2,  (byte)1,
    (byte)2,  (byte)2,  (byte)1, (byte)-2,  (byte)5,  (byte)0,
    (byte)2,  (byte)1,  (byte)1,  (byte)4,  (byte)3,  (byte)0,
    (byte)2,  (byte)2,  (byte)1, (byte)-3,  (byte)6,  (byte)0,
    (byte)2,  (byte)2,  (byte)1, (byte)-1,  (byte)5,  (byte)0,
    (byte)2,  (byte)2,  (byte)1, (byte)-2,  (byte)6,  (byte)0,
    (byte)1,  (byte)2,  (byte)1,  (byte)4,
    (byte)2,  (byte)2,  (byte)1,  (byte)1,  (byte)5,  (byte)0,
    (byte)2,  (byte)3,  (byte)1, (byte)-4,  (byte)3,  (byte)0,
    (byte)2,  (byte)2,  (byte)1,  (byte)2,  (byte)5,  (byte)0,
    (byte)2,  (byte)4,  (byte)1, (byte)-5,  (byte)2,  (byte)2,
    (byte)2,  (byte)1,  (byte)1,  (byte)3,  (byte)2,  (byte)0,
    (byte)2,  (byte)3,  (byte)1, (byte)-2,  (byte)2,  (byte)1,
    (byte)2,  (byte)3,  (byte)1, (byte)-3,  (byte)3,  (byte)0,
    (byte)2,  (byte)2,  (byte)1,  (byte)1,  (byte)2,  (byte)0,
    (byte)2,  (byte)4,  (byte)1, (byte)-4,  (byte)2,  (byte)0,
    (byte)2,  (byte)3,  (byte)1, (byte)-2,  (byte)3,  (byte)0,
    (byte)2,  (byte)3,  (byte)1, (byte)-1,  (byte)2,  (byte)0,
    (byte)2,  (byte)3,  (byte)1, (byte)-1,  (byte)3,  (byte)0,
    (byte)2,  (byte)2,  (byte)1,  (byte)2,  (byte)2,  (byte)0,
    (byte)2,  (byte)4,  (byte)1, (byte)-3,  (byte)2,  (byte)0,
    (byte)2,  (byte)3,  (byte)1, (byte)-3,  (byte)5,  (byte)0,
    (byte)2,  (byte)1,  (byte)1,  (byte)5,  (byte)2,  (byte)1,
    (byte)2,  (byte)3,  (byte)1, (byte)-2,  (byte)5,  (byte)0,
    (byte)2,  (byte)3,  (byte)1, (byte)-1,  (byte)5,  (byte)0,
    (byte)2,  (byte)3,  (byte)1, (byte)-2,  (byte)6,  (byte)0,
    (byte)1,  (byte)3,  (byte)1,  (byte)3,
    (byte)2,  (byte)4,  (byte)1, (byte)-4,  (byte)3,  (byte)0,
    (byte)2,  (byte)5,  (byte)1, (byte)-5,  (byte)2,  (byte)0,
    (byte)2,  (byte)4,  (byte)1, (byte)-2,  (byte)2,  (byte)0,
    (byte)2,  (byte)5,  (byte)1, (byte)-4,  (byte)2,  (byte)0,
    (byte)2,  (byte)4,  (byte)1, (byte)-2,  (byte)3,  (byte)0,
    (byte)2,  (byte)5,  (byte)1, (byte)-3,  (byte)2,  (byte)0,
    (byte)2,  (byte)2,  (byte)1,  (byte)5,  (byte)2,  (byte)0,
    (byte)2,  (byte)4,  (byte)1, (byte)-2,  (byte)5,  (byte)0,
    (byte)2,  (byte)4,  (byte)1, (byte)-1,  (byte)5,  (byte)0,
    (byte)1,  (byte)4,  (byte)1,  (byte)3,
    (byte)2,  (byte)6,  (byte)1, (byte)-5,  (byte)2,  (byte)1,
    (byte)2,  (byte)5,  (byte)1, (byte)-2,  (byte)2,  (byte)0,
    (byte)2,  (byte)5,  (byte)1, (byte)-2,  (byte)5,  (byte)0,
    (byte)1,  (byte)5,  (byte)1,  (byte)3,
    (byte)2,  (byte)7,  (byte)1, (byte)-5,  (byte)2,  (byte)0,
    (byte)1,  (byte)6,  (byte)1,  (byte)3,
    (byte)1,  (byte)7,  (byte)1,  (byte)3,
    (byte)1,  (byte)8,  (byte)1,  (byte)2,
    (byte)1,  (byte)9,  (byte)1,  (byte)2,
    (byte)1, (byte)10,  (byte)1,  (byte)1,
    (byte)1, (byte)11,  (byte)1,  (byte)0,
   (byte)-1
  };
  
  static Plantbl mer404=new Plantbl(
                            new short[]{11, 14, 10, 11,  4,  5,  2,  0,  0},
                            (short)6,merargs,mertabl,mertabb,mertabr,
                            3.8709830979999998e-01);
}
class SwemptabNep {
  
  static final double neptabl[] = {
       -1376.86480,         730.38970,    78655362.50948,     1095691.38676,
        -196.19023,        2086.77782,
        -122.04650,        -276.81592,
         184.56164,        -148.08924,
           3.39142,         -14.75027,
          -9.22741,           0.87688,
          -0.13903,          -0.44707,
          -0.17668,          -0.36299,
          -0.12682,          -0.26636,
          -0.51426,          -0.24667,
          -0.04965,          -0.03177,
           0.05050,          -0.00249,
          -0.80362,          -0.07363,          -0.15436,          -0.07180,
           2.45034,          -3.50145,           0.86698,           0.09777,
           7.72386,           7.16565,           2.10273,           8.86682,
           2.44705,          77.90155,
           0.28323,         -11.87157,         -13.64083,         252.70556,
          -4.94214,          -6.17988,        -305.60504,          51.23962,
       -2759.81719,        2476.20912,
          12.65762,          13.31543,
           0.36996,          -0.19077,           0.67363,           0.36737,
           0.02312,           0.02216,
           0.09953,           0.04777,
          -0.00572,          -0.02772,
          -0.02478,          -0.21920,
          -0.15289,          -1.50784,
          -0.17822,           0.34638,          -0.70473,          -8.61559,
          -2.65756,           1.25632,
          -0.31453,          -1.40348,          -4.02571,          -1.50467,
         -69.62308,           3.21315,
           0.69973,           0.08832,
          -0.00551,          -0.04964,
          -0.02264,          -0.34881,
           0.00762,          -1.85072,
           0.01407,          -0.30457,
          -0.09851,          -0.02372,
          -0.07729,          -0.11602,          -0.75995,          -0.71884,
          -0.08585,          -0.30406,           0.45818,           0.14921,
          -0.01033,          -0.11776,
           0.00640,          -0.57717,
          -0.01014,          -0.01357,          -0.00544,          -0.02168,
           0.40468,           0.28195,           0.00668,           0.14448,
           0.01245,          -0.08956,
          -0.26283,           0.01864,          -0.00641,          18.55347,
           0.01460,           0.08284,
          -0.04785,           0.11360,
          -0.33861,           0.01327,          -0.06392,          -0.18758,
           0.05449,          -0.05583,
          -0.00435,          -0.09869,
          -0.00286,          -0.04613,
          -0.00395,          -0.14564,
          -0.01385,          -0.01762,
           0.21160,          -0.61631,          -0.52100,          -0.04583,
           0.32812,           0.32138,
           0.04749,          -0.05724,
           0.11239,           0.13216,
          -0.01203,           0.40084,          -0.05207,          34.07903,
          -0.21457,          -0.34938,          -0.04594,           0.11198,
          -0.30662,          -0.20776,          -0.01076,          -0.10959,
           0.10891,          -0.10304,
          -0.28141,           0.25061,          -0.20293,           0.79930,
  };
  static final double neptabb[] = {
        -391.05987,        -243.95958,         -23.83558,          58.13857,
           5.04859,          -3.93183,
         -14.21914,           7.14247,
         -12.09415,          -9.70132,
           1.04307,           0.47323,
          -0.07504,           0.70575,
          -0.05239,           0.00482,
          -0.02916,           0.00877,
          -0.00528,          -0.00286,
           0.00028,          -0.00228,
          -0.00056,          -0.00149,
           0.00049,           0.00047,
          -0.18765,          -0.59571,           0.03742,          -0.14653,
           2.30535,           0.65092,           0.42216,           0.24521,
          -2.86932,           2.37808,          -0.58456,           0.27446,
          -1.12264,          -2.04413,
         -11.71318,          -1.41554,         -23.30671,         -24.70499,
           8.82738,          85.64657,         -90.02223,          22.42604,
       -4749.41359,       -4244.46820,
          25.20811,         -18.51469,
          -1.19892,          -0.61067,           0.67734,          -1.08912,
          -0.01607,           0.00626,
          -0.00008,           0.00126,
          -0.00330,          -0.00078,
          -0.01503,           0.00758,
          -0.13208,          -0.00218,
          -0.04522,           0.20297,          -0.94708,          -0.77897,
          -2.74075,          -3.01122,
          -1.03394,           0.00886,           1.55485,          -4.68416,
          -0.13244,         -57.26983,
           0.05589,          -0.55396,
          -0.00130,           0.00526,
          -0.01028,           0.02086,
           0.01334,           0.00699,
           0.08565,           0.02020,
           0.01001,          -0.08402,
           0.08558,          -0.04488,           0.57268,          -0.59574,
           0.00807,           0.00492,           0.21993,          -0.18949,
          -0.00396,           0.00735,
           0.00487,           0.00230,
           0.00699,          -0.00473,           0.01406,          -0.00139,
           0.00738,           0.00099,           0.00161,           0.00019,
          -0.00067,          -0.00047,
           0.00572,          -0.00486,          -0.00842,           0.00322,
           0.00018,          -0.00109,
          -0.00272,           0.00112,
          -0.00041,           0.00763,           0.00211,           0.00118,
          -0.46842,          -0.17877,
           0.00209,          -0.00179,
           0.00090,          -0.00075,
           0.00618,           0.00610,
           0.00015,           0.00032,
          -0.00123,           0.00026,           0.00332,           0.00135,
           0.39130,          -0.34727,
           0.00015,          -0.00027,
          -0.00026,          -0.00052,
           0.00162,           0.00913,          -0.00697,           0.00308,
          -0.00333,          -0.00258,          -0.00117,           0.00035,
           0.00766,           0.00194,           0.00135,           0.00067,
          -0.41171,           0.24241,
           0.00106,           0.00025,           0.00013,          -0.00019,
  };
  static final double neptabr[] = {
        -767.68936,        -460.59576,         -52.41861,        -273.85897,
          59.52489,           1.85006,
         -39.64750,          23.63348,
         -34.60399,         -23.41681,
           2.74937,           1.55389,
           0.20343,           2.15502,
          -0.12846,           0.07199,
          -0.07555,           0.05582,
          -0.04354,           0.01546,
          -0.03931,           0.07623,
          -0.00491,           0.00661,
           0.00322,           0.01540,
          -0.06741,          -0.35343,           0.00469,          -0.08073,
           1.94975,           0.66376,           0.06137,           0.31426,
          -2.93841,           4.27732,          -4.00342,           1.11157,
         -36.87785,           1.24960,
           4.69573,           2.15164,        -114.24899,          -6.69320,
          12.99919,          -9.47795,         -21.82350,        -156.88624,
       -1237.19769,       -1379.88864,
           6.54369,          -6.20873,
          -0.14163,          -0.32700,           0.17937,          -0.34864,
           0.01393,          -0.01286,
           0.02876,          -0.05767,
           0.02210,          -0.00128,
           0.16495,          -0.01242,
           1.15915,          -0.10365,
          -0.33224,          -0.10045,           6.83719,          -0.27499,
          -0.31284,          -0.94332,
           1.63704,          -0.33318,           1.48134,          -1.32257,
           0.96498,          -8.31047,
          -0.00402,          -0.09441,
           0.04292,          -0.00444,
           0.30325,          -0.02012,
           1.67999,           0.00353,
           0.00467,           0.03556,
           0.01393,          -0.01229,
           0.01188,          -0.01390,           0.04615,          -0.03509,
           0.32423,          -0.12491,           0.13682,           0.15131,
           0.11221,          -0.01201,
           0.57239,           0.00093,
           0.02068,          -0.01162,           0.00647,          -0.00325,
           0.27010,          -0.42993,           0.14314,          -0.01353,
          -0.08757,          -0.00699,
           0.00199,           0.31873,          18.80329,           0.01681,
           0.08009,          -0.00998,
          -0.14421,          -0.15912,
           0.37208,           0.49744,           0.35144,           0.06582,
          -0.11501,          -0.14037,
           0.10352,          -0.00768,
           0.04826,          -0.00423,
           0.19850,           0.00310,
          -0.01780,           0.01350,
          -0.61106,          -0.20525,          -0.04388,           0.52143,
           0.19300,          -0.21446,
          -0.05749,          -0.04776,
           0.12877,          -0.10908,
           0.39821,           0.00627,          34.03956,           0.04392,
          -0.34455,           0.22015,           0.11743,           0.04638,
           0.20723,          -0.30447,           0.10976,          -0.01008,
          -0.20778,          -0.21822,
           0.24939,           0.27976,           0.79790,           0.20200,
  };
  static byte nepargs[] = {
  (byte)0,  (byte)3,
  (byte)2,  (byte)1,  (byte)7, (byte)-2,  (byte)8,  (byte)0,
  (byte)3,  (byte)3,  (byte)5, (byte)-8,  (byte)6,  (byte)3,  (byte)8,  (byte)0,
  (byte)2,  (byte)2,  (byte)7, (byte)-4,  (byte)8,  (byte)0,
  (byte)3,  (byte)1,  (byte)5, (byte)-3,  (byte)6,  (byte)3,  (byte)8,  (byte)0,
  (byte)2,  (byte)3,  (byte)7, (byte)-6,  (byte)8,  (byte)0,
  (byte)2,  (byte)4,  (byte)7, (byte)-8,  (byte)8,  (byte)0,
  (byte)3,  (byte)1,  (byte)6, (byte)-6,  (byte)7,  (byte)6,  (byte)8,  (byte)0,
  (byte)3,  (byte)1,  (byte)6, (byte)-5,  (byte)7,  (byte)4,  (byte)8,  (byte)0,
  (byte)3,  (byte)1,  (byte)6, (byte)-4,  (byte)7,  (byte)2,  (byte)8,  (byte)0,
  (byte)2,  (byte)1,  (byte)6, (byte)-3,  (byte)7,  (byte)0,
  (byte)3,  (byte)1,  (byte)6, (byte)-2,  (byte)7, (byte)-1,  (byte)8,  (byte)0,
  (byte)2,  (byte)5,  (byte)7, (byte)-9,  (byte)8,  (byte)1,
  (byte)2,  (byte)4,  (byte)7, (byte)-7,  (byte)8,  (byte)1,
  (byte)2,  (byte)3,  (byte)7, (byte)-5,  (byte)8,  (byte)1,
  (byte)2,  (byte)2,  (byte)7, (byte)-3,  (byte)8,  (byte)0,
  (byte)2,  (byte)1,  (byte)7, (byte)-1,  (byte)8,  (byte)1,
  (byte)1,  (byte)1,  (byte)8,  (byte)2,
  (byte)2,  (byte)1,  (byte)7, (byte)-3,  (byte)8,  (byte)0,
  (byte)2,  (byte)2,  (byte)7, (byte)-5,  (byte)8,  (byte)1,
  (byte)3,  (byte)1,  (byte)6, (byte)-6,  (byte)7,  (byte)5,  (byte)8,  (byte)0,
  (byte)3,  (byte)1,  (byte)6, (byte)-5,  (byte)7,  (byte)3,  (byte)8,  (byte)0,
  (byte)2,  (byte)5,  (byte)7, (byte)-8,  (byte)8,  (byte)0,
  (byte)2,  (byte)4,  (byte)7, (byte)-6,  (byte)8,  (byte)0,
  (byte)2,  (byte)3,  (byte)7, (byte)-4,  (byte)8,  (byte)0,
  (byte)2,  (byte)2,  (byte)7, (byte)-2,  (byte)8,  (byte)1,
  (byte)1,  (byte)1,  (byte)7,  (byte)0,
  (byte)1,  (byte)2,  (byte)8,  (byte)2,
  (byte)2,  (byte)1,  (byte)7, (byte)-4,  (byte)8,  (byte)0,
  (byte)2,  (byte)5,  (byte)7, (byte)-7,  (byte)8,  (byte)0,
  (byte)2,  (byte)4,  (byte)7, (byte)-5,  (byte)8,  (byte)0,
  (byte)2,  (byte)3,  (byte)7, (byte)-3,  (byte)8,  (byte)0,
  (byte)2,  (byte)2,  (byte)7, (byte)-1,  (byte)8,  (byte)0,
  (byte)2,  (byte)1,  (byte)7,  (byte)1,  (byte)8,  (byte)0,
  (byte)1,  (byte)3,  (byte)8,  (byte)1,
  (byte)2,  (byte)1,  (byte)6, (byte)-2,  (byte)8,  (byte)1,
  (byte)2,  (byte)5,  (byte)7, (byte)-6,  (byte)8,  (byte)0,
  (byte)2,  (byte)4,  (byte)7, (byte)-4,  (byte)8,  (byte)0,
  (byte)1,  (byte)4,  (byte)8,  (byte)1,
  (byte)3,  (byte)2,  (byte)5, (byte)-4,  (byte)6, (byte)-1,  (byte)8,  (byte)1,
  (byte)3,  (byte)1,  (byte)6,  (byte)1,  (byte)7, (byte)-3,  (byte)8,  (byte)0,
  (byte)2,  (byte)1,  (byte)6, (byte)-1,  (byte)8,  (byte)1,
  (byte)3,  (byte)1,  (byte)6, (byte)-1,  (byte)7,  (byte)1,  (byte)8,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-6,  (byte)6,  (byte)1,  (byte)8,  (byte)0,
  (byte)2,  (byte)5,  (byte)7, (byte)-5,  (byte)8,  (byte)1,
  (byte)1,  (byte)1,  (byte)6,  (byte)0,
  (byte)2,  (byte)6,  (byte)7, (byte)-6,  (byte)8,  (byte)0,
  (byte)2,  (byte)7,  (byte)7, (byte)-7,  (byte)8,  (byte)0,
  (byte)2,  (byte)2,  (byte)6, (byte)-2,  (byte)8,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-3,  (byte)6, (byte)-1,  (byte)8,  (byte)0,
  (byte)2,  (byte)2,  (byte)6, (byte)-1,  (byte)8,  (byte)1,
  (byte)2,  (byte)1,  (byte)5, (byte)-2,  (byte)8,  (byte)0,
  (byte)3,  (byte)3,  (byte)5, (byte)-5,  (byte)6, (byte)-1,  (byte)8,  (byte)0,
  (byte)2,  (byte)4,  (byte)7,  (byte)5,  (byte)8,  (byte)0,
  (byte)2,  (byte)1,  (byte)5, (byte)-1,  (byte)8,  (byte)1,
  (byte)3,  (byte)1,  (byte)5, (byte)-1,  (byte)7,  (byte)1,  (byte)8,  (byte)1,
  (byte)3,  (byte)1,  (byte)5, (byte)-5,  (byte)6,  (byte)1,  (byte)8,  (byte)1,
  (byte)1,  (byte)1,  (byte)5,  (byte)0,
  (byte)2,  (byte)2,  (byte)5, (byte)-1,  (byte)8,  (byte)1,
 (byte)-1
  };
  
  static Plantbl nep404 = new Plantbl(
                               new short[]{0,  0,  0,  0,  3,  8,  7,  9,  0},
                               (short)3,
                               nepargs,
                               neptabl,
                               neptabb,
                               neptabr,
                               3.0110386869399999e+01
  );
}
class SwemptabPlu {
  
  static final double plutabl[] = {
    74986469.33577,   100898343.73690,    48199471.54076,     9520076.03177,
      690431.67340,     -427355.12716,    52266623.77862,      860190.70714,
         -21.08511,        -143.39295,
        -126.71124,          48.18528,
         -88.74508,          40.50942,
          51.29367,         -10.24075,
           0.63094,          32.03258,
        -410.00781,         399.90234,        -116.54319,          51.50329,
         116.84565,         687.76781,         -13.38605,         182.70107,
       -1668.12226,       -5162.22648,        -585.68297,       -2247.56041,
         -20.95875,        -193.13703,
         -57.12097,         -10.35058,
       -1778.01442,       -6463.73779,        -657.86093,       -2713.44436,
         -41.32560,        -211.82042,
        -107.16513,         -36.58628,
    97929588.08231,   -33582903.63417,   143382679.31770,   -47411568.92345,
    79428827.73581,   -24658834.87499,    19861233.17488,    -5755585.62084,
     1995060.95931,     -693507.08147,      135176.31467,      109360.38672,
       -8188.00598,       -1680.95072,       71020.19608,      -70785.39049,
         -24.56034,         -20.34919,
        1618.45976,       -2079.48538,         635.62954,        -850.87068,
          44.95257,         -64.04459,
         -18.61475,          -1.77734,
           9.38079,           5.19958,
       17422.08783,       -4872.53852,       10985.76629,       -1137.68569,
        1771.28893,         288.93745,          40.22664,          37.90027,
           6.81361,         -32.65868,
          16.97268,          11.76152,
          29.33024,         -12.92289,
         -55.13187,         -14.73791,
           7.52474,        -102.05060,
         182.53144,         -20.18960,
  -490237997.49400,   486646248.63360,  -781277018.26430,   602300460.57290,
  -463787999.46420,   249529525.96100,  -123964746.86420,    31353019.97807,
   -13353800.92159,    -3463382.63269,      -35469.17654,    -1035343.45385,
       65076.64025,      -38181.61312,      -16473.33813,        3928.44674,
         188.60263,        1000.42530,
     -208376.39376,     -700566.62363,      114839.84613,     -342407.71113,
       39467.04812,      -14553.84849,
      581895.26100,     1012499.16715,      406317.22416,      310804.78515,
       43625.07033,       -4157.26545,
       -5930.13795,       -2070.62413,
        3348.17582,      -10871.23729,
      144609.18550,       60383.63650,       27912.02226,       15254.61228,
      -98561.37758,      -67442.28158,      -15573.63338,      -19931.99773,
       24323.06905,      -37473.32558,        2840.64042,       -8911.23694,
      -19636.31898,       71725.21946,      -12280.54554,       12251.00101,
       88626.52260,        5513.68450,       18506.41546,       -6513.87434,
      -83350.14621,       44300.00743,      -22075.37353,        3731.57531,
      -29167.76020,      -21642.67384,
    56602666.72177,   -22225578.01823,    50576897.80669,   -50319847.79086,
     5689259.25622,   -29585299.79697,    -4249711.27661,    -4490830.29568,
     -727678.08724,      366050.85631,       19183.62792,       55647.98226,
        1897.78091,       -1091.03988,         432.38158,        -138.62556,
         101.38743,          25.67379,
         320.20735,         362.16615,          85.06067,          54.02616,
           2.39460,          18.70004,
          -8.43353,           2.72100,
          -3.11205,          -3.06201,
         136.31503,         -28.33620,          48.68781,         -18.45285,
           1.15302,          -1.52360,
          -0.13706,          -0.37489,
           0.08750,          -0.14579,
          -0.07051,          -0.06518,
           0.30237,          -0.00448,
           4.83172,           6.83684,
     1752447.78043,     -945086.75857,     2340978.12819,    -1963675.42559,
     1254147.25257,    -1274861.91191,      279459.60237,     -263954.01378,
       11835.62290,      -16344.44434,        9119.98960,       -2390.44218,
         -23.67909,          86.73916,        -642.78635,       -1290.12208,
          -0.43345,          -1.85348,
           0.03094,          -0.01655,
           0.12380,           0.31834,
           5.54756,          -1.63109,           1.10598,          -0.17578,
           2.66994,          -2.17573,           0.97360,          -0.92226,
          -0.18533,          -0.39747,
           0.45809,          -0.65286,
           0.26129,           0.91922,
           0.81068,           0.11183,
           6.32182,          14.16786,           0.20872,           3.28489,
          -1.47458,          -2.11724,
           1.70020,          -1.99889,
           3.13003,           1.90638,
    -4483669.52795,     -446454.90158,    -6586256.67478,     -671890.16779,
    -3620444.55554,     -499672.41074,     -855998.32655,     -191073.94266,
      -73186.69110,      -22649.38582,       -2414.81729,       -1294.40542,
         436.80907,         125.48109,         -81.16877,         458.86508,
         -11.57414,         -26.39114,          -4.00801,          -5.01054,
         -18.17569,          20.86879,          -4.80965,           3.10535,
          -4.71122,           1.18169,
          74.75544,         649.21464,         -26.55060,         272.35592,
          -8.06982,          16.86110,
         -26.54868,          26.75711,
         -35.82910,          38.51063,
          22.22814,          19.38336,
          -6.30462,           0.90602,
           0.62856,          -0.34981,
          -0.10232,          -0.00939,
           0.04439,          -0.18875,
           0.16025,           0.11306,
          -0.06803,           0.06004,
      -91305.66728,      262370.61704,     -194633.44577,      304838.17733,
     -124505.90904,       94111.75602,      -22317.18255,        1575.23438,
         748.66316,        -349.78711,         166.64450,         -89.05045,
         120.76207,        -100.26715,
           3.13806,           3.71747,
          -1.44731,          -0.35235,
          -0.51660,          -1.50621,
           2.81310,          -3.93573,           1.20292,          -0.36412,
          -0.03340,          -0.00561,
          -5.29764,          26.02941,           1.91382,           3.30686,
          -3.35265,          -3.20868,
           0.05807,          -0.11885,
          -0.78588,           0.34807,          -0.19038,           0.11295,
          -0.03642,          -0.03794,
           0.00251,           0.03449,
          -0.08426,          -0.00310,
           0.05297,          -0.09278,
           0.10941,           0.00099,
     -228688.56632,      312567.73069,     -331458.31119,      328200.19460,
     -143760.57524,      104182.01134,      -17313.30132,       12591.15513,
        -440.32735,        -105.67674,         104.35854,        -852.84590,
           0.95527,           0.30212,         -54.63983,           4.06948,
           0.07545,          -0.13429,
          16.21005,          29.24658,           9.23410,          50.48867,
          30.55641,          12.76809,           0.11781,           0.70929,
          -0.04100,          13.60859,
           0.04976,          -0.02083,
           0.36279,           0.30130,          -0.02129,           0.09363,
          -0.07812,           0.01570,
          -0.06217,          -0.37181,
      -29348.55031,       43889.87672,      -35765.41577,       33855.90070,
      -10128.69894,        4535.32148,         281.75353,        -218.49194,
          -7.55224,         134.28640,           2.11319,          -2.13109,
          15.71244,          11.07183,
          -0.05406,          -0.23337,
          -1.28949,           1.34281,
           0.04212,          -0.02080,
           0.08109,           0.14820,
       -6010.46564,        3639.41780,       -5973.16000,        1381.66999,
       -1177.36865,        -501.06937,         166.14792,        -103.36431,
          14.92766,           4.12877,          -2.20893,          -6.32033,
          -0.29038,          -0.43172,
          -0.59341,           0.20477,          -0.13143,          -0.03150,
           0.10992,           0.01976,
          -0.00254,           0.02028,
          -0.30044,          -0.44658,          -0.03409,          -0.10758,
           0.08349,           0.06153,
          -0.06055,           0.18249,
          -1.15341,          -8.68699,          -0.11348,          -3.30688,
           1.08604,           1.04018,
          -0.46892,          -0.69765,           0.21504,           0.01968,
          -0.00455,          -0.01678,
           3.95643,          -3.17191,           3.95220,          -2.12670,
           0.99305,          -0.16651,
           0.34839,          -0.49162,
           0.85744,           0.20173,          -0.00975,           0.20225,
          -0.02627,          -0.02281,
          -0.18002,          -0.01803,
          -0.06144,          -0.21510,
           0.15935,          -0.01251,
          -0.21378,           0.44806,          -0.01174,           0.05779,
           0.07646,          -0.19656,          -0.04044,          -0.02521,
           0.02996,           0.06169,
           0.16698,          -0.04710,          -0.06506,          -0.02114,
           0.05500,           0.00276,
           0.08433,           0.03160,
           0.08193,           0.35773,           0.05454,           0.10718,
          -0.02823,          -0.00839,
           0.54078,           0.49347,           0.09609,           0.11825,
          -0.16092,          -0.11897,
           0.09059,           0.08254,
           0.16712,           0.05860,
          -0.09547,          -0.03206,
           0.03876,           0.04719,
          -0.02345,           0.02240,
          -0.00609,          -0.00649,
           0.03859,           0.00077,
           0.47819,           0.26196,           0.09780,           0.08104,
          -0.16919,           0.05042,
          -0.42652,           0.30810,
          -0.03409,          -0.51452,
          -0.23120,          -0.01380,
          -0.01157,          -0.00143,
          -0.00512,          -0.01628,
          -0.00189,           0.00183,
          -0.01427,          -0.02861,
           0.00618,          -0.00015,
           0.13087,           0.13870,
           0.15158,          -0.21056,
          -3.94829,          -1.06028,          -1.36602,           0.77954,
           0.08709,          -0.03118,
         -44.74949,          91.17393,           8.78173,          45.84010,
           1.97560,         -15.02849,          -0.10755,          -0.02884,
           3.38670,           0.30615,
         130.92778,         -24.33209,          43.01636,         -40.81327,
         -19.43900,          22.18162,          -0.12691,           0.33795,
          -6.44790,          -6.23145,
           0.00319,           0.01141,
          -0.03252,           0.03872,
           0.04467,           0.01614,
          -0.00382,          -0.00019,
           0.05955,           0.01533,
          16.11371,          41.37565,          61.44963,           6.90615,
           1.41326,          -0.73920,          -0.03871,          24.81978,
          -0.10229,          -0.32775,          -0.05188,          -0.05628,
          -2.33618,           2.39053,
          -0.00584,           0.00436,
           0.20903,           0.02220,
          -0.01738,          -0.02765,
          -0.00217,           0.00613,
          -0.01772,           0.01903,
           0.07075,          -0.00530,
           0.15234,          -0.37760,          -0.11641,          -0.20102,
          -0.63675,           0.20525,          -0.15783,           0.58945,
          -0.06243,           0.04306,
  };
  static final double plutabb[] = {
   -35042727.30412,   -49049197.81293,   -25374963.60995,    -5761406.03035,
     -467370.57540,       14040.11453,        2329.15763,      -13978.69390,
          45.43441,          29.70305,
          32.33772,         -38.34012,
          26.43575,         -28.76136,
         -18.59040,          12.64837,
           5.56569,         -12.51581,
         248.37350,         -64.44466,          54.02618,           4.39466,
        -269.35114,        -290.63134,         -48.03841,         -52.83576,
        1508.94995,        1682.78967,         554.02336,         715.65819,
          34.37602,          58.44397,
          16.63685,          16.10176,
       -1069.51609,        2300.89166,        -437.16796,         927.89245,
         -33.17679,          68.74495,
          18.72022,          32.97640,
   -34004958.12619,   -17758805.77098,   -48416073.75788,   -24973405.03542,
   -25374996.23732,   -13351084.97340,    -5738294.54942,    -3082092.63350,
     -519989.39256,     -206440.89101,       44186.23548,      -87639.22630,
        2506.47602,        2327.01164,      -53878.47903,      -19670.13471,
           2.66934,          -3.86086,
         106.32427,         576.47944,          46.56388,         218.28339,
           4.35402,          15.04642,
           2.68717,          -2.86835,
           0.81728,          -2.34417,
       -1604.85823,       -1999.24986,        -631.47343,       -1382.19156,
         -15.74075,        -256.97077,           6.99648,          -4.54257,
           2.63478,           1.88838,
           0.17628,          -2.11518,
          -2.46735,          -1.48743,
           1.83456,           4.68487,
          -7.10919,           3.57046,
          -5.36342,          -7.70367,
    28395956.20816,   -37176795.74372,    48969952.83034,   -48145798.96248,
    31155823.23557,   -21163596.14822,     9057634.38260,    -3167688.51696,
     1167488.70078,      219103.97591,      -19017.97335,      107849.61195,
       -3814.43474,        4405.92120,        5800.13959,       12619.88708,
          22.18168,         -89.47801,
       52202.81929,       55119.44083,        5082.58907,       37955.06062,
       -3165.24355,        3316.67588,
     -113906.43970,      -69279.41495,      -57358.07767,      -10176.17329,
       -4179.79867,        2495.99374,
         787.87180,        -154.35591,
       -1148.62509,        1034.58199,
      -22194.95235,        3341.97949,       -4578.53994,         108.30832,
        7444.39789,       16646.40725,         509.75430,        3808.92686,
        -179.85869,        7408.76716,         340.65366,        1504.64227,
       -3783.09873,      -13505.60867,         875.74489,       -3181.27898,
      -16220.93983,        8041.37347,       -2631.07448,        2899.50781,
       18894.92095,      -20072.81471,        5925.05701,       -1947.91902,
       -6731.56601,        8014.52403,
     -987793.49463,     6491762.34471,     -279205.73643,     6117135.96868,
     -140925.91402,     2259422.06929,      114028.61646,      605600.90358,
       91858.00186,       56506.65187,        8949.15777,       -9782.67413,
        -394.66541,        -105.19208,         -76.54752,         -32.59411,
         -19.28741,          10.40013,
        -107.64003,          -7.36229,         -22.25126,           4.05952,
          -3.74402,          -2.79308,
           1.03337,          -2.13968,
           1.53794,          -0.02617,
          35.70756,          12.97733,          14.46213,           6.20518,
           1.79381,           1.65422,
          -0.31216,           0.29053,
          -0.03538,          -0.01584,
          -0.08934,           0.00079,
           0.05539,          -0.21591,
           2.86929,          -2.24724,
      320797.07455,       93342.16556,      -20903.39115,       79523.22083,
     -226588.37473,     -121017.23944,      -48472.25935,      -74195.36778,
       -7962.48081,       -4607.76339,       -4597.33274,       -7983.12541,
         -20.34500,          56.82999,       -1038.19507,         619.69624,
           1.08907,          -0.91278,
          -0.13391,           0.34956,
          -0.19982,          -0.18296,
          -0.97688,           2.36806,          -0.30127,           0.50980,
           0.96103,           1.96432,           0.43338,           0.87317,
           0.36997,          -0.01583,
          -0.44692,          -0.25159,
          -0.53525,           0.01154,
          -0.13231,           0.35562,
           3.88928,          -4.02882,           1.06967,          -0.56305,
          -0.45204,           0.77213,
          -0.82873,          -0.25854,
           0.21136,          -1.06696,
      458529.05491,      616790.47568,      698431.01349,     1124501.41713,
      300226.10339,      766533.33698,       26896.22954,      207880.75720,
        1116.29607,       21793.26153,        -850.64044,        3528.95568,
          29.61278,        -120.13367,         376.95131,          66.45758,
          -3.64868,           2.76062,          -0.85352,           0.95115,
           5.35056,           2.52803,           0.90026,           0.76403,
           0.43191,           0.83605,
         125.81792,         -39.65364,          50.14425,          -5.75891,
           2.78555,           2.05055,
          -4.27266,          -4.92428,
           6.78868,           5.73537,
           3.35229,          -3.70143,
           0.08488,           1.07465,
           0.10227,           0.06074,
           0.00291,           0.01522,
          -0.02274,           0.00297,
           0.01095,          -0.01856,
          -0.02862,           0.00178,
      143640.07486,         707.21331,      177163.08586,       53386.52697,
       56856.89297,       48268.74645,        1764.52814,        7711.76224,
         352.34159,        -968.03169,         -45.16568,         -81.60481,
         -76.35993,         -98.06932,
          -1.42185,           1.81425,
          -0.23427,           0.59023,
           0.57127,          -0.36335,
           1.89975,           0.66890,           0.28797,           0.43592,
          -0.03769,           0.03273,
          -6.06571,          -2.68515,          -0.55315,           0.86977,
           1.53840,          -0.59422,
          -0.05453,           0.02447,
          -0.12658,           0.22814,          -0.01715,           0.08497,
          -0.01288,          -0.00606,
           0.01547,          -0.00692,
           0.01157,           0.02407,
          -0.03883,           0.00835,
          -0.01542,          -0.04761,
      174386.39024,      158048.26273,      159192.81681,      220154.55148,
       33716.11953,       87537.86597,        -116.90381,        7535.83928,
        -962.06994,        -132.28837,        -644.90482,        -110.52332,
           3.42499,           3.74660,          -0.94008,          41.55548,
          -0.03824,          -0.05607,
          28.74787,         -37.31399,          30.87853,         -26.11940,
          10.79742,          -5.97905,           1.01237,          -0.04429,
           0.54402,           0.41905,
          -0.02440,          -0.03991,
          -0.00347,          -0.04362,          -0.00347,          -0.00469,
          -0.02707,           0.02761,
          -0.17773,          -0.11789,
       26475.02580,       35363.04345,       19877.11475,       41430.35940,
        2948.09998,       12983.41406,         281.93744,         570.70054,
         147.83157,          16.00090,          -1.62814,          -8.30846,
           9.29131,         -10.16496,
          -0.15799,           0.03843,
           1.44716,           0.46953,
          -0.02150,          -0.02502,
           0.08861,          -0.06690,
        2237.41551,        3739.08722,         753.74867,        3460.41553,
        -298.69226,         520.47031,         -33.62615,        -138.12767,
           3.61843,          -8.29860,          -4.56656,           0.79553,
           0.20041,          -0.25771,
          -0.35233,          -0.27913,          -0.02799,          -0.08328,
          -0.06889,          -0.16853,
           0.01701,          -0.00964,
          -0.37737,           0.18030,          -0.08525,           0.01906,
           0.05236,          -0.05155,
           0.11320,           0.05991,
          -5.66926,          -0.54402,          -2.08508,          -0.39407,
           0.82155,          -0.55975,
           0.39168,          -0.25551,           0.00623,           0.16162,
          -0.02519,           0.02420,
          -1.23293,          -3.19649,          -0.60519,          -2.79729,
           0.05362,          -0.61569,
          -0.25638,          -0.27033,
          -0.03987,           0.46623,          -0.12070,           0.00643,
           0.00849,          -0.00768,
          -0.03687,           0.10445,
          -0.13544,          -0.00592,
           0.02078,           0.09172,
           0.15824,           0.15815,           0.02020,           0.00747,
           0.10919,           0.09553,           0.01953,          -0.00135,
           0.04266,          -0.00218,
           0.02182,          -0.13742,          -0.01249,           0.01724,
          -0.02200,           0.02975,
          -0.01401,           0.03416,
          -0.28873,           0.04235,          -0.08137,           0.04223,
          -0.00326,           0.02144,
          -0.40423,           0.14281,          -0.08256,           0.02142,
           0.08116,          -0.03680,
          -0.02324,           0.07260,
          -0.06746,           0.11645,
           0.03233,          -0.05997,
          -0.03101,           0.02197,
          -0.00896,          -0.00491,
           0.00574,           0.00855,
           0.00052,           0.01209,
          -0.31828,           0.29955,          -0.08133,           0.04318,
           0.06787,          -0.08865,
          -0.13228,          -0.06507,
           0.34008,           0.06417,
          -0.00177,          -0.15116,
          -0.00553,          -0.01950,
           0.01144,          -0.00309,
          -0.00115,          -0.00153,
           0.02063,          -0.00791,
          -0.00314,           0.00493,
          -0.10614,           0.08338,
           0.08845,           0.20168,
           1.38955,          -2.52285,          -0.30475,          -1.05787,
           0.00580,           0.06623,
         -44.33263,         -47.70073,         -29.80583,          -8.77838,
           7.02948,           2.77221,           0.05248,          -0.13702,
          -0.78176,           1.77489,
         -16.32831,          46.68457,           2.54516,          21.78145,
          -5.09080,          -8.42611,          -0.24419,          -0.03315,
           2.80629,          -1.12755,
          -0.00402,           0.00053,
           0.00024,          -0.00043,
           0.00403,          -0.00210,
           0.00603,           0.00411,
          -0.00260,           0.00416,
           2.29235,           3.05992,           2.36465,          -0.58750,
           0.14030,           0.13523,           0.89998,           0.70156,
          -0.02188,           0.02003,          -0.00533,           0.00447,
           2.96411,           1.30183,
           0.01422,           0.00624,
          -0.10737,          -0.38316,
          -0.05968,           0.04379,
           0.01171,           0.01180,
          -0.00989,          -0.01375,
          -0.00845,           0.03782,
           0.09484,           0.09909,           0.07640,          -0.00898,
          -0.01076,           0.02760,           0.01630,           0.02198,
           0.05985,           0.04130,
  };
  static final double plutabr[] = {
    17990649.12487,    24806479.30874,    12690953.00645,     2892671.69562,
      249947.71316,       -5138.71425,        1142.68629,        6075.25751,
         -34.76785,         -19.72399,
         -15.81516,          30.47718,
         -11.73638,          21.87955,
           9.42107,         -10.40957,
          -5.59670,           6.85778,
        -167.06735,          -2.31999,         -32.42575,         -13.72714,
         130.16635,         117.97555,          31.33915,          39.64331,
       -1378.54934,        -395.83244,        -562.79856,        -167.74359,
         -45.12476,         -17.08986,
          -4.20576,         -16.56724,
        1762.12089,       -1148.86987,         736.55320,        -423.09108,
          56.13621,         -26.26674,
           9.77810,         -38.05151,
     4702224.98754,    27254904.94363,     5306232.25993,    39518429.29982,
     1725110.05669,    21833263.27069,       46010.62605,     5425411.66252,
       17238.09865,      536771.62156,      -61263.36051,       66270.70142,
        2084.66296,       -1936.71208,       35898.49503,       34885.28549,
           1.93276,          10.66292,
        -665.11445,           3.70467,        -265.68478,          16.16272,
         -19.45954,           2.32738,
           3.04237,           3.97339,
          -2.64312,           0.66308,
       -3207.68754,        3418.03720,       -2342.62310,        1729.15030,
        -450.84643,         179.00943,         -13.20367,          -1.86087,
          -4.95659,           7.22347,
          -5.08890,          -1.28891,
          -6.21713,           5.10551,
          13.97276,           0.44529,
           3.25177,          25.02775,
         -45.56672,          11.58470,
   124443355.55450,  -100018293.41775,   190506421.77863,  -118262753.40162,
   108199328.45091,   -45247957.63323,    27272084.41143,    -4125106.01144,
     2583469.66051,     1024678.12935,      -22702.55109,      199269.51481,
      -15783.14789,        5564.52481,        -427.22231,       -6330.86079,
         -97.50757,        -204.32241,
       -9060.54822,      156661.77631,      -47791.83678,       59725.58975,
       -8807.74881,         -92.38886,
      -28886.11572,     -244419.59744,      -53336.36915,      -92232.16479,
       -8724.89354,       -2446.76739,
         889.71335,         936.51108,
         494.80305,        2252.83602,
      -18326.60823,      -25443.13554,       -3130.86382,       -5426.29135,
       23494.08846,          91.28882,        4664.14726,        1552.06143,
       -8090.43357,        2843.48366,       -1445.73506,        1023.11482,
       11664.20863,       -7020.08612,        3100.21504,         -64.16577,
       -9724.97938,      -12261.47155,       -3008.08276,       -1523.06301,
        6788.74046,       10708.27853,         343.09434,        1701.52760,
       14743.99857,       -4781.96586,
   -15922236.41469,     1825172.51825,   -14006084.36972,    10363332.64447,
     -979550.91360,     6542446.18797,     1160614.26915,      570804.88172,
       89912.68112,     -171247.08757,      -13899.52899,       -6182.25841,
        -240.64725,         412.42581,         -66.24510,          71.30726,
         -15.81125,         -15.76899,
         -21.85515,        -102.12717,         -10.18287,         -19.38527,
           1.43749,          -3.87533,
           1.97109,           0.20138,
           0.32012,           1.02928,
         -40.22077,          20.80684,         -15.69766,           9.63663,
          -1.26010,           0.56197,
           0.08592,           0.18540,
          -0.07303,           0.03897,
           0.01438,          -0.08809,
           0.15479,           0.10354,
           0.19052,           2.08790,
      405480.24475,     -607986.83623,      582811.58843,     -915111.10396,
      258696.21023,     -493391.09443,       23403.62628,     -119503.67282,
       -4036.86957,       -9766.17805,        -663.93268,        2544.07799,
          40.36638,          76.26390,         246.67716,         -13.93440,
           0.12403,           0.25378,
           0.14004,          -0.08501,
           0.07904,           0.12731,
           1.02117,          -1.34663,           0.25142,          -0.26903,
           0.18135,          -0.57683,          -0.30092,          -0.36121,
          -0.09623,           0.05873,
          -0.05803,           0.02869,
          -0.01194,           0.04983,
           0.04250,           0.04894,
           1.34245,           0.70137,           0.24217,           0.25912,
          -0.32759,          -0.03575,
           0.06780,          -0.41277,
           0.43865,           0.17857,
     -763933.02226,      465658.17048,    -1082753.91241,      593319.68634,
     -553911.89340,      274748.95145,     -122250.71547,       56608.95768,
       -9914.17300,        2988.43709,         707.94605,        -765.01470,
          52.73260,         -34.22263,         -43.58300,         -38.43647,
          -4.95939,          -1.97173,          -1.04406,          -0.13072,
          -0.34281,           4.75202,          -0.35513,           0.93597,
          -0.54380,           0.70536,
          84.83116,         102.93003,          26.34884,          48.57746,
           0.02853,           2.91676,
          -8.07116,           1.66613,
          -2.07908,          11.62592,
           6.64704,           0.98291,
          -1.19192,           0.93791,
           0.18822,           0.00900,
          -0.03181,          -0.02000,
           0.02755,          -0.01398,
          -0.03971,          -0.03756,
           0.13454,          -0.04193,
      -18672.98484,       28230.75834,      -28371.58823,       26448.45214,
      -13352.09393,        7461.71279,       -2609.33578,         726.50321,
        -309.72942,         -86.71982,          12.48589,          -9.69726,
           1.82185,          14.92220,
          -0.04748,           0.42510,
          -0.20047,           0.00154,
           0.00176,          -0.26262,
           0.78218,          -0.73243,           0.23694,          -0.03132,
          -0.00290,          -0.03678,
          14.03094,           4.25948,           0.79368,          -0.78489,
          -2.30962,           2.31946,
           0.00158,          -0.04125,
          -0.01387,           0.28503,           0.00892,           0.05154,
           0.00184,          -0.01727,
          -0.00889,           0.03526,
          -0.00521,          -0.02093,
           0.00200,           0.04872,
          -0.02163,           0.00578,
       20699.27413,       -2175.57827,       31177.33085,        4572.02063,
       15486.28190,        8747.74091,        2455.51737,        3839.83609,
          51.31433,         507.91086,          15.90082,          44.75942,
          -0.98374,          -2.64477,           2.52336,          -3.09203,
          -0.08897,          -0.00083,
         -15.91892,           0.72597,          14.04523,          -3.16525,
           4.33379,         -30.82980,           0.40462,          -0.75845,
          13.14831,          -0.02721,
          -0.01779,           0.00481,
           0.42365,          -0.09048,           0.08653,           0.04391,
           0.00846,           0.01082,
          -0.04736,           0.02308,
        6282.21778,       -4952.70286,        7886.57505,       -5328.36122,
        3113.76826,       -1696.84590,         330.70011,        -155.51989,
         -18.31559,          -3.90798,          -3.11242,           1.87818,
          -1.05578,           0.11198,
           0.05077,          -0.01571,
           2.41291,           2.40568,
          -0.01136,          -0.00076,
          -0.00392,          -0.02774,
         634.85065,        -352.21937,         674.31665,        -260.73473,
         199.16422,         -28.44198,           6.54187,           6.44960,
          -1.55155,           0.29755,           0.16977,           0.17540,
          -0.02652,           0.03726,
          -0.00623,           0.11777,          -0.00933,           0.02602,
          -0.13943,          -0.24818,
           0.02876,          -0.01463,
          -0.07166,           0.06747,          -0.01578,           0.01628,
           0.00233,          -0.00686,
           0.00431,          -0.00276,
           0.21774,           0.09735,           0.07894,           0.07279,
          -0.01300,          -0.00268,
           0.10824,           0.09435,           0.00720,           0.02111,
          -0.01960,           0.06154,
           0.56867,          -0.07544,           0.18210,           0.06343,
          -0.00906,           0.01942,
          -0.00850,          -0.00351,
          -0.06988,           0.01713,          -0.01110,          -0.00663,
           0.00196,          -0.02064,
          -0.00008,           0.00043,
           0.00375,           0.00084,
          -0.00279,           0.00100,
           0.00271,          -0.02017,          -0.00074,          -0.00357,
           0.03793,          -0.10108,          -0.01083,          -0.03952,
           0.00030,           0.00012,
           0.01576,           0.01142,           0.00351,           0.00277,
           0.01409,          -0.00774,
          -0.00065,           0.01895,
           0.07350,          -0.02519,           0.01528,          -0.01057,
          -0.00099,          -0.00295,
           0.21347,          -0.17458,           0.04940,          -0.02757,
          -0.06243,           0.05203,
           0.01055,          -0.00109,
           0.00003,          -0.04201,
          -0.00263,           0.02387,
           0.00886,          -0.01168,
           0.00479,           0.00204,
          -0.00239,           0.00022,
          -0.00223,          -0.02029,
          -0.14130,          -0.15237,          -0.01827,          -0.04877,
           0.12104,           0.06796,
           0.16379,           0.31892,
          -0.15605,           0.07048,
          -0.00700,           0.07481,
          -0.00370,          -0.00142,
          -0.00446,           0.00329,
          -0.00018,           0.00117,
          -0.00910,           0.00510,
          -0.00055,          -0.00114,
           0.04131,          -0.04013,
          -0.13238,           0.02680,
          -0.10369,           1.38709,           0.35515,           0.41437,
          -0.01327,          -0.02692,
          38.02603,          13.38166,          15.33389,          -7.40145,
          -8.55293,          -0.13185,          -0.03316,           0.13016,
           0.04428,          -1.60953,
         -12.87829,         -76.97922,         -23.96039,         -22.45636,
          14.83309,          14.09854,           0.24252,           0.13850,
          -4.16582,           4.08846,
           0.00751,          -0.00051,
           0.03456,           0.02900,
           0.01625,          -0.04660,
           0.01390,          -0.00530,
           0.01665,          -0.04571,
          40.90768,         -14.11641,           7.46071,         -58.07356,
          -0.27859,          -1.33816,          23.76074,          -0.03124,
          -0.27860,           0.13654,          -0.04800,           0.05375,
           4.38091,           4.39337,
           0.02233,           0.00514,
          -0.25616,          -0.54439,
          -0.05155,           0.11553,
           0.02944,          -0.00818,
           0.00570,           0.00119,
          -0.00733,          -0.02700,
          -0.23759,          -0.08712,          -0.12433,           0.07397,
           0.20629,           0.60251,           0.56512,           0.14790,
           0.07778,           0.11614,
  };
  static byte pluargs[] = {
  (byte)0,  (byte)7,
  (byte)2,  (byte)3,  (byte)7, (byte)-9,  (byte)9,  (byte)0,
  (byte)2,  (byte)4,  (byte)7,(byte)-12,  (byte)9,  (byte)0,
  (byte)2,  (byte)4,  (byte)7, (byte)-8,  (byte)8,  (byte)0,
  (byte)3, (byte)-4,  (byte)7,  (byte)5,  (byte)8,  (byte)4,  (byte)9,  (byte)0,
  (byte)3,  (byte)3,  (byte)7, (byte)-5,  (byte)8, (byte)-1,  (byte)9,  (byte)0,
  (byte)2,  (byte)1,  (byte)6, (byte)-8,  (byte)9,  (byte)1,
  (byte)2,  (byte)3,  (byte)8, (byte)-5,  (byte)9,  (byte)1,
  (byte)2,  (byte)1,  (byte)6, (byte)-9,  (byte)9,  (byte)2,
  (byte)3,  (byte)6,  (byte)7, (byte)-6,  (byte)8, (byte)-8,  (byte)9,  (byte)0,
  (byte)3,  (byte)4,  (byte)7,(byte)-10,  (byte)8,  (byte)4,  (byte)9,  (byte)2,
  (byte)2,  (byte)3,  (byte)7, (byte)-8,  (byte)9,  (byte)0,
  (byte)1,  (byte)1,  (byte)9,  (byte)7,
  (byte)2,  (byte)3,  (byte)7,(byte)-10,  (byte)9,  (byte)0,
  (byte)3,  (byte)4,  (byte)7,(byte)-10,  (byte)8,  (byte)2,  (byte)9,  (byte)2,
  (byte)3,  (byte)5,  (byte)7,(byte)-12,  (byte)8,  (byte)2,  (byte)9,  (byte)0,
  (byte)2,  (byte)1,  (byte)6, (byte)-7,  (byte)9,  (byte)0,
  (byte)1,  (byte)1,  (byte)8,  (byte)3,
  (byte)2,  (byte)1,  (byte)6,(byte)-10,  (byte)9,  (byte)0,
  (byte)3,  (byte)6,  (byte)7,(byte)-12,  (byte)8,  (byte)2,  (byte)9,  (byte)0,
  (byte)3,  (byte)5,  (byte)7,(byte)-10,  (byte)8,  (byte)2,  (byte)9,  (byte)0,
  (byte)2,  (byte)5,  (byte)7,(byte)-13,  (byte)9,  (byte)0,
  (byte)2,  (byte)4,  (byte)7,(byte)-10,  (byte)9,  (byte)0,
  (byte)2,  (byte)3,  (byte)7, (byte)-7,  (byte)9,  (byte)0,
  (byte)1,  (byte)2,  (byte)9,  (byte)7,
  (byte)2,  (byte)3,  (byte)7,(byte)-11,  (byte)9,  (byte)0,
  (byte)3,  (byte)4,  (byte)7, (byte)-9,  (byte)8,  (byte)4,  (byte)9,  (byte)2,
  (byte)3,  (byte)3,  (byte)7, (byte)-5,  (byte)8,  (byte)1,  (byte)9,  (byte)2,
  (byte)2,  (byte)1,  (byte)6, (byte)-6,  (byte)9,  (byte)0,
  (byte)2,  (byte)7,  (byte)8,(byte)-13,  (byte)9,  (byte)0,
  (byte)2,  (byte)3,  (byte)8, (byte)-2,  (byte)9,  (byte)1,
  (byte)3,  (byte)1,  (byte)7, (byte)-5,  (byte)8,  (byte)2,  (byte)9,  (byte)1,
  (byte)3,  (byte)6,  (byte)7,(byte)-12,  (byte)8,  (byte)3,  (byte)9,  (byte)1,
  (byte)2,  (byte)5,  (byte)7,(byte)-12,  (byte)9,  (byte)1,
  (byte)2,  (byte)4,  (byte)7, (byte)-9,  (byte)9,  (byte)1,
  (byte)2,  (byte)2,  (byte)7, (byte)-3,  (byte)9,  (byte)1,
  (byte)1,  (byte)1,  (byte)7,  (byte)0,
  (byte)1,  (byte)3,  (byte)9,  (byte)5,
  (byte)2,  (byte)3,  (byte)7,(byte)-12,  (byte)9,  (byte)1,
  (byte)3,  (byte)5,  (byte)7, (byte)-9,  (byte)8,  (byte)2,  (byte)9,  (byte)0,
  (byte)3,  (byte)4,  (byte)7, (byte)-7,  (byte)8,  (byte)2,  (byte)9,  (byte)1,
  (byte)3,  (byte)3,  (byte)7, (byte)-5,  (byte)8,  (byte)2,  (byte)9,  (byte)0,
  (byte)3,  (byte)2,  (byte)7, (byte)-5,  (byte)8,  (byte)5,  (byte)9,  (byte)0,
  (byte)2,  (byte)1,  (byte)6, (byte)-5,  (byte)9,  (byte)0,
  (byte)2,  (byte)3,  (byte)8, (byte)-1,  (byte)9,  (byte)2,
  (byte)2,  (byte)1,  (byte)6,(byte)-12,  (byte)9,  (byte)0,
  (byte)3,  (byte)2,  (byte)7, (byte)-7,  (byte)8,  (byte)1,  (byte)9,  (byte)0,
  (byte)2,  (byte)5,  (byte)7,(byte)-11,  (byte)9,  (byte)0,
  (byte)2,  (byte)4,  (byte)7, (byte)-8,  (byte)9,  (byte)0,
  (byte)2,  (byte)2,  (byte)7, (byte)-2,  (byte)9,  (byte)0,
  (byte)1,  (byte)4,  (byte)9,  (byte)7,
  (byte)3,  (byte)2,  (byte)7, (byte)-8,  (byte)8,  (byte)2,  (byte)9,  (byte)0,
  (byte)3,  (byte)5,  (byte)7, (byte)-9,  (byte)8,  (byte)3,  (byte)9,  (byte)0,
  (byte)3,  (byte)4,  (byte)7, (byte)-9,  (byte)8,  (byte)6,  (byte)9,  (byte)0,
  (byte)3,  (byte)3,  (byte)7, (byte)-5,  (byte)8,  (byte)3,  (byte)9,  (byte)1,
  (byte)2,  (byte)2,  (byte)7, (byte)-1,  (byte)8,  (byte)1,
  (byte)2,  (byte)3,  (byte)8, (byte)-9,  (byte)9,  (byte)0,
  (byte)2,  (byte)9,  (byte)8, (byte)-9,  (byte)9,  (byte)0,
  (byte)2,  (byte)1,  (byte)6,(byte)-13,  (byte)9,  (byte)0,
  (byte)3,  (byte)2,  (byte)7, (byte)-5,  (byte)8, (byte)-3,  (byte)9,  (byte)0,
  (byte)2,  (byte)6,  (byte)7,(byte)-13,  (byte)9,  (byte)1,
  (byte)2,  (byte)5,  (byte)7,(byte)-10,  (byte)9,  (byte)0,
  (byte)2,  (byte)4,  (byte)7, (byte)-7,  (byte)9,  (byte)0,
  (byte)2,  (byte)3,  (byte)7, (byte)-4,  (byte)9,  (byte)0,
  (byte)1,  (byte)5,  (byte)9,  (byte)7,
  (byte)3,  (byte)6,  (byte)7, (byte)-9,  (byte)8,  (byte)1,  (byte)9,  (byte)1,
  (byte)3,  (byte)4,  (byte)7, (byte)-5,  (byte)8,  (byte)1,  (byte)9,  (byte)1,
  (byte)3,  (byte)3,  (byte)7, (byte)-3,  (byte)8,  (byte)1,  (byte)9,  (byte)0,
  (byte)2,  (byte)1,  (byte)6, (byte)-3,  (byte)9,  (byte)2,
  (byte)2,  (byte)3,  (byte)8,(byte)-10,  (byte)9,  (byte)0,
  (byte)2,  (byte)1,  (byte)8,  (byte)4,  (byte)9,  (byte)0,
  (byte)2,  (byte)5,  (byte)8, (byte)-2,  (byte)9,  (byte)0,
  (byte)2, (byte)11,  (byte)8,(byte)-11,  (byte)9,  (byte)0,
  (byte)3,  (byte)1,  (byte)7, (byte)-9,  (byte)8,  (byte)5,  (byte)9,  (byte)0,
  (byte)2,  (byte)6,  (byte)7,(byte)-12,  (byte)9,  (byte)0,
  (byte)2,  (byte)5,  (byte)7, (byte)-9,  (byte)9,  (byte)0,
  (byte)2,  (byte)4,  (byte)7, (byte)-6,  (byte)9,  (byte)0,
  (byte)2,  (byte)3,  (byte)7, (byte)-3,  (byte)9,  (byte)0,
  (byte)1,  (byte)6,  (byte)9,  (byte)6,
  (byte)2,  (byte)2,  (byte)7,(byte)-12,  (byte)9,  (byte)0,
  (byte)3,  (byte)6,  (byte)7, (byte)-9,  (byte)8,  (byte)2,  (byte)9,  (byte)0,
  (byte)3,  (byte)3,  (byte)7,(byte)-12,  (byte)8,  (byte)3,  (byte)9,  (byte)0,
  (byte)3,  (byte)4,  (byte)7,(byte)-10,  (byte)8, (byte)-3,  (byte)9,  (byte)1,
  (byte)3,  (byte)3,  (byte)7, (byte)-3,  (byte)8,  (byte)2,  (byte)9,  (byte)0,
  (byte)2,  (byte)1,  (byte)6, (byte)-2,  (byte)9,  (byte)2,
  (byte)2,  (byte)1,  (byte)8,  (byte)5,  (byte)9,  (byte)0,
  (byte)2, (byte)13,  (byte)8,(byte)-13,  (byte)9,  (byte)1,
  (byte)3,  (byte)2,  (byte)7, (byte)-9,  (byte)8,  (byte)1,  (byte)9,  (byte)0,
  (byte)2,  (byte)6,  (byte)7,(byte)-11,  (byte)9,  (byte)0,
  (byte)2,  (byte)5,  (byte)7, (byte)-8,  (byte)9,  (byte)0,
  (byte)2,  (byte)4,  (byte)7, (byte)-5,  (byte)9,  (byte)0,
  (byte)2,  (byte)3,  (byte)7, (byte)-2,  (byte)9,  (byte)0,
  (byte)1,  (byte)7,  (byte)9,  (byte)7,
  (byte)3,  (byte)6,  (byte)7, (byte)-9,  (byte)8,  (byte)3,  (byte)9,  (byte)0,
  (byte)2,  (byte)1,  (byte)6, (byte)-1,  (byte)9,  (byte)4,
  (byte)2,  (byte)3,  (byte)8,  (byte)3,  (byte)9,  (byte)0,
  (byte)2,  (byte)7,  (byte)7,(byte)-13,  (byte)9,  (byte)1,
  (byte)2,  (byte)3,  (byte)7, (byte)-1,  (byte)9,  (byte)0,
  (byte)2,  (byte)2,  (byte)7,  (byte)2,  (byte)9,  (byte)0,
  (byte)1,  (byte)8,  (byte)9,  (byte)6,
  (byte)3,  (byte)7,  (byte)7, (byte)-9,  (byte)8,  (byte)1,  (byte)9,  (byte)0,
  (byte)1,  (byte)1,  (byte)6,  (byte)0,
  (byte)1,  (byte)3,  (byte)7,  (byte)0,
  (byte)2,  (byte)2,  (byte)7,  (byte)3,  (byte)9,  (byte)0,
  (byte)1,  (byte)9,  (byte)9,  (byte)5,
  (byte)3,  (byte)1,  (byte)7,(byte)-10,  (byte)8,  (byte)3,  (byte)9,  (byte)0,
  (byte)3,  (byte)2,  (byte)7,(byte)-12,  (byte)8,  (byte)3,  (byte)9,  (byte)1,
  (byte)2,  (byte)1,  (byte)6,  (byte)1,  (byte)9,  (byte)0,
  (byte)3,  (byte)1,  (byte)7, (byte)-1,  (byte)8,  (byte)8,  (byte)9,  (byte)0,
  (byte)2,  (byte)3,  (byte)7,  (byte)1,  (byte)9,  (byte)1,
  (byte)2,  (byte)2,  (byte)7,  (byte)4,  (byte)9,  (byte)0,
  (byte)2,  (byte)1,  (byte)7,  (byte)7,  (byte)9,  (byte)0,
  (byte)2,  (byte)4,  (byte)8,  (byte)4,  (byte)9,  (byte)1,
  (byte)2, (byte)12,  (byte)8, (byte)-8,  (byte)9,  (byte)0,
  (byte)3,  (byte)1,  (byte)7,(byte)-10,  (byte)8,  (byte)2,  (byte)9,  (byte)1,
  (byte)2,  (byte)1,  (byte)6,  (byte)2,  (byte)9,  (byte)0,
  (byte)1, (byte)11,  (byte)9,  (byte)2,
  (byte)2, (byte)12,  (byte)8, (byte)-7,  (byte)9,  (byte)0,
  (byte)3,  (byte)1,  (byte)7,(byte)-10,  (byte)8,  (byte)1,  (byte)9,  (byte)1,
  (byte)1,  (byte)4,  (byte)7,  (byte)0,
  (byte)1, (byte)12,  (byte)9,  (byte)0,
  (byte)2,  (byte)6,  (byte)8,  (byte)3,  (byte)9,  (byte)0,
  (byte)3,  (byte)1,  (byte)7, (byte)-2,  (byte)8,(byte)-12,  (byte)9,  (byte)0,
  (byte)3,  (byte)7,  (byte)7, (byte)-7,  (byte)8,  (byte)2,  (byte)9,  (byte)1,
  (byte)2,  (byte)2,  (byte)6, (byte)-4,  (byte)9,  (byte)1,
  (byte)1, (byte)13,  (byte)9,  (byte)0,
  (byte)2, (byte)10,  (byte)8, (byte)-2,  (byte)9,  (byte)1,
  (byte)2,  (byte)4,  (byte)7,  (byte)2,  (byte)9,  (byte)0,
  (byte)2,  (byte)2,  (byte)6, (byte)-3,  (byte)9,  (byte)0,
  (byte)2,  (byte)2,  (byte)7,  (byte)8,  (byte)9,  (byte)1,
  (byte)2,  (byte)8,  (byte)8,  (byte)2,  (byte)9,  (byte)0,
  (byte)1,  (byte)5,  (byte)7,  (byte)1,
  (byte)2,  (byte)4,  (byte)7,  (byte)3,  (byte)9,  (byte)0,
  (byte)2,  (byte)3,  (byte)7,  (byte)6,  (byte)9,  (byte)0,
  (byte)2,  (byte)1,  (byte)5, (byte)-6,  (byte)9,  (byte)0,
  (byte)3,  (byte)2,  (byte)7,  (byte)8,  (byte)8, (byte)-3,  (byte)9,  (byte)0,
  (byte)3,  (byte)1,  (byte)7,  (byte)6,  (byte)8,  (byte)3,  (byte)9,  (byte)0,
  (byte)2,  (byte)6,  (byte)8,  (byte)6,  (byte)9,  (byte)0,
  (byte)3,  (byte)8,  (byte)7, (byte)-7,  (byte)8,  (byte)2,  (byte)9,  (byte)0,
  (byte)2,  (byte)9,  (byte)7,(byte)-11,  (byte)9,  (byte)0,
  (byte)2,  (byte)5,  (byte)7,  (byte)1,  (byte)9,  (byte)1,
  (byte)2,  (byte)4,  (byte)7,  (byte)4,  (byte)9,  (byte)0,
  (byte)2,  (byte)2,  (byte)6, (byte)-1,  (byte)9,  (byte)0,
  (byte)3,  (byte)2,  (byte)6, (byte)-1,  (byte)7,  (byte)2,  (byte)9,  (byte)0,
  (byte)2,  (byte)2,  (byte)7, (byte)10,  (byte)9,  (byte)0,
  (byte)2,  (byte)1,  (byte)7, (byte)13,  (byte)9,  (byte)0,
  (byte)2,  (byte)8,  (byte)7, (byte)-7,  (byte)9,  (byte)0,
  (byte)2,  (byte)7,  (byte)7, (byte)-4,  (byte)9,  (byte)0,
  (byte)2,  (byte)6,  (byte)7, (byte)-1,  (byte)9,  (byte)0,
  (byte)2,  (byte)5,  (byte)7,  (byte)3,  (byte)9,  (byte)0,
  (byte)2,  (byte)4,  (byte)7,  (byte)5,  (byte)9,  (byte)0,
  (byte)1,  (byte)2,  (byte)6,  (byte)0,
  (byte)2,  (byte)1,  (byte)5, (byte)-4,  (byte)9,  (byte)1,
  (byte)3,  (byte)1,  (byte)6,  (byte)9,  (byte)8, (byte)-5,  (byte)9,  (byte)0,
  (byte)2,  (byte)1,  (byte)5, (byte)-3,  (byte)9,  (byte)4,
  (byte)2,  (byte)1,  (byte)5, (byte)-2,  (byte)9,  (byte)4,
  (byte)3,  (byte)9,  (byte)7, (byte)-9,  (byte)8,  (byte)6,  (byte)9,  (byte)0,
  (byte)2,  (byte)8,  (byte)7, (byte)-4,  (byte)9,  (byte)0,
  (byte)2,  (byte)7,  (byte)7, (byte)-1,  (byte)9,  (byte)0,
  (byte)2,  (byte)1,  (byte)6,  (byte)3,  (byte)9,  (byte)0,
  (byte)2,  (byte)2,  (byte)6,  (byte)3,  (byte)9,  (byte)0,
  (byte)2,  (byte)1,  (byte)5, (byte)-1,  (byte)9,  (byte)3,
  (byte)3,  (byte)6,  (byte)7, (byte)-3,  (byte)8,  (byte)7,  (byte)9,  (byte)1,
  (byte)1,  (byte)1,  (byte)5,  (byte)0,
  (byte)2,  (byte)2,  (byte)6,  (byte)5,  (byte)9,  (byte)0,
  (byte)2,  (byte)1,  (byte)5,  (byte)1,  (byte)9,  (byte)0,
  (byte)2,  (byte)1,  (byte)5,  (byte)2,  (byte)9,  (byte)0,
  (byte)2,  (byte)1,  (byte)5,  (byte)3,  (byte)9,  (byte)0,
  (byte)2,  (byte)2,  (byte)5, (byte)-4,  (byte)9,  (byte)0,
  (byte)2,  (byte)2,  (byte)5, (byte)-3,  (byte)9,  (byte)0,
  (byte)2,  (byte)2,  (byte)5, (byte)-2,  (byte)9,  (byte)1,
  (byte)2,  (byte)2,  (byte)5, (byte)-1,  (byte)9,  (byte)1,
  (byte)1,  (byte)2,  (byte)5,  (byte)0,
 (byte)-1
  };
  
  static Plantbl plu404 = new Plantbl(
                               new short[]{0,  0,  0,  0,  2,  2,  9, 13, 13},
                               (short)7,
                               pluargs,
                               plutabl,
                               plutabb,
                               plutabr,
                               3.9539999999999999e+01
  );
}
class SwemptabSat {
  
  static final double sattabl[] = {
     1788381.26240,     2460423.68044,     1370113.15868,      415406.99187,
       72040.39885,       12669.58806,   439960754.85333,      180256.80433,
          18.71177,         -40.37092,
       66531.01889,     -195702.70142,       57188.02694,     -179110.60982,
      -19803.06520,      -58084.15705,       -9055.13344,      -31146.10779,
       11245.43286,       -3247.59575,         459.48670,        2912.82402,
          -4.06749,         -13.53763,
         -30.55598,          -4.51172,
           1.48832,           0.37139,
         597.35433,        1193.44545,        -297.50957,         976.38608,
        -263.26842,          34.84354,          -6.77785,         -29.92106,
          -0.16325,          -0.18346,
          -0.15364,          -0.08227,
           0.20180,           0.02244,
           0.04672,          -0.29867,
          -0.04143,          -0.00760,
          -0.17046,          -0.00778,
           0.04200,           0.23937,          -0.00098,          -0.05236,
          -0.02749,          -0.01813,
           0.00637,           0.01256,
          -0.04506,           0.04448,
          -0.00105,           0.06224,
           0.01157,           0.17057,          -0.03214,           0.18178,
          -0.22059,          -0.01472,
          -0.24213,           0.04309,           0.03436,           0.44873,
           0.01350,          -0.01931,
          -0.80618,          -0.56864,           0.29223,          -0.03101,
           0.04171,           0.02264,
          -0.01264,          -0.01645,
           0.01774,           0.06374,
          -0.01925,          -0.03552,
           0.10473,          -0.04119,
           0.08045,           0.04635,
          -3.01112,          -9.26158,           8.13745,           1.88838,
          -0.15184,           0.16898,
          -0.22091,           0.29070,          -0.03259,           0.06938,
          -0.08499,          -0.21688,           0.01848,          -0.05594,
           0.50100,          -0.00027,           0.13300,           0.12055,
           0.03039,           0.03854,
          -1.55287,           2.55618,          -0.45497,          -0.29895,
          -0.93268,           0.83518,
          -0.32785,           7.03878,          -1.66649,           2.75564,
          -0.29459,           0.01050,
           0.08293,          -0.03161,
          -0.12750,          -0.04359,
           0.04217,           0.07480,
        -114.43467,          49.47867,         -66.52340,         -26.27841,
          15.48190,         -13.06589,           3.28365,           5.02286,
          -0.17155,          -0.07404,
           0.00924,          -0.07407,
          -0.02922,           0.06184,
         108.04882,          86.09791,        -155.12793,         208.10044,
        -311.72810,        -268.92703,          74.57561,        -420.03057,
          -0.07893,           0.09246,
          -0.66033,          -0.39026,          -0.13816,          -0.08490,
         -36.79241,         -78.88254,          71.88167,         -68.05297,
          51.71616,          65.77970,         -43.59328,          23.51076,
          -0.02029,          -0.32943,
          -8.82754,           1.48646,          -3.12794,           2.12866,
          -0.06926,           0.44979,
           0.00621,          -0.51720,
          -3.82964,          -1.48596,          -0.11277,          -3.21677,
           0.81705,          -0.19487,
          -0.06195,           0.10005,          -0.02208,           0.00108,
           0.00455,          -0.03825,
           0.01217,          -0.00599,
          -0.17479,          -0.47290,           0.85469,           1.12548,
          -0.80648,          -0.44134,
          -0.01559,          -0.07061,
           0.01268,          -0.01773,
           0.01308,          -0.03461,
          -0.71114,           1.97680,          -0.78306,          -0.23052,
           0.94475,          -0.10743,
           0.18252,          -8.03174,
           0.00734,           0.04779,
           0.12334,          -0.03513,
           0.01341,           0.02461,
           0.02047,          -0.03454,
           0.02169,          -0.01921,
          -1.12789,           0.09304,           0.14585,           0.36365,
           0.03702,           0.10661,          -0.00464,          -1.72706,
          -0.00769,          -0.04635,
          -0.01157,           0.00099,
          10.92646,           1.96174,           2.91142,           4.74585,
          -0.29832,           0.75543,
           0.05411,           1.05850,
           0.38846,          -0.16265,
           1.52209,           0.12185,           0.18650,           0.35535,
        -278.33587,         -82.58648,        -160.00093,        -225.55776,
          35.17458,         -77.56672,          10.61975,           3.33907,
           0.06090,           2.17429,
          -4.32981,          -5.84246,          11.43116,          20.61395,
          -0.65772,           1.28796,
        1224.46687,       -3113.15508,        3798.33409,        -137.28735,
        -256.89302,        2227.35649,        -779.78215,        -260.37372,
          11.73617,         -13.25050,          -0.75248,          -2.87527,
          -8.38102,          17.21321,
      -61784.69616,       39475.02257,      -54086.68308,       54550.85490,
      -16403.69351,       29602.70098,       14672.06363,       16234.17489,
       15702.37109,      -22086.30300,      -22889.89844,       -1245.88352,
           1.48864,          19.75000,           0.78646,           3.29343,
       -1058.13125,        4095.02368,       -2793.78506,        1381.93282,
        -409.19381,        -772.54270,         161.67509,         -34.15910,
        -514.27437,          27.34222,        -311.04046,          48.01030,
         -43.36486,          16.19535,          -0.73816,          -0.81422,
         287.32231,        -110.44135,         200.43610,          37.98170,
          17.73719,          34.40023,          -2.46337,           1.48125,
           0.09042,          -0.11788,
           0.37284,           0.51725,           0.00597,           0.14590,
          -0.01536,           0.00980,
           0.00721,           0.02023,
           0.00027,           0.02451,
          -0.72448,          -0.71371,           0.29322,           0.18359,
           0.72719,          -0.37154,           0.14854,          -0.02530,
           0.23052,           0.04258,
           4.82082,           0.01885,           3.11279,          -0.63338,
           0.10559,          -0.02146,
          -0.01672,           0.03412,
           0.00605,           0.06415,
          -0.89085,           1.51929,          -0.36571,           0.39317,
          12.05250,          -3.79392,           3.96557,          -3.51272,
          -0.17953,          12.30669,
          -0.05083,          -0.11442,
           0.02013,          -0.02837,
          -0.02087,          -0.01599,
           0.49190,           0.30360,           0.01316,           0.17649,
           0.21193,          -0.09149,          -0.07173,          -0.05707,
           4.24196,          -1.25155,           1.81336,           0.68887,
          -0.01675,           0.20772,
          -0.04117,          -0.03531,
          -0.02690,          -0.02766,
          37.54264,          10.95327,           8.05610,          30.58210,
         -12.68257,           1.72831,           0.13466,          -3.27007,
           0.01864,          -0.00595,
           0.03676,           0.14857,          -0.07223,           0.06179,
           0.44878,          -1.64901,         -20.06001,           0.63384,
          -4.97849,           4.78627,          29.87370,           7.29899,
           0.00047,          -0.00155,
           0.00314,           0.01425,
          -0.17842,          -0.08461,
          -1.61020,          -8.47710,           6.85048,          -4.38196,
           1.05809,           2.68088,
          -0.01027,          -0.00833,
           0.06834,          -0.04205,
           0.03330,          -0.01271,
           0.01301,          -0.01358,
           0.03537,           0.03612,           0.02962,           0.62471,
          -0.30400,          -0.64857,
           0.01773,           0.01890,
           0.01426,          -0.00226,
          -0.50957,          -0.01955,          -0.09702,           1.09983,
           0.64387,          -0.02755,
           0.26604,           0.30684,           0.06354,           0.05114,
          -0.00058,          -0.04672,
          -0.00828,           0.00712,
          -0.00440,           0.00029,
          -0.01601,           0.03566,
           0.13398,          -0.02666,
          -0.06752,          -0.43044,           0.07172,          -0.01999,
          -0.01761,          -0.05357,
           0.06104,           0.29742,          -0.08785,           0.05241,
          -6.57162,          -4.20103,           0.03199,          -6.46187,
           1.32846,          -0.51137,
           0.06358,           0.37309,
          -1.46946,           2.34981,
          -0.18712,           0.11618,
         240.62965,        -107.21962,         219.81977,          84.04246,
         -62.22931,          68.35902,          -9.48460,         -32.62906,
           5.57483,          -1.82396,           1.00095,          -0.39774,
           7.87054,          11.45449,
        -432.67155,       55064.72398,       12444.62359,       54215.28871,
        8486.03749,       12297.48243,        -333.27968,        1147.93192,
        1403.73797,         990.40885,          -3.84938,        -722.43963,
          16.83276,          96.48787,           7.04834,          38.22208,
           0.63843,           2.61007,
         230.73221,         171.64166,           1.96751,         287.80846,
         -85.21762,          31.33649,          -2.25739,         -11.28441,
           0.04699,           0.06555,
          -0.08887,           1.70919,           0.09477,           0.26291,
          -0.15490,           0.16009,
           1.93274,           1.01953,           0.36380,           1.29582,
          -0.13911,           0.14169,
          -0.00491,          -0.00030,
          -0.08908,          -0.10216,
          -0.03265,          -0.03889,
           0.40413,          -1.12715,          -0.94687,          -0.04514,
           0.02487,          -0.01048,
           0.39729,           2.82305,          -0.61100,           1.11728,
          -0.13083,          -0.04965,
          -0.00602,          -0.02952,
          -6.13507,          13.73998,         -15.70559,          -1.28059,
           2.64422,          -9.33798,           3.26470,           1.56984,
          -0.00572,           0.09992,
          -8.80458,          -8.23890,         -11.51628,           9.47904,
          11.31646,           4.29587,
          -2.41367,          -0.05883,          -0.80022,          -1.02706,
           0.21461,          -0.06864,
           0.01882,           0.01798,
           0.27614,          -0.01007,           0.04362,           0.07560,
           0.05519,           0.23435,
          -0.09389,           0.01613,
           0.01298,           0.04691,
          -0.02665,          -0.03582,
           0.60080,          -4.28673,           1.87316,          -1.05840,
           0.13248,           0.40887,
          -0.67657,           0.67732,           0.05522,           0.07812,
          -0.17707,          -0.07510,
           0.24885,          10.63974,          -7.40226,          -2.33827,
           2.75463,         -32.51518,
           0.05140,           0.01555,
         180.43808,         263.28252,         384.50646,         -76.53434,
         -93.50706,        -220.50123,         -81.91610,         103.92061,
          30.90305,          -2.89292,
          -0.06634,          -0.37717,          -0.01945,          -0.05936,
          29.27877,         -59.73705,          35.86569,         -18.36556,
           3.88812,           4.82090,          -0.70903,           0.06615,
           0.01558,          -0.01854,
           0.16209,           0.12682,           0.02508,           0.02406,
          -0.03078,          -0.01737,          -0.00033,          -0.00020,
           0.01023,           0.05972,
          -0.03373,          -0.07289,
          -2.08162,          -0.14717,          -0.64233,          -0.75397,
           0.11752,          -0.09202,
           4.42981,          -4.19241,           5.02542,           5.03467,
          -4.22983,           2.80794,
           3.03016,          -2.74373,          -1.11490,          -2.72378,
          -0.63131,           0.74864,
          -0.00759,          -0.00675,
           0.03615,          -0.01806,
          -2.71920,          -1.50954,           0.54479,          -1.92088,
           0.66427,           0.32228,
          -2.55188,          -0.65332,          -2.73798,           2.10182,
           1.54407,           3.01357,
          38.76777,          23.54578,          27.29884,         -14.93005,
          -7.50931,          -5.66773,           0.30142,           1.52416,
           0.00634,           0.09697,          -0.00748,           0.01433,
           0.02936,           0.53228,          -0.03603,           0.06345,
           0.30816,          -1.07925,           0.46709,          -0.21568,
           0.01663,           0.10810,
          -0.42511,           0.35872,          -0.19662,          -6.74031,
           1.05776,           1.86205,           1.08919,           0.10483,
          -0.03368,          -0.21535,
           0.07556,          -0.27104,           0.05142,          -0.03812,
           1.20189,          -1.36782,           1.35764,           1.39387,
          -1.19124,           0.77347,
          -0.54760,          -0.26295,          -0.07473,           0.23043,
           2.82621,          -0.23524,           0.47352,          -0.81672,
          -0.08515,           0.04700,
           0.55355,          -0.40138,           0.22255,           0.12236,
          -0.09110,           0.31982,           0.39404,          -0.17898,
          -0.00056,           0.00014,
          -0.02012,           0.03102,
           0.43236,          -0.10037,          -0.00961,           0.07440,
          -0.07076,          -1.97272,
           0.25555,          -0.21832,          -0.00837,          -0.08393,
           0.01531,           0.00627,
           0.33193,           0.70765,          -0.43556,           0.28542,
          -0.23190,          -0.04293,          -0.08062,           0.13427,
           0.23763,          -0.17092,           0.09259,           0.05155,
           0.08065,          -0.11943,
          -0.02174,          -0.68899,
          -0.01875,          -0.01746,
           0.13604,           0.29280,          -0.17871,           0.11799,
           0.02003,           0.04065,
           0.01343,          -0.06060,
          -0.01290,          -0.26068,
          -0.09033,           0.02649,
          -0.00092,          -0.03094,
          -0.00770,          -0.10447,
          -0.04113,           0.01259,
          -0.00469,          -0.04346,
          -0.00010,           0.06547,
  };
  static final double sattabb[] = {
     -567865.62548,     -796277.29029,     -410804.00791,      -91793.12562,
       -6268.13975,         398.64391,        -710.67442,         175.29456,
          -0.87260,           0.18444,
       -1314.88121,       20709.97394,       -1850.41481,       20670.34255,
        -896.96283,        6597.16433,        -179.80702,         613.45468,
          17.37823,         -13.62177,          -0.36348,          12.34740,
           0.47532,           0.48189,
           0.27162,          -0.20655,
          -0.23268,           0.05992,
          46.94511,          15.78836,          21.57439,          23.11342,
          -0.25862,           5.21410,          -0.22612,          -0.05822,
          -0.00439,          -0.01641,
          -0.01108,          -0.00608,
           0.00957,           0.00272,
          -0.00217,           0.00001,
          -0.00534,          -0.00545,
           0.00277,          -0.00843,
           0.00167,          -0.00794,           0.00032,          -0.00242,
          -0.00002,          -0.00041,
          -0.00025,           0.00031,
           0.00062,          -0.00060,
           0.00083,           0.00032,
           0.00527,          -0.00211,           0.00054,           0.00004,
          -0.02769,          -0.01777,
           0.00247,           0.00097,           0.00020,          -0.00232,
           0.00044,          -0.00035,
          -0.00072,           0.01341,           0.00325,          -0.01159,
           0.00079,          -0.00078,
          -0.00009,           0.00066,
           0.00222,           0.00002,
           0.00013,          -0.00161,
           0.01374,          -0.05305,
           0.00478,          -0.00283,
           0.16033,           0.13859,           0.33288,          -0.16932,
          -0.00316,           0.00625,
          -0.00309,           0.01687,           0.00001,           0.00486,
           0.00401,          -0.01805,          -0.00048,          -0.00407,
          -0.01329,           0.01311,          -0.00591,           0.00166,
           0.00830,           0.00665,
          -0.80207,           0.22994,          -0.34687,           0.08460,
          -0.11499,          -0.01449,
          -0.01574,           0.78813,          -0.03063,           0.28872,
          -0.00337,           0.01801,
          -0.01703,          -0.00929,
          -0.00738,           0.03938,
           0.05616,          -0.00516,
          -3.09497,          30.13091,          -3.14968,          17.62201,
          -0.73728,           2.46962,          -0.11233,           0.03450,
          -0.07837,          -0.01573,
          -0.01595,           0.00394,
           0.00174,           0.01470,
           6.83560,          -2.37594,           4.95125,           3.24711,
           2.44781,           5.17159,           1.99820,          -2.38419,
           0.00840,           0.03614,
          -0.00209,          -0.30407,          -0.02681,          -0.06128,
           1.50134,          11.82856,           4.39644,           6.98850,
          -4.17679,           5.73436,          -9.66087,           1.98221,
          -0.29755,           0.08019,
          -0.24766,          -8.54956,          -1.74494,          -3.36794,
          -0.32661,          -0.00722,
           0.14141,           0.01023,
          -1.21541,          -2.58470,           0.38983,          -1.70307,
           0.31209,          -0.10345,
           0.02593,           0.02178,           0.00289,           0.00393,
          -0.00236,          -0.00373,
          -0.00270,          -0.00049,
          -0.06282,          -0.00443,          -0.02439,          -0.02254,
          -0.02220,           0.03532,
          -0.00072,           0.00010,
          -0.00049,          -0.00112,
           0.00086,           0.00112,
           0.10135,          -0.10972,           0.08357,           0.00155,
           0.04363,          -0.00201,
          -0.01996,          -0.01341,
          -0.00039,          -0.00042,
          -0.00294,           0.00070,
           0.00005,          -0.00027,
           0.00070,          -0.00076,
           0.00234,          -0.00239,
          -0.08365,          -0.08531,          -0.03531,           0.15012,
          -0.01995,          -0.01731,          -0.00370,          -0.00745,
          -0.00315,          -0.00079,
          -0.00120,          -0.00145,
          -0.99404,          -1.31859,           0.03584,          -0.83421,
           0.10720,          -0.05768,
           0.06664,          -0.09338,
          -0.01814,          -0.00003,
          -0.05371,          -0.06458,          -0.00100,          -0.01298,
          -7.08710,         -23.13374,           4.18669,         -19.94756,
           4.85584,          -3.37187,           0.58851,           0.31363,
           0.01994,           0.27494,
          -1.37112,           2.61742,           0.52477,          -0.46520,
          -0.13183,           0.26777,
         836.90400,        -484.65861,         815.99098,         236.54649,
         -32.38814,         288.95705,         -68.17178,         -18.87875,
          -1.79782,          -3.68662,          -1.27310,          -0.65697,
          -3.67530,           2.10471,
      -13758.97795,        4807.62301,      -14582.14552,        9019.73021,
       -3202.60105,        4570.16895,        2078.68911,        2892.62326,
       -2399.35382,        3253.16198,       -8182.38152,       -3588.77680,
          -0.16505,           1.08603,           0.53388,           0.87152,
          61.53677,         538.43813,        -407.32927,         322.27446,
        -148.71585,        -179.37765,          54.07268,         -34.12281,
         -14.76569,         -17.95681,         -10.82061,          -6.39954,
          -2.10954,           0.67063,           0.22607,          -0.43648,
          20.90476,         -45.48667,          30.39436,         -14.20077,
           5.17385,           5.12726,          -0.66319,           0.55668,
           0.02269,          -0.00016,
           0.07811,           0.00111,           0.01603,           0.01020,
          -0.00107,           0.00494,
          -0.00077,          -0.00084,
          -0.00196,           0.00081,
          -0.03776,           0.01286,          -0.00652,          -0.01450,
           0.05942,          -0.08612,           0.01093,          -0.01644,
           0.02147,          -0.00592,
           0.36350,          -0.00201,           0.14419,          -0.10070,
          -0.00491,          -0.01771,
          -0.00053,          -0.00033,
           0.00146,           0.00048,
           0.00582,           0.04423,          -0.00549,           0.00983,
           0.27355,          -0.38057,           0.24001,          -0.05441,
          -0.07706,           0.14269,
          -0.00059,          -0.00154,
          -0.00013,          -0.00088,
          -0.00046,           0.00029,
          -0.00276,          -0.00507,           0.00075,          -0.00076,
           0.01806,           0.00862,          -0.00510,          -0.01364,
          -0.00029,          -0.12664,           0.03899,          -0.03562,
           0.00318,           0.00514,
           0.00057,           0.00201,
           0.00028,           0.00014,
          -0.47022,          -0.74561,           0.40155,          -0.16471,
          -0.18445,           0.34425,          -0.07464,          -0.13709,
          -0.01018,          -0.00748,
          -0.01210,          -0.04274,          -0.00579,          -0.00692,
         -11.09188,          -1.67755,          -6.62063,         -13.84023,
          12.75563,          -6.73501,           8.31662,           5.40196,
           0.00052,           0.00034,
           0.00128,           0.00085,
          -0.02202,          -0.00599,
          -0.33458,          -1.65852,           1.47003,          -1.02434,
           0.87885,           1.15334,
          -0.00241,          -0.00721,
           0.03154,           0.00612,
           0.00318,          -0.02521,
           0.00042,           0.00213,
          -0.01094,           0.05417,          -0.03989,          -0.00567,
           0.00123,          -0.00244,
           0.00108,           0.00242,
          -0.00138,          -0.00099,
           0.04967,           0.01643,          -0.00133,           0.02296,
           0.12207,           0.05584,
           0.00437,          -0.04432,          -0.00176,          -0.00922,
          -0.00252,           0.00326,
          -0.00020,          -0.00050,
          -0.00263,          -0.00084,
          -0.01971,           0.00297,
           0.03076,           0.01736,
          -0.01331,           0.01121,          -0.00675,           0.00340,
          -0.00256,           0.00327,
          -0.00946,           0.03377,          -0.00770,           0.00337,
           0.61383,           0.71128,          -0.02018,           0.62097,
          -0.07247,           0.04418,
          -0.02886,          -0.03848,
          -0.44062,           0.03973,
          -0.00999,          -0.04382,
          57.94459,         117.45112,         -71.22893,         126.39415,
         -62.33152,         -31.90754,          12.17738,         -16.46809,
          -1.13298,           0.08962,          -0.20532,           0.16320,
          -1.55110,          -1.44757,
       -3102.08749,       -7452.61957,       -5009.53858,       -7216.29165,
       -2476.87148,       -1880.58197,        -574.49433,         227.45615,
         144.50228,         379.15791,         225.36130,        -443.47371,
          -8.51989,          -3.75208,          -4.25415,          -1.59741,
          -0.43946,          -0.06595,
         150.42986,           6.54937,          87.67736,          92.32332,
         -21.97187,          29.87097,          -4.21636,          -5.72955,
          -0.03879,          -0.01071,
          -0.45985,           0.02679,          -0.02448,           0.02397,
          -0.06551,          -0.01154,
           1.97905,          -0.82292,           1.10140,           0.30924,
           0.03389,           0.14230,
           0.00003,           0.00119,
          -0.01117,           0.00665,
          -0.00132,          -0.00576,
          -0.08356,           0.08556,          -0.26362,          -0.12450,
           0.00509,           0.00165,
           0.02591,           0.16200,          -0.03318,           0.06463,
          -0.00899,          -0.00462,
           0.00102,           0.00004,
          -0.73102,           0.08299,          -0.52957,          -0.35744,
           0.14119,          -0.24903,           0.20843,           0.14143,
           0.00031,          -0.00234,
          -0.42643,          -2.02084,           1.58848,          -1.57963,
           0.68418,           2.07749,
          -0.45888,           0.19859,          -0.30277,          -0.22591,
           0.11607,          -0.09705,
           0.00040,           0.00431,
          -0.02683,           0.03158,          -0.01302,          -0.00541,
           0.01742,          -0.00006,
          -0.02231,          -0.01128,
          -0.00800,           0.02055,
          -0.00346,           0.00151,
           0.56732,          -0.68995,           0.27701,          -0.16748,
           0.01002,           0.00043,
           0.26916,          -0.57751,           0.15547,          -0.15825,
          -0.02074,          -0.07722,
          -8.23483,          -4.02022,           0.69327,          -5.91543,
           1.72440,           1.02090,
           0.00024,          -0.00053,
          20.03959,          14.79136,          76.43531,         -14.42019,
          -7.82608,         -69.96121,         -54.94229,          23.55140,
          26.60767,          14.68275,
           0.05118,          -0.10401,          -0.00075,          -0.01942,
          -3.84266,         -26.23442,          10.20395,         -14.77139,
           3.40853,           2.07297,          -0.53348,           0.40635,
           0.00716,          -0.00189,
           0.12472,          -0.02903,           0.02254,          -0.00183,
          -0.00175,          -0.01522,           0.00003,          -0.00339,
           0.00383,          -0.00168,
           0.01327,          -0.03657,
          -0.08458,          -0.00115,          -0.03991,          -0.02629,
           0.00243,          -0.00505,
           0.33875,          -0.16744,           0.05183,           0.01744,
          -0.24427,           0.15271,
           0.37550,          -0.17378,           0.09198,          -0.27966,
          -0.22160,           0.16426,
           0.00032,          -0.00310,
          -0.00022,          -0.00144,
          -0.06170,          -0.01195,          -0.00918,           0.02538,
           0.03602,           0.03414,
          -0.14998,          -0.44351,           0.45512,          -0.11766,
           0.35638,           0.27539,
           5.93405,          10.55777,          12.42596,          -1.82530,
          -2.36124,          -6.04176,          -0.98609,           1.67652,
          -0.09271,           0.03448,          -0.01951,           0.00108,
           0.33862,           0.21461,           0.02564,           0.06924,
           0.01126,          -0.01168,          -0.00829,          -0.00740,
           0.00106,          -0.00854,
          -0.08404,           0.02508,          -0.02722,          -0.06537,
           0.01662,           0.11454,           0.06747,           0.00742,
          -0.01975,          -0.02597,
          -0.00097,          -0.01154,           0.00164,          -0.00274,
           0.02954,          -0.05161,          -0.02162,          -0.02069,
          -0.06369,           0.03846,
           0.00219,          -0.01634,          -0.04518,           0.06696,
           1.21537,           0.99500,           0.68376,          -0.28709,
          -0.11397,          -0.06468,
           0.00607,          -0.00744,           0.01531,           0.00975,
          -0.03983,           0.02405,           0.07563,           0.00356,
          -0.00018,          -0.00009,
           0.00172,          -0.00331,
           0.01565,          -0.03466,          -0.00230,           0.00142,
          -0.00788,          -0.01019,
           0.01411,          -0.01456,          -0.00672,          -0.00543,
           0.00059,          -0.00011,
          -0.00661,          -0.00496,          -0.01986,           0.01271,
          -0.01323,          -0.00764,           0.00041,           0.01145,
           0.00378,          -0.00137,           0.00652,           0.00412,
           0.01946,          -0.00573,
          -0.00326,          -0.00257,
          -0.00225,           0.00090,
          -0.00292,          -0.00317,          -0.00719,           0.00468,
           0.00245,           0.00189,
           0.00565,          -0.00330,
          -0.00168,          -0.00047,
          -0.00256,           0.00220,
           0.00180,          -0.00162,
          -0.00085,          -0.00003,
          -0.00100,           0.00098,
          -0.00043,           0.00007,
          -0.00003,          -0.00013,
  };
  static final double sattabr[] = {
      -38127.94034,      -48221.08524,      -20986.93487,       -3422.75861,
          -8.97362,          53.34259,        -404.15708,          -0.05434,
           0.46327,           0.16968,
        -387.16771,        -146.07622,         103.77956,          19.11054,
         -40.21762,         996.16803,        -702.22737,         246.36496,
         -63.89626,        -304.82756,          78.23653,          -2.58314,
          -0.11368,          -0.06541,
          -0.34321,           0.33039,
           0.05652,          -0.16493,
          67.44536,         -29.43578,          50.85074,          18.68861,
           0.39742,          13.64587,          -1.61284,           0.11482,
           0.01668,          -0.01182,
          -0.00386,           0.01025,
           0.00234,          -0.01530,
          -0.02569,          -0.00799,
          -0.00429,          -0.00217,
          -0.00672,           0.00650,
           0.01154,           0.00120,          -0.00515,           0.00125,
           0.00236,          -0.00216,
          -0.00098,           0.00009,
          -0.00460,          -0.00518,
           0.00600,           0.00003,
           0.00834,           0.00095,           0.01967,           0.00637,
          -0.00558,          -0.06911,
          -0.01344,          -0.06589,          -0.05425,          -0.00607,
          -0.00247,          -0.00266,
           0.08790,          -0.08537,          -0.00647,           0.04028,
          -0.00325,           0.00488,
           0.00111,          -0.00044,
          -0.00731,           0.00127,
          -0.00417,           0.00303,
           0.05261,           0.01858,
          -0.00807,           0.01195,
           1.26352,          -0.38591,          -0.34825,           1.10733,
          -0.02815,          -0.02148,
          -0.05083,          -0.04377,          -0.01206,          -0.00586,
           0.03158,          -0.01117,           0.00643,           0.00306,
          -0.01186,          -0.05161,           0.01136,          -0.00976,
          -0.00536,           0.01949,
          -1.41680,          -0.81290,          -0.09254,          -0.24347,
          -0.14831,          -0.34381,
          -2.44464,           0.41202,          -0.99240,          -0.33707,
          -0.01930,          -0.08473,
           0.00830,           0.01165,
          -0.01604,          -0.02439,
           0.00227,           0.04493,
         -42.75310,         -22.65155,          -9.93679,         -18.36179,
           2.73773,           3.24126,          -1.20698,           1.07731,
           0.00434,          -0.10360,
          -0.02359,           0.00054,
          -0.02664,          -0.00122,
         -19.79520,          33.11770,         -53.56452,         -35.41902,
          67.95039,         -82.46551,         117.31843,          14.08609,
           0.06447,           0.03289,
           0.40365,          -0.33397,           0.07079,          -0.09504,
         -30.36873,           6.23538,         -14.25988,         -44.91408,
          38.53146,         -16.31919,           6.99584,          22.47169,
          -0.13313,           0.28016,
           6.83715,          -6.01384,           1.68531,          -3.62443,
          -0.22469,          -0.29718,
           0.25169,           0.13780,
          -3.64824,           1.22420,          -2.48963,          -1.12515,
          -0.01510,          -0.56180,
          -0.03306,           0.01848,          -0.00103,          -0.00077,
          -0.01681,          -0.00227,
          -0.00402,          -0.00287,
           0.04965,          -0.16190,          -0.40025,           0.20734,
           0.15819,          -0.25451,
           0.02467,          -0.00495,
           0.00597,           0.00490,
          -0.01085,          -0.00460,
          -0.71564,          -0.26624,           0.03797,          -0.28263,
           0.03510,           0.30014,
           2.79810,           0.07258,
          -0.01618,           0.00337,
           0.00876,           0.04438,
           0.00742,          -0.00455,
          -0.01163,          -0.00683,
           0.00950,           0.01275,
          -0.02124,          -0.67527,          -0.23635,           0.06298,
          -0.03844,           0.01010,           0.73588,          -0.00271,
           0.01742,          -0.00467,
           0.00017,          -0.00505,
          -0.27482,           5.00521,          -1.92099,           1.55295,
          -0.35919,          -0.09314,
          -0.47002,           0.06826,
           0.07924,           0.16838,
          -0.04221,           0.71510,          -0.16482,           0.08809,
          41.76829,        -125.79427,         106.65271,         -71.30642,
          36.18112,          17.36143,          -1.63846,           5.02215,
          -1.08404,           0.00061,
           2.45567,          -2.42818,          -9.88756,           5.36587,
          -0.61253,          -0.35003,
        1523.54790,         602.82184,          68.66902,        1878.26100,
       -1098.78095,        -120.72600,         127.30918,        -383.96064,
          -7.00838,          -6.09942,          -1.54187,           0.34883,
          -9.47561,          -4.35408,
      -21541.63676,      -32542.09807,      -29720.82604,      -28072.21231,
      -15755.56255,       -8084.58657,       -8148.87315,        7434.89857,
       11033.30133,        7827.94658,         610.18256,      -11411.93624,
          -9.87426,           0.94865,          -1.63656,           0.41275,
        1996.57150,         511.48468,         669.78228,        1363.67610,
        -379.72037,         198.84438,         -16.63126,         -79.37624,
          -2.30776,        -246.07820,         -16.85846,        -148.18168,
          -6.89632,         -20.49587,           0.39892,          -0.34627,
         -57.81309,        -136.96971,          15.25671,         -96.61153,
          16.09785,          -8.79091,           0.70515,           1.16197,
           0.05647,           0.04684,
           0.25032,          -0.19951,           0.07282,          -0.00696,
           0.00493,           0.00733,
          -0.01085,           0.00422,
          -0.01309,           0.00262,
           0.37616,          -0.36203,          -0.11154,           0.18213,
           0.15691,           0.29343,           0.00485,           0.06106,
          -0.01492,           0.09954,
           0.28486,           2.27190,           0.33102,           1.50696,
          -0.01926,           0.04901,
           0.01827,           0.00863,
          -0.03315,           0.00178,
          -0.77600,          -0.48576,          -0.21111,          -0.19485,
           1.90295,           6.44856,           1.71638,           2.12980,
          -7.19585,          -0.08043,
           0.07004,          -0.02764,
           0.01604,           0.01158,
           0.00936,          -0.01199,
           0.18396,          -0.29234,           0.10422,          -0.00720,
           0.05196,           0.10753,           0.02859,          -0.03602,
           0.63828,           1.96280,          -0.31919,           0.85859,
          -0.10218,          -0.00673,
           0.01748,          -0.02190,
           0.01266,          -0.02729,
          -4.80220,           8.90557,          -5.94059,           2.28577,
          -0.19687,          -1.28666,           0.32398,           0.14879,
          -0.02619,          -0.02056,
          -0.04872,          -0.07011,          -0.04082,          -0.04740,
           0.60167,          -2.20365,          -0.27919,          -0.45957,
          -1.31664,          -2.22682,         176.89871,          13.03918,
           0.00568,           0.00560,
           0.01093,           0.00486,
          -0.00948,          -0.31272,
         -11.87638,          -3.68471,          -1.74977,          -9.60468,
           2.94988,          -0.57118,
           0.00307,          -0.01636,
           0.02624,           0.03032,
          -0.00464,          -0.01338,
           0.00935,           0.00530,
          -0.11822,           0.03328,          -0.41854,           0.04331,
           0.41340,          -0.21657,
          -0.00865,           0.00849,
          -0.00374,          -0.00899,
           0.01227,          -0.23462,          -0.71894,          -0.04515,
           0.00047,           0.28112,
          -0.12788,           0.11698,          -0.02030,           0.02759,
           0.02967,          -0.00092,
           0.00454,           0.00565,
          -0.00026,           0.00164,
          -0.01405,          -0.00862,
           0.01088,           0.05589,
           0.18248,          -0.06931,          -0.00011,           0.03713,
           0.01932,          -0.00982,
          -0.13861,           0.09853,          -0.03441,          -0.02492,
           2.26163,          -5.94453,           4.14361,          -0.94105,
           0.39561,           0.75414,
          -0.17642,           0.03724,
          -1.32978,          -0.56610,
          -0.03259,          -0.06752,
          39.07495,          80.25429,         -28.15558,          82.69851,
         -37.53894,         -17.88963,           6.98299,         -13.04691,
          -0.48675,          -1.84530,          -0.07985,          -0.33004,
          -3.39292,           2.73153,
      -17268.46134,        1144.22336,      -16658.48585,        5252.94094,
       -3461.47865,        2910.56452,        -433.49442,        -305.74268,
        -383.45023,         545.16136,         313.83376,          27.00533,
         -31.41075,           7.90570,         -12.40592,           3.01833,
          -0.83334,           0.23404,
          59.26487,        -112.74279,         113.29402,         -15.37579,
          14.03282,          32.74482,          -4.73299,           1.30224,
          -0.00866,           0.01232,
          -0.53797,           0.00238,          -0.07979,           0.04443,
          -0.05617,          -0.05396,
           0.10185,          -1.05476,           0.43791,          -0.32302,
           0.06465,           0.03815,
           0.00028,          -0.00446,
           0.09289,          -0.06389,
           0.01701,          -0.01409,
           0.47101,           0.16158,           0.01036,          -0.39836,
           0.00477,           0.01101,
          -2.06535,           0.33197,          -0.82468,          -0.41414,
           0.03209,          -0.09348,
           0.00843,          -0.00030,
          -9.49517,          -3.82206,           0.66899,         -10.28786,
           6.33435,           1.73684,          -0.98164,           2.25164,
          -0.07577,          -0.00277,
           1.02122,           0.75747,           1.79155,          -0.77789,
          -2.56780,          -2.07807,
           0.19528,           0.77118,          -0.28083,           0.32130,
          -0.04350,          -0.07428,
          -0.01161,           0.01387,
           0.02074,           0.19802,          -0.03600,           0.04922,
          -0.19837,           0.02572,
          -0.00682,          -0.04277,
          -0.01805,           0.00299,
           0.03283,          -0.02099,
           3.57307,           1.17468,           0.65769,           1.88181,
          -0.39215,           0.08415,
          -0.53635,          -0.19087,          -0.12456,           0.02176,
           0.01182,          -0.07941,
          -2.43731,           2.44464,           1.03961,          -1.81936,
          30.33140,           0.92645,
           0.00508,          -0.01771,
         -81.06338,          66.43957,          33.16729,         131.44697,
          76.63344,         -34.34324,         -35.33012,         -28.04413,
          -1.47440,          13.09015,
           0.13253,          -0.01629,           0.02187,          -0.00963,
         -21.47470,          -9.44332,          -7.21711,         -12.59472,
           1.76195,          -1.63911,           0.09060,           0.28656,
           0.00635,           0.00536,
           0.03470,          -0.06493,           0.00666,          -0.01084,
           0.01116,          -0.01612,          -0.00102,           0.00208,
          -0.05568,           0.00628,
           0.02665,          -0.01032,
           0.21261,          -1.90651,           0.72728,          -0.57788,
           0.08662,           0.10918,
           3.39133,           3.97302,          -4.63381,           4.26670,
          -2.50873,          -3.76064,
           1.28114,           1.81919,           1.48064,          -0.37578,
          -0.26209,          -0.47187,
           0.00282,          -0.00499,
           0.01749,           0.03222,
           1.60521,          -1.79705,           1.61453,           0.68886,
          -0.29909,           0.55025,
          -0.07894,           0.19880,          -0.15635,           0.46159,
           2.09769,           1.52742,
          -7.60312,          11.34886,           4.35640,           8.61048,
           2.15001,          -2.15303,          -0.61587,          -0.11950,
          -0.03289,          -0.00520,          -0.00501,          -0.00445,
           0.15294,          -0.05277,           0.02455,           0.00408,
           1.19601,           0.43479,           0.20422,           0.57125,
          -0.12790,           0.01318,
          -0.15275,          -0.43856,           6.99144,          -0.08794,
          -1.69865,           0.82589,          -0.20235,           0.97040,
           0.20903,           0.00675,
           0.26943,           0.08281,           0.03686,           0.05311,
           1.28468,           1.21735,          -1.38174,           1.29570,
          -0.75899,          -1.17168,
           0.44696,          -0.32341,          -0.06378,          -0.27573,
          -0.06406,           0.87186,           0.21069,           0.19724,
           0.00119,          -0.04147,
           0.39279,           0.51437,          -0.11035,           0.21450,
          -0.04309,           0.02359,           0.20490,           0.14210,
           0.00007,          -0.00017,
          -0.03529,          -0.02644,
           0.10710,           0.44476,          -0.02632,          -0.01817,
           2.11335,          -0.04432,
           0.18206,           0.27335,           0.08867,           0.00313,
          -0.00692,           0.01595,
          -0.72957,           0.32080,          -0.29291,          -0.44764,
           0.12767,          -0.05778,           0.04797,          -0.00223,
           0.17661,           0.22427,          -0.04914,           0.09114,
           0.12236,           0.00708,
           0.74315,          -0.01346,
           0.02245,          -0.02555,
          -0.30446,           0.13947,          -0.12340,          -0.18498,
          -0.04099,           0.02103,
           0.06337,          -0.01224,
           0.28181,          -0.01019,
          -0.02794,          -0.09412,
           0.03272,          -0.01095,
           0.11247,          -0.00650,
          -0.01319,          -0.04296,
           0.04653,          -0.00423,
           0.06535,           0.00014,
  };
  static final byte satargs[] = {
  (byte)0,  (byte)7,
  (byte)3,  (byte)2,  (byte)5, (byte)-6,  (byte)6,  (byte)3,  (byte)7,  (byte)0,
  (byte)2,  (byte)2,  (byte)5, (byte)-5,  (byte)6,  (byte)5,
  (byte)3,  (byte)1,  (byte)6, (byte)-4,  (byte)7,  (byte)2,  (byte)8,  (byte)0,
  (byte)2,  (byte)1,  (byte)6, (byte)-3,  (byte)7,  (byte)0,
  (byte)3,  (byte)1,  (byte)6, (byte)-2,  (byte)7, (byte)-2,  (byte)8,  (byte)0,
  (byte)2,  (byte)4,  (byte)5,(byte)-10,  (byte)6,  (byte)3,
  (byte)3,  (byte)1,  (byte)5, (byte)-1,  (byte)6, (byte)-4,  (byte)7,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-4,  (byte)6, (byte)-3,  (byte)7,  (byte)0,
  (byte)3,  (byte)2,  (byte)6, (byte)-8,  (byte)7,  (byte)4,  (byte)8,  (byte)0,
  (byte)3,  (byte)3,  (byte)5,(byte)-10,  (byte)6,  (byte)7,  (byte)7,  (byte)0,
  (byte)2,  (byte)6,  (byte)5,(byte)-15,  (byte)6,  (byte)0,
  (byte)2,  (byte)2,  (byte)6, (byte)-6,  (byte)7,  (byte)0,
  (byte)3,  (byte)1,  (byte)5, (byte)-4,  (byte)6,  (byte)4,  (byte)7,  (byte)1,
  (byte)3,  (byte)1,  (byte)5, (byte)-2,  (byte)6, (byte)-1,  (byte)7,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-5,  (byte)6,  (byte)1,  (byte)8,  (byte)0,
  (byte)3,  (byte)3,  (byte)5, (byte)-8,  (byte)6,  (byte)2,  (byte)7,  (byte)0,
  (byte)3,  (byte)1,  (byte)5, (byte)-3,  (byte)6,  (byte)2,  (byte)8,  (byte)0,
  (byte)3,  (byte)1,  (byte)5, (byte)-3,  (byte)6,  (byte)1,  (byte)7,  (byte)1,
  (byte)1,  (byte)1,  (byte)8,  (byte)0,
  (byte)3,  (byte)1,  (byte)5, (byte)-3,  (byte)6,  (byte)2,  (byte)7,  (byte)1,
  (byte)3,  (byte)1,  (byte)5, (byte)-2,  (byte)6, (byte)-2,  (byte)7,  (byte)0,
  (byte)2,  (byte)2,  (byte)6, (byte)-5,  (byte)7,  (byte)1,
  (byte)3,  (byte)2,  (byte)6, (byte)-6,  (byte)7,  (byte)2,  (byte)8,  (byte)0,
  (byte)3,  (byte)2,  (byte)6, (byte)-7,  (byte)7,  (byte)4,  (byte)8,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-4,  (byte)6, (byte)-2,  (byte)7,  (byte)0,
  (byte)3,  (byte)1,  (byte)5, (byte)-1,  (byte)6, (byte)-5,  (byte)7,  (byte)0,
  (byte)3,  (byte)2,  (byte)6, (byte)-7,  (byte)7,  (byte)5,  (byte)8,  (byte)0,
  (byte)3,  (byte)1,  (byte)6, (byte)-1,  (byte)7, (byte)-2,  (byte)8,  (byte)0,
  (byte)2,  (byte)1,  (byte)6, (byte)-2,  (byte)7,  (byte)1,
  (byte)3,  (byte)1,  (byte)6, (byte)-3,  (byte)7,  (byte)2,  (byte)8,  (byte)0,
  (byte)3,  (byte)1,  (byte)6, (byte)-4,  (byte)7,  (byte)4,  (byte)8,  (byte)1,
  (byte)3,  (byte)2,  (byte)5, (byte)-5,  (byte)6,  (byte)2,  (byte)8,  (byte)1,
  (byte)3,  (byte)2,  (byte)5, (byte)-6,  (byte)6,  (byte)2,  (byte)7,  (byte)1,
  (byte)2,  (byte)2,  (byte)7, (byte)-2,  (byte)8,  (byte)0,
  (byte)1,  (byte)1,  (byte)7,  (byte)2,
  (byte)2,  (byte)5,  (byte)5,(byte)-12,  (byte)6,  (byte)2,
  (byte)3,  (byte)2,  (byte)6, (byte)-5,  (byte)7,  (byte)1,  (byte)8,  (byte)0,
  (byte)3,  (byte)1,  (byte)5, (byte)-1,  (byte)6, (byte)-3,  (byte)7,  (byte)0,
  (byte)3,  (byte)7,  (byte)5,(byte)-18,  (byte)6,  (byte)3,  (byte)7,  (byte)0,
  (byte)2,  (byte)3,  (byte)5, (byte)-7,  (byte)6,  (byte)3,
  (byte)3,  (byte)1,  (byte)6,  (byte)1,  (byte)7, (byte)-5,  (byte)8,  (byte)0,
  (byte)3,  (byte)1,  (byte)5, (byte)-4,  (byte)6,  (byte)3,  (byte)7,  (byte)0,
  (byte)3,  (byte)5,  (byte)5,(byte)-13,  (byte)6,  (byte)3,  (byte)7,  (byte)0,
  (byte)2,  (byte)1,  (byte)5, (byte)-2,  (byte)6,  (byte)3,
  (byte)3,  (byte)3,  (byte)5, (byte)-9,  (byte)6,  (byte)3,  (byte)7,  (byte)0,
  (byte)3,  (byte)3,  (byte)5, (byte)-8,  (byte)6,  (byte)3,  (byte)7,  (byte)1,
  (byte)2,  (byte)1,  (byte)5, (byte)-3,  (byte)6,  (byte)3,
  (byte)3,  (byte)5,  (byte)5,(byte)-14,  (byte)6,  (byte)3,  (byte)7,  (byte)0,
  (byte)3,  (byte)1,  (byte)5, (byte)-3,  (byte)6,  (byte)3,  (byte)7,  (byte)2,
  (byte)2,  (byte)3,  (byte)6, (byte)-7,  (byte)7,  (byte)0,
  (byte)2,  (byte)3,  (byte)5, (byte)-8,  (byte)6,  (byte)2,
  (byte)3,  (byte)2,  (byte)5, (byte)-3,  (byte)6, (byte)-4,  (byte)7,  (byte)1,
  (byte)3,  (byte)2,  (byte)5, (byte)-8,  (byte)6,  (byte)7,  (byte)7,  (byte)0,
  (byte)2,  (byte)5,  (byte)5,(byte)-13,  (byte)6,  (byte)0,
  (byte)2,  (byte)2,  (byte)6, (byte)-4,  (byte)7,  (byte)2,
  (byte)3,  (byte)2,  (byte)6, (byte)-5,  (byte)7,  (byte)2,  (byte)8,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-4,  (byte)6, (byte)-1,  (byte)7,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-7,  (byte)6,  (byte)4,  (byte)7,  (byte)0,
  (byte)2,  (byte)1,  (byte)6, (byte)-2,  (byte)8,  (byte)2,
  (byte)2,  (byte)1,  (byte)6, (byte)-1,  (byte)7,  (byte)0,
  (byte)3,  (byte)1,  (byte)6, (byte)-2,  (byte)7,  (byte)2,  (byte)8,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-5,  (byte)6,  (byte)2,  (byte)7,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-6,  (byte)6,  (byte)2,  (byte)8,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-6,  (byte)6,  (byte)1,  (byte)7,  (byte)0,
  (byte)2,  (byte)3,  (byte)7, (byte)-2,  (byte)8,  (byte)0,
  (byte)1,  (byte)2,  (byte)7,  (byte)1,
  (byte)2,  (byte)1,  (byte)6, (byte)-1,  (byte)8,  (byte)1,
  (byte)3,  (byte)1,  (byte)5, (byte)-2,  (byte)6,  (byte)1,  (byte)7,  (byte)0,
  (byte)3,  (byte)1,  (byte)5, (byte)-2,  (byte)6,  (byte)2,  (byte)8,  (byte)0,
  (byte)2,  (byte)3,  (byte)6, (byte)-6,  (byte)7,  (byte)2,
  (byte)2,  (byte)6,  (byte)5,(byte)-14,  (byte)6,  (byte)0,
  (byte)3,  (byte)3,  (byte)6, (byte)-7,  (byte)7,  (byte)2,  (byte)8,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-3,  (byte)6, (byte)-3,  (byte)7,  (byte)1,
  (byte)2,  (byte)4,  (byte)5, (byte)-9,  (byte)6,  (byte)3,
  (byte)3,  (byte)2,  (byte)6, (byte)-2,  (byte)7, (byte)-2,  (byte)8,  (byte)0,
  (byte)2,  (byte)2,  (byte)6, (byte)-3,  (byte)7,  (byte)1,
  (byte)3,  (byte)2,  (byte)6, (byte)-4,  (byte)7,  (byte)2,  (byte)8,  (byte)0,
  (byte)2,  (byte)2,  (byte)5, (byte)-4,  (byte)6,  (byte)3,
  (byte)3,  (byte)2,  (byte)5, (byte)-7,  (byte)6,  (byte)3,  (byte)7,  (byte)1,
  (byte)3,  (byte)1,  (byte)6,  (byte)1,  (byte)7, (byte)-2,  (byte)8,  (byte)0,
  (byte)1,  (byte)1,  (byte)6,  (byte)5,
  (byte)3,  (byte)2,  (byte)5, (byte)-5,  (byte)6,  (byte)3,  (byte)7,  (byte)1,
  (byte)2,  (byte)2,  (byte)5, (byte)-6,  (byte)6,  (byte)3,
  (byte)1,  (byte)3,  (byte)7,  (byte)3,
  (byte)2,  (byte)4,  (byte)5,(byte)-11,  (byte)6,  (byte)3,
  (byte)2,  (byte)1,  (byte)5, (byte)-4,  (byte)7,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-5,  (byte)6, (byte)-3,  (byte)7,  (byte)1,
  (byte)2,  (byte)6,  (byte)5,(byte)-16,  (byte)6,  (byte)0,
  (byte)3,  (byte)3,  (byte)5, (byte)-7,  (byte)6,  (byte)2,  (byte)7,  (byte)0,
  (byte)3,  (byte)3,  (byte)6, (byte)-4,  (byte)7, (byte)-2,  (byte)8,  (byte)0,
  (byte)2,  (byte)3,  (byte)6, (byte)-5,  (byte)7,  (byte)1,
  (byte)3,  (byte)3,  (byte)6, (byte)-6,  (byte)7,  (byte)2,  (byte)8,  (byte)1,
  (byte)3,  (byte)3,  (byte)6, (byte)-7,  (byte)7,  (byte)4,  (byte)8,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-3,  (byte)6, (byte)-2,  (byte)7,  (byte)2,
  (byte)3,  (byte)2,  (byte)5, (byte)-8,  (byte)6,  (byte)5,  (byte)7,  (byte)0,
  (byte)2,  (byte)2,  (byte)6, (byte)-4,  (byte)8,  (byte)0,
  (byte)3,  (byte)2,  (byte)6, (byte)-1,  (byte)7, (byte)-2,  (byte)8,  (byte)1,
  (byte)2,  (byte)2,  (byte)6, (byte)-2,  (byte)7,  (byte)2,
  (byte)3,  (byte)2,  (byte)6, (byte)-3,  (byte)7,  (byte)2,  (byte)8,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-4,  (byte)6,  (byte)1,  (byte)7,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-4,  (byte)6,  (byte)2,  (byte)8,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-7,  (byte)6,  (byte)2,  (byte)7,  (byte)1,
  (byte)2,  (byte)1,  (byte)6,  (byte)1,  (byte)7,  (byte)1,
  (byte)2,  (byte)5,  (byte)5,(byte)-11,  (byte)6,  (byte)2,
  (byte)3,  (byte)1,  (byte)5, (byte)-2,  (byte)7, (byte)-2,  (byte)8,  (byte)0,
  (byte)2,  (byte)1,  (byte)5, (byte)-3,  (byte)7,  (byte)0,
  (byte)2,  (byte)3,  (byte)5, (byte)-6,  (byte)6,  (byte)3,
  (byte)3,  (byte)2,  (byte)6,  (byte)1,  (byte)7, (byte)-5,  (byte)8,  (byte)0,
  (byte)2,  (byte)2,  (byte)6, (byte)-3,  (byte)8,  (byte)1,
  (byte)2,  (byte)1,  (byte)5, (byte)-1,  (byte)6,  (byte)3,
  (byte)3,  (byte)2,  (byte)5, (byte)-7,  (byte)6,  (byte)3,  (byte)8,  (byte)0,
  (byte)3,  (byte)3,  (byte)5, (byte)-7,  (byte)6,  (byte)3,  (byte)7,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-1,  (byte)6, (byte)-7,  (byte)7,  (byte)0,
  (byte)2,  (byte)1,  (byte)5, (byte)-4,  (byte)6,  (byte)2,
  (byte)3,  (byte)1,  (byte)5, (byte)-2,  (byte)6,  (byte)3,  (byte)7,  (byte)0,
  (byte)2,  (byte)4,  (byte)6, (byte)-7,  (byte)7,  (byte)0,
  (byte)2,  (byte)3,  (byte)5, (byte)-9,  (byte)6,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-2,  (byte)6, (byte)-4,  (byte)7,  (byte)0,
  (byte)2,  (byte)3,  (byte)6, (byte)-4,  (byte)7,  (byte)2,
  (byte)3,  (byte)2,  (byte)5, (byte)-3,  (byte)6, (byte)-1,  (byte)7,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-8,  (byte)6,  (byte)4,  (byte)7,  (byte)0,
  (byte)2,  (byte)2,  (byte)6, (byte)-2,  (byte)8,  (byte)1,
  (byte)2,  (byte)2,  (byte)6, (byte)-1,  (byte)7,  (byte)0,
  (byte)3,  (byte)2,  (byte)6, (byte)-2,  (byte)7,  (byte)2,  (byte)8,  (byte)1,
  (byte)3,  (byte)2,  (byte)5, (byte)-4,  (byte)6,  (byte)2,  (byte)7,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-7,  (byte)6,  (byte)2,  (byte)8,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-7,  (byte)6,  (byte)1,  (byte)7,  (byte)0,
  (byte)2,  (byte)1,  (byte)6,  (byte)2,  (byte)7,  (byte)0,
  (byte)2,  (byte)2,  (byte)6, (byte)-1,  (byte)8,  (byte)0,
  (byte)2,  (byte)4,  (byte)6, (byte)-6,  (byte)7,  (byte)1,
  (byte)2,  (byte)6,  (byte)5,(byte)-13,  (byte)6,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-2,  (byte)6, (byte)-3,  (byte)7,  (byte)1,
  (byte)2,  (byte)4,  (byte)5, (byte)-8,  (byte)6,  (byte)2,
  (byte)3,  (byte)3,  (byte)6, (byte)-2,  (byte)7, (byte)-2,  (byte)8,  (byte)0,
  (byte)2,  (byte)3,  (byte)6, (byte)-3,  (byte)7,  (byte)0,
  (byte)3,  (byte)3,  (byte)6, (byte)-4,  (byte)7,  (byte)2,  (byte)8,  (byte)0,
  (byte)2,  (byte)2,  (byte)5, (byte)-3,  (byte)6,  (byte)3,
  (byte)3,  (byte)2,  (byte)5, (byte)-8,  (byte)6,  (byte)3,  (byte)7,  (byte)1,
  (byte)3,  (byte)2,  (byte)6,  (byte)1,  (byte)7, (byte)-2,  (byte)8,  (byte)0,
  (byte)1,  (byte)2,  (byte)6,  (byte)5,
  (byte)3,  (byte)2,  (byte)5, (byte)-4,  (byte)6,  (byte)3,  (byte)7,  (byte)2,
  (byte)2,  (byte)2,  (byte)5, (byte)-7,  (byte)6,  (byte)3,
  (byte)3,  (byte)1,  (byte)6,  (byte)4,  (byte)7, (byte)-2,  (byte)8,  (byte)0,
  (byte)2,  (byte)1,  (byte)6,  (byte)3,  (byte)7,  (byte)1,
  (byte)3,  (byte)1,  (byte)6,  (byte)2,  (byte)7,  (byte)2,  (byte)8,  (byte)0,
  (byte)2,  (byte)4,  (byte)5,(byte)-12,  (byte)6,  (byte)2,
  (byte)2,  (byte)5,  (byte)6, (byte)-8,  (byte)7,  (byte)0,
  (byte)2,  (byte)4,  (byte)6, (byte)-5,  (byte)7,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-2,  (byte)6, (byte)-2,  (byte)7,  (byte)0,
  (byte)2,  (byte)3,  (byte)6, (byte)-2,  (byte)7,  (byte)1,
  (byte)3,  (byte)3,  (byte)6, (byte)-3,  (byte)7,  (byte)2,  (byte)8,  (byte)0,
  (byte)2,  (byte)5,  (byte)5,(byte)-10,  (byte)6,  (byte)2,
  (byte)3,  (byte)1,  (byte)5,  (byte)1,  (byte)6, (byte)-3,  (byte)7,  (byte)0,
  (byte)2,  (byte)3,  (byte)5, (byte)-5,  (byte)6,  (byte)3,
  (byte)2,  (byte)3,  (byte)6, (byte)-3,  (byte)8,  (byte)0,
  (byte)1,  (byte)1,  (byte)5,  (byte)2,
  (byte)2,  (byte)1,  (byte)5, (byte)-5,  (byte)6,  (byte)2,
  (byte)2,  (byte)5,  (byte)6, (byte)-7,  (byte)7,  (byte)0,
  (byte)2,  (byte)4,  (byte)6, (byte)-4,  (byte)7,  (byte)2,
  (byte)2,  (byte)3,  (byte)6, (byte)-2,  (byte)8,  (byte)0,
  (byte)2,  (byte)3,  (byte)6, (byte)-1,  (byte)7,  (byte)0,
  (byte)2,  (byte)5,  (byte)6, (byte)-6,  (byte)7,  (byte)0,
  (byte)2,  (byte)4,  (byte)5, (byte)-7,  (byte)6,  (byte)2,
  (byte)2,  (byte)4,  (byte)6, (byte)-3,  (byte)7,  (byte)2,
  (byte)2,  (byte)2,  (byte)5, (byte)-2,  (byte)6,  (byte)2,
  (byte)3,  (byte)2,  (byte)6, (byte)-9,  (byte)7,  (byte)3,  (byte)8,  (byte)0,
  (byte)1,  (byte)3,  (byte)6,  (byte)4,
  (byte)3,  (byte)2,  (byte)5, (byte)-3,  (byte)6,  (byte)3,  (byte)7,  (byte)1,
  (byte)2,  (byte)2,  (byte)5, (byte)-8,  (byte)6,  (byte)3,
  (byte)3,  (byte)2,  (byte)6,  (byte)4,  (byte)7, (byte)-2,  (byte)8,  (byte)0,
  (byte)2,  (byte)4,  (byte)5,(byte)-13,  (byte)6,  (byte)1,
  (byte)2,  (byte)6,  (byte)6, (byte)-8,  (byte)7,  (byte)1,
  (byte)2,  (byte)5,  (byte)6, (byte)-5,  (byte)7,  (byte)0,
  (byte)2,  (byte)4,  (byte)6, (byte)-2,  (byte)7,  (byte)0,
  (byte)2,  (byte)5,  (byte)5, (byte)-9,  (byte)6,  (byte)2,
  (byte)2,  (byte)3,  (byte)5, (byte)-4,  (byte)6,  (byte)2,
  (byte)2,  (byte)1,  (byte)5,  (byte)1,  (byte)6,  (byte)2,
  (byte)2,  (byte)6,  (byte)5,(byte)-11,  (byte)6,  (byte)0,
  (byte)3,  (byte)6,  (byte)6, (byte)-7,  (byte)7,  (byte)2,  (byte)8,  (byte)0,
  (byte)2,  (byte)4,  (byte)5, (byte)-6,  (byte)6,  (byte)2,
  (byte)2,  (byte)2,  (byte)5, (byte)-1,  (byte)6,  (byte)2,
  (byte)1,  (byte)4,  (byte)6,  (byte)3,
  (byte)3,  (byte)2,  (byte)5, (byte)-2,  (byte)6,  (byte)3,  (byte)7,  (byte)1,
  (byte)2,  (byte)2,  (byte)5, (byte)-9,  (byte)6,  (byte)1,
  (byte)2,  (byte)5,  (byte)5, (byte)-8,  (byte)6,  (byte)2,
  (byte)2,  (byte)3,  (byte)5, (byte)-3,  (byte)6,  (byte)1,
  (byte)2,  (byte)1,  (byte)5,  (byte)2,  (byte)6,  (byte)2,
  (byte)2,  (byte)6,  (byte)5,(byte)-10,  (byte)6,  (byte)1,
  (byte)2,  (byte)4,  (byte)5, (byte)-5,  (byte)6,  (byte)2,
  (byte)1,  (byte)2,  (byte)5,  (byte)1,
  (byte)1,  (byte)5,  (byte)6,  (byte)2,
  (byte)2,  (byte)5,  (byte)5, (byte)-7,  (byte)6,  (byte)1,
  (byte)2,  (byte)3,  (byte)5, (byte)-2,  (byte)6,  (byte)1,
  (byte)3,  (byte)1,  (byte)5,  (byte)2,  (byte)6,  (byte)3,  (byte)7,  (byte)0,
  (byte)2,  (byte)6,  (byte)5, (byte)-9,  (byte)6,  (byte)0,
  (byte)2,  (byte)4,  (byte)5, (byte)-4,  (byte)6,  (byte)2,
  (byte)2,  (byte)2,  (byte)5,  (byte)1,  (byte)6,  (byte)1,
  (byte)2,  (byte)7,  (byte)5,(byte)-11,  (byte)6,  (byte)0,
  (byte)2,  (byte)5,  (byte)5, (byte)-6,  (byte)6,  (byte)1,
  (byte)2,  (byte)3,  (byte)5, (byte)-1,  (byte)6,  (byte)1,
  (byte)2,  (byte)6,  (byte)5, (byte)-8,  (byte)6,  (byte)1,
  (byte)2,  (byte)4,  (byte)5, (byte)-3,  (byte)6,  (byte)0,
  (byte)2,  (byte)5,  (byte)5, (byte)-5,  (byte)6,  (byte)0,
  (byte)1,  (byte)3,  (byte)5,  (byte)0,
  (byte)2,  (byte)6,  (byte)5, (byte)-7,  (byte)6,  (byte)1,
  (byte)2,  (byte)7,  (byte)5, (byte)-9,  (byte)6,  (byte)0,
  (byte)2,  (byte)5,  (byte)5, (byte)-4,  (byte)6,  (byte)0,
  (byte)2,  (byte)6,  (byte)5, (byte)-6,  (byte)6,  (byte)0,
  (byte)2,  (byte)7,  (byte)5, (byte)-8,  (byte)6,  (byte)0,
  (byte)2,  (byte)6,  (byte)5, (byte)-5,  (byte)6,  (byte)0,
  (byte)2,  (byte)7,  (byte)5, (byte)-7,  (byte)6,  (byte)0,
  (byte)2,  (byte)8,  (byte)5, (byte)-9,  (byte)6,  (byte)0,
  (byte)2,  (byte)8,  (byte)5, (byte)-8,  (byte)6,  (byte)0,
  (byte)2,  (byte)1,  (byte)3, (byte)-1,  (byte)6,  (byte)0,
 (byte)-1
  };
  
  static Plantbl sat404 = new Plantbl(
                               new short[]{0,  0,  1,  0,  8, 18,  9,  5,  0},
                               (short)7,
                               satargs,
                               sattabl,
                               sattabb,
                               sattabr,
                               9.5575813548599999e+00
  );
}
class SwemptabUra {
  
  static final double uratabl[] = {
          21.56000,       -4652.06828,   154246324.90417,     1130486.05080,
         330.11531,       -3020.20235,
          -8.03769,        -122.02019,
         212.45130,         254.23866,          25.39758,          60.08296,
        6949.85053,       51951.42606,       -1834.66531,       44481.91144,
       -3267.45825,       10776.65972,        -628.05388,         532.83011,
         -16.80583,         -30.05544,
        1420.33767,        2007.21040,         592.32842,        1541.61732,
        -163.55984,         121.14134,         114.74969,         -16.04944,
           0.06069,           0.00725,
          -0.16861,           0.28785,
           0.07399,          -0.09680,
           0.19936,          -0.41620,
           0.02922,           0.07398,
           0.17272,           0.05602,
           1.65461,          -0.68278,          -2.18745,          -0.85327,
           0.52467,          -0.30863,
           0.01598,           0.30017,
          -0.04190,          -0.03288,
          -0.02013,           0.02257,
          -0.54883,          -0.22701,          -0.09257,          -0.03921,
           0.02644,           0.04667,
           0.24773,          -0.16562,
       44242.85814,     -223163.54065,      123776.84417,     -206375.74884,
       70472.73820,      -27456.55173,        4065.74401,       13202.39154,
       -3260.72648,         802.50579,        -153.13236,        -503.81026,
          30.17812,         -31.91893,
         -65.14719,          77.78417,         -37.38185,          19.13337,
          -3.14043,          -0.21147,
           0.27143,           0.17424,
           0.04458,           0.10976,
          -0.41841,          -0.21887,          -0.09194,          -0.02303,
           0.02896,           0.10044,
           0.01385,           0.01723,
          -0.01126,          -0.09318,
         -57.95890,          29.69059,         -46.41390,           3.07177,
           0.42494,           2.33678,          -3.09621,           0.05256,
          -0.02134,          -0.35202,
          -0.44475,          -0.83135,
        1318.18265,       25605.86848,       -9168.38371,       18917.31507,
       -5145.74480,        2130.77612,        -485.25920,        -438.44867,
          19.97802,         -33.14800,
      -23383.91826,      -45133.19122,      -18520.80729,      -26549.95198,
       -2276.70124,       -2974.01604,         603.23665,         306.87616,
         -87.73070,         -32.49134,
      549975.14525,      261920.31896,      526261.09735,      362619.26839,
      150616.68873,      164643.90808,        9550.02662,       27381.83042,
       -1065.89047,        1024.20231,         -66.63822,         -44.75169,
         -92.10532,         -20.26930,
     -313205.95341,     1462242.64616,      112982.53079,     1865690.41965,
      308844.30901,      639864.93227,       89716.32843,       10378.80773,
        4395.08428,      -14565.35913,       -3016.07754,      -19348.64612,
        3838.36899,       -9813.42713,        6883.58821,       -6064.92588,
        2740.47455,        -176.29547,         241.91895,         268.44181,
          -6.13397,          17.92503,
          -0.01377,          -0.08742,
         387.51915,         257.03872,         152.81792,         221.56197,
         -22.94836,          29.56640,          -2.27801,           4.72805,
          -6.03420,          -0.36763,
           0.00667,           0.00443,
          -0.01405,           0.04658,
          -0.06533,          -0.01966,
           0.10738,           0.00443,
           0.02889,           0.01056,
           0.00900,          -0.02206,
           0.00013,           0.05281,
           0.03035,           0.34793,
           0.19460,           2.47360,
           0.18189,          -0.83895,           0.24983,          15.32050,
           0.46010,           2.79643,
          -0.45793,           0.96707,          -0.31226,           0.51911,
           0.04071,           0.39399,
           0.00038,           0.03854,
           0.22446,           0.13630,          -0.04357,           0.03635,
           0.00202,          -0.04502,
          -0.00458,          -0.03884,
           1.32597,           3.40849,          -1.67839,          -0.95411,
          -1.00116,          -0.72744,          -0.22484,          -0.27682,
          -0.18069,           0.00405,
          -0.01000,           0.27523,
          -0.07038,          -0.01051,
          -0.09064,           0.08518,
           0.02083,          -0.25406,
           0.17745,          -0.00944,
           0.21326,           0.20454,
          18.84894,          -7.64400,           0.62670,         -11.02728,
           8.91329,          20.67190,
           0.17757,          -0.15471,
          -0.11385,          -0.46057,
           6.23014,         -14.46025,           2.30012,          -2.22677,
           5.16823,          -1.64235,
        -274.58413,         833.33247,        -191.26241,         269.90157,
         -17.25965,           9.11368,
        -261.65136,      -18274.45858,       -2553.83872,      -10039.10490,
        -508.52567,         336.18172,          14.88587,         421.35954,
         162.43462,         544.92580,
          -0.44246,           0.23216,
          -0.29024,          -0.13057,
          -1.58438,           0.34032,          -0.31604,          -0.01166,
          -0.07112,           0.05721,
          -0.10813,           0.01064,
          -0.05413,           0.06705,
          -0.41582,          -0.47725,           0.31031,           0.08605,
           0.00409,           0.02373,
           0.08092,           0.06247,          -0.01026,           0.05863,
          -0.00238,           0.02948,
           0.00117,           0.02714,
           0.01720,           0.18261,
          -0.04067,           0.88639,
          -0.15502,          -0.96383,
          -0.05307,          -0.17319,
          -0.00486,          -0.02373,
          -0.14748,          -0.11884,           0.07798,          -0.00358,
           0.01104,           0.00805,
           0.15099,          -0.03453,           0.01846,           0.03459,
           0.02197,           0.07012,
          -0.43677,          -1.87445,           1.35202,           2.28294,
          -0.03592,           0.07679,
           0.16427,           0.03014,           0.02472,           0.05549,
          -0.04985,           0.05874,
           0.35361,           0.01144,          -0.57400,           1.34898,
           0.00265,           0.01540,
           0.00951,           0.08159,
          -0.00435,           0.34759,
          -0.12413,          -0.49848,
          -0.77075,          -2.73810,
         -31.77702,          12.16042,         -14.87605,          11.98287,
          12.69358,           1.31307,          -8.22911,         -21.47437,
          -0.24051,          -0.38332,
          -0.01162,          -0.03175,
           0.00556,           0.02454,
          -0.02297,          -0.01654,
           0.00707,           0.04828,
          -0.00309,           0.17381,
          -0.00500,          -0.07579,
           0.02008,           0.05356,
           0.00702,           0.01133,
          -0.00237,          -0.00612,
           0.18551,           0.22799,          -0.14194,          -0.08593,
           0.00002,          -0.01049,
          -0.17363,          -0.13986,           0.00078,          -0.06993,
          -0.00430,          -0.07795,
          -0.03232,          -4.13170,
           0.00311,           0.05356,
          -0.17324,          -0.15505,          -0.00590,          -0.06608,
           0.04257,          -0.04571,
           0.00501,           0.02141,
          -0.00037,           0.07845,
          -0.00381,          -0.03417,
           0.01834,           0.03349,
           0.07994,           0.15297,
          -0.82299,           0.24672,           0.51764,           0.96379,
           0.01729,           0.02489,
          -0.08581,           0.13252,
           0.00538,           0.01995,
          -0.00148,          -0.02261,
           0.00534,           0.01565,
          -0.07518,          -0.28114,           0.22386,           0.39023,
          -0.00864,           0.00964,
          -0.01923,          -0.02426,
          -0.00112,           0.00923,
          -0.00685,           0.02450,
           0.26733,          -0.99972,          -0.82005,           0.13725,
           0.01520,          -0.00790,
           0.00358,           0.00751,
          -0.00648,          -0.00605,
          -0.04966,          -0.04633,
           0.06394,          -0.01965,
           0.50185,           0.40553,          -0.25809,           0.28853,
           0.52545,          -3.41675,
          -0.00347,          -0.11848,
           0.02945,          -0.01061,
          -0.04160,          -0.03519,
          -0.03234,          -0.81852,
          -0.02156,          -0.00841,
           0.00029,           0.00020,
          -0.02281,          -0.00364,
           0.04738,          -0.04504,
          -0.19161,           0.37225,           0.05765,           0.11987,
           0.00050,           0.02012,
          -0.03806,           0.39498,
           0.29982,           0.00886,           0.01671,          53.04042,
          -0.04160,          -0.38856,
          -0.00174,          -0.01773,
          -0.47661,          -0.32010,          -0.01088,          -0.16231,
          -0.01584,          -0.00144,
           0.06659,           0.12734,
           0.04884,           0.02236,
           0.00146,           0.06030,
          -0.20660,          -0.03982,           0.15091,           1.24562,
          -0.01303,          -0.22426,
          -0.01518,          -0.03922,
          -0.00043,          -0.00047,
           0.02451,           0.04437,
           0.02380,          -0.00189,
          -0.00640,          -0.07114,
          -0.00320,          -0.02491,
          -0.00829,           0.07284,
           0.02846,          -0.28034,
          -0.00268,           0.00256,
          -0.43420,           0.39645,          -0.31053,           1.25916,
          -0.00371,          -0.00651,
          -0.00096,           0.02762,
          -0.00067,          -0.02503,
          -0.01517,           0.03748,
  };
  static final double uratabb[] = {
           0.00000,         107.91527,          83.39404,        -124.29804,
          -7.73277,          -3.99442,
          -0.08328,          -1.74251,
          -9.05659,         -22.88559,          -2.30655,          -4.40259,
        -470.94604,       -3648.43408,         326.28960,       -2972.91303,
         337.37285,        -650.33570,          57.18479,         -18.29130,
           1.13897,           2.70158,
         -13.64388,         -71.88619,           7.36408,         -43.79994,
           6.57463,          -5.81111,          -0.06451,           0.73379,
           0.00574,          -0.01635,
           0.00074,          -0.01496,
          -0.00418,           0.00647,
          -0.00407,           0.00548,
           0.00002,           0.00187,
          -0.00591,           0.00557,
           0.32568,          -0.01574,           0.19347,          -0.01705,
           0.00173,           0.02384,
          -0.00248,          -0.00103,
           0.00227,           0.00146,
           0.00307,          -0.00040,
           0.03886,           0.01987,           0.00546,           0.00345,
           0.00134,          -0.00609,
          -0.01502,          -0.01569,
      -10080.59325,       10806.67752,      -14013.76861,        9928.38683,
       -6540.83480,        2084.91597,       -1093.05006,        -305.34266,
          -9.04558,        -110.32310,           9.26094,          -3.93195,
           0.25552,           0.50327,
         -13.12170,          -4.19317,          -4.50857,          -3.37626,
          -0.26850,          -0.36028,
          -0.00357,           0.05862,
          -0.00828,           0.00926,
          -0.01515,          -0.03687,          -0.00224,          -0.00802,
          -0.00225,          -0.00158,
          -0.00022,          -0.00044,
          -0.00281,           0.00371,
           2.28259,          -4.29888,           1.74622,          -2.13604,
           0.37023,          -0.37022,           0.00886,           0.07081,
           0.01669,           0.00056,
          -0.02020,           0.01586,
       -4255.31929,        5978.03267,       -7264.48027,        1884.12585,
       -2353.93882,       -1593.23001,          17.57205,        -498.54139,
          33.28704,         -13.79498,
      -38416.64883,      -13774.09664,      -32822.03952,       -3983.42726,
       -7538.09822,        1906.66915,        -221.24439,         512.77046,
          32.26101,          12.46483,
      142710.47871,      -96584.83892,      145395.05981,      -86630.96423,
       48202.96749,      -23596.77676,        5286.16967,       -1626.44031,
         -16.53568,          95.15428,         -15.19472,           5.69207,
          -6.72181,           7.28683,
        9515.16142,     -166495.49381,        5588.84271,     -146260.29445,
        2023.55881,      -30687.22422,         243.64741,         971.58076,
         390.73247,        -236.13754,       -2684.56349,         739.81087,
        -597.39429,         474.89313,        -631.69166,         213.04947,
        -204.89515,         -33.09139,         -17.78004,         -22.21866,
           0.61083,          -1.41177,
          -0.00070,          -0.00501,
         -58.24552,          25.27978,         -36.39386,           0.36376,
          -2.21030,          -6.46685,          -0.58473,          -0.09357,
           0.12829,          -0.94855,
           0.00042,           0.00048,
           0.00411,           0.00101,
           0.00249,          -0.00865,
           0.00223,           0.00293,
           0.00041,          -0.00042,
           0.00104,          -0.00086,
           0.00126,          -0.00380,
           0.00906,          -0.02253,
           0.05998,          -0.10318,
           0.00004,          -0.03225,           0.14303,          -0.05273,
           0.32683,           0.09386,
          -0.17053,           0.60847,          -0.06190,           0.28166,
           0.06411,           0.05289,
           0.01138,           0.00128,
          -0.00930,           0.00272,           0.00037,           0.00215,
           0.00004,           0.00050,
           0.00114,          -0.00217,
           0.05358,          -0.06413,          -0.00124,           0.03842,
           0.01006,           0.22479,           0.00412,           0.04040,
           0.01708,           0.02164,
           0.02484,          -0.02463,
          -0.00103,           0.02633,
          -0.01303,          -0.03214,
           0.03613,           0.02205,
          -0.02677,          -0.02522,
          -0.00293,           0.03130,
          -1.87255,          -2.50308,          -1.53715,           0.36859,
          -0.17829,          -1.12095,
          -0.05652,          -0.00786,
          -0.06992,           0.07279,
          -2.95896,           0.55138,          -0.61498,          -0.11008,
          -0.87790,          -0.50965,
         119.73553,         -35.18217,          44.78683,          -4.22438,
           1.95723,           0.58033,
       -4077.02379,        -353.39110,       -2781.63273,         -75.23318,
        -312.50478,         -23.86495,          24.59887,          32.56837,
         120.09593,         -51.00495,
           0.09737,           0.09111,
           0.04799,          -0.05029,
           0.08351,          -0.33726,           0.03158,          -0.06435,
          -0.00523,          -0.01736,
           0.00751,          -0.01757,
          -0.00406,          -0.01198,
           0.16402,          -0.10986,          -0.02024,           0.07205,
          -0.00440,          -0.00072,
          -0.00465,           0.00310,          -0.00121,          -0.00121,
           0.00083,           0.00020,
           0.00140,          -0.00176,
           0.00381,          -0.00731,
          -0.01618,           0.01570,
          -0.10201,           0.05809,
          -0.03359,           0.01024,
          -0.00535,           0.00018,
           0.00024,           0.00509,          -0.00158,          -0.00466,
           0.00009,          -0.00083,
          -0.00700,          -0.00090,          -0.00011,          -0.00079,
           0.00133,          -0.00126,
           0.01416,           0.05553,           0.04283,          -0.06719,
           0.00119,           0.00291,
          -0.00263,           0.01282,          -0.00040,           0.00188,
          -0.00237,           0.00973,
          -0.39533,           0.18773,          -0.79821,          -0.40168,
           0.00151,          -0.00161,
           0.00123,          -0.00516,
          -0.01432,          -0.00293,
          -0.05477,           0.04130,
          -0.48837,           0.18944,
          -0.12552,           9.37098,           1.02045,           5.11382,
           0.72098,          -3.70049,          -5.80982,           3.30105,
          -0.09682,           0.09696,
          -0.00876,           0.00504,
           0.00318,           0.00245,
           0.00563,          -0.00665,
           0.00108,          -0.00233,
          -0.00117,           0.00177,
          -0.00343,           0.00503,
           0.01044,          -0.00651,
           0.00296,          -0.00162,
           0.00037,           0.00028,
          -0.00020,          -0.00786,           0.00029,           0.00836,
           0.00004,           0.00033,
          -0.00309,          -0.00086,          -0.00157,          -0.00086,
          -0.00058,           0.00105,
          -0.04557,           0.01794,
          -0.00122,          -0.00086,
           0.00420,          -0.00285,           0.00118,          -0.00020,
           0.00743,          -0.01217,
           0.00053,          -0.00084,
          -0.00075,           0.00097,
          -0.00107,           0.00314,
           0.00576,          -0.00505,
           0.03624,          -0.02546,
           0.05379,           0.30081,           0.29870,          -0.22106,
           0.00696,          -0.00801,
          -0.03995,          -0.01808,
          -0.00139,           0.00102,
          -0.00059,           0.00138,
           0.00019,          -0.00037,
           0.00274,           0.00658,           0.00672,          -0.01132,
           0.00023,           0.00051,
           0.00031,           0.00090,
          -0.00017,          -0.00001,
           0.00085,           0.00004,
           0.02221,          -0.01977,           0.07498,           0.03025,
          -0.00082,          -0.00022,
          -0.00073,          -0.00028,
          -0.00253,           0.00259,
          -0.01329,           0.01805,
           0.00096,           0.00833,
          -0.11836,           0.04277,          -0.10820,          -0.03018,
           0.34504,           0.09834,
          -0.00538,          -0.00231,
           0.00036,           0.00042,
          -0.00023,           0.00260,
          -0.01137,           0.00036,
           0.01081,          -0.03271,
          -0.00029,          -0.00028,
           0.00018,          -0.00003,
           0.00009,           0.00012,
           0.00127,           0.00343,           0.00100,          -0.00064,
           0.00014,           0.00004,
           0.00150,           0.00069,
          -0.01484,           0.00135,           0.03930,           0.01405,
           0.00064,           0.00029,
           0.00009,           0.00009,
           0.00054,          -0.00048,           0.00019,           0.00005,
          -0.00009,           0.00018,
           0.00192,          -0.00333,
           0.01824,           0.01071,
           0.00107,          -0.00341,
           0.25530,          -0.18414,          -0.84151,          -0.31475,
          -0.00400,          -0.00010,
          -0.00174,           0.00019,
           0.00006,          -0.00079,
           0.00066,          -0.00070,
           0.00599,           0.00330,
          -0.00160,          -0.00013,
          -0.00067,          -0.00006,
          -0.00176,          -0.00111,
           0.00652,           0.00368,
           0.00004,           0.00001,
          -0.00081,           0.00089,           0.00366,           0.00139,
           0.00002,           0.00001,
          -0.01870,          -0.00998,
          -0.00020,          -0.00007,
           0.00005,           0.00003,
  };
  static final double uratabr[] = {
           0.00000,         -53.23277,         -44.70609,         -62.54432,
         -19.15218,           0.10867,
          -1.91911,           1.47517,
          16.51994,           5.00458,           3.88980,           1.55740,
        3598.17109,        1831.07574,        2633.34851,        1775.69482,
         497.10486,         488.77343,           6.03892,          31.08365,
          -2.06585,          -1.12599,
         230.37762,        -113.95449,         162.40244,         -46.57185,
           6.70207,          17.27241,          -0.66092,         -14.42065,
          -0.01044,          -0.00287,
          -0.03894,          -0.01663,
           0.01629,           0.00496,
           0.08411,           0.02855,
           0.01795,          -0.00695,
           0.02426,          -0.03921,
          -0.24495,          -0.77369,          -0.31404,           0.38668,
          -0.05682,          -0.17197,
           0.06145,          -0.00510,
           0.00606,          -0.00886,
          -0.00370,          -0.00588,
           0.02173,          -0.11909,           0.00302,          -0.01796,
          -0.01067,           0.00990,
           0.05283,           0.06517,
       59710.89716,        -491.12783,       58672.38609,       19564.41947,
       10597.99050,       14313.02561,       -2585.52040,         766.78396,
        -138.39893,        -802.43403,         131.35006,         -31.97561,
           7.95978,           8.16075,
          28.72669,          31.72473,           6.45792,          16.50701,
           0.01066,           1.29718,
           0.11565,          -0.13240,
           0.05110,          -0.01543,
          -0.09994,           0.18864,          -0.01330,           0.04148,
           0.03510,          -0.00366,
           0.00604,          -0.00604,
           0.03752,          -0.00256,
          -7.00488,         -21.63748,           1.43064,         -17.10914,
          -0.62987,           0.48719,           0.00697,          -1.22665,
          -0.14435,          -0.00550,
           0.32008,          -0.19855,
      -13976.73731,       -3559.49432,       -7709.90803,       -9310.80334,
         749.31835,       -3491.50696,         540.94979,         -84.57550,
          16.96663,          35.53930,
       37214.64771,      -36361.15845,       21093.74492,      -31855.33076,
        1500.84653,       -7031.97901,        -453.40865,         -18.36692,
          -2.07726,         -17.92336,
      -56348.30507,      378512.71483,     -111444.43340,      370543.95160,
      -61893.70301,      112131.05507,      -11977.44617,        9156.15245,
        -567.61838,        -495.25760,          16.96202,         -44.06279,
           4.24760,         -48.83674,
     -643705.49516,     -131013.09649,     -838580.02217,       67627.11556,
     -288441.70339,      150227.25291,       -2500.57537,       42676.19888,
        7084.60505,        2043.65642,        9639.56835,       -1502.03390,
       -4126.00409,        -828.73564,       -2801.35204,       -2293.77751,
        -209.23365,       -1045.31476,          95.57334,        -102.74623,
           7.19216,           1.89593,
          -0.05661,           0.02166,
         120.38332,        -141.16507,          98.31386,         -40.23448,
          10.84269,          17.57713,           1.69239,           1.45065,
          -0.19626,           2.76108,
          -0.00270,           0.00360,
          -0.02333,          -0.00710,
          -0.01035,           0.02950,
           0.00737,          -0.06311,
          -0.00613,           0.01407,
           0.01377,           0.00879,
          -0.03287,           0.00012,
          -0.21667,           0.01793,
          -1.54865,           0.10953,
           0.54543,           0.12102,          -9.48047,           0.11477,
          -1.34966,           0.23199,
          -1.50834,           0.26567,          -0.64503,           0.10742,
          -0.21452,           0.04428,
          -0.01920,          -0.00906,
          -0.09378,           0.12773,          -0.02787,          -0.03090,
           0.03111,           0.00140,
           0.03771,          -0.01269,
          -1.94794,           1.22823,           0.64183,          -1.11467,
          -0.19301,          -0.27357,           0.05710,          -0.08115,
          -0.07318,           0.00806,
           0.14286,           0.20297,
           0.14920,          -0.07897,
           0.09682,           0.02379,
          -0.13928,           0.01679,
          -0.00774,           0.10060,
           0.24433,           0.16760,
          -2.88905,          -1.61439,           2.83052,          -3.41031,
          36.37048,           3.37867,
           0.29321,           0.09687,
           0.29324,          -0.14651,
           8.11116,           1.79211,           1.36421,           0.88111,
           1.21683,           2.37950,
        -357.76211,         -87.84636,        -117.55745,         -67.18338,
          -5.26029,          -6.27559,
        7509.94562,           3.68942,        4223.62097,       -1041.13557,
         -74.64464,        -251.41613,        -166.22180,          -1.68190,
        -214.55340,          62.79593,
          -0.08250,          -0.15936,
          -0.03830,           0.10857,
           0.21368,           0.50812,           0.00869,           0.09832,
           0.02158,           0.02045,
           0.01407,           0.03591,
           0.03460,           0.01171,
          -0.16400,           0.09751,           0.03521,          -0.12858,
           0.00700,          -0.00524,
           0.01698,          -0.04796,           0.04006,           0.00565,
          -0.02783,          -0.00205,
          -0.02296,           0.00153,
          -0.16139,           0.01514,
          -0.78136,          -0.01546,
           0.40374,          -0.06014,
           0.06212,          -0.01828,
           0.00831,          -0.00173,
           0.06857,          -0.11677,           0.00028,           0.05765,
          -0.00796,           0.00691,
           0.03764,           0.14902,          -0.02653,           0.02122,
          -0.05503,           0.01549,
           1.56630,          -0.35551,          -1.87960,           1.14303,
          -0.06063,          -0.03425,
           0.03367,          -0.11969,           0.04485,          -0.01651,
           0.04647,          -0.02097,
           0.22841,           0.47362,           0.99226,          -0.60660,
          -0.01249,           0.00134,
          -0.07435,           0.00722,
          -0.31796,          -0.00015,
           0.20533,          -0.04398,
           0.93944,          -0.26710,
          -5.60051,          -9.32918,          -5.13538,          -4.05130,
          -0.56529,           4.34112,           7.18308,          -2.66103,
           0.13241,          -0.07999,
           0.01046,          -0.00535,
          -0.04037,          -0.00455,
          -0.00510,           0.00731,
          -0.04576,           0.00513,
          -0.15846,          -0.00236,
           0.04628,          -0.00463,
          -0.01585,           0.00585,
          -0.00213,           0.00283,
           0.00778,          -0.00198,
          -0.17803,           0.18321,           0.07702,          -0.12325,
           0.01091,           0.00349,
           0.14211,          -0.21830,           0.07289,          -0.00994,
           0.07090,          -0.00079,
           4.18441,          -0.07413,
          -0.06247,          -0.00011,
          -0.15453,           0.14499,          -0.06557,          -0.00098,
           0.00290,           0.02921,
          -0.01923,           0.00457,
          -0.07538,          -0.00120,
           0.02263,          -0.00037,
          -0.01061,           0.00591,
          -0.04725,           0.02364,
          -0.07460,          -0.24108,          -0.28310,           0.14643,
          -0.00700,           0.00427,
           0.22963,           0.03713,
          -0.02062,           0.00478,
           0.01434,           0.00095,
          -0.01425,           0.00376,
           0.29611,          -0.08038,          -0.37811,           0.21703,
          -0.00723,          -0.00924,
          -0.02736,           0.01814,
           0.00934,           0.00731,
           0.00613,           0.00686,
          -0.91503,          -0.32009,          -0.15505,           0.79589,
          -0.00555,          -0.01536,
          -0.00698,           0.00480,
           0.00373,          -0.00046,
           0.00715,          -0.00470,
          -0.01970,          -0.05238,
           0.60649,          -0.32669,           0.17790,           0.33383,
          -2.74922,          -0.25827,
          -0.07862,           0.00406,
          -0.00948,          -0.02117,
           0.03127,          -0.04199,
           0.89670,          -0.02413,
           0.01954,           0.03990,
           0.00063,          -0.00071,
          -0.00226,           0.02009,
          -0.04407,          -0.05069,
           0.38230,           0.16101,           0.11893,          -0.06125,
           0.02051,          -0.00046,
           0.39211,           0.03679,
           0.01666,          -0.31336,          53.28735,          -0.01791,
          -0.39414,           0.04181,
          -0.01885,           0.00165,
           0.31349,          -0.47359,           0.16133,          -0.01023,
           0.00007,           0.01758,
          -0.13351,           0.07249,
           0.00977,           0.05445,
           0.11650,          -0.00191,
          -0.09824,           0.40106,           2.41155,          -0.30655,
           0.24975,          -0.01248,
          -0.03688,           0.01097,
           0.00038,          -0.00051,
          -0.04736,           0.02610,
           0.00968,           0.02634,
           0.07918,          -0.00606,
           0.02735,          -0.00320,
          -0.07544,          -0.00468,
           0.19996,          -0.01964,
           0.00201,           0.00267,
           0.39562,           0.43289,           1.24743,           0.31084,
          -0.00666,           0.00377,
           0.05668,           0.00148,
           0.03220,          -0.00026,
           0.03717,           0.01509,
  };
  static byte uraargs[] = {
  (byte)0,  (byte)3,
  (byte)2,  (byte)1,  (byte)7, (byte)-2,  (byte)8,  (byte)0,
  (byte)2,  (byte)2,  (byte)7, (byte)-4,  (byte)8,  (byte)0,
  (byte)2,  (byte)3,  (byte)7, (byte)-6,  (byte)8,  (byte)1,
  (byte)2,  (byte)2,  (byte)5, (byte)-5,  (byte)6,  (byte)4,
  (byte)2,  (byte)1,  (byte)6, (byte)-3,  (byte)7,  (byte)3,
  (byte)3,  (byte)1,  (byte)6, (byte)-1,  (byte)7, (byte)-4,  (byte)8,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-7,  (byte)6,  (byte)6,  (byte)7,  (byte)0,
  (byte)3,  (byte)2,  (byte)6, (byte)-6,  (byte)7,  (byte)1,  (byte)8,  (byte)0,
  (byte)3,  (byte)2,  (byte)6, (byte)-7,  (byte)7,  (byte)3,  (byte)8,  (byte)0,
  (byte)3,  (byte)2,  (byte)6, (byte)-8,  (byte)7,  (byte)4,  (byte)8,  (byte)0,
  (byte)3,  (byte)2,  (byte)6, (byte)-7,  (byte)7,  (byte)2,  (byte)8,  (byte)0,
  (byte)2,  (byte)2,  (byte)6, (byte)-6,  (byte)7,  (byte)2,
  (byte)3,  (byte)1,  (byte)5, (byte)-4,  (byte)6,  (byte)4,  (byte)7,  (byte)0,
  (byte)3,  (byte)1,  (byte)6, (byte)-2,  (byte)7, (byte)-1,  (byte)8,  (byte)0,
  (byte)3,  (byte)1,  (byte)6, (byte)-3,  (byte)7,  (byte)1,  (byte)8,  (byte)0,
  (byte)3,  (byte)1,  (byte)6, (byte)-4,  (byte)7,  (byte)3,  (byte)8,  (byte)1,
  (byte)2,  (byte)5,  (byte)7, (byte)-9,  (byte)8,  (byte)0,
  (byte)2,  (byte)4,  (byte)7, (byte)-7,  (byte)8,  (byte)0,
  (byte)2,  (byte)2,  (byte)7, (byte)-3,  (byte)8,  (byte)6,
  (byte)2,  (byte)1,  (byte)7, (byte)-3,  (byte)8,  (byte)2,
  (byte)2,  (byte)2,  (byte)7, (byte)-5,  (byte)8,  (byte)0,
  (byte)2,  (byte)3,  (byte)7, (byte)-7,  (byte)8,  (byte)0,
  (byte)3,  (byte)1,  (byte)6, (byte)-6,  (byte)7,  (byte)5,  (byte)8,  (byte)1,
  (byte)3,  (byte)1,  (byte)6, (byte)-5,  (byte)7,  (byte)3,  (byte)8,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-8,  (byte)6,  (byte)8,  (byte)7,  (byte)0,
  (byte)3,  (byte)1,  (byte)5, (byte)-4,  (byte)6,  (byte)5,  (byte)7,  (byte)0,
  (byte)2,  (byte)2,  (byte)6, (byte)-5,  (byte)7,  (byte)3,
  (byte)3,  (byte)1,  (byte)6,  (byte)1,  (byte)7, (byte)-9,  (byte)8,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-4,  (byte)6, (byte)-2,  (byte)7,  (byte)0,
  (byte)2,  (byte)1,  (byte)6, (byte)-4,  (byte)8,  (byte)4,
  (byte)2,  (byte)1,  (byte)6, (byte)-2,  (byte)7,  (byte)4,
  (byte)2,  (byte)5,  (byte)7, (byte)-8,  (byte)8,  (byte)5,
  (byte)2,  (byte)3,  (byte)7, (byte)-4,  (byte)8,  (byte)0,
  (byte)1,  (byte)1,  (byte)7,  (byte)5,
  (byte)2,  (byte)2,  (byte)7, (byte)-6,  (byte)8,  (byte)4,
  (byte)3,  (byte)1,  (byte)6, (byte)-6,  (byte)7,  (byte)4,  (byte)8,  (byte)0,
  (byte)2,  (byte)1,  (byte)6, (byte)-4,  (byte)7,  (byte)4,
  (byte)3,  (byte)2,  (byte)6, (byte)-5,  (byte)7,  (byte)1,  (byte)8,  (byte)0,
  (byte)3,  (byte)2,  (byte)6, (byte)-6,  (byte)7,  (byte)3,  (byte)8,  (byte)0,
  (byte)2,  (byte)2,  (byte)6, (byte)-7,  (byte)7,  (byte)0,
  (byte)3,  (byte)1,  (byte)5, (byte)-4,  (byte)6,  (byte)3,  (byte)7,  (byte)0,
  (byte)3,  (byte)1,  (byte)6, (byte)-1,  (byte)7, (byte)-1,  (byte)8,  (byte)0,
  (byte)2,  (byte)1,  (byte)5, (byte)-2,  (byte)6,  (byte)0,
  (byte)2,  (byte)6,  (byte)7, (byte)-9,  (byte)8,  (byte)0,
  (byte)2,  (byte)5,  (byte)7, (byte)-7,  (byte)8,  (byte)0,
  (byte)2,  (byte)4,  (byte)7, (byte)-5,  (byte)8,  (byte)0,
  (byte)2,  (byte)3,  (byte)7, (byte)-3,  (byte)8,  (byte)1,
  (byte)2,  (byte)2,  (byte)7, (byte)-1,  (byte)8,  (byte)0,
  (byte)2,  (byte)1,  (byte)7,  (byte)1,  (byte)8,  (byte)2,
  (byte)1,  (byte)3,  (byte)8,  (byte)0,
  (byte)2,  (byte)3,  (byte)6, (byte)-7,  (byte)7,  (byte)1,
  (byte)3,  (byte)2,  (byte)5, (byte)-3,  (byte)6, (byte)-4,  (byte)7,  (byte)0,
  (byte)3,  (byte)2,  (byte)6, (byte)-3,  (byte)7, (byte)-2,  (byte)8,  (byte)0,
  (byte)2,  (byte)2,  (byte)6, (byte)-4,  (byte)7,  (byte)1,
  (byte)3,  (byte)2,  (byte)6, (byte)-5,  (byte)7,  (byte)2,  (byte)8,  (byte)1,
  (byte)3,  (byte)5,  (byte)5, (byte)-9,  (byte)6, (byte)-8,  (byte)7,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-4,  (byte)6, (byte)-1,  (byte)7,  (byte)0,
  (byte)3,  (byte)1,  (byte)6,  (byte)3,  (byte)7, (byte)-8,  (byte)8,  (byte)0,
  (byte)3,  (byte)2,  (byte)6, (byte)-8,  (byte)7,  (byte)1,  (byte)8,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-7,  (byte)6,  (byte)4,  (byte)7,  (byte)0,
  (byte)3,  (byte)4,  (byte)5,(byte)-10,  (byte)6,  (byte)2,  (byte)7,  (byte)0,
  (byte)2,  (byte)1,  (byte)6, (byte)-2,  (byte)8,  (byte)0,
  (byte)2,  (byte)1,  (byte)6, (byte)-1,  (byte)7,  (byte)2,
  (byte)2,  (byte)8,  (byte)7,(byte)-12,  (byte)8,  (byte)0,
  (byte)2,  (byte)7,  (byte)7,(byte)-10,  (byte)8,  (byte)0,
  (byte)2,  (byte)6,  (byte)7, (byte)-8,  (byte)8,  (byte)1,
  (byte)2,  (byte)5,  (byte)7, (byte)-6,  (byte)8,  (byte)0,
  (byte)2,  (byte)4,  (byte)7, (byte)-4,  (byte)8,  (byte)2,
  (byte)1,  (byte)2,  (byte)7,  (byte)4,
  (byte)1,  (byte)4,  (byte)8,  (byte)0,
  (byte)2,  (byte)1,  (byte)7, (byte)-6,  (byte)8,  (byte)0,
  (byte)2,  (byte)2,  (byte)7, (byte)-8,  (byte)8,  (byte)1,
  (byte)2,  (byte)3,  (byte)7,(byte)-10,  (byte)8,  (byte)0,
  (byte)2,  (byte)4,  (byte)7,(byte)-12,  (byte)8,  (byte)0,
  (byte)3,  (byte)1,  (byte)6, (byte)-6,  (byte)7,  (byte)2,  (byte)8,  (byte)0,
  (byte)2,  (byte)1,  (byte)6, (byte)-5,  (byte)7,  (byte)1,
  (byte)3,  (byte)1,  (byte)6, (byte)-4,  (byte)7, (byte)-2,  (byte)8,  (byte)0,
  (byte)3,  (byte)1,  (byte)5, (byte)-4,  (byte)6,  (byte)2,  (byte)7,  (byte)1,
  (byte)3,  (byte)1,  (byte)5, (byte)-2,  (byte)6,  (byte)1,  (byte)7,  (byte)0,
  (byte)2,  (byte)7,  (byte)7, (byte)-9,  (byte)8,  (byte)0,
  (byte)2,  (byte)6,  (byte)7, (byte)-7,  (byte)8,  (byte)0,
  (byte)2,  (byte)5,  (byte)7, (byte)-5,  (byte)8,  (byte)0,
  (byte)2,  (byte)4,  (byte)7, (byte)-3,  (byte)8,  (byte)0,
  (byte)2,  (byte)3,  (byte)7, (byte)-1,  (byte)8,  (byte)0,
  (byte)2,  (byte)2,  (byte)7,  (byte)1,  (byte)8,  (byte)0,
  (byte)2,  (byte)3,  (byte)6, (byte)-6,  (byte)7,  (byte)1,
  (byte)3,  (byte)3,  (byte)6, (byte)-7,  (byte)7,  (byte)2,  (byte)8,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-3,  (byte)6, (byte)-3,  (byte)7,  (byte)1,
  (byte)3,  (byte)2,  (byte)6, (byte)-2,  (byte)7, (byte)-2,  (byte)8,  (byte)0,
  (byte)2,  (byte)2,  (byte)6, (byte)-3,  (byte)7,  (byte)1,
  (byte)3,  (byte)2,  (byte)6, (byte)-4,  (byte)7,  (byte)2,  (byte)8,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-7,  (byte)6,  (byte)3,  (byte)7,  (byte)1,
  (byte)3,  (byte)1,  (byte)6,  (byte)1,  (byte)7, (byte)-2,  (byte)8,  (byte)0,
  (byte)1,  (byte)1,  (byte)6,  (byte)1,
  (byte)2,  (byte)8,  (byte)7,(byte)-10,  (byte)8,  (byte)0,
  (byte)2,  (byte)7,  (byte)7, (byte)-8,  (byte)8,  (byte)0,
  (byte)2,  (byte)6,  (byte)7, (byte)-6,  (byte)8,  (byte)0,
  (byte)2,  (byte)5,  (byte)7, (byte)-4,  (byte)8,  (byte)0,
  (byte)2,  (byte)4,  (byte)7, (byte)-2,  (byte)8,  (byte)0,
  (byte)1,  (byte)3,  (byte)7,  (byte)3,
  (byte)2,  (byte)2,  (byte)7,  (byte)2,  (byte)8,  (byte)0,
  (byte)2,  (byte)1,  (byte)7,  (byte)4,  (byte)8,  (byte)0,
  (byte)2,  (byte)1,  (byte)5, (byte)-4,  (byte)7,  (byte)0,
  (byte)2,  (byte)1,  (byte)6, (byte)-6,  (byte)7,  (byte)0,
  (byte)2,  (byte)8,  (byte)7, (byte)-9,  (byte)8,  (byte)0,
  (byte)2,  (byte)7,  (byte)7, (byte)-7,  (byte)8,  (byte)0,
  (byte)2,  (byte)6,  (byte)7, (byte)-5,  (byte)8,  (byte)0,
  (byte)2,  (byte)5,  (byte)7, (byte)-3,  (byte)8,  (byte)0,
  (byte)2,  (byte)4,  (byte)7, (byte)-1,  (byte)8,  (byte)0,
  (byte)3,  (byte)3,  (byte)6, (byte)-4,  (byte)7, (byte)-2,  (byte)8,  (byte)0,
  (byte)2,  (byte)3,  (byte)6, (byte)-5,  (byte)7,  (byte)1,
  (byte)3,  (byte)3,  (byte)6, (byte)-6,  (byte)7,  (byte)2,  (byte)8,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-3,  (byte)6, (byte)-2,  (byte)7,  (byte)1,
  (byte)3,  (byte)2,  (byte)6, (byte)-1,  (byte)7, (byte)-2,  (byte)8,  (byte)0,
  (byte)2,  (byte)2,  (byte)6, (byte)-2,  (byte)7,  (byte)0,
  (byte)3,  (byte)2,  (byte)6, (byte)-3,  (byte)7,  (byte)2,  (byte)8,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-7,  (byte)6,  (byte)2,  (byte)7,  (byte)1,
  (byte)2,  (byte)1,  (byte)6,  (byte)1,  (byte)7,  (byte)0,
  (byte)2,  (byte)9,  (byte)7,(byte)-10,  (byte)8,  (byte)0,
  (byte)2,  (byte)8,  (byte)7, (byte)-8,  (byte)8,  (byte)0,
  (byte)2,  (byte)7,  (byte)7, (byte)-6,  (byte)8,  (byte)0,
  (byte)2,  (byte)6,  (byte)7, (byte)-4,  (byte)8,  (byte)0,
  (byte)2,  (byte)5,  (byte)7, (byte)-2,  (byte)8,  (byte)0,
  (byte)1,  (byte)4,  (byte)7,  (byte)1,
  (byte)2,  (byte)3,  (byte)7,  (byte)2,  (byte)8,  (byte)0,
  (byte)2,  (byte)1,  (byte)5, (byte)-3,  (byte)7,  (byte)0,
  (byte)2,  (byte)9,  (byte)7, (byte)-9,  (byte)8,  (byte)0,
  (byte)2,  (byte)8,  (byte)7, (byte)-7,  (byte)8,  (byte)0,
  (byte)3,  (byte)3,  (byte)6, (byte)-3,  (byte)7, (byte)-2,  (byte)8,  (byte)0,
  (byte)2,  (byte)3,  (byte)6, (byte)-4,  (byte)7,  (byte)1,
  (byte)3,  (byte)3,  (byte)6, (byte)-5,  (byte)7,  (byte)2,  (byte)8,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-3,  (byte)6, (byte)-1,  (byte)7,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-8,  (byte)6,  (byte)4,  (byte)7,  (byte)0,
  (byte)2,  (byte)2,  (byte)6, (byte)-2,  (byte)8,  (byte)0,
  (byte)2,  (byte)2,  (byte)6, (byte)-1,  (byte)7,  (byte)1,
  (byte)3,  (byte)2,  (byte)6, (byte)-2,  (byte)7,  (byte)2,  (byte)8,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-7,  (byte)6,  (byte)1,  (byte)7,  (byte)0,
  (byte)2,  (byte)6,  (byte)7, (byte)-2,  (byte)8,  (byte)0,
  (byte)1,  (byte)5,  (byte)7,  (byte)0,
  (byte)3,  (byte)3,  (byte)6, (byte)-4,  (byte)7,  (byte)1,  (byte)8,  (byte)0,
  (byte)2,  (byte)1,  (byte)5, (byte)-2,  (byte)7,  (byte)2,
  (byte)3,  (byte)1,  (byte)5, (byte)-3,  (byte)7,  (byte)2,  (byte)8,  (byte)0,
  (byte)3,  (byte)1,  (byte)5, (byte)-1,  (byte)6,  (byte)1,  (byte)7,  (byte)0,
  (byte)2,  (byte)4,  (byte)6, (byte)-6,  (byte)7,  (byte)0,
  (byte)2,  (byte)3,  (byte)6, (byte)-3,  (byte)7,  (byte)0,
  (byte)1,  (byte)2,  (byte)6,  (byte)0,
  (byte)3,  (byte)2,  (byte)5, (byte)-4,  (byte)6,  (byte)3,  (byte)7,  (byte)0,
  (byte)3,  (byte)1,  (byte)5,  (byte)1,  (byte)6, (byte)-4,  (byte)7,  (byte)0,
  (byte)3,  (byte)3,  (byte)5, (byte)-5,  (byte)6, (byte)-1,  (byte)7,  (byte)0,
  (byte)1,  (byte)6,  (byte)7,  (byte)1,
  (byte)3,  (byte)1,  (byte)5,  (byte)1,  (byte)7, (byte)-4,  (byte)8,  (byte)0,
  (byte)2,  (byte)1,  (byte)5, (byte)-2,  (byte)8,  (byte)0,
  (byte)2,  (byte)1,  (byte)5, (byte)-1,  (byte)7,  (byte)1,
  (byte)3,  (byte)1,  (byte)5, (byte)-2,  (byte)7,  (byte)2,  (byte)8,  (byte)0,
  (byte)3,  (byte)1,  (byte)5, (byte)-3,  (byte)7,  (byte)4,  (byte)8,  (byte)0,
  (byte)3,  (byte)1,  (byte)5, (byte)-5,  (byte)6,  (byte)1,  (byte)7,  (byte)1,
  (byte)3,  (byte)1,  (byte)5, (byte)-1,  (byte)6,  (byte)2,  (byte)7,  (byte)0,
  (byte)2,  (byte)4,  (byte)6, (byte)-5,  (byte)7,  (byte)0,
  (byte)2,  (byte)3,  (byte)6, (byte)-2,  (byte)7,  (byte)0,
  (byte)3,  (byte)1,  (byte)5,  (byte)1,  (byte)7, (byte)-2,  (byte)8,  (byte)0,
  (byte)1,  (byte)1,  (byte)5,  (byte)1,
  (byte)2,  (byte)4,  (byte)6, (byte)-4,  (byte)7,  (byte)0,
  (byte)2,  (byte)3,  (byte)6, (byte)-1,  (byte)7,  (byte)0,
  (byte)3,  (byte)3,  (byte)5, (byte)-5,  (byte)6,  (byte)1,  (byte)7,  (byte)0,
  (byte)2,  (byte)5,  (byte)6, (byte)-6,  (byte)7,  (byte)0,
  (byte)2,  (byte)4,  (byte)6, (byte)-3,  (byte)7,  (byte)0,
  (byte)2,  (byte)5,  (byte)6, (byte)-5,  (byte)7,  (byte)0,
  (byte)2,  (byte)6,  (byte)6, (byte)-6,  (byte)7,  (byte)0,
  (byte)2,  (byte)2,  (byte)5, (byte)-3,  (byte)7,  (byte)0,
  (byte)2,  (byte)2,  (byte)5, (byte)-2,  (byte)7,  (byte)0,
  (byte)2,  (byte)2,  (byte)5, (byte)-2,  (byte)8,  (byte)0,
  (byte)2,  (byte)2,  (byte)5, (byte)-1,  (byte)7,  (byte)1,
  (byte)3,  (byte)2,  (byte)5, (byte)-2,  (byte)7,  (byte)2,  (byte)8,  (byte)0,
  (byte)1,  (byte)2,  (byte)5,  (byte)0,
  (byte)2,  (byte)3,  (byte)5, (byte)-3,  (byte)7,  (byte)0,
  (byte)2,  (byte)3,  (byte)5, (byte)-1,  (byte)7,  (byte)0,
 (byte)-1
  };
  
  static Plantbl ura404 = new Plantbl(
                               new short[]{0,  0,  0,  0,  5, 10,  9, 12,  0},
                               (short)6,
                               uraargs,
                               uratabl,
                               uratabb,
                               uratabr,
                               1.9218446061800002e+01
  );
}
class SwemptabVen {
  
  static final double ventabl[] = {
           9.08078,          55.42416, 21066413644.98911,      655127.20186,
           0.00329,           0.10408,
           0.00268,          -0.01908,
           0.00653,           0.00183,
           0.15083,          -0.21997,
           6.08596,           2.34841,           3.70668,          -0.22740,
          -2.29376,          -1.46741,
          -0.03840,           0.01242,
           0.00176,           0.00913,
           0.00121,          -0.01222,
          -1.22624,           0.65264,          -1.15974,          -1.28172,
           1.00656,          -0.66266,
           0.01560,          -0.00654,           0.00896,           0.00069,
           0.21649,          -0.01786,
           0.01239,           0.00255,
           0.00084,          -0.06086,
          -0.00041,           0.00887,
           0.13453,          -0.20013,           0.08234,           0.01575,
           0.00658,          -0.00214,
           0.00254,           0.00857,
          -0.01047,          -0.00519,
           0.63215,          -0.40914,           0.34271,          -1.53258,
           0.00038,          -0.01437,
          -0.02599,          -2.27805,          -0.36873,          -1.01799,
          -0.36798,           1.41356,
          -0.08167,           0.01368,           0.20676,           0.06807,
           0.02282,          -0.04691,
           0.30308,          -0.20218,           0.24785,           0.27522,
           0.00197,          -0.00499,
           1.43909,          -0.46154,           0.93459,           2.99583,
          -3.43274,           0.05672,
          -0.06586,           0.12467,           0.02505,          -0.08433,
           0.00743,           0.00174,
          -0.04013,           0.17715,
          -0.00603,          -0.01024,
           0.01542,          -0.02378,
           0.00676,           0.00002,
          -0.00168,          -4.89487,
           0.02393,          -0.03064,
           0.00090,           0.00977,
           0.01223,           0.00381,
           0.28135,          -0.09158,           0.18550,           0.58372,
          -0.67437,           0.01409,
          -0.25404,          -0.06863,
           0.06763,          -0.02939,
          -0.00009,          -0.04888,
           0.01718,          -0.00978,
          -0.01945,           0.08847,
          -0.00135,         -11.29920,
           0.01689,          -0.04756,
           0.02075,          -0.01667,
           0.01397,           0.00443,
          -0.28437,           0.07600,           0.17996,          -0.44326,
           0.29356,           1.41869,          -1.58617,           0.03206,
           0.00229,          -0.00753,
          -0.03076,          -2.96766,
           0.00245,           0.00697,
           0.01063,          -0.02468,
          -0.00351,          -0.18179,
          -0.01088,           0.00380,
           0.00496,           0.02072,
          -0.12890,           0.16719,          -0.06820,          -0.03234,
         -60.36135,         -11.74485,         -11.03752,          -3.80145,
         -21.33955,        -284.54495,        -763.43839,         248.50823,
        1493.02775,        1288.79621,       -2091.10921,       -1851.15420,
          -0.00922,           0.06233,
           0.00004,           0.00785,
           0.10363,          -0.16770,           0.45497,           0.24051,
          -0.28057,           0.61126,
          -0.02057,           0.00010,
           0.00561,           0.01994,
           0.01416,          -0.00442,
           0.03073,          -0.14961,
          -0.06272,           0.08301,
           0.02040,           7.12824,
          -0.00453,          -0.01815,
           0.00004,          -0.00013,
          -0.03593,          -0.18147,           0.20353,          -0.00683,
           0.00003,           0.06226,
          -0.00443,           0.00257,
           0.03194,           0.03254,
           0.00282,          -0.01401,
           0.00422,           1.03169,
          -0.00169,          -0.00591,
          -0.00307,           0.00540,
           0.05511,           0.00347,
           0.07896,           0.06583,
           0.00783,           0.01926,
           0.03109,           0.15967,
           0.00343,           0.88734,
           0.01047,           0.32054,
           0.00814,           0.00051,
           0.02474,           0.00047,
           0.00052,           0.03763,
         -57.06618,          20.34614,         -45.06541,        -115.20465,
         136.46887,         -84.67046,          92.93308,         160.44644,
          -0.00020,          -0.00082,
           0.02496,           0.00279,
           0.00849,           0.00195,
          -0.05013,          -0.04331,
          -0.00136,           0.14491,
          -0.00183,          -0.00406,
           0.01163,           0.00093,
          -0.00604,          -0.00680,
          -0.00036,           0.06861,
          -0.00450,          -0.00969,
           0.00171,           0.00979,
          -0.00152,           0.03929,
           0.00631,           0.00048,
          -0.00709,          -0.00864,
           1.51002,          -0.24657,           1.27338,           2.64699,
          -2.40990,          -0.57413,
          -0.00023,           0.03528,
           0.00268,           0.00522,
          -0.00010,           0.01933,
          -0.00006,           0.01100,
           0.06313,          -0.09939,           0.08571,           0.03206,
          -0.00004,           0.00645,
  };
  static final double ventabb[] = {
         -23.91858,          31.44154,          25.93273,         -67.68643,
          -0.00171,           0.00123,
           0.00001,          -0.00018,
          -0.00005,           0.00018,
          -0.00001,           0.00019,
           0.00733,           0.00030,          -0.00038,           0.00011,
           0.00181,           0.00120,
           0.00010,           0.00002,
          -0.00012,           0.00002,
           0.00021,           0.00004,
          -0.00403,           0.00101,           0.00342,          -0.00328,
           0.01564,           0.01212,
           0.00011,           0.00010,          -0.00002,          -0.00004,
          -0.00524,           0.00079,
           0.00011,           0.00002,
          -0.00001,           0.00003,
           0.00001,           0.00000,
           0.00108,           0.00035,           0.00003,           0.00064,
          -0.00000,          -0.00002,
          -0.00069,           0.00031,
           0.00020,           0.00003,
           0.00768,           0.03697,          -0.07906,           0.01673,
          -0.00003,          -0.00001,
          -0.00198,          -0.01045,           0.01761,          -0.00803,
          -0.00751,           0.04199,
           0.00280,          -0.00213,          -0.00482,          -0.00209,
          -0.01077,           0.00715,
           0.00048,          -0.00004,           0.00199,           0.00237,
           0.00017,          -0.00032,
          -0.07513,          -0.00658,          -0.04213,           0.16065,
           0.27661,           0.06515,
           0.02156,          -0.08144,          -0.23994,          -0.05674,
           0.00167,           0.00069,
           0.00244,          -0.01247,
          -0.00100,           0.00036,
           0.00240,           0.00012,
           0.00010,           0.00018,
           0.00208,          -0.00098,
          -0.00217,           0.00707,
          -0.00338,           0.01260,
          -0.00127,          -0.00039,
          -0.03516,          -0.00544,          -0.01746,           0.08258,
           0.10633,           0.02523,
           0.00077,          -0.00214,
          -0.02335,           0.00976,
          -0.00019,           0.00003,
           0.00041,           0.00039,
           0.00199,          -0.01098,
           0.00813,          -0.00853,
           0.02230,           0.00349,
          -0.02250,           0.08119,
          -0.00214,          -0.00052,
          -0.00220,           0.15216,           0.17152,           0.08051,
          -0.01561,           0.27727,           0.25837,           0.07021,
          -0.00005,          -0.00000,
          -0.02692,          -0.00047,
          -0.00007,          -0.00016,
           0.01072,           0.01418,
          -0.00076,           0.00379,
          -0.00807,           0.03463,
          -0.05199,           0.06680,
          -0.00622,           0.00787,           0.00672,           0.00453,
         -10.69951,         -67.43445,        -183.55956,         -37.87932,
        -102.30497,        -780.40465,        2572.21990,        -446.97798,
        1665.42632,        5698.61327,      -11889.66501,        2814.93799,
           0.03204,          -0.09479,
           0.00014,          -0.00001,
          -0.04118,          -0.04562,           0.03435,          -0.05878,
           0.01700,           0.02566,
          -0.00121,           0.00170,
           0.02390,           0.00403,
           0.04629,           0.01896,
          -0.00521,           0.03215,
          -0.01051,           0.00696,
          -0.01332,          -0.08937,
          -0.00469,          -0.00751,
           0.00016,          -0.00035,
           0.00492,          -0.03930,          -0.04742,          -0.01013,
           0.00065,           0.00021,
          -0.00006,           0.00017,
           0.06768,          -0.01558,
          -0.00055,           0.00322,
          -0.00287,          -0.01656,
           0.00061,          -0.00041,
           0.00030,           0.00047,
          -0.01436,          -0.00148,
           0.30302,          -0.05511,
          -0.00020,          -0.00005,
           0.00042,          -0.00025,
           0.01270,           0.00458,
          -0.00593,          -0.04480,
           0.00005,          -0.00008,
           0.08457,          -0.01569,
           0.00062,           0.00018,
           9.79942,          -2.48836,           4.17423,           6.72044,
         -63.33456,          34.63597,          39.11878,         -72.89581,
          -0.00066,           0.00036,
          -0.00045,          -0.00062,
          -0.00287,          -0.00118,
          -0.21879,           0.03947,
           0.00086,           0.00671,
          -0.00113,           0.00122,
          -0.00193,          -0.00029,
          -0.03612,           0.00635,
           0.00024,           0.00207,
          -0.00273,           0.00443,
          -0.00055,           0.00030,
          -0.00451,           0.00175,
          -0.00110,          -0.00015,
          -0.02608,           0.00480,
           2.16555,          -0.70419,           1.74648,           0.97514,
          -1.15360,           1.73688,
           0.00004,           0.00105,
           0.00187,          -0.00311,
           0.00005,           0.00055,
           0.00004,           0.00032,
          -0.04629,           0.02292,          -0.00363,          -0.03807,
           0.00002,           0.00020,
  };
  static final double ventabr[] = {
          -0.24459,           3.72698,          -6.67281,           5.24378,
           0.00030,           0.00003,
          -0.00002,          -0.00000,
          -0.00000,           0.00001,
           0.00032,           0.00021,
          -0.00326,           0.01002,           0.00067,           0.00653,
           0.00243,          -0.00417,
          -0.00004,          -0.00010,
          -0.00002,          -0.00001,
           0.00004,          -0.00002,
          -0.00638,          -0.01453,           0.01458,          -0.01235,
           0.00755,           0.01030,
           0.00006,           0.00014,           0.00000,           0.00009,
           0.00063,           0.00176,
           0.00003,          -0.00022,
           0.00112,           0.00001,
          -0.00014,          -0.00001,
           0.00485,           0.00322,          -0.00035,           0.00198,
           0.00004,           0.00013,
          -0.00015,          -0.00003,
           0.00011,          -0.00025,
           0.00634,           0.02207,           0.04620,           0.00160,
           0.00045,           0.00001,
          -0.11563,           0.00643,          -0.05947,           0.02018,
           0.07704,           0.01574,
          -0.00090,          -0.00471,          -0.00322,           0.01104,
           0.00265,          -0.00038,
           0.01395,           0.02165,          -0.01948,           0.01713,
          -0.00057,          -0.00019,
           0.04889,           0.13403,          -0.28327,           0.10597,
          -0.02325,          -0.35829,
           0.01171,          -0.00904,           0.00747,           0.02546,
           0.00029,          -0.00190,
          -0.03408,          -0.00703,
           0.00176,          -0.00109,
           0.00463,           0.00293,
           0.00000,           0.00148,
           1.06691,          -0.00054,
          -0.00935,          -0.00790,
           0.00552,          -0.00084,
          -0.00100,           0.00336,
           0.02874,           0.08604,          -0.17876,           0.05973,
          -0.00720,          -0.21195,
           0.02134,          -0.07980,
           0.01500,           0.01398,
           0.01758,          -0.00004,
           0.00371,           0.00650,
          -0.03375,          -0.00723,
           4.65465,          -0.00040,
           0.02040,           0.00707,
          -0.00727,          -0.01144,
          -0.00196,           0.00620,
          -0.03396,          -0.12904,           0.20160,           0.08092,
          -0.67045,           0.14014,          -0.01571,          -0.75141,
           0.00361,           0.00110,
           1.42165,          -0.01499,
          -0.00334,           0.00117,
           0.01187,           0.00507,
           0.08935,          -0.00174,
          -0.00211,          -0.00525,
           0.01035,          -0.00252,
          -0.08355,          -0.06442,           0.01616,          -0.03409,
           5.55241,         -30.62428,           2.03824,          -6.26978,
         143.07279,         -10.24734,        -125.25411,        -380.85360,
        -644.78411,         745.02852,         926.70000,       -1045.09820,
          -0.03124,          -0.00465,
          -0.00396,           0.00002,
           0.08518,           0.05248,          -0.12178,           0.23023,
          -0.30943,          -0.14208,
          -0.00005,          -0.01054,
          -0.00894,           0.00233,
          -0.00173,          -0.00768,
           0.07881,           0.01633,
          -0.04463,          -0.03347,
          -3.92991,           0.00945,
           0.01524,          -0.00422,
          -0.00011,          -0.00005,
           0.10842,          -0.02126,           0.00349,           0.12097,
          -0.03752,           0.00001,
          -0.00156,          -0.00270,
          -0.01520,           0.01349,
           0.00895,           0.00186,
          -0.67751,           0.00180,
           0.00516,          -0.00151,
          -0.00365,          -0.00210,
          -0.00276,           0.03793,
          -0.02637,           0.03235,
          -0.01343,           0.00541,
          -0.11270,           0.02169,
          -0.63365,           0.00122,
          -0.24329,           0.00428,
          -0.00040,           0.00586,
           0.00581,           0.01112,
          -0.02731,           0.00008,
          -2.69091,           0.42729,           2.78805,           3.43849,
          -0.87998,          -6.62373,           0.56882,           4.69370,
           0.00005,          -0.00008,
          -0.00181,           0.01767,
          -0.00168,           0.00660,
           0.01802,          -0.01836,
          -0.11245,          -0.00061,
           0.00199,          -0.00070,
          -0.00076,           0.00919,
           0.00311,          -0.00165,
          -0.05650,          -0.00018,
           0.00121,          -0.00069,
          -0.00803,           0.00146,
          -0.03260,          -0.00072,
          -0.00042,           0.00524,
           0.00464,          -0.00339,
          -0.06203,          -0.00278,           0.04145,           0.02871,
          -0.01962,          -0.01362,
          -0.03040,          -0.00010,
           0.00085,          -0.00001,
          -0.01712,          -0.00006,
          -0.00996,          -0.00003,
          -0.00029,           0.00026,           0.00016,          -0.00005,
          -0.00594,          -0.00003,
  };
  static byte venargs[] = {
  (byte)0,  (byte)3,
  (byte)2,  (byte)2,  (byte)5, (byte)-5,  (byte)6,  (byte)0,
  (byte)3,  (byte)2,  (byte)2,  (byte)1,  (byte)3, (byte)-8,  (byte)4,  (byte)0,
  (byte)3,  (byte)5,  (byte)1,(byte)-14,  (byte)2,  (byte)2,  (byte)3,  (byte)0,
  (byte)3,  (byte)3,  (byte)2, (byte)-7,  (byte)3,  (byte)4,  (byte)4,  (byte)0,
  (byte)2,  (byte)8,  (byte)2,(byte)-13,  (byte)3,  (byte)2,
  (byte)3,  (byte)6,  (byte)2,(byte)-10,  (byte)3,  (byte)3,  (byte)5,  (byte)0,
  (byte)1,  (byte)1,  (byte)7,  (byte)0,
  (byte)2,  (byte)1,  (byte)5, (byte)-2,  (byte)6,  (byte)0,
  (byte)2,  (byte)1,  (byte)2, (byte)-3,  (byte)4,  (byte)2,
  (byte)2,  (byte)2,  (byte)5, (byte)-4,  (byte)6,  (byte)1,
  (byte)1,  (byte)1,  (byte)6,  (byte)0,
  (byte)3,  (byte)3,  (byte)2, (byte)-5,  (byte)3,  (byte)1,  (byte)5,  (byte)0,
  (byte)3,  (byte)3,  (byte)2, (byte)-5,  (byte)3,  (byte)2,  (byte)5,  (byte)0,
  (byte)2,  (byte)1,  (byte)5, (byte)-1,  (byte)6,  (byte)0,
  (byte)2,  (byte)2,  (byte)2, (byte)-6,  (byte)4,  (byte)1,
  (byte)2,  (byte)2,  (byte)5, (byte)-3,  (byte)6,  (byte)0,
  (byte)1,  (byte)2,  (byte)6,  (byte)0,
  (byte)2,  (byte)3,  (byte)5, (byte)-5,  (byte)6,  (byte)0,
  (byte)1,  (byte)1,  (byte)5,  (byte)1,
  (byte)2,  (byte)2,  (byte)5, (byte)-2,  (byte)6,  (byte)0,
  (byte)2,  (byte)3,  (byte)2, (byte)-5,  (byte)3,  (byte)2,
  (byte)2,  (byte)5,  (byte)2, (byte)-8,  (byte)3,  (byte)1,
  (byte)1,  (byte)2,  (byte)5,  (byte)0,
  (byte)2,  (byte)2,  (byte)1, (byte)-5,  (byte)2,  (byte)1,
  (byte)2,  (byte)6,  (byte)2,(byte)-10,  (byte)3,  (byte)0,
  (byte)2,  (byte)2,  (byte)2, (byte)-3,  (byte)3,  (byte)2,
  (byte)2,  (byte)1,  (byte)2, (byte)-2,  (byte)3,  (byte)1,
  (byte)2,  (byte)4,  (byte)2, (byte)-7,  (byte)3,  (byte)0,
  (byte)2,  (byte)4,  (byte)2, (byte)-6,  (byte)3,  (byte)0,
  (byte)1,  (byte)1,  (byte)4,  (byte)0,
  (byte)2,  (byte)1,  (byte)2, (byte)-2,  (byte)4,  (byte)0,
  (byte)2,  (byte)2,  (byte)2, (byte)-5,  (byte)4,  (byte)0,
  (byte)2,  (byte)1,  (byte)2, (byte)-1,  (byte)3,  (byte)0,
  (byte)2,  (byte)1,  (byte)1, (byte)-3,  (byte)2,  (byte)0,
  (byte)2,  (byte)2,  (byte)2, (byte)-4,  (byte)3,  (byte)0,
  (byte)2,  (byte)6,  (byte)2, (byte)-9,  (byte)3,  (byte)0,
  (byte)2,  (byte)3,  (byte)2, (byte)-4,  (byte)3,  (byte)2,
  (byte)2,  (byte)1,  (byte)1, (byte)-2,  (byte)2,  (byte)0,
  (byte)1,  (byte)1,  (byte)3,  (byte)0,
  (byte)2,  (byte)1,  (byte)2, (byte)-1,  (byte)4,  (byte)0,
  (byte)2,  (byte)2,  (byte)2, (byte)-4,  (byte)4,  (byte)0,
  (byte)2,  (byte)5,  (byte)2, (byte)-7,  (byte)3,  (byte)0,
  (byte)2,  (byte)2,  (byte)2, (byte)-2,  (byte)3,  (byte)0,
  (byte)2,  (byte)1,  (byte)2, (byte)-3,  (byte)5,  (byte)0,
  (byte)2,  (byte)1,  (byte)2, (byte)-3,  (byte)3,  (byte)0,
  (byte)2,  (byte)7,  (byte)2,(byte)-10,  (byte)3,  (byte)0,
  (byte)2,  (byte)1,  (byte)2, (byte)-2,  (byte)5,  (byte)1,
  (byte)2,  (byte)4,  (byte)2, (byte)-5,  (byte)3,  (byte)1,
  (byte)3,  (byte)1,  (byte)2,  (byte)1,  (byte)5, (byte)-5,  (byte)6,  (byte)0,
  (byte)2,  (byte)1,  (byte)2, (byte)-1,  (byte)5,  (byte)0,
  (byte)3,  (byte)1,  (byte)2, (byte)-3,  (byte)5,  (byte)5,  (byte)6,  (byte)0,
  (byte)2,  (byte)1,  (byte)2, (byte)-2,  (byte)6,  (byte)0,
  (byte)2,  (byte)1,  (byte)2, (byte)-1,  (byte)6,  (byte)0,
  (byte)1,  (byte)3,  (byte)4,  (byte)0,
  (byte)2,  (byte)7,  (byte)2,(byte)-13,  (byte)3,  (byte)0,
  (byte)3,  (byte)1,  (byte)2,  (byte)2,  (byte)5, (byte)-5,  (byte)6,  (byte)1,
  (byte)1,  (byte)1,  (byte)2,  (byte)5,
  (byte)2,  (byte)9,  (byte)2,(byte)-13,  (byte)3,  (byte)0,
  (byte)3,  (byte)1,  (byte)2,  (byte)1,  (byte)5, (byte)-2,  (byte)6,  (byte)0,
  (byte)2,  (byte)2,  (byte)2, (byte)-3,  (byte)4,  (byte)2,
  (byte)2,  (byte)3,  (byte)2, (byte)-6,  (byte)4,  (byte)0,
  (byte)2,  (byte)1,  (byte)2,  (byte)1,  (byte)5,  (byte)0,
  (byte)2,  (byte)2,  (byte)2, (byte)-5,  (byte)3,  (byte)0,
  (byte)2,  (byte)6,  (byte)2, (byte)-8,  (byte)3,  (byte)0,
  (byte)2,  (byte)2,  (byte)1, (byte)-4,  (byte)2,  (byte)0,
  (byte)2,  (byte)3,  (byte)2, (byte)-3,  (byte)3,  (byte)0,
  (byte)1,  (byte)2,  (byte)3,  (byte)0,
  (byte)2,  (byte)3,  (byte)2, (byte)-7,  (byte)3,  (byte)0,
  (byte)2,  (byte)5,  (byte)2, (byte)-6,  (byte)3,  (byte)1,
  (byte)2,  (byte)2,  (byte)2, (byte)-2,  (byte)4,  (byte)0,
  (byte)2,  (byte)3,  (byte)2, (byte)-5,  (byte)4,  (byte)0,
  (byte)2,  (byte)2,  (byte)2, (byte)-1,  (byte)3,  (byte)0,
  (byte)2,  (byte)7,  (byte)2, (byte)-9,  (byte)3,  (byte)0,
  (byte)2,  (byte)4,  (byte)2, (byte)-4,  (byte)3,  (byte)0,
  (byte)2,  (byte)1,  (byte)2,  (byte)1,  (byte)3,  (byte)0,
  (byte)2,  (byte)3,  (byte)2, (byte)-4,  (byte)4,  (byte)0,
  (byte)2,  (byte)6,  (byte)2, (byte)-7,  (byte)3,  (byte)0,
  (byte)2,  (byte)3,  (byte)2, (byte)-2,  (byte)3,  (byte)0,
  (byte)2,  (byte)2,  (byte)2, (byte)-4,  (byte)5,  (byte)0,
  (byte)2,  (byte)2,  (byte)2, (byte)-3,  (byte)5,  (byte)0,
  (byte)2,  (byte)2,  (byte)2, (byte)-2,  (byte)5,  (byte)0,
  (byte)2,  (byte)5,  (byte)2, (byte)-5,  (byte)3,  (byte)0,
  (byte)2,  (byte)2,  (byte)2, (byte)-3,  (byte)6,  (byte)0,
  (byte)2,  (byte)2,  (byte)2, (byte)-1,  (byte)5,  (byte)0,
  (byte)2,  (byte)2,  (byte)2, (byte)-2,  (byte)6,  (byte)0,
  (byte)1,  (byte)2,  (byte)2,  (byte)3,
  (byte)2,  (byte)2,  (byte)2,  (byte)1,  (byte)5,  (byte)0,
  (byte)2,  (byte)7,  (byte)2, (byte)-8,  (byte)3,  (byte)0,
  (byte)2,  (byte)2,  (byte)1, (byte)-3,  (byte)2,  (byte)0,
  (byte)2,  (byte)4,  (byte)2, (byte)-3,  (byte)3,  (byte)0,
  (byte)2,  (byte)6,  (byte)2, (byte)-6,  (byte)3,  (byte)0,
  (byte)2,  (byte)3,  (byte)2, (byte)-1,  (byte)3,  (byte)0,
  (byte)2,  (byte)8,  (byte)2, (byte)-9,  (byte)3,  (byte)0,
  (byte)2,  (byte)5,  (byte)2, (byte)-4,  (byte)3,  (byte)0,
  (byte)2,  (byte)7,  (byte)2, (byte)-7,  (byte)3,  (byte)0,
  (byte)2,  (byte)4,  (byte)2, (byte)-2,  (byte)3,  (byte)0,
  (byte)2,  (byte)3,  (byte)2, (byte)-4,  (byte)5,  (byte)0,
  (byte)2,  (byte)3,  (byte)2, (byte)-3,  (byte)5,  (byte)0,
  (byte)2,  (byte)9,  (byte)2,(byte)-10,  (byte)3,  (byte)0,
  (byte)2,  (byte)3,  (byte)2, (byte)-2,  (byte)5,  (byte)0,
  (byte)1,  (byte)3,  (byte)2,  (byte)2,
  (byte)2,  (byte)8,  (byte)2, (byte)-8,  (byte)3,  (byte)0,
  (byte)2,  (byte)5,  (byte)2, (byte)-3,  (byte)3,  (byte)0,
  (byte)2,  (byte)9,  (byte)2, (byte)-9,  (byte)3,  (byte)0,
  (byte)2, (byte)10,  (byte)2,(byte)-10,  (byte)3,  (byte)0,
  (byte)1,  (byte)4,  (byte)2,  (byte)1,
  (byte)2, (byte)11,  (byte)2,(byte)-11,  (byte)3,  (byte)0,
 (byte)-1
  };
  
  static Plantbl ven404 = new Plantbl(
                               new short[]{5, 14, 13,  8,  4,  5,  1,  0,  0},
                               (short)5,
                               venargs,
                               ventabl,
                               ventabb,
                               ventabr,
                               7.2332982000000001e-01
                              );
}
class Swenut2000a {
  
  static final double O1MAS2DEG = 1 / 3600.0 / 10000000.0;
  
  static final int NLS = 678;
  static final int NLS_2000B = 77;
  
  static final int NPL = 687;
  
  static final int nls[] = {
  0, 0, 0, 0, 1,
  0, 0, 2, -2, 2,
  0, 0, 2, 0, 2,
  0, 0, 0, 0, 2,
  0, 1, 0, 0, 0,
  0, 1, 2, -2, 2,
  1, 0, 0, 0, 0,
  0, 0, 2, 0, 1,
  1, 0, 2, 0, 2,
  0, -1, 2, -2, 2,
  0, 0, 2, -2, 1,
  -1, 0, 2, 0, 2,
  -1, 0, 0, 2, 0,
  1, 0, 0, 0, 1,
  -1, 0, 0, 0, 1,
  -1, 0, 2, 2, 2,
  1, 0, 2, 0, 1,
  -2, 0, 2, 0, 1,
  0, 0, 0, 2, 0,
  0, 0, 2, 2, 2,
  0, -2, 2, -2, 2,
  -2, 0, 0, 2, 0,
  2, 0, 2, 0, 2,
  1, 0, 2, -2, 2,
  -1, 0, 2, 0, 1,
  2, 0, 0, 0, 0,
  0, 0, 2, 0, 0,
  0, 1, 0, 0, 1,
  -1, 0, 0, 2, 1,
  0, 2, 2, -2, 2,
  0, 0, -2, 2, 0,
  1, 0, 0, -2, 1,
  0, -1, 0, 0, 1,
  -1, 0, 2, 2, 1,
  0, 2, 0, 0, 0,
  1, 0, 2, 2, 2,
  -2, 0, 2, 0, 0,
  0, 1, 2, 0, 2,
  0, 0, 2, 2, 1,
  0, -1, 2, 0, 2,
  0, 0, 0, 2, 1,
  1, 0, 2, -2, 1,
  2, 0, 2, -2, 2,
  -2, 0, 0, 2, 1,
  2, 0, 2, 0, 1,
  0, -1, 2, -2, 1,
  0, 0, 0, -2, 1,
  -1, -1, 0, 2, 0,
  2, 0, 0, -2, 1,
  1, 0, 0, 2, 0,
  0, 1, 2, -2, 1,
  1, -1, 0, 0, 0,
  -2, 0, 2, 0, 2,
  3, 0, 2, 0, 2,
  0, -1, 0, 2, 0,
  1, -1, 2, 0, 2,
  0, 0, 0, 1, 0,
  -1, -1, 2, 2, 2,
  -1, 0, 2, 0, 0,
  0, -1, 2, 2, 2,
  -2, 0, 0, 0, 1,
  1, 1, 2, 0, 2,
  2, 0, 0, 0, 1,
  -1, 1, 0, 1, 0,
  1, 1, 0, 0, 0,
  1, 0, 2, 0, 0,
  -1, 0, 2, -2, 1,
  1, 0, 0, 0, 2,
  -1, 0, 0, 1, 0,
  0, 0, 2, 1, 2,
  -1, 0, 2, 4, 2,
  -1, 1, 0, 1, 1,
  0, -2, 2, -2, 1,
  1, 0, 2, 2, 1,
  -2, 0, 2, 2, 2,
  -1, 0, 0, 0, 2,
  1, 1, 2, -2, 2,
  -2, 0, 2, 4, 2,
  -1, 0, 4, 0, 2,
  2, 0, 2, -2, 1,
  2, 0, 2, 2, 2,
  1, 0, 0, 2, 1,
  3, 0, 0, 0, 0,
  3, 0, 2, -2, 2,
  0, 0, 4, -2, 2,
  0, 1, 2, 0, 1,
  0, 0, -2, 2, 1,
  0, 0, 2, -2, 3,
  -1, 0, 0, 4, 0,
  2, 0, -2, 0, 1,
  -2, 0, 0, 4, 0,
  -1, -1, 0, 2, 1,
  -1, 0, 0, 1, 1,
  0, 1, 0, 0, 2,
  0, 0, -2, 0, 1,
  0, -1, 2, 0, 1,
  0, 0, 2, -1, 2,
  0, 0, 2, 4, 2,
  -2, -1, 0, 2, 0,
  1, 1, 0, -2, 1,
  -1, 1, 0, 2, 0,
  -1, 1, 0, 1, 2,
  1, -1, 0, 0, 1,
  1, -1, 2, 2, 2,
  -1, 1, 2, 2, 2,
  3, 0, 2, 0, 1,
  0, 1, -2, 2, 0,
  -1, 0, 0, -2, 1,
  0, 1, 2, 2, 2,
  -1, -1, 2, 2, 1,
  0, -1, 0, 0, 2,
  1, 0, 2, -4, 1,
  -1, 0, -2, 2, 0,
  0, -1, 2, 2, 1,
  2, -1, 2, 0, 2,
  0, 0, 0, 2, 2,
  1, -1, 2, 0, 1,
  -1, 1, 2, 0, 2,
  0, 1, 0, 2, 0,
  0, -1, -2, 2, 0,
  0, 3, 2, -2, 2,
  0, 0, 0, 1, 1,
  -1, 0, 2, 2, 0,
  2, 1, 2, 0, 2,
  1, 1, 0, 0, 1,
  1, 1, 2, 0, 1,
  2, 0, 0, 2, 0,
  1, 0, -2, 2, 0,
  -1, 0, 0, 2, 2,
  0, 1, 0, 1, 0,
  0, 1, 0, -2, 1,
  -1, 0, 2, -2, 2,
  0, 0, 0, -1, 1,
  -1, 1, 0, 0, 1,
  1, 0, 2, -1, 2,
  1, -1, 0, 2, 0,
  0, 0, 0, 4, 0,
  1, 0, 2, 1, 2,
  0, 0, 2, 1, 1,
  1, 0, 0, -2, 2,
  -1, 0, 2, 4, 1,
  1, 0, -2, 0, 1,
  1, 1, 2, -2, 1,
  0, 0, 2, 2, 0,
  -1, 0, 2, -1, 1,
  -2, 0, 2, 2, 1,
  4, 0, 2, 0, 2,
  2, -1, 0, 0, 0,
  2, 1, 2, -2, 2,
  0, 1, 2, 1, 2,
  1, 0, 4, -2, 2,
  -1, -1, 0, 0, 1,
  0, 1, 0, 2, 1,
  -2, 0, 2, 4, 1,
  2, 0, 2, 0, 0,
  1, 0, 0, 1, 0,
  -1, 0, 0, 4, 1,
  -1, 0, 4, 0, 1,
  2, 0, 2, 2, 1,
  0, 0, 2, -3, 2,
  -1, -2, 0, 2, 0,
  2, 1, 0, 0, 0,
  0, 0, 4, 0, 2,
  0, 0, 0, 0, 3,
  0, 3, 0, 0, 0,
  0, 0, 2, -4, 1,
  0, -1, 0, 2, 1,
  0, 0, 0, 4, 1,
  -1, -1, 2, 4, 2,
  1, 0, 2, 4, 2,
  -2, 2, 0, 2, 0,
  -2, -1, 2, 0, 1,
  -2, 0, 0, 2, 2,
  -1, -1, 2, 0, 2,
  0, 0, 4, -2, 1,
  3, 0, 2, -2, 1,
  -2, -1, 0, 2, 1,
  1, 0, 0, -1, 1,
  0, -2, 0, 2, 0,
  -2, 0, 0, 4, 1,
  -3, 0, 0, 0, 1,
  1, 1, 2, 2, 2,
  0, 0, 2, 4, 1,
  3, 0, 2, 2, 2,
  -1, 1, 2, -2, 1,
  2, 0, 0, -4, 1,
  0, 0, 0, -2, 2,
  2, 0, 2, -4, 1,
  -1, 1, 0, 2, 1,
  0, 0, 2, -1, 1,
  0, -2, 2, 2, 2,
  2, 0, 0, 2, 1,
  4, 0, 2, -2, 2,
  2, 0, 0, -2, 2,
  0, 2, 0, 0, 1,
  1, 0, 0, -4, 1,
  0, 2, 2, -2, 1,
  -3, 0, 0, 4, 0,
  -1, 1, 2, 0, 1,
  -1, -1, 0, 4, 0,
  -1, -2, 2, 2, 2,
  -2, -1, 2, 4, 2,
  1, -1, 2, 2, 1,
  -2, 1, 0, 2, 0,
  -2, 1, 2, 0, 1,
  2, 1, 0, -2, 1,
  -3, 0, 2, 0, 1,
  -2, 0, 2, -2, 1,
  -1, 1, 0, 2, 2,
  0, -1, 2, -1, 2,
  -1, 0, 4, -2, 2,
  0, -2, 2, 0, 2,
  -1, 0, 2, 1, 2,
  2, 0, 0, 0, 2,
  0, 0, 2, 0, 3,
  -2, 0, 4, 0, 2,
  -1, 0, -2, 0, 1,
  -1, 1, 2, 2, 1,
  3, 0, 0, 0, 1,
  -1, 0, 2, 3, 2,
  2, -1, 2, 0, 1,
  0, 1, 2, 2, 1,
  0, -1, 2, 4, 2,
  2, -1, 2, 2, 2,
  0, 2, -2, 2, 0,
  -1, -1, 2, -1, 1,
  0, -2, 0, 0, 1,
  1, 0, 2, -4, 2,
  1, -1, 0, -2, 1,
  -1, -1, 2, 0, 1,
  1, -1, 2, -2, 2,
  -2, -1, 0, 4, 0,
  -1, 0, 0, 3, 0,
  -2, -1, 2, 2, 2,
  0, 2, 2, 0, 2,
  1, 1, 0, 2, 0,
  2, 0, 2, -1, 2,
  1, 0, 2, 1, 1,
  4, 0, 0, 0, 0,
  2, 1, 2, 0, 1,
  3, -1, 2, 0, 2,
  -2, 2, 0, 2, 1,
  1, 0, 2, -3, 1,
  1, 1, 2, -4, 1,
  -1, -1, 2, -2, 1,
  0, -1, 0, -1, 1,
  0, -1, 0, -2, 1,
  -2, 0, 0, 0, 2,
  -2, 0, -2, 2, 0,
  -1, 0, -2, 4, 0,
  1, -2, 0, 0, 0,
  0, 1, 0, 1, 1,
  -1, 2, 0, 2, 0,
  1, -1, 2, -2, 1,
  1, 2, 2, -2, 2,
  2, -1, 2, -2, 2,
  1, 0, 2, -1, 1,
  2, 1, 2, -2, 1,
  -2, 0, 0, -2, 1,
  1, -2, 2, 0, 2,
  0, 1, 2, 1, 1,
  1, 0, 4, -2, 1,
  -2, 0, 4, 2, 2,
  1, 1, 2, 1, 2,
  1, 0, 0, 4, 0,
  1, 0, 2, 2, 0,
  2, 0, 2, 1, 2,
  3, 1, 2, 0, 2,
  4, 0, 2, 0, 1,
  -2, -1, 2, 0, 0,
  0, 1, -2, 2, 1,
  1, 0, -2, 1, 0,
  0, -1, -2, 2, 1,
  2, -1, 0, -2, 1,
  -1, 0, 2, -1, 2,
  1, 0, 2, -3, 2,
  0, 1, 2, -2, 3,
  0, 0, 2, -3, 1,
  -1, 0, -2, 2, 1,
  0, 0, 2, -4, 2,
  -2, 1, 0, 0, 1,
  -1, 0, 0, -1, 1,
  2, 0, 2, -4, 2,
  0, 0, 4, -4, 4,
  0, 0, 4, -4, 2,
  -1, -2, 0, 2, 1,
  -2, 0, 0, 3, 0,
  1, 0, -2, 2, 1,
  -3, 0, 2, 2, 2,
  -3, 0, 2, 2, 1,
  -2, 0, 2, 2, 0,
  2, -1, 0, 0, 1,
  -2, 1, 2, 2, 2,
  1, 1, 0, 1, 0,
  0, 1, 4, -2, 2,
  -1, 1, 0, -2, 1,
  0, 0, 0, -4, 1,
  1, -1, 0, 2, 1,
  1, 1, 0, 2, 1,
  -1, 2, 2, 2, 2,
  3, 1, 2, -2, 2,
  0, -1, 0, 4, 0,
  2, -1, 0, 2, 0,
  0, 0, 4, 0, 1,
  2, 0, 4, -2, 2,
  -1, -1, 2, 4, 1,
  1, 0, 0, 4, 1,
  1, -2, 2, 2, 2,
  0, 0, 2, 3, 2,
  -1, 1, 2, 4, 2,
  3, 0, 0, 2, 0,
  -1, 0, 4, 2, 2,
  1, 1, 2, 2, 1,
  -2, 0, 2, 6, 2,
  2, 1, 2, 2, 2,
  -1, 0, 2, 6, 2,
  1, 0, 2, 4, 1,
  2, 0, 2, 4, 2,
  1, 1, -2, 1, 0,
  -3, 1, 2, 1, 2,
  2, 0, -2, 0, 2,
  -1, 0, 0, 1, 2,
  -4, 0, 2, 2, 1,
  -1, -1, 0, 1, 0,
  0, 0, -2, 2, 2,
  1, 0, 0, -1, 2,
  0, -1, 2, -2, 3,
  -2, 1, 2, 0, 0,
  0, 0, 2, -2, 4,
  -2, -2, 0, 2, 0,
  -2, 0, -2, 4, 0,
  0, -2, -2, 2, 0,
  1, 2, 0, -2, 1,
  3, 0, 0, -4, 1,
  -1, 1, 2, -2, 2,
  1, -1, 2, -4, 1,
  1, 1, 0, -2, 2,
  -3, 0, 2, 0, 0,
  -3, 0, 2, 0, 2,
  -2, 0, 0, 1, 0,
  0, 0, -2, 1, 0,
  -3, 0, 0, 2, 1,
  -1, -1, -2, 2, 0,
  0, 1, 2, -4, 1,
  2, 1, 0, -4, 1,
  0, 2, 0, -2, 1,
  1, 0, 0, -3, 1,
  -2, 0, 2, -2, 2,
  -2, -1, 0, 0, 1,
  -4, 0, 0, 2, 0,
  1, 1, 0, -4, 1,
  -1, 0, 2, -4, 1,
  0, 0, 4, -4, 1,
  0, 3, 2, -2, 2,
  -3, -1, 0, 4, 0,
  -3, 0, 0, 4, 1,
  1, -1, -2, 2, 0,
  -1, -1, 0, 2, 2,
  1, -2, 0, 0, 1,
  1, -1, 0, 0, 2,
  0, 0, 0, 1, 2,
  -1, -1, 2, 0, 0,
  1, -2, 2, -2, 2,
  0, -1, 2, -1, 1,
  -1, 0, 2, 0, 3,
  1, 1, 0, 0, 2,
  -1, 1, 2, 0, 0,
  1, 2, 0, 0, 0,
  -1, 2, 2, 0, 2,
  -1, 0, 4, -2, 1,
  3, 0, 2, -4, 2,
  1, 2, 2, -2, 1,
  1, 0, 4, -4, 2,
  -2, -1, 0, 4, 1,
  0, -1, 0, 2, 2,
  -2, 1, 0, 4, 0,
  -2, -1, 2, 2, 1,
  2, 0, -2, 2, 0,
  1, 0, 0, 1, 1,
  0, 1, 0, 2, 2,
  1, -1, 2, -1, 2,
  -2, 0, 4, 0, 1,
  2, 1, 0, 0, 1,
  0, 1, 2, 0, 0,
  0, -1, 4, -2, 2,
  0, 0, 4, -2, 4,
  0, 2, 2, 0, 1,
  -3, 0, 0, 6, 0,
  -1, -1, 0, 4, 1,
  1, -2, 0, 2, 0,
  -1, 0, 0, 4, 2,
  -1, -2, 2, 2, 1,
  -1, 0, 0, -2, 2,
  1, 0, -2, -2, 1,
  0, 0, -2, -2, 1,
  -2, 0, -2, 0, 1,
  0, 0, 0, 3, 1,
  0, 0, 0, 3, 0,
  -1, 1, 0, 4, 0,
  -1, -1, 2, 2, 0,
  -2, 0, 2, 3, 2,
  1, 0, 0, 2, 2,
  0, -1, 2, 1, 2,
  3, -1, 0, 0, 0,
  2, 0, 0, 1, 0,
  1, -1, 2, 0, 0,
  0, 0, 2, 1, 0,
  1, 0, 2, 0, 3,
  3, 1, 0, 0, 0,
  3, -1, 2, -2, 2,
  2, 0, 2, -1, 1,
  1, 1, 2, 0, 0,
  0, 0, 4, -1, 2,
  1, 2, 2, 0, 2,
  -2, 0, 0, 6, 0,
  0, -1, 0, 4, 1,
  -2, -1, 2, 4, 1,
  0, -2, 2, 2, 1,
  0, -1, 2, 2, 0,
  -1, 0, 2, 3, 1,
  -2, 1, 2, 4, 2,
  2, 0, 0, 2, 2,
  2, -2, 2, 0, 2,
  -1, 1, 2, 3, 2,
  3, 0, 2, -1, 2,
  4, 0, 2, -2, 1,
  -1, 0, 0, 6, 0,
  -1, -2, 2, 4, 2,
  -3, 0, 2, 6, 2,
  -1, 0, 2, 4, 0,
  3, 0, 0, 2, 1,
  3, -1, 2, 0, 1,
  3, 0, 2, 0, 0,
  1, 0, 4, 0, 2,
  5, 0, 2, -2, 2,
  0, -1, 2, 4, 1,
  2, -1, 2, 2, 1,
  0, 1, 2, 4, 2,
  1, -1, 2, 4, 2,
  3, -1, 2, 2, 2,
  3, 0, 2, 2, 1,
  5, 0, 2, 0, 2,
  0, 0, 2, 6, 2,
  4, 0, 2, 2, 2,
  0, -1, 1, -1, 1,
  -1, 0, 1, 0, 3,
  0, -2, 2, -2, 3,
  1, 0, -1, 0, 1,
  2, -2, 0, -2, 1,
  -1, 0, 1, 0, 2,
  -1, 0, 1, 0, 1,
  -1, -1, 2, -1, 2,
  -2, 2, 0, 2, 2,
  -1, 0, 1, 0, 0,
  -4, 1, 2, 2, 2,
  -3, 0, 2, 1, 1,
  -2, -1, 2, 0, 2,
  1, 0, -2, 1, 1,
  2, -1, -2, 0, 1,
  -4, 0, 2, 2, 0,
  -3, 1, 0, 3, 0,
  -1, 0, -1, 2, 0,
  0, -2, 0, 0, 2,
  0, -2, 0, 0, 2,
  -3, 0, 0, 3, 0,
  -2, -1, 0, 2, 2,
  -1, 0, -2, 3, 0,
  -4, 0, 0, 4, 0,
  2, 1, -2, 0, 1,
  2, -1, 0, -2, 2,
  0, 0, 1, -1, 0,
  -1, 2, 0, 1, 0,
  -2, 1, 2, 0, 2,
  1, 1, 0, -1, 1,
  1, 0, 1, -2, 1,
  0, 2, 0, 0, 2,
  1, -1, 2, -3, 1,
  -1, 1, 2, -1, 1,
  -2, 0, 4, -2, 2,
  -2, 0, 4, -2, 1,
  -2, -2, 0, 2, 1,
  -2, 0, -2, 4, 0,
  1, 2, 2, -4, 1,
  1, 1, 2, -4, 2,
  -1, 2, 2, -2, 1,
  2, 0, 0, -3, 1,
  -1, 2, 0, 0, 1,
  0, 0, 0, -2, 0,
  -1, -1, 2, -2, 2,
  -1, 1, 0, 0, 2,
  0, 0, 0, -1, 2,
  -2, 1, 0, 1, 0,
  1, -2, 0, -2, 1,
  1, 0, -2, 0, 2,
  -3, 1, 0, 2, 0,
  -1, 1, -2, 2, 0,
  -1, -1, 0, 0, 2,
  -3, 0, 0, 2, 0,
  -3, -1, 0, 2, 0,
  2, 0, 2, -6, 1,
  0, 1, 2, -4, 2,
  2, 0, 0, -4, 2,
  -2, 1, 2, -2, 1,
  0, -1, 2, -4, 1,
  0, 1, 0, -2, 2,
  -1, 0, 0, -2, 0,
  2, 0, -2, -2, 1,
  -4, 0, 2, 0, 1,
  -1, -1, 0, -1, 1,
  0, 0, -2, 0, 2,
  -3, 0, 0, 1, 0,
  -1, 0, -2, 1, 0,
  -2, 0, -2, 2, 1,
  0, 0, -4, 2, 0,
  -2, -1, -2, 2, 0,
  1, 0, 2, -6, 1,
  -1, 0, 2, -4, 2,
  1, 0, 0, -4, 2,
  2, 1, 2, -4, 2,
  2, 1, 2, -4, 1,
  0, 1, 4, -4, 4,
  0, 1, 4, -4, 2,
  -1, -1, -2, 4, 0,
  -1, -3, 0, 2, 0,
  -1, 0, -2, 4, 1,
  -2, -1, 0, 3, 0,
  0, 0, -2, 3, 0,
  -2, 0, 0, 3, 1,
  0, -1, 0, 1, 0,
  -3, 0, 2, 2, 0,
  1, 1, -2, 2, 0,
  -1, 1, 0, 2, 2,
  1, -2, 2, -2, 1,
  0, 0, 1, 0, 2,
  0, 0, 1, 0, 1,
  0, 0, 1, 0, 0,
  -1, 2, 0, 2, 1,
  0, 0, 2, 0, 2,
  -2, 0, 2, 0, 2,
  2, 0, 0, -1, 1,
  3, 0, 0, -2, 1,
  1, 0, 2, -2, 3,
  1, 2, 0, 0, 1,
  2, 0, 2, -3, 2,
  -1, 1, 4, -2, 2,
  -2, -2, 0, 4, 0,
  0, -3, 0, 2, 0,
  0, 0, -2, 4, 0,
  -1, -1, 0, 3, 0,
  -2, 0, 0, 4, 2,
  -1, 0, 0, 3, 1,
  2, -2, 0, 0, 0,
  1, -1, 0, 1, 0,
  -1, 0, 0, 2, 0,
  0, -2, 2, 0, 1,
  -1, 0, 1, 2, 1,
  -1, 1, 0, 3, 0,
  -1, -1, 2, 1, 2,
  0, -1, 2, 0, 0,
  -2, 1, 2, 2, 1,
  2, -2, 2, -2, 2,
  1, 1, 0, 1, 1,
  1, 0, 1, 0, 1,
  1, 0, 1, 0, 0,
  0, 2, 0, 2, 0,
  2, -1, 2, -2, 1,
  0, -1, 4, -2, 1,
  0, 0, 4, -2, 3,
  0, 1, 4, -2, 1,
  4, 0, 2, -4, 2,
  2, 2, 2, -2, 2,
  2, 0, 4, -4, 2,
  -1, -2, 0, 4, 0,
  -1, -3, 2, 2, 2,
  -3, 0, 2, 4, 2,
  -3, 0, 2, -2, 1,
  -1, -1, 0, -2, 1,
  -3, 0, 0, 0, 2,
  -3, 0, -2, 2, 0,
  0, 1, 0, -4, 1,
  -2, 1, 0, -2, 1,
  -4, 0, 0, 0, 1,
  -1, 0, 0, -4, 1,
  -3, 0, 0, -2, 1,
  0, 0, 0, 3, 2,
  -1, 1, 0, 4, 1,
  1, -2, 2, 0, 1,
  0, 1, 0, 3, 0,
  -1, 0, 2, 2, 3,
  0, 0, 2, 2, 2,
  -2, 0, 2, 2, 2,
  -1, 1, 2, 2, 0,
  3, 0, 0, 0, 2,
  2, 1, 0, 1, 0,
  2, -1, 2, -1, 2,
  0, 0, 2, 0, 1,
  0, 0, 3, 0, 3,
  0, 0, 3, 0, 2,
  -1, 2, 2, 2, 1,
  -1, 0, 4, 0, 0,
  1, 2, 2, 0, 1,
  3, 1, 2, -2, 1,
  1, 1, 4, -2, 2,
  -2, -1, 0, 6, 0,
  0, -2, 0, 4, 0,
  -2, 0, 0, 6, 1,
  -2, -2, 2, 4, 2,
  0, -3, 2, 2, 2,
  0, 0, 0, 4, 2,
  -1, -1, 2, 3, 2,
  -2, 0, 2, 4, 0,
  2, -1, 0, 2, 1,
  1, 0, 0, 3, 0,
  0, 1, 0, 4, 1,
  0, 1, 0, 4, 0,
  1, -1, 2, 1, 2,
  0, 0, 2, 2, 3,
  1, 0, 2, 2, 2,
  -1, 0, 2, 2, 2,
  -2, 0, 4, 2, 1,
  2, 1, 0, 2, 1,
  2, 1, 0, 2, 0,
  2, -1, 2, 0, 0,
  1, 0, 2, 1, 0,
  0, 1, 2, 2, 0,
  2, 0, 2, 0, 3,
  3, 0, 2, 0, 2,
  1, 0, 2, 0, 2,
  1, 0, 3, 0, 3,
  1, 1, 2, 1, 1,
  0, 2, 2, 2, 2,
  2, 1, 2, 0, 0,
  2, 0, 4, -2, 1,
  4, 1, 2, -2, 2,
  -1, -1, 0, 6, 0,
  -3, -1, 2, 6, 2,
  -1, 0, 0, 6, 1,
  -3, 0, 2, 6, 1,
  1, -1, 0, 4, 1,
  1, -1, 0, 4, 0,
  -2, 0, 2, 5, 2,
  1, -2, 2, 2, 1,
  3, -1, 0, 2, 0,
  1, -1, 2, 2, 0,
  0, 0, 2, 3, 1,
  -1, 1, 2, 4, 1,
  0, 1, 2, 3, 2,
  -1, 0, 4, 2, 1,
  2, 0, 2, 1, 1,
  5, 0, 0, 0, 0,
  2, 1, 2, 1, 2,
  1, 0, 4, 0, 1,
  3, 1, 2, 0, 1,
  3, 0, 4, -2, 2,
  -2, -1, 2, 6, 2,
  0, 0, 0, 6, 0,
  0, -2, 2, 4, 2,
  -2, 0, 2, 6, 1,
  2, 0, 0, 4, 1,
  2, 0, 0, 4, 0,
  2, -2, 2, 2, 2,
  0, 0, 2, 4, 0,
  1, 0, 2, 3, 2,
  4, 0, 0, 2, 0,
  2, 0, 2, 2, 0,
  0, 0, 4, 2, 2,
  4, -1, 2, 0, 2,
  3, 0, 2, 1, 2,
  2, 1, 2, 2, 1,
  4, 1, 2, 0, 2,
  -1, -1, 2, 6, 2,
  -1, 0, 2, 6, 1,
  1, -1, 2, 4, 1,
  1, 1, 2, 4, 2,
  3, 1, 2, 2, 2,
  5, 0, 2, 0, 1,
  2, -1, 2, 4, 2,
  2, 0, 2, 4, 1,
  };
  
  static final int cls[] = {
  -172064161, -174666, 33386, 92052331, 9086, 15377,
  -13170906, -1675, -13696, 5730336, -3015, -4587,
  -2276413, -234, 2796, 978459, -485, 1374,
  2074554, 207, -698, -897492, 470, -291,
  1475877, -3633, 11817, 73871, -184, -1924,
  -516821, 1226, -524, 224386, -677, -174,
  711159, 73, -872, -6750, 0, 358,
  -387298, -367, 380, 200728, 18, 318,
  -301461, -36, 816, 129025, -63, 367,
  215829, -494, 111, -95929, 299, 132,
  128227, 137, 181, -68982, -9, 39,
  123457, 11, 19, -53311, 32, -4,
  156994, 10, -168, -1235, 0, 82,
  63110, 63, 27, -33228, 0, -9,
  -57976, -63, -189, 31429, 0, -75,
  -59641, -11, 149, 25543, -11, 66,
  -51613, -42, 129, 26366, 0, 78,
  45893, 50, 31, -24236, -10, 20,
  63384, 11, -150, -1220, 0, 29,
  -38571, -1, 158, 16452, -11, 68,
  32481, 0, 0, -13870, 0, 0,
  -47722, 0, -18, 477, 0, -25,
  -31046, -1, 131, 13238, -11, 59,
  28593, 0, -1, -12338, 10, -3,
  20441, 21, 10, -10758, 0, -3,
  29243, 0, -74, -609, 0, 13,
  25887, 0, -66, -550, 0, 11,
  -14053, -25, 79, 8551, -2, -45,
  15164, 10, 11, -8001, 0, -1,
  -15794, 72, -16, 6850, -42, -5,
  21783, 0, 13, -167, 0, 13,
  -12873, -10, -37, 6953, 0, -14,
  -12654, 11, 63, 6415, 0, 26,
  -10204, 0, 25, 5222, 0, 15,
  16707, -85, -10, 168, -1, 10,
  -7691, 0, 44, 3268, 0, 19,
  -11024, 0, -14, 104, 0, 2,
  7566, -21, -11, -3250, 0, -5,
  -6637, -11, 25, 3353, 0, 14,
  -7141, 21, 8, 3070, 0, 4,
  -6302, -11, 2, 3272, 0, 4,
  5800, 10, 2, -3045, 0, -1,
  6443, 0, -7, -2768, 0, -4,
  -5774, -11, -15, 3041, 0, -5,
  -5350, 0, 21, 2695, 0, 12,
  -4752, -11, -3, 2719, 0, -3,
  -4940, -11, -21, 2720, 0, -9,
  7350, 0, -8, -51, 0, 4,
  4065, 0, 6, -2206, 0, 1,
  6579, 0, -24, -199, 0, 2,
  3579, 0, 5, -1900, 0, 1,
  4725, 0, -6, -41, 0, 3,
  -3075, 0, -2, 1313, 0, -1,
  -2904, 0, 15, 1233, 0, 7,
  4348, 0, -10, -81, 0, 2,
  -2878, 0, 8, 1232, 0, 4,
  -4230, 0, 5, -20, 0, -2,
  -2819, 0, 7, 1207, 0, 3,
  -4056, 0, 5, 40, 0, -2,
  -2647, 0, 11, 1129, 0, 5,
  -2294, 0, -10, 1266, 0, -4,
  2481, 0, -7, -1062, 0, -3,
  2179, 0, -2, -1129, 0, -2,
  3276, 0, 1, -9, 0, 0,
  -3389, 0, 5, 35, 0, -2,
  3339, 0, -13, -107, 0, 1,
  -1987, 0, -6, 1073, 0, -2,
  -1981, 0, 0, 854, 0, 0,
  4026, 0, -353, -553, 0, -139,
  1660, 0, -5, -710, 0, -2,
  -1521, 0, 9, 647, 0, 4,
  1314, 0, 0, -700, 0, 0,
  -1283, 0, 0, 672, 0, 0,
  -1331, 0, 8, 663, 0, 4,
  1383, 0, -2, -594, 0, -2,
  1405, 0, 4, -610, 0, 2,
  1290, 0, 0, -556, 0, 0,
  -1214, 0, 5, 518, 0, 2,
  1146, 0, -3, -490, 0, -1,
  1019, 0, -1, -527, 0, -1,
  -1100, 0, 9, 465, 0, 4,
  -970, 0, 2, 496, 0, 1,
  1575, 0, -6, -50, 0, 0,
  934, 0, -3, -399, 0, -1,
  922, 0, -1, -395, 0, -1,
  815, 0, -1, -422, 0, -1,
  834, 0, 2, -440, 0, 1,
  1248, 0, 0, -170, 0, 1,
  1338, 0, -5, -39, 0, 0,
  716, 0, -2, -389, 0, -1,
  1282, 0, -3, -23, 0, 1,
  742, 0, 1, -391, 0, 0,
  1020, 0, -25, -495, 0, -10,
  715, 0, -4, -326, 0, 2,
  -666, 0, -3, 369, 0, -1,
  -667, 0, 1, 346, 0, 1,
  -704, 0, 0, 304, 0, 0,
  -694, 0, 5, 294, 0, 2,
  -1014, 0, -1, 4, 0, -1,
  -585, 0, -2, 316, 0, -1,
  -949, 0, 1, 8, 0, -1,
  -595, 0, 0, 258, 0, 0,
  528, 0, 0, -279, 0, 0,
  -590, 0, 4, 252, 0, 2,
  570, 0, -2, -244, 0, -1,
  -502, 0, 3, 250, 0, 2,
  -875, 0, 1, 29, 0, 0,
  -492, 0, -3, 275, 0, -1,
  535, 0, -2, -228, 0, -1,
  -467, 0, 1, 240, 0, 1,
  591, 0, 0, -253, 0, 0,
  -453, 0, -1, 244, 0, -1,
  766, 0, 1, 9, 0, 0,
  -446, 0, 2, 225, 0, 1,
  -488, 0, 2, 207, 0, 1,
  -468, 0, 0, 201, 0, 0,
  -421, 0, 1, 216, 0, 1,
  463, 0, 0, -200, 0, 0,
  -673, 0, 2, 14, 0, 0,
  658, 0, 0, -2, 0, 0,
  -438, 0, 0, 188, 0, 0,
  -390, 0, 0, 205, 0, 0,
  639, -11, -2, -19, 0, 0,
  412, 0, -2, -176, 0, -1,
  -361, 0, 0, 189, 0, 0,
  360, 0, -1, -185, 0, -1,
  588, 0, -3, -24, 0, 0,
  -578, 0, 1, 5, 0, 0,
  -396, 0, 0, 171, 0, 0,
  565, 0, -1, -6, 0, 0,
  -335, 0, -1, 184, 0, -1,
  357, 0, 1, -154, 0, 0,
  321, 0, 1, -174, 0, 0,
  -301, 0, -1, 162, 0, 0,
  -334, 0, 0, 144, 0, 0,
  493, 0, -2, -15, 0, 0,
  494, 0, -2, -19, 0, 0,
  337, 0, -1, -143, 0, -1,
  280, 0, -1, -144, 0, 0,
  309, 0, 1, -134, 0, 0,
  -263, 0, 2, 131, 0, 1,
  253, 0, 1, -138, 0, 0,
  245, 0, 0, -128, 0, 0,
  416, 0, -2, -17, 0, 0,
  -229, 0, 0, 128, 0, 0,
  231, 0, 0, -120, 0, 0,
  -259, 0, 2, 109, 0, 1,
  375, 0, -1, -8, 0, 0,
  252, 0, 0, -108, 0, 0,
  -245, 0, 1, 104, 0, 0,
  243, 0, -1, -104, 0, 0,
  208, 0, 1, -112, 0, 0,
  199, 0, 0, -102, 0, 0,
  -208, 0, 1, 105, 0, 0,
  335, 0, -2, -14, 0, 0,
  -325, 0, 1, 7, 0, 0,
  -187, 0, 0, 96, 0, 0,
  197, 0, -1, -100, 0, 0,
  -192, 0, 2, 94, 0, 1,
  -188, 0, 0, 83, 0, 0,
  276, 0, 0, -2, 0, 0,
  -286, 0, 1, 6, 0, 0,
  186, 0, -1, -79, 0, 0,
  -219, 0, 0, 43, 0, 0,
  276, 0, 0, 2, 0, 0,
  -153, 0, -1, 84, 0, 0,
  -156, 0, 0, 81, 0, 0,
  -154, 0, 1, 78, 0, 0,
  -174, 0, 1, 75, 0, 0,
  -163, 0, 2, 69, 0, 1,
  -228, 0, 0, 1, 0, 0,
  91, 0, -4, -54, 0, -2,
  175, 0, 0, -75, 0, 0,
  -159, 0, 0, 69, 0, 0,
  141, 0, 0, -72, 0, 0,
  147, 0, 0, -75, 0, 0,
  -132, 0, 0, 69, 0, 0,
  159, 0, -28, -54, 0, 11,
  213, 0, 0, -4, 0, 0,
  123, 0, 0, -64, 0, 0,
  -118, 0, -1, 66, 0, 0,
  144, 0, -1, -61, 0, 0,
  -121, 0, 1, 60, 0, 0,
  -134, 0, 1, 56, 0, 1,
  -105, 0, 0, 57, 0, 0,
  -102, 0, 0, 56, 0, 0,
  120, 0, 0, -52, 0, 0,
  101, 0, 0, -54, 0, 0,
  -113, 0, 0, 59, 0, 0,
  -106, 0, 0, 61, 0, 0,
  -129, 0, 1, 55, 0, 0,
  -114, 0, 0, 57, 0, 0,
  113, 0, -1, -49, 0, 0,
  -102, 0, 0, 44, 0, 0,
  -94, 0, 0, 51, 0, 0,
  -100, 0, -1, 56, 0, 0,
  87, 0, 0, -47, 0, 0,
  161, 0, 0, -1, 0, 0,
  96, 0, 0, -50, 0, 0,
  151, 0, -1, -5, 0, 0,
  -104, 0, 0, 44, 0, 0,
  -110, 0, 0, 48, 0, 0,
  -100, 0, 1, 50, 0, 0,
  92, 0, -5, 12, 0, -2,
  82, 0, 0, -45, 0, 0,
  82, 0, 0, -45, 0, 0,
  -78, 0, 0, 41, 0, 0,
  -77, 0, 0, 43, 0, 0,
  2, 0, 0, 54, 0, 0,
  94, 0, 0, -40, 0, 0,
  -93, 0, 0, 40, 0, 0,
  -83, 0, 10, 40, 0, -2,
  83, 0, 0, -36, 0, 0,
  -91, 0, 0, 39, 0, 0,
  128, 0, 0, -1, 0, 0,
  -79, 0, 0, 34, 0, 0,
  -83, 0, 0, 47, 0, 0,
  84, 0, 0, -44, 0, 0,
  83, 0, 0, -43, 0, 0,
  91, 0, 0, -39, 0, 0,
  -77, 0, 0, 39, 0, 0,
  84, 0, 0, -43, 0, 0,
  -92, 0, 1, 39, 0, 0,
  -92, 0, 1, 39, 0, 0,
  -94, 0, 0, 0, 0, 0,
  68, 0, 0, -36, 0, 0,
  -61, 0, 0, 32, 0, 0,
  71, 0, 0, -31, 0, 0,
  62, 0, 0, -34, 0, 0,
  -63, 0, 0, 33, 0, 0,
  -73, 0, 0, 32, 0, 0,
  115, 0, 0, -2, 0, 0,
  -103, 0, 0, 2, 0, 0,
  63, 0, 0, -28, 0, 0,
  74, 0, 0, -32, 0, 0,
  -103, 0, -3, 3, 0, -1,
  -69, 0, 0, 30, 0, 0,
  57, 0, 0, -29, 0, 0,
  94, 0, 0, -4, 0, 0,
  64, 0, 0, -33, 0, 0,
  -63, 0, 0, 26, 0, 0,
  -38, 0, 0, 20, 0, 0,
  -43, 0, 0, 24, 0, 0,
  -45, 0, 0, 23, 0, 0,
  47, 0, 0, -24, 0, 0,
  -48, 0, 0, 25, 0, 0,
  45, 0, 0, -26, 0, 0,
  56, 0, 0, -25, 0, 0,
  88, 0, 0, 2, 0, 0,
  -75, 0, 0, 0, 0, 0,
  85, 0, 0, 0, 0, 0,
  49, 0, 0, -26, 0, 0,
  -74, 0, -3, -1, 0, -1,
  -39, 0, 0, 21, 0, 0,
  45, 0, 0, -20, 0, 0,
  51, 0, 0, -22, 0, 0,
  -40, 0, 0, 21, 0, 0,
  41, 0, 0, -21, 0, 0,
  -42, 0, 0, 24, 0, 0,
  -51, 0, 0, 22, 0, 0,
  -42, 0, 0, 22, 0, 0,
  39, 0, 0, -21, 0, 0,
  46, 0, 0, -18, 0, 0,
  -53, 0, 0, 22, 0, 0,
  82, 0, 0, -4, 0, 0,
  81, 0, -1, -4, 0, 0,
  47, 0, 0, -19, 0, 0,
  53, 0, 0, -23, 0, 0,
  -45, 0, 0, 22, 0, 0,
  -44, 0, 0, -2, 0, 0,
  -33, 0, 0, 16, 0, 0,
  -61, 0, 0, 1, 0, 0,
  28, 0, 0, -15, 0, 0,
  -38, 0, 0, 19, 0, 0,
  -33, 0, 0, 21, 0, 0,
  -60, 0, 0, 0, 0, 0,
  48, 0, 0, -10, 0, 0,
  27, 0, 0, -14, 0, 0,
  38, 0, 0, -20, 0, 0,
  31, 0, 0, -13, 0, 0,
  -29, 0, 0, 15, 0, 0,
  28, 0, 0, -15, 0, 0,
  -32, 0, 0, 15, 0, 0,
  45, 0, 0, -8, 0, 0,
  -44, 0, 0, 19, 0, 0,
  28, 0, 0, -15, 0, 0,
  -51, 0, 0, 0, 0, 0,
  -36, 0, 0, 20, 0, 0,
  44, 0, 0, -19, 0, 0,
  26, 0, 0, -14, 0, 0,
  -60, 0, 0, 2, 0, 0,
  35, 0, 0, -18, 0, 0,
  -27, 0, 0, 11, 0, 0,
  47, 0, 0, -1, 0, 0,
  36, 0, 0, -15, 0, 0,
  -36, 0, 0, 20, 0, 0,
  -35, 0, 0, 19, 0, 0,
  -37, 0, 0, 19, 0, 0,
  32, 0, 0, -16, 0, 0,
  35, 0, 0, -14, 0, 0,
  32, 0, 0, -13, 0, 0,
  65, 0, 0, -2, 0, 0,
  47, 0, 0, -1, 0, 0,
  32, 0, 0, -16, 0, 0,
  37, 0, 0, -16, 0, 0,
  -30, 0, 0, 15, 0, 0,
  -32, 0, 0, 16, 0, 0,
  -31, 0, 0, 13, 0, 0,
  37, 0, 0, -16, 0, 0,
  31, 0, 0, -13, 0, 0,
  49, 0, 0, -2, 0, 0,
  32, 0, 0, -13, 0, 0,
  23, 0, 0, -12, 0, 0,
  -43, 0, 0, 18, 0, 0,
  26, 0, 0, -11, 0, 0,
  -32, 0, 0, 14, 0, 0,
  -29, 0, 0, 14, 0, 0,
  -27, 0, 0, 12, 0, 0,
  30, 0, 0, 0, 0, 0,
  -11, 0, 0, 5, 0, 0,
  -21, 0, 0, 10, 0, 0,
  -34, 0, 0, 15, 0, 0,
  -10, 0, 0, 6, 0, 0,
  -36, 0, 0, 0, 0, 0,
  -9, 0, 0, 4, 0, 0,
  -12, 0, 0, 5, 0, 0,
  -21, 0, 0, 5, 0, 0,
  -29, 0, 0, -1, 0, 0,
  -15, 0, 0, 3, 0, 0,
  -20, 0, 0, 0, 0, 0,
  28, 0, 0, 0, 0, -2,
  17, 0, 0, 0, 0, 0,
  -22, 0, 0, 12, 0, 0,
  -14, 0, 0, 7, 0, 0,
  24, 0, 0, -11, 0, 0,
  11, 0, 0, -6, 0, 0,
  14, 0, 0, -6, 0, 0,
  24, 0, 0, 0, 0, 0,
  18, 0, 0, -8, 0, 0,
  -38, 0, 0, 0, 0, 0,
  -31, 0, 0, 0, 0, 0,
  -16, 0, 0, 8, 0, 0,
  29, 0, 0, 0, 0, 0,
  -18, 0, 0, 10, 0, 0,
  -10, 0, 0, 5, 0, 0,
  -17, 0, 0, 10, 0, 0,
  9, 0, 0, -4, 0, 0,
  16, 0, 0, -6, 0, 0,
  22, 0, 0, -12, 0, 0,
  20, 0, 0, 0, 0, 0,
  -13, 0, 0, 6, 0, 0,
  -17, 0, 0, 9, 0, 0,
  -14, 0, 0, 8, 0, 0,
  0, 0, 0, -7, 0, 0,
  14, 0, 0, 0, 0, 0,
  19, 0, 0, -10, 0, 0,
  -34, 0, 0, 0, 0, 0,
  -20, 0, 0, 8, 0, 0,
  9, 0, 0, -5, 0, 0,
  -18, 0, 0, 7, 0, 0,
  13, 0, 0, -6, 0, 0,
  17, 0, 0, 0, 0, 0,
  -12, 0, 0, 5, 0, 0,
  15, 0, 0, -8, 0, 0,
  -11, 0, 0, 3, 0, 0,
  13, 0, 0, -5, 0, 0,
  -18, 0, 0, 0, 0, 0,
  -35, 0, 0, 0, 0, 0,
  9, 0, 0, -4, 0, 0,
  -19, 0, 0, 10, 0, 0,
  -26, 0, 0, 11, 0, 0,
  8, 0, 0, -4, 0, 0,
  -10, 0, 0, 4, 0, 0,
  10, 0, 0, -6, 0, 0,
  -21, 0, 0, 9, 0, 0,
  -15, 0, 0, 0, 0, 0,
  9, 0, 0, -5, 0, 0,
  -29, 0, 0, 0, 0, 0,
  -19, 0, 0, 10, 0, 0,
  12, 0, 0, -5, 0, 0,
  22, 0, 0, -9, 0, 0,
  -10, 0, 0, 5, 0, 0,
  -20, 0, 0, 11, 0, 0,
  -20, 0, 0, 0, 0, 0,
  -17, 0, 0, 7, 0, 0,
  15, 0, 0, -3, 0, 0,
  8, 0, 0, -4, 0, 0,
  14, 0, 0, 0, 0, 0,
  -12, 0, 0, 6, 0, 0,
  25, 0, 0, 0, 0, 0,
  -13, 0, 0, 6, 0, 0,
  -14, 0, 0, 8, 0, 0,
  13, 0, 0, -5, 0, 0,
  -17, 0, 0, 9, 0, 0,
  -12, 0, 0, 6, 0, 0,
  -10, 0, 0, 5, 0, 0,
  10, 0, 0, -6, 0, 0,
  -15, 0, 0, 0, 0, 0,
  -22, 0, 0, 0, 0, 0,
  28, 0, 0, -1, 0, 0,
  15, 0, 0, -7, 0, 0,
  23, 0, 0, -10, 0, 0,
  12, 0, 0, -5, 0, 0,
  29, 0, 0, -1, 0, 0,
  -25, 0, 0, 1, 0, 0,
  22, 0, 0, 0, 0, 0,
  -18, 0, 0, 0, 0, 0,
  15, 0, 0, 3, 0, 0,
  -23, 0, 0, 0, 0, 0,
  12, 0, 0, -5, 0, 0,
  -8, 0, 0, 4, 0, 0,
  -19, 0, 0, 0, 0, 0,
  -10, 0, 0, 4, 0, 0,
  21, 0, 0, -9, 0, 0,
  23, 0, 0, -1, 0, 0,
  -16, 0, 0, 8, 0, 0,
  -19, 0, 0, 9, 0, 0,
  -22, 0, 0, 10, 0, 0,
  27, 0, 0, -1, 0, 0,
  16, 0, 0, -8, 0, 0,
  19, 0, 0, -8, 0, 0,
  9, 0, 0, -4, 0, 0,
  -9, 0, 0, 4, 0, 0,
  -9, 0, 0, 4, 0, 0,
  -8, 0, 0, 4, 0, 0,
  18, 0, 0, -9, 0, 0,
  16, 0, 0, -1, 0, 0,
  -10, 0, 0, 4, 0, 0,
  -23, 0, 0, 9, 0, 0,
  16, 0, 0, -1, 0, 0,
  -12, 0, 0, 6, 0, 0,
  -8, 0, 0, 4, 0, 0,
  30, 0, 0, -2, 0, 0,
  24, 0, 0, -10, 0, 0,
  10, 0, 0, -4, 0, 0,
  -16, 0, 0, 7, 0, 0,
  -16, 0, 0, 7, 0, 0,
  17, 0, 0, -7, 0, 0,
  -24, 0, 0, 10, 0, 0,
  -12, 0, 0, 5, 0, 0,
  -24, 0, 0, 11, 0, 0,
  -23, 0, 0, 9, 0, 0,
  -13, 0, 0, 5, 0, 0,
  -15, 0, 0, 7, 0, 0,
  0, 0, -1988, 0, 0, -1679,
  0, 0, -63, 0, 0, -27,
  -4, 0, 0, 0, 0, 0,
  0, 0, 5, 0, 0, 4,
  5, 0, 0, -3, 0, 0,
  0, 0, 364, 0, 0, 176,
  0, 0, -1044, 0, 0, -891,
  -3, 0, 0, 1, 0, 0,
  4, 0, 0, -2, 0, 0,
  0, 0, 330, 0, 0, 0,
  5, 0, 0, -2, 0, 0,
  3, 0, 0, -2, 0, 0,
  -3, 0, 0, 1, 0, 0,
  -5, 0, 0, 2, 0, 0,
  3, 0, 0, -1, 0, 0,
  3, 0, 0, 0, 0, 0,
  3, 0, 0, 0, 0, 0,
  0, 0, 5, 0, 0, 0,
  0, 0, 0, 1, 0, 0,
  4, 0, 0, -2, 0, 0,
  6, 0, 0, 0, 0, 0,
  5, 0, 0, -2, 0, 0,
  -7, 0, 0, 0, 0, 0,
  -12, 0, 0, 0, 0, 0,
  5, 0, 0, -3, 0, 0,
  3, 0, 0, -1, 0, 0,
  -5, 0, 0, 0, 0, 0,
  3, 0, 0, 0, 0, 0,
  -7, 0, 0, 3, 0, 0,
  7, 0, 0, -4, 0, 0,
  0, 0, -12, 0, 0, -10,
  4, 0, 0, -2, 0, 0,
  3, 0, 0, -2, 0, 0,
  -3, 0, 0, 2, 0, 0,
  -7, 0, 0, 3, 0, 0,
  -4, 0, 0, 2, 0, 0,
  -3, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 0, 0,
  -3, 0, 0, 1, 0, 0,
  7, 0, 0, -3, 0, 0,
  -4, 0, 0, 2, 0, 0,
  4, 0, 0, -2, 0, 0,
  -5, 0, 0, 3, 0, 0,
  5, 0, 0, 0, 0, 0,
  -5, 0, 0, 2, 0, 0,
  5, 0, 0, -2, 0, 0,
  -8, 0, 0, 3, 0, 0,
  9, 0, 0, 0, 0, 0,
  6, 0, 0, -3, 0, 0,
  -5, 0, 0, 2, 0, 0,
  3, 0, 0, 0, 0, 0,
  -7, 0, 0, 0, 0, 0,
  -3, 0, 0, 1, 0, 0,
  5, 0, 0, 0, 0, 0,
  3, 0, 0, 0, 0, 0,
  -3, 0, 0, 2, 0, 0,
  4, 0, 0, -2, 0, 0,
  3, 0, 0, -1, 0, 0,
  -5, 0, 0, 2, 0, 0,
  4, 0, 0, -2, 0, 0,
  9, 0, 0, -3, 0, 0,
  4, 0, 0, 0, 0, 0,
  4, 0, 0, -2, 0, 0,
  -3, 0, 0, 2, 0, 0,
  -4, 0, 0, 2, 0, 0,
  9, 0, 0, -3, 0, 0,
  -4, 0, 0, 0, 0, 0,
  -4, 0, 0, 0, 0, 0,
  3, 0, 0, -2, 0, 0,
  8, 0, 0, 0, 0, 0,
  3, 0, 0, 0, 0, 0,
  -3, 0, 0, 2, 0, 0,
  3, 0, 0, -1, 0, 0,
  3, 0, 0, -1, 0, 0,
  -3, 0, 0, 1, 0, 0,
  6, 0, 0, -3, 0, 0,
  3, 0, 0, 0, 0, 0,
  -3, 0, 0, 1, 0, 0,
  -7, 0, 0, 0, 0, 0,
  9, 0, 0, 0, 0, 0,
  -3, 0, 0, 2, 0, 0,
  -3, 0, 0, 0, 0, 0,
  -4, 0, 0, 0, 0, 0,
  -5, 0, 0, 3, 0, 0,
  -13, 0, 0, 0, 0, 0,
  -7, 0, 0, 0, 0, 0,
  10, 0, 0, 0, 0, 0,
  3, 0, 0, -1, 0, 0,
  10, 0, 13, 6, 0, -5,
  0, 0, 30, 0, 0, 14,
  0, 0, -162, 0, 0, -138,
  0, 0, 75, 0, 0, 0,
  -7, 0, 0, 4, 0, 0,
  -4, 0, 0, 2, 0, 0,
  4, 0, 0, -2, 0, 0,
  5, 0, 0, -2, 0, 0,
  5, 0, 0, -3, 0, 0,
  -3, 0, 0, 0, 0, 0,
  -3, 0, 0, 2, 0, 0,
  -4, 0, 0, 2, 0, 0,
  -5, 0, 0, 2, 0, 0,
  6, 0, 0, 0, 0, 0,
  9, 0, 0, 0, 0, 0,
  5, 0, 0, 0, 0, 0,
  -7, 0, 0, 0, 0, 0,
  -3, 0, 0, 1, 0, 0,
  -4, 0, 0, 2, 0, 0,
  7, 0, 0, 0, 0, 0,
  -4, 0, 0, 0, 0, 0,
  4, 0, 0, 0, 0, 0,
  -6, 0, -3, 3, 0, 1,
  0, 0, -3, 0, 0, -2,
  11, 0, 0, 0, 0, 0,
  3, 0, 0, -1, 0, 0,
  11, 0, 0, 0, 0, 0,
  -3, 0, 0, 2, 0, 0,
  -1, 0, 3, 3, 0, -1,
  4, 0, 0, -2, 0, 0,
  0, 0, -13, 0, 0, -11,
  3, 0, 6, 0, 0, 0,
  -7, 0, 0, 0, 0, 0,
  5, 0, 0, -3, 0, 0,
  -3, 0, 0, 1, 0, 0,
  3, 0, 0, 0, 0, 0,
  5, 0, 0, -3, 0, 0,
  -7, 0, 0, 3, 0, 0,
  8, 0, 0, -3, 0, 0,
  -4, 0, 0, 2, 0, 0,
  11, 0, 0, 0, 0, 0,
  -3, 0, 0, 1, 0, 0,
  3, 0, 0, -1, 0, 0,
  -4, 0, 0, 2, 0, 0,
  8, 0, 0, -4, 0, 0,
  3, 0, 0, -1, 0, 0,
  11, 0, 0, 0, 0, 0,
  -6, 0, 0, 3, 0, 0,
  -4, 0, 0, 2, 0, 0,
  -8, 0, 0, 4, 0, 0,
  -7, 0, 0, 3, 0, 0,
  -4, 0, 0, 2, 0, 0,
  3, 0, 0, -1, 0, 0,
  6, 0, 0, -3, 0, 0,
  -6, 0, 0, 3, 0, 0,
  6, 0, 0, 0, 0, 0,
  6, 0, 0, -1, 0, 0,
  5, 0, 0, -2, 0, 0,
  -5, 0, 0, 2, 0, 0,
  -4, 0, 0, 0, 0, 0,
  -4, 0, 0, 2, 0, 0,
  4, 0, 0, 0, 0, 0,
  6, 0, 0, -3, 0, 0,
  -4, 0, 0, 2, 0, 0,
  0, 0, -26, 0, 0, -11,
  0, 0, -10, 0, 0, -5,
  5, 0, 0, -3, 0, 0,
  -13, 0, 0, 0, 0, 0,
  3, 0, 0, -2, 0, 0,
  4, 0, 0, -2, 0, 0,
  7, 0, 0, -3, 0, 0,
  4, 0, 0, 0, 0, 0,
  5, 0, 0, 0, 0, 0,
  -3, 0, 0, 2, 0, 0,
  -6, 0, 0, 2, 0, 0,
  -5, 0, 0, 2, 0, 0,
  -7, 0, 0, 3, 0, 0,
  5, 0, 0, -2, 0, 0,
  13, 0, 0, 0, 0, 0,
  -4, 0, 0, 2, 0, 0,
  -3, 0, 0, 0, 0, 0,
  5, 0, 0, -2, 0, 0,
  -11, 0, 0, 0, 0, 0,
  5, 0, 0, -2, 0, 0,
  4, 0, 0, 0, 0, 0,
  4, 0, 0, -2, 0, 0,
  -4, 0, 0, 2, 0, 0,
  6, 0, 0, -3, 0, 0,
  3, 0, 0, -2, 0, 0,
  -12, 0, 0, 0, 0, 0,
  4, 0, 0, 0, 0, 0,
  -3, 0, 0, 0, 0, 0,
  -4, 0, 0, 0, 0, 0,
  3, 0, 0, 0, 0, 0,
  3, 0, 0, -1, 0, 0,
  -3, 0, 0, 1, 0, 0,
  0, 0, -5, 0, 0, -2,
  -7, 0, 0, 4, 0, 0,
  6, 0, 0, -3, 0, 0,
  -3, 0, 0, 0, 0, 0,
  5, 0, 0, -3, 0, 0,
  3, 0, 0, -1, 0, 0,
  3, 0, 0, 0, 0, 0,
  -3, 0, 0, 1, 0, 0,
  -5, 0, 0, 3, 0, 0,
  -3, 0, 0, 2, 0, 0,
  -3, 0, 0, 2, 0, 0,
  12, 0, 0, 0, 0, 0,
  3, 0, 0, -1, 0, 0,
  -4, 0, 0, 2, 0, 0,
  4, 0, 0, 0, 0, 0,
  6, 0, 0, 0, 0, 0,
  5, 0, 0, -3, 0, 0,
  4, 0, 0, -2, 0, 0,
  -6, 0, 0, 3, 0, 0,
  4, 0, 0, -2, 0, 0,
  6, 0, 0, -3, 0, 0,
  6, 0, 0, 0, 0, 0,
  -6, 0, 0, 3, 0, 0,
  3, 0, 0, -2, 0, 0,
  7, 0, 0, -4, 0, 0,
  4, 0, 0, -2, 0, 0,
  -5, 0, 0, 2, 0, 0,
  5, 0, 0, 0, 0, 0,
  -6, 0, 0, 3, 0, 0,
  -6, 0, 0, 3, 0, 0,
  -4, 0, 0, 2, 0, 0,
  10, 0, 0, 0, 0, 0,
  -4, 0, 0, 2, 0, 0,
  7, 0, 0, 0, 0, 0,
  7, 0, 0, -3, 0, 0,
  4, 0, 0, 0, 0, 0,
  11, 0, 0, 0, 0, 0,
  5, 0, 0, -2, 0, 0,
  -6, 0, 0, 2, 0, 0,
  4, 0, 0, -2, 0, 0,
  3, 0, 0, -2, 0, 0,
  5, 0, 0, -2, 0, 0,
  -4, 0, 0, 2, 0, 0,
  -4, 0, 0, 2, 0, 0,
  -3, 0, 0, 2, 0, 0,
  4, 0, 0, -2, 0, 0,
  3, 0, 0, -1, 0, 0,
  -3, 0, 0, 1, 0, 0,
  -3, 0, 0, 1, 0, 0,
  -3, 0, 0, 2, 0, 0,
  };
  
}
class SwephData {
  // Mean node seems to have a constant speed and distance?
  // Aus: sweodef.h:
  static final double M_PI = 3.14159265358979323846;
  // Aus sweph.h:
  static final int[] PNOINT2JPL = new int[] {SwephJPL.J_EARTH, SwephJPL.J_MOON,
                    SwephJPL.J_MERCURY, SwephJPL.J_VENUS, SwephJPL.J_MARS,
                    SwephJPL.J_JUPITER, SwephJPL.J_SATURN, SwephJPL.J_URANUS,
                    SwephJPL.J_NEPTUNE, SwephJPL.J_PLUTO, SwephJPL.J_SUN};
  static final int[] pnoint2jpl = PNOINT2JPL;
  
  static final int NDIAM = (SweConst.SE_VESTA + 1);
  static final double pla_diam[] = {1392000000.0, 
                           3476300.0, 
                           2439000.0 * 2, 
                           6052000.0 * 2, 
                           3397200.0 * 2, 
                          71398000.0 * 2, 
                          60000000.0 * 2, 
                          25400000.0 * 2, 
                          24300000.0 * 2, 
                           2500000.0 * 2, 
                           0, 0, 0, 0,    
                           6378140.0 * 2, 
                                 0.0, 
                                 0.0, 
                            913000.0, 
                            523000.0, 
                            244000.0, 
                            501000.0, 
                        };
  static final double J2000 = 2451545.0;        // 2000 January 1.5
  static final double B1950 = 2433282.42345905; // 1950 January 0.923
  static final double J1900 = 2415020.0;        // 1900 January 0.5
  static final int MPC_CERES = 1;
  static final int MPC_PALLAS = 2;
  static final int MPC_JUNO = 3;
  static final int MPC_VESTA = 4;
  static final int MPC_CHIRON = 2060;
  static final int MPC_PHOLUS = 5145;
  static final String SE_NAME_SUN = "Sun";
  static final String SE_NAME_MOON = "Moon";
  static final String SE_NAME_MERCURY = "Mercury";
  static final String SE_NAME_VENUS = "Venus";
  static final String SE_NAME_MARS = "Mars";
  static final String SE_NAME_JUPITER = "Jupiter";
  static final String SE_NAME_SATURN = "Saturn";
  static final String SE_NAME_URANUS = "Uranus";
  static final String SE_NAME_NEPTUNE = "Neptune";
  static final String SE_NAME_PLUTO = "Pluto";
  static final String SE_NAME_MEAN_NODE = "mean Node";
  static final String SE_NAME_TRUE_NODE = "true Node";
  static final String SE_NAME_MEAN_APOG = "mean Apogee";
  static final String SE_NAME_OSCU_APOG = "osc. Apogee";
  static final String SE_NAME_INTP_APOG = "intp. Apogee";
  static final String SE_NAME_INTP_PERG = "intp. Perigee";
  static final String SE_NAME_EARTH = "Earth";
  static final String SE_NAME_CERES = "Ceres";
  static final String SE_NAME_PALLAS = "Pallas";
  static final String SE_NAME_JUNO = "Juno";
  static final String SE_NAME_VESTA = "Vesta";
  static final String SE_NAME_CHIRON = "Chiron";
  static final String SE_NAME_PHOLUS = "Pholus";
  static final String SE_NAME_CUPIDO = "Cupido";
  static final String SE_NAME_HADES = "Hades";
  static final String SE_NAME_ZEUS = "Zeus";
  static final String SE_NAME_KRONOS = "Kronos";
  static final String SE_NAME_APOLLON = "Apollon";
  static final String SE_NAME_ADMETOS = "Admetos";
  static final String SE_NAME_VULKANUS = "Vulkanus";
  static final String SE_NAME_POSEIDON = "Poseidon";
  static final String SE_NAME_ISIS = "Isis";
  static final String SE_NAME_NIBIRU = "Nibiru";
  static final String SE_NAME_HARRINGTON = "Harrington";
  static final String SE_NAME_NEPTUNE_LEVERRIER = "Leverrier";
  static final String SE_NAME_NEPTUNE_ADAMS = "Adams";
  static final String SE_NAME_PLUTO_LOWELL = "Lowell";
  static final String SE_NAME_PLUTO_PICKERING = "Pickering";
  static final String SE_NAME_VULCAN = "Vulcan";
  static final String SE_NAME_WHITE_MOON = "White Moon";
  static final AyaInit[] ayanamsa = new AyaInit[] {
    new AyaInit(2433282.5, 24.042044444),  
    new AyaInit(J1900, 360 - 337.53953),   
    new AyaInit(J1900, 360 - 333.58695),   
    new AyaInit(J1900, 360 - 338.98556),   
    new AyaInit(J1900, 360 - 341.33904),   
    new AyaInit(J1900, 360 - 337.636111),  
    new AyaInit(J1900, 360 - 333.0369024), 
    new AyaInit(J1900, 360 - 338.917778),  
    new AyaInit(J1900, 360 - 338.634444),  
    new AyaInit(1684532.5, -3.36667),      
    new AyaInit(1684532.5, -4.76667),      
    new AyaInit(1684532.5, -5.61667),      
    new AyaInit(1684532.5, -4.56667),      
    new AyaInit(1673941, -5.079167),       
    new AyaInit(1684532.5, -4.44088389),   
    new AyaInit(1674484, -9.33333),        
    new AyaInit(1927135.8747793, 0),       
    new AyaInit(1746443.513, 0),           
    new AyaInit(J2000, 0),                 
    new AyaInit(J1900, 0),                 
    new AyaInit(B1950, 0),                 
        };
  static final double PI = M_PI;   // 3.14159265358979323846, math.h
  static final double TWOPI = 2.0 * PI;
  static final int SEI_EPSILON = -2;
  static final int SEI_NUTATION = -1;
  static final int SEI_EMB = 0;
  static final int SEI_EARTH = 0;
  static final int SEI_SUN = 0;
  static final int SEI_MOON = 1;
  static final int SEI_MERCURY = 2;
  static final int SEI_VENUS = 3;
  static final int SEI_MARS = 4;
  static final int SEI_JUPITER = 5;
  static final int SEI_SATURN = 6;
  static final int SEI_URANUS = 7;
  static final int SEI_NEPTUNE = 8;
  static final int SEI_PLUTO = 9;
  static final int SEI_SUNBARY = 10;     // barycentric sun
  static final int SEI_ANYBODY = 11;     // any asteroid
  static final int SEI_CHIRON = 12;
  static final int SEI_PHOLUS = 13;
  static final int SEI_CERES = 14;
  static final int SEI_PALLAS = 15;
  static final int SEI_JUNO = 16;
  static final int SEI_VESTA = 17;
  static final int SEI_NPLANETS = 18;
  static final int SEI_MEAN_NODE = 0;
  static final int SEI_TRUE_NODE = 1;
  static final int SEI_MEAN_APOG = 2;
  static final int SEI_OSCU_APOG = 3;
  static final int SEI_INTP_APOG = 4;
  static final int SEI_INTP_PERG = 5;
  static final int SEI_NNODE_ETC = 6;
  static final int SEI_FLG_HELIO = 1;
  static final int SEI_FLG_ROTATE = 2;
  static final int SEI_FLG_ELLIPSE = 4;
  static final int SEI_FLG_EMBHEL = 8; // TRUE, if heliocentric earth is given
                                     // instead of barycentric sun
                                     // i.e. bary sun is computed from
                                     // barycentric and heliocentric earth
  static final int SEI_FILE_PLANET = 0;
  static final int SEI_FILE_MOON = 1;
  static final int SEI_FILE_MAIN_AST = 2;
  static final int SEI_FILE_ANY_AST = 3;
  static final int SEI_FILE_FIXSTAR = 4;
  // Aus swephexph.h:
  static final int SEI_FILE_TEST_ENDIAN = 0x616263;   // abc
  static final int SEI_FILE_BIGENDIAN = 0;
  static final int SEI_FILE_NOREORD = 0;
  static final int SEI_FILE_LITENDIAN = 1;
  static final int SEI_FILE_REORD = 2;
  static final int SEI_FILE_NMAXPLAN = 50;
  static final int SEI_FILE_EFPOSBEGIN = 500;
  static final String SE_FILE_SUFFIX = "se1";
  static final int SEI_NEPHFILES = 7;
  static final int SEI_CURR_FPOS = -1;
  static final double CHIRON_START = 1958470.5;      // 1.1.650
  static final double CHIRON_END = 3419437.5;        // 1.1.4650
  static final double PHOLUS_START = 314845.5;       // 1.1.-3850
  static final double MOSHPLEPH_START =  625000.5;
  static final double MOSHPLEPH_END =   2818000.5;
  static final double MOSHLUEPH_START =  625000.5;
  static final double MOSHLUEPH_END =   2818000.5;
  static final double MOSHNDEPH_START = -254900.5; // 14 Feb -5410 00:00 ET jul.
  static final double MOSHNDEPH_END =   3697000.5; // 11 Dec 5409 00:00 ET, greg.
  static final int MAXORD = 40;
  static final double NCTIES = 6.0;    // number of centuries per eph. file
  static final int NOT_AVAILABLE = -2;
  static final int BEYOND_EPH_LIMITS = -3;
  static final int J_TO_J2000 = 1;
  static final int J2000_TO_J = -1;
  // we always use Astronomical Almanac constants, if available
  static final double MOON_MEAN_DIST = 384400000.0;           // in m, AA 1996, F2
  static final double MOON_MEAN_INCL = 5.1453964;             // AA 1996, D2
  static final double MOON_MEAN_ECC = 0.054900489;            // AA 1996, F2
  // static final double SUN_EARTH_MRAT = 328900.561400;         Su/(Ea+Mo) AA 2006 K7
  static final double SUN_EARTH_MRAT = 332946.050895;         // Su / (Ea only) AA 2006 K7
  static final double EARTH_MOON_MRAT = (1 / 0.0123000383);   // AA 2006, K7
  static final double AUNIT = 1.49597870691e+11;              // au in meters, AA 2006 K6
  static final double CLIGHT = 2.99792458e+8;                 // m/s, AA 1996 K6
  static final double HELGRAVCONST = 1.32712440017987e+20;    // G * M(sun), m^3/sec^2, AA 2006 K6
  static final double GEOGCONST = 3.98600448e+14; // G * M(earth) m^3/sec^2, AA 1996 K6
  static final double KGAUSS = 0.01720209895; // Gaussian gravitational constant K6
  static final double KGAUSS_GEO = 0.0000298122353216;        // Earth only
  // static final double KGAUSS_GEO = 0.0000299502129737        // Earth + Moon
  static final double SUN_RADIUS = 959.63 / 3600 * SwissData.DEGTORAD;  // Meeus germ. p 391
  static final double EARTH_RADIUS = 6378136.6;               // AA 2006 K6
  
  static final double EARTH_OBLATENESS = (1.0/ 298.25642);    // AA 2006 K6
  static final double EARTH_ROT_SPEED = 7.2921151467e-5 * 86400; // in rad/day, expl. suppl., p 162
  static final double LIGHTTIME_AUNIT = (499.0047838061/3600/24); // 8.3167 minutes (days), AA 2006 K6
  
  static final double SSY_PLANE_NODE_E2000 = 107.582569 * SwissData.DEGTORAD;
  
  static final double SSY_PLANE_NODE = 107.58883388 * SwissData.DEGTORAD;
  
  static final double SSY_PLANE_INCL = 1.578701 * SwissData.DEGTORAD;
  static final double KM_S_TO_AU_CTY = 21.095;           // km/s to AU/century
  static final double MOON_SPEED_INTV = 0.00005;         // 4.32 seconds (in days)
  static final double PLAN_SPEED_INTV = 0.0001;          // 8.64 seconds (in days)
  static final double MEAN_NODE_SPEED_INTV = 0.001;
  static final double NODE_CALC_INTV = 0.0001;
  static final double NODE_CALC_INTV_MOSH = 0.1;
  static final double NUT_SPEED_INTV = 0.0001;
  static final double DEFL_SPEED_INTV = 0.0000005;
  static final double STR = 4.8481368110953599359e-6;   // radians per arc second
  // Aus sweph.c:
  static final int IS_PLANET = 0;
  static final int IS_MOON = 1;
  static final int IS_ANY_BODY = 2;
  static final int IS_MAIN_ASTEROID = 3;
  static final boolean DO_SAVE = true;
  static final boolean NO_SAVE = false;
  static final double SURYA_MAX_LON_SPEED = 1.025;
  static final double SURYA_MIN_LON_SPEED = 0.946;
  static final double SURYA_MAX_LON_ACCEL = 0.000735;
  static final double SURYA_MIN_LON_ACCEL = -0.000720;
  static final double SURYA_MAX_TOPO_LON_SPEED = 1.04;
  static final double SURYA_MIN_TOPO_LON_SPEED = 0.93;
  static final double SURYA_MAX_TOPO_LON_ACCEL = 0.06;
  static final double SURYA_MIN_TOPO_LON_ACCEL = -0.06;
  static final double SURYA_MAX_HELIO_LON_SPEED = 0;
  static final double SURYA_MIN_HELIO_LON_SPEED = 0;
  static final double SURYA_MAX_HELIO_LON_ACCEL = 0;
  static final double SURYA_MIN_HELIO_LON_ACCEL = 0;
  static final double SURYA_MAX_LAT_SPEED = 0.0000620;
  static final double SURYA_MIN_LAT_SPEED = -0.0000618;
  static final double SURYA_MAX_LAT_ACCEL = 0.0000203;
  static final double SURYA_MIN_LAT_ACCEL = -0.0000204;
  static final double SURYA_MAX_TOPO_LAT_SPEED = 0.0066;
  static final double SURYA_MIN_TOPO_LAT_SPEED = -0.0065;
  static final double SURYA_MAX_TOPO_LAT_ACCEL = 0.025;
  static final double SURYA_MIN_TOPO_LAT_ACCEL = -0.025;
  static final double SURYA_MAX_HELIO_LAT_SPEED = 0;
  static final double SURYA_MIN_HELIO_LAT_SPEED = 0;
  static final double SURYA_MAX_HELIO_LAT_ACCEL = 0;
  static final double SURYA_MIN_HELIO_LAT_ACCEL = 0;
  static final double SURYA_MAX_DIST_SPEED = 0.000328;
  static final double SURYA_MIN_DIST_SPEED = -0.000327;
  static final double SURYA_MAX_DIST_ACCEL = 0.00000734;
  static final double SURYA_MIN_DIST_ACCEL = -0.00000694;
  static final double SURYA_MAX_TOPO_DIST_SPEED = 0.00059;
  static final double SURYA_MIN_TOPO_DIST_SPEED = -0.00058;
  static final double SURYA_MAX_TOPO_DIST_ACCEL = 0.00104;
  static final double SURYA_MIN_TOPO_DIST_ACCEL = -0.0013;
  static final double SURYA_MAX_HELIO_DIST_SPEED = 0;
  static final double SURYA_MIN_HELIO_DIST_SPEED = 0;
  static final double SURYA_MAX_HELIO_DIST_ACCEL = 0;
  static final double SURYA_MIN_HELIO_DIST_ACCEL = 0;
  static final double CHANDRA_MAX_LON_SPEED = 15.41;
  static final double CHANDRA_MIN_LON_SPEED = 11.75;
  static final double CHANDRA_MAX_LON_ACCEL = 0.522;
  static final double CHANDRA_MIN_LON_ACCEL = -0.520;
  static final double CHANDRA_MAX_TOPO_LON_SPEED = 22.0;
  static final double CHANDRA_MIN_TOPO_LON_SPEED = 6.0;
  static final double CHANDRA_MAX_TOPO_LON_ACCEL = 23.5;
  static final double CHANDRA_MIN_TOPO_LON_ACCEL = -23.2;
  static final double CHANDRA_MAX_HELIO_LON_SPEED = 1.0584;
  static final double CHANDRA_MIN_HELIO_LON_SPEED = 0.9155;
  static final double CHANDRA_MAX_HELIO_LON_ACCEL = 0.007875;
  static final double CHANDRA_MIN_HELIO_LON_ACCEL = -0.007888;
  static final double CHANDRA_MAX_LAT_SPEED = 1.44;
  static final double CHANDRA_MIN_LAT_SPEED = -1.44;
  static final double CHANDRA_MAX_LAT_ACCEL = 0.366;
  static final double CHANDRA_MIN_LAT_ACCEL = -0.366;
  static final double CHANDRA_MAX_TOPO_LAT_SPEED = 4.2;
  static final double CHANDRA_MIN_TOPO_LAT_SPEED = -4.7;
  static final double CHANDRA_MAX_TOPO_LAT_ACCEL = 12.5;
  static final double CHANDRA_MIN_TOPO_LAT_ACCEL = -12.5;
  static final double CHANDRA_MAX_HELIO_LAT_SPEED = 0.003415;
  static final double CHANDRA_MIN_HELIO_LAT_SPEED = -0.0034187;
  static final double CHANDRA_MAX_HELIO_LAT_ACCEL = 0.0008119;
  static final double CHANDRA_MIN_HELIO_LAT_ACCEL = -0.0008069;
  static final double CHANDRA_MAX_DIST_SPEED = 0.000044;
  static final double CHANDRA_MIN_DIST_SPEED = -0.0000434;
  static final double CHANDRA_MAX_DIST_ACCEL = 0.0000140;
  static final double CHANDRA_MIN_DIST_ACCEL = -0.00000898;
  static final double CHANDRA_MAX_TOPO_DIST_SPEED = 0.00030;
  static final double CHANDRA_MIN_TOPO_DIST_SPEED = -0.00031;
  static final double CHANDRA_MAX_TOPO_DIST_ACCEL = 0.00099;
  static final double CHANDRA_MIN_TOPO_DIST_ACCEL = -0.00098;
  static final double CHANDRA_MAX_HELIO_DIST_SPEED = 0.0008899;
  static final double CHANDRA_MIN_HELIO_DIST_SPEED = -0.000889;
  static final double CHANDRA_MAX_HELIO_DIST_ACCEL = 0.0001394;
  static final double CHANDRA_MIN_HELIO_DIST_ACCEL = -0.00013959;
  static final double BUDHA_MAX_LON_SPEED = 2.23;
  static final double BUDHA_MIN_LON_SPEED = -1.40;
  static final double BUDHA_MAX_LON_ACCEL = 0.20;
  static final double BUDHA_MIN_LON_ACCEL = -0.199;
  static final double BUDHA_MAX_TOPO_LON_SPEED = 2.3;
  static final double BUDHA_MIN_TOPO_LON_SPEED = -1.49;
  static final double BUDHA_MAX_TOPO_LON_ACCEL = 0.281;
  static final double BUDHA_MIN_TOPO_LON_ACCEL = -0.282;
  static final double BUDHA_MAX_HELIO_LON_SPEED = 6.358;
  static final double BUDHA_MIN_HELIO_LON_SPEED = 2.743;
  static final double BUDHA_MAX_HELIO_LON_ACCEL = 0.1547;
  static final double BUDHA_MIN_HELIO_LON_ACCEL = -0.1654;
  static final double BUDHA_MAX_LAT_SPEED = 0.35;
  static final double BUDHA_MIN_LAT_SPEED = -0.31;
  static final double BUDHA_MAX_LAT_ACCEL = 0.036;
  static final double BUDHA_MIN_LAT_ACCEL = -0.044;
  static final double BUDHA_MAX_TOPO_LAT_SPEED = 0.37;
  static final double BUDHA_MIN_TOPO_LAT_SPEED = -0.34;
  static final double BUDHA_MAX_TOPO_LAT_ACCEL = 0.078;
  static final double BUDHA_MIN_TOPO_LAT_ACCEL = -0.10;
  static final double BUDHA_MAX_HELIO_LAT_SPEED = 0.7557;
  static final double BUDHA_MIN_HELIO_LAT_SPEED = -0.4114;
  static final double BUDHA_MAX_HELIO_LAT_ACCEL = 0.05938;
  static final double BUDHA_MIN_HELIO_LAT_ACCEL = -0.07986;
  static final double BUDHA_MAX_DIST_SPEED = 0.0286;
  static final double BUDHA_MIN_DIST_SPEED = -0.0285;
  static final double BUDHA_MAX_DIST_ACCEL = 0.00325;
  static final double BUDHA_MIN_DIST_ACCEL = -0.00150;
  static final double BUDHA_MAX_TOPO_DIST_SPEED = 0.031;
  static final double BUDHA_MIN_TOPO_DIST_SPEED = -0.031;
  static final double BUDHA_MAX_TOPO_DIST_ACCEL = 0.0045;
  static final double BUDHA_MIN_TOPO_DIST_ACCEL = -0.0026;
  static final double BUDHA_MAX_HELIO_DIST_SPEED = 0.005831;
  static final double BUDHA_MIN_HELIO_DIST_SPEED = -0.005831;
  static final double BUDHA_MAX_HELIO_DIST_ACCEL = 0.00064693;
  static final double BUDHA_MIN_HELIO_DIST_ACCEL = -0.0002801;
  static final double SHUKRA_MAX_LON_SPEED = 1.266;
  static final double SHUKRA_MIN_LON_SPEED = -0.65;
  static final double SHUKRA_MAX_LON_ACCEL = 0.0427;
  static final double SHUKRA_MIN_LON_ACCEL = -0.0432;
  static final double SHUKRA_MAX_TOPO_LON_SPEED = 1.28;
  static final double SHUKRA_MIN_TOPO_LON_SPEED = -0.70;
  static final double SHUKRA_MAX_TOPO_LON_ACCEL = 0.246;
  static final double SHUKRA_MIN_TOPO_LON_ACCEL = -0.245;
  static final double SHUKRA_MAX_HELIO_LON_SPEED = 1.635;
  static final double SHUKRA_MIN_HELIO_LON_SPEED = 1.565;
  static final double SHUKRA_MAX_HELIO_LON_ACCEL = 0.0009600;
  static final double SHUKRA_MIN_HELIO_LON_ACCEL = -0.001066;
  static final double SHUKRA_MAX_LAT_SPEED = 0.264;
  static final double SHUKRA_MIN_LAT_SPEED = -0.251;
  static final double SHUKRA_MAX_LAT_ACCEL = 0.0167;
  static final double SHUKRA_MIN_LAT_ACCEL = -0.0170;
  static final double SHUKRA_MAX_TOPO_LAT_SPEED = 0.29;
  static final double SHUKRA_MIN_TOPO_LAT_SPEED = -0.27;
  static final double SHUKRA_MAX_TOPO_LAT_ACCEL = 0.13;
  static final double SHUKRA_MIN_TOPO_LAT_ACCEL = -0.113;
  static final double SHUKRA_MAX_HELIO_LAT_SPEED = 0.096175;
  static final double SHUKRA_MIN_HELIO_LAT_SPEED = -0.09549;
  static final double SHUKRA_MAX_HELIO_LAT_ACCEL = 0.002635;
  static final double SHUKRA_MIN_HELIO_LAT_ACCEL = -0.00275;
  static final double SHUKRA_MAX_DIST_SPEED = 0.00806;
  static final double SHUKRA_MIN_DIST_SPEED = -0.0083;
  static final double SHUKRA_MAX_DIST_ACCEL = 0.000316;
  static final double SHUKRA_MIN_DIST_ACCEL = -0.0000625;
  static final double SHUKRA_MAX_TOPO_DIST_SPEED = 0.0084;
  static final double SHUKRA_MIN_TOPO_DIST_SPEED = -0.0086;
  static final double SHUKRA_MAX_TOPO_DIST_ACCEL = 0.0015;
  static final double SHUKRA_MIN_TOPO_DIST_ACCEL = -0.00108;
  static final double SHUKRA_MAX_HELIO_DIST_SPEED = 0.0002173;
  static final double SHUKRA_MIN_HELIO_DIST_SPEED = -0.0002172;
  static final double SHUKRA_MAX_HELIO_DIST_ACCEL = 0.000006264;
  static final double SHUKRA_MIN_HELIO_DIST_ACCEL = -0.000005947;
  static final double MANGALA_MAX_LON_SPEED = 0.794;
  static final double MANGALA_MIN_LON_SPEED = -0.404;
  static final double MANGALA_MAX_LON_ACCEL = 0.0146;
  static final double MANGALA_MIN_LON_ACCEL = -0.0152;
  static final double MANGALA_MAX_TOPO_LON_SPEED = 0.81;
  static final double MANGALA_MIN_TOPO_LON_SPEED = -0.425;
  static final double MANGALA_MAX_TOPO_LON_ACCEL = 0.16;
  static final double MANGALA_MIN_TOPO_LON_ACCEL = -0.159;
  static final double MANGALA_MAX_HELIO_LON_SPEED = 0.6390;
  static final double MANGALA_MIN_HELIO_LON_SPEED = 0.4337;
  static final double MANGALA_MAX_HELIO_LON_ACCEL = 0.0010154;
  static final double MANGALA_MIN_HELIO_LON_ACCEL = -0.0010040;
  static final double MANGALA_MAX_LAT_SPEED = 0.084;
  static final double MANGALA_MIN_LAT_SPEED = -0.0839;
  static final double MANGALA_MAX_LAT_ACCEL = 0.0035;
  static final double MANGALA_MIN_LAT_ACCEL = -0.00209;
  static final double MANGALA_MAX_TOPO_LAT_SPEED = 0.095;
  static final double MANGALA_MIN_TOPO_LAT_SPEED = -0.099;
  static final double MANGALA_MAX_TOPO_LAT_ACCEL = 0.0805;
  static final double MANGALA_MIN_TOPO_LAT_ACCEL = -0.074;
  static final double MANGALA_MAX_HELIO_LAT_SPEED = 0.01994;
  static final double MANGALA_MIN_HELIO_LAT_SPEED = -0.02097;
  static final double MANGALA_MAX_HELIO_LAT_ACCEL = 0.00023610;
  static final double MANGALA_MIN_HELIO_LAT_ACCEL = -0.0001698;
  static final double MANGALA_MAX_DIST_SPEED = 0.0101;
  static final double MANGALA_MIN_DIST_SPEED = -0.01028;
  static final double MANGALA_MAX_DIST_ACCEL = 0.000234;
  static final double MANGALA_MIN_DIST_ACCEL = -0.0000695;
  static final double MANGALA_MAX_TOPO_DIST_SPEED = 0.0103;
  static final double MANGALA_MIN_TOPO_DIST_SPEED = -0.0105;
  static final double MANGALA_MAX_TOPO_DIST_ACCEL = 0.00123;
  static final double MANGALA_MIN_TOPO_DIST_ACCEL = -0.0011;
  static final double MANGALA_MAX_HELIO_DIST_SPEED = 0.0013516;
  static final double MANGALA_MIN_HELIO_DIST_SPEED = -0.0013516;
  static final double MANGALA_MAX_HELIO_DIST_ACCEL = 0.000015148;
  static final double MANGALA_MIN_HELIO_DIST_ACCEL = -0.000010287;
  static final double GURU_MAX_LON_SPEED = 0.244;
  static final double GURU_MIN_LON_SPEED = -0.1369;
  static final double GURU_MAX_LON_ACCEL = 0.00354;
  static final double GURU_MIN_LON_ACCEL = -0.00341;
  static final double GURU_MAX_TOPO_LON_SPEED = 0.247;
  static final double GURU_MIN_TOPO_LON_SPEED = -0.1405;
  static final double GURU_MAX_TOPO_LON_ACCEL = 0.0167;
  static final double GURU_MIN_TOPO_LON_ACCEL = -0.0167;
  static final double GURU_MAX_HELIO_LON_SPEED = 0.09287;
  static final double GURU_MIN_HELIO_LON_SPEED = 0.074689;
  static final double GURU_MAX_HELIO_LON_ACCEL = 0.000036229;
  static final double GURU_MIN_HELIO_LON_ACCEL = -0.000036650;
  static final double GURU_MAX_LAT_SPEED = 0.0063;
  static final double GURU_MIN_LAT_SPEED = -0.0062;
  static final double GURU_MAX_LAT_ACCEL = 0.000164;
  static final double GURU_MIN_LAT_ACCEL = -0.000144;
  static final double GURU_MAX_TOPO_LAT_SPEED = 0.0074;
  static final double GURU_MIN_TOPO_LAT_SPEED = -0.0074;
  static final double GURU_MAX_TOPO_LAT_ACCEL = 0.0064;
  static final double GURU_MIN_TOPO_LAT_ACCEL = -0.00601;
  static final double GURU_MAX_HELIO_LAT_SPEED = 0.0024277;
  static final double GURU_MIN_HELIO_LAT_SPEED = -0.002620;
  static final double GURU_MAX_HELIO_LAT_ACCEL = 0.000013982;
  static final double GURU_MIN_HELIO_LAT_ACCEL = -0.000013189;
  static final double GURU_MAX_DIST_SPEED = 0.0163;
  static final double GURU_MIN_DIST_SPEED = -0.0164;
  static final double GURU_MAX_DIST_ACCEL = 0.000325; // ???
  static final double GURU_MIN_DIST_ACCEL = -0.000225;
  static final double GURU_MAX_TOPO_DIST_SPEED = 0.0165;
  static final double GURU_MIN_TOPO_DIST_SPEED = -0.0166;
  static final double GURU_MAX_TOPO_DIST_ACCEL = 0.00133; // ???
  static final double GURU_MIN_TOPO_DIST_ACCEL = -0.00122;
  static final double GURU_MAX_HELIO_DIST_SPEED = 0.00040998;
  static final double GURU_MIN_HELIO_DIST_SPEED = -0.00040970;
  static final double GURU_MAX_HELIO_DIST_ACCEL = 0.00000077866;
  static final double GURU_MIN_HELIO_DIST_ACCEL = -0.0000006786;
  static final double SHANI_MAX_LON_SPEED = 0.13404;
  static final double SHANI_MIN_LON_SPEED = -0.084;
  static final double SHANI_MAX_LON_ACCEL = 0.00199;
  static final double SHANI_MIN_LON_ACCEL = -0.00195;
  static final double SHANI_MAX_TOPO_LON_SPEED = 0.134;
  static final double SHANI_MIN_TOPO_LON_SPEED = -0.0855;
  static final double SHANI_MAX_TOPO_LON_ACCEL = 0.0086;
  static final double SHANI_MIN_TOPO_LON_ACCEL = -0.00864;
  static final double SHANI_MAX_HELIO_LON_SPEED = 0.03929;
  static final double SHANI_MIN_HELIO_LON_SPEED = 0.028729;
  static final double SHANI_MAX_HELIO_LON_ACCEL = 0.000026497;
  static final double SHANI_MIN_HELIO_LON_ACCEL = -0.000026590;
  static final double SHANI_MAX_LAT_SPEED = 0.0055;
  static final double SHANI_MIN_LAT_SPEED = -0.0054;
  static final double SHANI_MAX_LAT_ACCEL = 0.000123;
  static final double SHANI_MIN_LAT_ACCEL = -0.000104;
  static final double SHANI_MAX_TOPO_LAT_SPEED = 0.006;
  static final double SHANI_MIN_TOPO_LAT_SPEED = -0.0059;
  static final double SHANI_MAX_TOPO_LAT_ACCEL = 0.0032;
  static final double SHANI_MIN_TOPO_LAT_ACCEL = -0.00301;
  static final double SHANI_MAX_HELIO_LAT_SPEED = 0.0016789;
  static final double SHANI_MIN_HELIO_LAT_SPEED = -0.001653;
  static final double SHANI_MAX_HELIO_LAT_ACCEL = 0.00001127;
  static final double SHANI_MIN_HELIO_LAT_ACCEL = -0.000011128;
  static final double SHANI_MAX_DIST_SPEED = 0.0168;
  static final double SHANI_MIN_DIST_SPEED = -0.0169;
  static final double SHANI_MAX_DIST_ACCEL = 0.000322;
  static final double SHANI_MIN_DIST_ACCEL = -0.00027;
  static final double SHANI_MAX_TOPO_DIST_SPEED = 0.017;
  static final double SHANI_MIN_TOPO_DIST_SPEED = -0.01702;
  static final double SHANI_MAX_TOPO_DIST_ACCEL = 0.00133;
  static final double SHANI_MIN_TOPO_DIST_ACCEL = -0.00127;
  static final double SHANI_MAX_HELIO_DIST_SPEED = 0.00043914;
  static final double SHANI_MIN_HELIO_DIST_SPEED = -0.00044091;
  static final double SHANI_MAX_HELIO_DIST_ACCEL = 0.00000043248;
  static final double SHANI_MIN_HELIO_DIST_ACCEL = -0.00000041039;
  static final double URANUS_MAX_LON_SPEED = 0.067;
  static final double URANUS_MIN_LON_SPEED = -0.044;
  static final double URANUS_MAX_LON_ACCEL = 0.000929;
  static final double URANUS_MIN_LON_ACCEL = -0.000975;
  static final double URANUS_MAX_TOPO_LON_SPEED = 0.067;
  static final double URANUS_MIN_TOPO_LON_SPEED = -0.045;
  static final double URANUS_MAX_TOPO_LON_ACCEL = 0.00408;
  static final double URANUS_MIN_TOPO_LON_ACCEL = -0.00414;
  static final double URANUS_MAX_HELIO_LON_SPEED = 0.013090;
  static final double URANUS_MIN_HELIO_LON_SPEED = 0.010609;
  static final double URANUS_MAX_HELIO_LON_ACCEL = 0.000023908;
  static final double URANUS_MIN_HELIO_LON_ACCEL = -0.000024088;
  static final double URANUS_MAX_LAT_SPEED = 0.00082;
  static final double URANUS_MIN_LAT_SPEED = -0.00079;
  static final double URANUS_MAX_LAT_ACCEL = 0.000073;
  static final double URANUS_MIN_LAT_ACCEL = -0.000078;
  static final double URANUS_MAX_TOPO_LAT_SPEED = 0.0011;
  static final double URANUS_MIN_TOPO_LAT_SPEED = -0.0011;
  static final double URANUS_MAX_TOPO_LAT_ACCEL = 0.0018;
  static final double URANUS_MIN_TOPO_LAT_ACCEL = -0.0014;
  static final double URANUS_MAX_HELIO_LAT_SPEED = 0.00022338;
  static final double URANUS_MIN_HELIO_LAT_SPEED = -0.00020480;
  static final double URANUS_MAX_HELIO_LAT_ACCEL = 0.0000105550;
  static final double URANUS_MIN_HELIO_LAT_ACCEL = -0.000010525;
  static final double URANUS_MAX_DIST_SPEED = 0.0174;
  static final double URANUS_MIN_DIST_SPEED = -0.0174;
  static final double URANUS_MAX_DIST_ACCEL = 0.00032;
  static final double URANUS_MIN_DIST_ACCEL = -0.00029;
  static final double URANUS_MAX_TOPO_DIST_SPEED = 0.0177;
  static final double URANUS_MIN_TOPO_DIST_SPEED = -0.0176;
  static final double URANUS_MAX_TOPO_DIST_ACCEL = 0.0014;
  static final double URANUS_MIN_TOPO_DIST_ACCEL = -0.0013;
  static final double URANUS_MAX_HELIO_DIST_SPEED = 0.00020103;
  static final double URANUS_MIN_HELIO_DIST_SPEED = -0.00020132;
  static final double URANUS_MAX_HELIO_DIST_ACCEL = 0.00000028679;
  static final double URANUS_MIN_HELIO_DIST_ACCEL = -0.000000229;
  static final double NEPTUNE_MAX_LON_SPEED = 0.040;
  static final double NEPTUNE_MIN_LON_SPEED = -0.0286;
  static final double NEPTUNE_MAX_LON_ACCEL = 0.000612;
  static final double NEPTUNE_MIN_LON_ACCEL = -0.000606;
  static final double NEPTUNE_MAX_TOPO_LON_SPEED = 0.043; // ???
  static final double NEPTUNE_MIN_TOPO_LON_SPEED = -0.0295;
  static final double NEPTUNE_MAX_TOPO_LON_ACCEL = 0.00253;
  static final double NEPTUNE_MIN_TOPO_LON_ACCEL = -0.00252;
  static final double NEPTUNE_MAX_HELIO_LON_SPEED = 0.006223;
  static final double NEPTUNE_MIN_HELIO_LON_SPEED = 0.00584;
  static final double NEPTUNE_MAX_HELIO_LON_ACCEL = 0.000023804;
  static final double NEPTUNE_MIN_HELIO_LON_ACCEL = -0.000023845;
  static final double NEPTUNE_MAX_LAT_SPEED = 0.0013;
  static final double NEPTUNE_MIN_LAT_SPEED = -0.0013;
  static final double NEPTUNE_MAX_LAT_ACCEL = 0.000069;
  static final double NEPTUNE_MIN_LAT_ACCEL = -0.000065;
  static final double NEPTUNE_MAX_TOPO_LAT_SPEED = 0.00156;
  static final double NEPTUNE_MIN_TOPO_LAT_SPEED = -0.00143;
  static final double NEPTUNE_MAX_TOPO_LAT_ACCEL = 0.00087;
  static final double NEPTUNE_MIN_TOPO_LAT_ACCEL = -0.000854;
  static final double NEPTUNE_MAX_HELIO_LAT_SPEED = 0.0002670;
  static final double NEPTUNE_MIN_HELIO_LAT_SPEED = -0.0002728;
  static final double NEPTUNE_MAX_HELIO_LAT_ACCEL = 0.0000106092;
  static final double NEPTUNE_MIN_HELIO_LAT_ACCEL = -0.000010590;
  static final double NEPTUNE_MAX_DIST_SPEED = 0.0175;
  static final double NEPTUNE_MIN_DIST_SPEED = -0.0175;
  static final double NEPTUNE_MAX_DIST_ACCEL = 0.000316;
  static final double NEPTUNE_MIN_DIST_ACCEL = -0.0003;
  static final double NEPTUNE_MAX_TOPO_DIST_SPEED = 0.0177;
  static final double NEPTUNE_MIN_TOPO_DIST_SPEED = -0.0177;
  static final double NEPTUNE_MAX_TOPO_DIST_ACCEL = 0.00135;
  static final double NEPTUNE_MIN_TOPO_DIST_ACCEL = -0.00129;
  static final double NEPTUNE_MAX_HELIO_DIST_SPEED = 0.000038700;
  static final double NEPTUNE_MIN_HELIO_DIST_SPEED = -0.000038379;
  static final double NEPTUNE_MAX_HELIO_DIST_ACCEL = 0.00000022853;
  static final double NEPTUNE_MIN_HELIO_DIST_ACCEL = -0.00000023012;
  static final double PLUTO_MAX_LON_SPEED = 0.041;
  static final double PLUTO_MIN_LON_SPEED = -0.0284;
  static final double PLUTO_MAX_LON_ACCEL = 0.000601;
  static final double PLUTO_MIN_LON_ACCEL = -0.00065; // ????
  static final double PLUTO_MAX_TOPO_LON_SPEED = 0.0413;
  static final double PLUTO_MIN_TOPO_LON_SPEED = -0.0288;
  static final double PLUTO_MAX_TOPO_LON_ACCEL = 0.00253;
  static final double PLUTO_MIN_TOPO_LON_ACCEL = -0.0026; // ????
  static final double PLUTO_MAX_HELIO_LON_SPEED = 0.0072091;
  static final double PLUTO_MIN_HELIO_LON_SPEED = 0.0025030;
  static final double PLUTO_MAX_HELIO_LON_ACCEL = 0.000024137;
  static final double PLUTO_MIN_HELIO_LON_ACCEL = -0.00002406;
  static final double PLUTO_MAX_LAT_SPEED = 0.0101;
  static final double PLUTO_MIN_LAT_SPEED = -0.00998;
  static final double PLUTO_MAX_LAT_ACCEL = 0.000159;
  static final double PLUTO_MIN_LAT_ACCEL = -0.000188;
  static final double PLUTO_MAX_TOPO_LAT_SPEED = 0.0102;
  static final double PLUTO_MIN_TOPO_LAT_SPEED = -0.011;
  static final double PLUTO_MAX_TOPO_LAT_ACCEL = 0.0013;
  static final double PLUTO_MIN_TOPO_LAT_ACCEL = -0.0014;
  static final double PLUTO_MAX_HELIO_LAT_SPEED = 0.0012607;
  static final double PLUTO_MIN_HELIO_LAT_SPEED = -0.00170212;
  static final double PLUTO_MAX_HELIO_LAT_ACCEL = 0.000010674;
  static final double PLUTO_MIN_HELIO_LAT_ACCEL = -0.000010758;
  static final double PLUTO_MAX_DIST_SPEED = 0.01805;
  static final double PLUTO_MIN_DIST_SPEED = -0.01805;
  static final double PLUTO_MAX_DIST_ACCEL = 0.000315;
  static final double PLUTO_MIN_DIST_ACCEL = -0.000296;
  static final double PLUTO_MAX_TOPO_DIST_SPEED = 0.0183;
  static final double PLUTO_MIN_TOPO_DIST_SPEED = -0.0183;
  static final double PLUTO_MAX_TOPO_DIST_ACCEL = 0.00135;
  static final double PLUTO_MIN_TOPO_DIST_ACCEL = -0.0013;
  static final double PLUTO_MAX_HELIO_DIST_SPEED = 0.00071348;
  static final double PLUTO_MIN_HELIO_DIST_SPEED = -0.00071142;
  static final double PLUTO_MAX_HELIO_DIST_ACCEL = 0.0000002773;
  static final double PLUTO_MIN_HELIO_DIST_ACCEL = -0.00000022049;
  static final double MNODE_MAX_LON_SPEED = -0.0528;
  static final double MNODE_MIN_LON_SPEED = -0.0531;
  static final double MNODE_MAX_LON_ACCEL = 0.0000249;
  static final double MNODE_MIN_LON_ACCEL = -0.0000244;
  
  static final double MNODE_MAX_TOPO_LON_SPEED = -0.0528;
  static final double MNODE_MIN_TOPO_LON_SPEED = -0.0531;
  static final double MNODE_MAX_TOPO_LON_ACCEL = 0.0000247;
  static final double MNODE_MIN_TOPO_LON_ACCEL = -0.0000252;
  static final double MNODE_MAX_HELIO_LON_SPEED = 1./0.;
  static final double MNODE_MIN_HELIO_LON_SPEED = 1./0.;
  static final double MNODE_MAX_HELIO_LON_ACCEL = 1./0.;
  static final double MNODE_MIN_HELIO_LON_ACCEL = 1./0.;
  static final double MNODE_MAX_LAT_SPEED = 0.;
  static final double MNODE_MIN_LAT_SPEED = 0.;
  static final double MNODE_MAX_LAT_ACCEL = 0.;
  static final double MNODE_MIN_LAT_ACCEL = 0.;
  static final double MNODE_MAX_TOPO_LAT_SPEED = 0.;
  static final double MNODE_MIN_TOPO_LAT_SPEED = 0.;
  static final double MNODE_MAX_TOPO_LAT_ACCEL = 0.;
  static final double MNODE_MIN_TOPO_LAT_ACCEL = 0.;
  static final double MNODE_MAX_HELIO_LAT_SPEED = 1./0.;
  static final double MNODE_MIN_HELIO_LAT_SPEED = 1./0.;
  static final double MNODE_MAX_HELIO_LAT_ACCEL = 1./0.;
  static final double MNODE_MIN_HELIO_LAT_ACCEL = 1./0.;
  static final double MNODE_MAX_DIST_SPEED = 0.;
  static final double MNODE_MIN_DIST_SPEED = 0.;
  static final double MNODE_MAX_DIST_ACCEL = 0.;
  static final double MNODE_MIN_DIST_ACCEL = 0.;
  static final double MNODE_MAX_TOPO_DIST_SPEED = 0.;
  static final double MNODE_MIN_TOPO_DIST_SPEED = 0.;
  static final double MNODE_MAX_TOPO_DIST_ACCEL = 0.;
  static final double MNODE_MIN_TOPO_DIST_ACCEL = 0.;
  static final double MNODE_MAX_HELIO_DIST_SPEED = 1./0.;
  static final double MNODE_MIN_HELIO_DIST_SPEED = 1./0.;
  static final double MNODE_MAX_HELIO_DIST_ACCEL = 1./0.;
  static final double MNODE_MIN_HELIO_DIST_ACCEL = 1./0.;
  static final double TNODE_MAX_LON_SPEED = 0.0328;
  static final double TNODE_MIN_LON_SPEED = -0.261;
  static final double TNODE_MAX_LON_ACCEL = 0.054;
  static final double TNODE_MIN_LON_ACCEL = -0.054;
  static final double TNODE_MAX_TOPO_LON_SPEED = 0.0328;
  static final double TNODE_MIN_TOPO_LON_SPEED = -0.261;
  static final double TNODE_MAX_TOPO_LON_ACCEL = 0.054;
  static final double TNODE_MIN_TOPO_LON_ACCEL = -0.054;
  static final double TNODE_MAX_HELIO_LON_SPEED = 1./0.;
  static final double TNODE_MIN_HELIO_LON_SPEED = 1./0.;
  static final double TNODE_MAX_HELIO_LON_ACCEL = 1./0.;
  static final double TNODE_MIN_HELIO_LON_ACCEL = 1./0.;
  static final double TNODE_MAX_LAT_SPEED = 0.;
  static final double TNODE_MIN_LAT_SPEED = 0.;
  static final double TNODE_MAX_LAT_ACCEL = 0.;
  static final double TNODE_MIN_LAT_ACCEL = 0.;
  static final double TNODE_MAX_TOPO_LAT_SPEED = 0.;
  static final double TNODE_MIN_TOPO_LAT_SPEED = 0.;
  static final double TNODE_MAX_TOPO_LAT_ACCEL = 0.;
  static final double TNODE_MIN_TOPO_LAT_ACCEL = 0.;
  static final double TNODE_MAX_HELIO_LAT_SPEED = 1./0.;
  static final double TNODE_MIN_HELIO_LAT_SPEED = 1./0.;
  static final double TNODE_MAX_HELIO_LAT_ACCEL = 1./0.;
  static final double TNODE_MIN_HELIO_LAT_ACCEL = 1./0.;
  static final double TNODE_MAX_DIST_SPEED = 0.0000228;
  static final double TNODE_MIN_DIST_SPEED = -0.0000216;
  static final double TNODE_MAX_DIST_ACCEL = 0.00000835;
  static final double TNODE_MIN_DIST_ACCEL = -0.0000086;
  static final double TNODE_MAX_TOPO_DIST_SPEED = 0.000022; // ????
  static final double TNODE_MIN_TOPO_DIST_SPEED = -0.000022; // ????
  static final double TNODE_MAX_TOPO_DIST_ACCEL = 0.00000835;
  static final double TNODE_MIN_TOPO_DIST_ACCEL = -0.00000856;
  static final double TNODE_MAX_HELIO_DIST_SPEED = 1./0.;
  static final double TNODE_MIN_HELIO_DIST_SPEED = 1./0.;
  static final double TNODE_MAX_HELIO_DIST_ACCEL = 1./0.;
  static final double TNODE_MIN_HELIO_DIST_ACCEL = 1./0.;
  static final double MAPOGEE_MAX_LON_SPEED = 0.114;
  static final double MAPOGEE_MIN_LON_SPEED = 0.113;
  static final double MAPOGEE_MAX_LON_ACCEL = 0.000031;
  static final double MAPOGEE_MIN_LON_ACCEL = -0.000031;
  
  static final double MAPOGEE_MAX_TOPO_LON_SPEED = 0.12;
  static final double MAPOGEE_MIN_TOPO_LON_SPEED = 0.12;
  static final double MAPOGEE_MAX_TOPO_LON_ACCEL = 0.000031;
  static final double MAPOGEE_MIN_TOPO_LON_ACCEL = 0.000031;
  static final double MAPOGEE_MAX_HELIO_LON_SPEED = 1./0;
  static final double MAPOGEE_MIN_HELIO_LON_SPEED = 1./0;
  static final double MAPOGEE_MAX_HELIO_LON_ACCEL = 1./0;
  static final double MAPOGEE_MIN_HELIO_LON_ACCEL = 1./0;
  static final double MAPOGEE_MAX_LAT_SPEED = 0.0155;
  static final double MAPOGEE_MIN_LAT_SPEED = -0.016;
  static final double MAPOGEE_MAX_LAT_ACCEL = 0.000052;
  static final double MAPOGEE_MIN_LAT_ACCEL = -0.0000525;
  static final double MAPOGEE_MAX_TOPO_LAT_SPEED = 0.0156;
  static final double MAPOGEE_MIN_TOPO_LAT_SPEED = -0.0156;
  static final double MAPOGEE_MAX_TOPO_LAT_ACCEL = 0.000052;
  static final double MAPOGEE_MIN_TOPO_LAT_ACCEL = -0.000052;
  static final double MAPOGEE_MAX_HELIO_LAT_SPEED = 1./0.;
  static final double MAPOGEE_MIN_HELIO_LAT_SPEED = 1./0.;
  static final double MAPOGEE_MAX_HELIO_LAT_ACCEL = 1./0.;
  static final double MAPOGEE_MIN_HELIO_LAT_ACCEL = 1./0.;
  static final double MAPOGEE_MAX_DIST_SPEED = 0.0;
  static final double MAPOGEE_MIN_DIST_SPEED = 0.0;
  static final double MAPOGEE_MAX_DIST_ACCEL = 0.0;
  static final double MAPOGEE_MIN_DIST_ACCEL = 0.0;
  static final double MAPOGEE_MAX_TOPO_DIST_SPEED = 0.0;
  static final double MAPOGEE_MIN_TOPO_DIST_SPEED = 0.0;
  static final double MAPOGEE_MAX_TOPO_DIST_ACCEL = 0.0;
  static final double MAPOGEE_MIN_TOPO_DIST_ACCEL = 0.0;
  static final double MAPOGEE_MAX_HELIO_DIST_SPEED = 1./0.;
  static final double MAPOGEE_MIN_HELIO_DIST_SPEED = 1./0.;
  static final double MAPOGEE_MAX_HELIO_DIST_ACCEL = 1./0.;
  static final double MAPOGEE_MIN_HELIO_DIST_ACCEL = 1./0.;
  static final double OAPOGEE_MAX_LON_SPEED = 6.5; // ???
  static final double OAPOGEE_MIN_LON_SPEED = -3.9; // ???
  static final double OAPOGEE_MAX_LON_ACCEL = 2.12; // ???
  static final double OAPOGEE_MIN_LON_ACCEL = -2.2; // ???
  static final double OAPOGEE_MAX_TOPO_LON_SPEED = 6.48;
  static final double OAPOGEE_MIN_TOPO_LON_SPEED = -7.12;
  static final double OAPOGEE_MAX_TOPO_LON_ACCEL = 5; // ???
  static final double OAPOGEE_MIN_TOPO_LON_ACCEL = -6; // ???
  static final double OAPOGEE_MAX_HELIO_LON_SPEED = 1./0.;
  static final double OAPOGEE_MIN_HELIO_LON_SPEED = 1./0.;
  static final double OAPOGEE_MAX_HELIO_LON_ACCEL = 1./0.;
  static final double OAPOGEE_MIN_HELIO_LON_ACCEL = 1./0.;
  static final double OAPOGEE_MAX_LAT_SPEED = 0.595;
  static final double OAPOGEE_MIN_LAT_SPEED = -0.592;
  static final double OAPOGEE_MAX_LAT_ACCEL = 0.198;
  static final double OAPOGEE_MIN_LAT_ACCEL = -0.184;
  static final double OAPOGEE_MAX_TOPO_LAT_SPEED = 0.595;
  static final double OAPOGEE_MIN_TOPO_LAT_SPEED = -0.593;
  static final double OAPOGEE_MAX_TOPO_LAT_ACCEL = 0.22; // ???
  static final double OAPOGEE_MIN_TOPO_LAT_ACCEL = -0.2; // ???
  static final double OAPOGEE_MAX_HELIO_LAT_SPEED = 1./0.;
  static final double OAPOGEE_MIN_HELIO_LAT_SPEED = 1./0.;
  static final double OAPOGEE_MAX_HELIO_LAT_ACCEL = 1./0.;
  static final double OAPOGEE_MIN_HELIO_LAT_ACCEL = 1./0.;
  static final double OAPOGEE_MAX_DIST_SPEED = 0.0000336;
  static final double OAPOGEE_MIN_DIST_SPEED = -0.0000388;
  static final double OAPOGEE_MAX_DIST_ACCEL = 0.000320;
  static final double OAPOGEE_MIN_DIST_ACCEL = -0.000332;
  static final double OAPOGEE_MAX_TOPO_DIST_SPEED = 0.0000348;
  static final double OAPOGEE_MIN_TOPO_DIST_SPEED = -0.0000389;
  static final double OAPOGEE_MAX_TOPO_DIST_ACCEL = 0.00033; // ???
  static final double OAPOGEE_MIN_TOPO_DIST_ACCEL = -0.00033; // ???
  static final double OAPOGEE_MAX_HELIO_DIST_SPEED = 1./0.;
  static final double OAPOGEE_MIN_HELIO_DIST_SPEED = 1./0.;
  static final double OAPOGEE_MAX_HELIO_DIST_ACCEL = 1./0.;
  static final double OAPOGEE_MIN_HELIO_DIST_ACCEL = 1./0.;
  static final double CHIRON_MAX_LON_SPEED = 0.1481;
  static final double CHIRON_MIN_LON_SPEED = -0.08136;
  static final double CHIRON_MAX_LON_ACCEL = 0.001985;
  static final double CHIRON_MIN_LON_ACCEL = -0.002076;
  static final double CHIRON_MAX_TOPO_LON_SPEED = 0.1490;
  static final double CHIRON_MIN_TOPO_LON_SPEED = -0.0826;
  static final double CHIRON_MAX_TOPO_LON_ACCEL = 0.00892;
  static final double CHIRON_MIN_TOPO_LON_ACCEL = -0.0091;
  static final double CHIRON_MAX_HELIO_LON_SPEED = 0.048572;
  static final double CHIRON_MIN_HELIO_LON_SPEED = 0.008467;
  static final double CHIRON_MAX_HELIO_LON_ACCEL = 0.000036235;
  static final double CHIRON_MIN_HELIO_LON_ACCEL = -0.000035949;
  static final double CHIRON_MAX_LAT_SPEED = 0.01538;
  static final double CHIRON_MIN_LAT_SPEED = -0.01344;
  static final double CHIRON_MAX_LAT_ACCEL = 0.000313;
  static final double CHIRON_MIN_LAT_ACCEL = -0.0002607;
  static final double CHIRON_MAX_TOPO_LAT_SPEED = 0.01574;
  static final double CHIRON_MIN_TOPO_LAT_SPEED =  -0.01368;
  static final double CHIRON_MAX_TOPO_LAT_ACCEL = 0.0033643;
  static final double CHIRON_MIN_TOPO_LAT_ACCEL = -0.003132;
  static final double CHIRON_MAX_HELIO_LAT_SPEED = 0.0066239;
  static final double CHIRON_MIN_HELIO_LAT_SPEED = -0.0018657;
  static final double CHIRON_MAX_HELIO_LAT_ACCEL = 0.000011620;
  static final double CHIRON_MIN_HELIO_LAT_ACCEL = -0.000017098;
  static final double CHIRON_MAX_DIST_SPEED = 0.01867;
  static final double CHIRON_MIN_DIST_SPEED = -0.018683;
  static final double CHIRON_MAX_DIST_ACCEL = 0.0003195;
  static final double CHIRON_MIN_DIST_ACCEL = -0.0002838;
  static final double CHIRON_MAX_TOPO_DIST_SPEED = 0.01883;
  static final double CHIRON_MIN_TOPO_DIST_SPEED = -0.01884;
  static final double CHIRON_MAX_TOPO_DIST_ACCEL = 0.001324;
  static final double CHIRON_MIN_TOPO_DIST_ACCEL = -0.001288;
  static final double CHIRON_MAX_HELIO_DIST_SPEED = 0.00208240;
  static final double CHIRON_MIN_HELIO_DIST_SPEED = -0.0020787;
  static final double CHIRON_MAX_HELIO_DIST_ACCEL = 0.0000023777;
  static final double CHIRON_MIN_HELIO_DIST_ACCEL = -0.0000012240;
  static final double PHOLUS_MAX_LON_SPEED = 0.144;
  static final double PHOLUS_MIN_LON_SPEED = -0.083;
  static final double PHOLUS_MAX_LON_ACCEL = 0.00202;
  static final double PHOLUS_MIN_LON_ACCEL = -0.00203;
  static final double PHOLUS_MAX_TOPO_LON_SPEED = 0.146;
  static final double PHOLUS_MIN_TOPO_LON_SPEED = -0.084;
  static final double PHOLUS_MAX_TOPO_LON_ACCEL = 0.009147;
  static final double PHOLUS_MIN_TOPO_LON_ACCEL = -0.0092;
  static final double PHOLUS_MAX_HELIO_LON_SPEED = 0.0456612;
  static final double PHOLUS_MIN_HELIO_LON_SPEED = 0.0031847;
  static final double PHOLUS_MAX_HELIO_LON_ACCEL = 0.000036611;
  static final double PHOLUS_MIN_HELIO_LON_ACCEL = -0.000035427;
  static final double PHOLUS_MAX_LAT_SPEED = 0.0475;
  static final double PHOLUS_MIN_LAT_SPEED = -0.0359;
  static final double PHOLUS_MAX_LAT_ACCEL = 0.0008841;
  static final double PHOLUS_MIN_LAT_ACCEL = -0.000759;
  static final double PHOLUS_MAX_TOPO_LAT_SPEED = 0.0482;
  static final double PHOLUS_MIN_TOPO_LAT_SPEED = -0.03636;
  static final double PHOLUS_MAX_TOPO_LAT_ACCEL = 0.00490;
  static final double PHOLUS_MIN_TOPO_LAT_ACCEL = -0.00485;
  static final double PHOLUS_MAX_HELIO_LAT_SPEED = 0.020809;
  static final double PHOLUS_MIN_HELIO_LAT_SPEED = -0.0036998;
  static final double PHOLUS_MAX_HELIO_LAT_ACCEL = 0.000022898;
  static final double PHOLUS_MIN_HELIO_LAT_ACCEL = -0.000020868;
  static final double PHOLUS_MAX_DIST_SPEED = 0.01806;
  static final double PHOLUS_MIN_DIST_SPEED = -0.01822;
  static final double PHOLUS_MAX_DIST_ACCEL = 0.0003200;
  static final double PHOLUS_MIN_DIST_ACCEL = -0.000297;
  static final double PHOLUS_MAX_TOPO_DIST_SPEED = 0.0183;
  static final double PHOLUS_MIN_TOPO_DIST_SPEED = -0.0185;
  static final double PHOLUS_MAX_TOPO_DIST_ACCEL = 0.00133;
  static final double PHOLUS_MIN_TOPO_DIST_ACCEL = -0.00131;
  static final double PHOLUS_MAX_HELIO_DIST_SPEED = 0.0026983;
  static final double PHOLUS_MIN_HELIO_DIST_SPEED = -0.0026987;
  static final double PHOLUS_MAX_HELIO_DIST_ACCEL = 0.0000030692;
  static final double PHOLUS_MIN_HELIO_DIST_ACCEL = -0.0000013359;
///////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
  static final double CERES_MAX_LON_SPEED = 0.47778;
  static final double CERES_MIN_LON_SPEED = -0.2397;
  static final double CERES_MAX_LON_ACCEL = 0.00784;
  static final double CERES_MIN_LON_ACCEL = -0.007809;
  static final double CERES_MAX_TOPO_LON_SPEED = 0.482;
  static final double CERES_MIN_TOPO_LON_SPEED = -0.2462;
  static final double CERES_MAX_TOPO_LON_ACCEL = 0.04415;
  static final double CERES_MIN_TOPO_LON_ACCEL = -0.0434;
  static final double CERES_MAX_HELIO_LON_SPEED = 0.27746;
  static final double CERES_MIN_HELIO_LON_SPEED = 0.1684273;
  static final double CERES_MAX_HELIO_LON_ACCEL = 0.00024858;
  static final double CERES_MIN_HELIO_LON_ACCEL = -0.00026465;
  static final double CERES_MAX_LAT_SPEED = 0.111909;
  static final double CERES_MIN_LAT_SPEED = -0.10943;
  static final double CERES_MAX_LAT_ACCEL = 0.003567;
  static final double CERES_MIN_LAT_ACCEL = -0.003284;
  static final double CERES_MAX_TOPO_LAT_SPEED = 0.1141;
  static final double CERES_MIN_TOPO_LAT_SPEED = -0.11225;
  static final double CERES_MAX_TOPO_LAT_ACCEL = 0.0254;
  static final double CERES_MIN_TOPO_LAT_ACCEL = -0.0241;
  static final double CERES_MAX_HELIO_LAT_SPEED = 0.049023;
  static final double CERES_MIN_HELIO_LAT_SPEED = -0.047271;
  static final double CERES_MAX_HELIO_LAT_ACCEL = 0.000239747;
  static final double CERES_MIN_HELIO_LAT_ACCEL = -0.00020807;
  static final double CERES_MAX_DIST_SPEED = 0.014525;
  static final double CERES_MIN_DIST_SPEED = -0.014456;
  static final double CERES_MAX_DIST_ACCEL = 0.0003006;
  static final double CERES_MIN_DIST_ACCEL = -0.0001636;
  static final double CERES_MAX_TOPO_DIST_SPEED = 0.01468;
  static final double CERES_MIN_TOPO_DIST_SPEED = -0.01462;
  static final double CERES_MAX_TOPO_DIST_ACCEL = 0.001298;
  static final double CERES_MIN_TOPO_DIST_ACCEL = -0.001166;
  static final double CERES_MAX_HELIO_DIST_SPEED = 0.0012446382;
  static final double CERES_MIN_HELIO_DIST_SPEED = -0.001241531;
  static final double CERES_MAX_HELIO_DIST_ACCEL = 0.0000061;
  static final double CERES_MIN_HELIO_DIST_ACCEL = -0.00000387;
///////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
  static final double PALLAS_MAX_LON_SPEED = 0.7687;
  static final double PALLAS_MIN_LON_SPEED = -0.3482;
  static final double PALLAS_MAX_LON_ACCEL = 0.01561;
  static final double PALLAS_MIN_LON_ACCEL = -0.01499;
  static final double PALLAS_MAX_TOPO_LON_SPEED = 0.7730;
  static final double PALLAS_MIN_TOPO_LON_SPEED = -0.3570;
  static final double PALLAS_MAX_TOPO_LON_ACCEL = 0.12775;
  static final double PALLAS_MIN_TOPO_LON_ACCEL = -0.1280;
  static final double PALLAS_MAX_HELIO_LON_SPEED = 0.626831;
  static final double PALLAS_MIN_HELIO_LON_SPEED = 0.11145519;
  static final double PALLAS_MAX_HELIO_LON_ACCEL = 0.0026825;
  static final double PALLAS_MIN_HELIO_LON_ACCEL = -0.0026481;
  static final double PALLAS_MAX_LAT_SPEED = 0.54900;
  static final double PALLAS_MIN_LAT_SPEED = -0.5261;
  static final double PALLAS_MAX_LAT_ACCEL = 0.013324;
  static final double PALLAS_MIN_LAT_ACCEL = -0.008125;
  static final double PALLAS_MAX_TOPO_LAT_SPEED = 0.5518;
  static final double PALLAS_MIN_TOPO_LAT_SPEED = -0.5288;
  static final double PALLAS_MAX_TOPO_LAT_ACCEL = 0.0506;
  static final double PALLAS_MIN_TOPO_LAT_ACCEL = -0.02938;
  static final double PALLAS_MAX_HELIO_LAT_SPEED = 0.2002976;
  static final double PALLAS_MIN_HELIO_LAT_SPEED = -0.18542288;
  static final double PALLAS_MAX_HELIO_LAT_ACCEL = 0.002821069;
  static final double PALLAS_MIN_HELIO_LAT_ACCEL = -0.00077783;
  static final double PALLAS_MAX_DIST_SPEED = 0.01780;
  static final double PALLAS_MIN_DIST_SPEED = -0.01778;
  static final double PALLAS_MAX_DIST_ACCEL = 0.0003338;
  static final double PALLAS_MIN_DIST_ACCEL = -0.000185;
  static final double PALLAS_MAX_TOPO_DIST_SPEED = 0.0180;
  static final double PALLAS_MIN_TOPO_DIST_SPEED = -0.01799;
  static final double PALLAS_MAX_TOPO_DIST_ACCEL = 0.001342;
  static final double PALLAS_MIN_TOPO_DIST_ACCEL = -0.001189;
  static final double PALLAS_MAX_HELIO_DIST_SPEED = 0.004602944;
  static final double PALLAS_MIN_HELIO_DIST_SPEED = -0.004618;
  static final double PALLAS_MAX_HELIO_DIST_ACCEL = 0.000044661;
  static final double PALLAS_MIN_HELIO_DIST_ACCEL = -0.0000083;
///////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
  static final double JUNO_MAX_LON_SPEED = 0.61473;
  static final double JUNO_MIN_LON_SPEED = -0.26366;
  static final double JUNO_MAX_LON_ACCEL = 0.00968;
  static final double JUNO_MIN_LON_ACCEL = -0.009779;
  static final double JUNO_MAX_TOPO_LON_SPEED = 0.6178;
  static final double JUNO_MIN_TOPO_LON_SPEED = -0.2702;
  static final double JUNO_MAX_TOPO_LON_ACCEL = 0.0682;
  static final double JUNO_MIN_TOPO_LON_ACCEL = -0.06812;
  static final double JUNO_MAX_HELIO_LON_SPEED = 0.42012063;
  static final double JUNO_MIN_HELIO_LON_SPEED = 0.1363890;
  static final double JUNO_MAX_HELIO_LON_ACCEL = 0.00087833;
  static final double JUNO_MIN_HELIO_LON_ACCEL = -0.00086738;
  static final double JUNO_MAX_LAT_SPEED = 0.2118;
  static final double JUNO_MIN_LAT_SPEED = -0.2069;
  static final double JUNO_MAX_LAT_ACCEL = 0.006619;
  static final double JUNO_MIN_LAT_ACCEL = -0.006030;
  static final double JUNO_MAX_TOPO_LAT_SPEED = 0.213;
  static final double JUNO_MIN_TOPO_LAT_SPEED = -0.2089;
  static final double JUNO_MAX_TOPO_LAT_ACCEL = 0.02594;
  static final double JUNO_MIN_TOPO_LAT_ACCEL = -0.02464;
  static final double JUNO_MAX_HELIO_LAT_SPEED = 0.09100508;
  static final double JUNO_MIN_HELIO_LAT_SPEED = -0.09178865;
  static final double JUNO_MAX_HELIO_LAT_ACCEL = 0.000645883;
  static final double JUNO_MIN_HELIO_LAT_ACCEL = -0.000592596;
  static final double JUNO_MAX_DIST_SPEED = 0.01631;
  static final double JUNO_MIN_DIST_SPEED = -0.01649;
  static final double JUNO_MAX_DIST_ACCEL = 0.0003149;
  static final double JUNO_MIN_DIST_ACCEL = -0.00018013;
  static final double JUNO_MAX_TOPO_DIST_SPEED = 0.016457;
  static final double JUNO_MIN_TOPO_DIST_SPEED = -0.01666;
  static final double JUNO_MAX_TOPO_DIST_ACCEL = 0.001315;
  static final double JUNO_MIN_TOPO_DIST_ACCEL = -0.001185;
  static final double JUNO_MAX_HELIO_DIST_SPEED = 0.0029944744;
  static final double JUNO_MIN_HELIO_DIST_SPEED = -0.002995286;
  static final double JUNO_MAX_HELIO_DIST_ACCEL = 0.00002158148;
  static final double JUNO_MIN_HELIO_DIST_ACCEL = -0.0000125;
///////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
  static final double VESTA_MAX_LON_SPEED = 0.5540;
  static final double VESTA_MIN_LON_SPEED = -0.2695;
  static final double VESTA_MAX_LON_ACCEL = 0.00876;
  static final double VESTA_MIN_LON_ACCEL = -0.00877;
  static final double VESTA_MAX_TOPO_LON_SPEED = 0.5568;
  static final double VESTA_MIN_TOPO_LON_SPEED = -0.2770;
  static final double VESTA_MAX_TOPO_LON_ACCEL = 0.05581;
  static final double VESTA_MIN_TOPO_LON_ACCEL = -0.05541;
  static final double VESTA_MAX_HELIO_LON_SPEED = 0.3379980;
  static final double VESTA_MIN_HELIO_LON_SPEED = 0.22067514;
  static final double VESTA_MAX_HELIO_LON_ACCEL = 0.00029479;
  static final double VESTA_MIN_HELIO_LON_ACCEL = -0.00033568;
  static final double VESTA_MAX_LAT_SPEED = 0.09498;
  static final double VESTA_MIN_LAT_SPEED = -0.09798;
  static final double VESTA_MAX_LAT_ACCEL = 0.003088;
  static final double VESTA_MIN_LAT_ACCEL = -0.003171;
  static final double VESTA_MAX_TOPO_LAT_SPEED = 0.09843;
  static final double VESTA_MIN_TOPO_LAT_SPEED = -0.1011;
  static final double VESTA_MAX_TOPO_LAT_ACCEL = 0.02671;
  static final double VESTA_MIN_TOPO_LAT_ACCEL = -0.02858;
  static final double VESTA_MAX_HELIO_LAT_SPEED = 0.0387172;
  static final double VESTA_MIN_HELIO_LAT_SPEED = -0.04107737;
  static final double VESTA_MAX_HELIO_LAT_ACCEL = 0.00022967;
  static final double VESTA_MIN_HELIO_LAT_ACCEL = -0.00022729;
  static final double VESTA_MAX_DIST_SPEED = 0.01421;
  static final double VESTA_MIN_DIST_SPEED = -0.01422;
  static final double VESTA_MAX_DIST_ACCEL = 0.000299;
  static final double VESTA_MIN_DIST_ACCEL = -0.0001321;
  static final double VESTA_MAX_TOPO_DIST_SPEED = 0.01438;
  static final double VESTA_MIN_TOPO_DIST_SPEED = -0.01420;
  static final double VESTA_MAX_TOPO_DIST_ACCEL = 0.001300;
  static final double VESTA_MIN_TOPO_DIST_ACCEL = -0.001138;
  static final double VESTA_MAX_HELIO_DIST_SPEED = 0.001193567;
  static final double VESTA_MIN_HELIO_DIST_SPEED = -0.001193051;
  static final double VESTA_MAX_HELIO_DIST_ACCEL = 0.0000070;
  static final double VESTA_MIN_HELIO_DIST_ACCEL = -0.0000048;
///////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
  static final double INTPAPOG_MAX_LON_SPEED = 0.240442;
  static final double INTPAPOG_MIN_LON_SPEED = -0.155670;
  static final double INTPAPOG_MAX_LON_ACCEL = 0.0103163;
  static final double INTPAPOG_MIN_LON_ACCEL = -0.0103726;
  static final double INTPAPOG_MAX_TOPO_LON_SPEED = 0.240440;
  static final double INTPAPOG_MIN_TOPO_LON_SPEED = -0.1556659;
  static final double INTPAPOG_MAX_TOPO_LON_ACCEL = 0.0103158;
  static final double INTPAPOG_MIN_TOPO_LON_ACCEL = -0.0103707;
  static final double INTPAPOG_MAX_HELIO_LON_SPEED = 1./0.;
  static final double INTPAPOG_MIN_HELIO_LON_SPEED = 1./0.;
  static final double INTPAPOG_MAX_HELIO_LON_ACCEL = 1./0.;
  static final double INTPAPOG_MIN_HELIO_LON_ACCEL = 1./0.;
  static final double INTPAPOG_MAX_LAT_SPEED = 0.031604;
  static final double INTPAPOG_MIN_LAT_SPEED = -0.031613;
  static final double INTPAPOG_MAX_LAT_ACCEL = 0.00109429;
  static final double INTPAPOG_MIN_LAT_ACCEL = -0.0010990;
  static final double INTPAPOG_MAX_TOPO_LAT_SPEED = 0.03159950;
  static final double INTPAPOG_MIN_TOPO_LAT_SPEED = -0.031610;
  static final double INTPAPOG_MAX_TOPO_LAT_ACCEL = 0.00109428;
  static final double INTPAPOG_MIN_TOPO_LAT_ACCEL = -0.00109888;
  static final double INTPAPOG_MAX_HELIO_LAT_SPEED = 1./0.;
  static final double INTPAPOG_MIN_HELIO_LAT_SPEED = 1./0.;
  static final double INTPAPOG_MAX_HELIO_LAT_ACCEL = 1./0.;
  static final double INTPAPOG_MIN_HELIO_LAT_ACCEL = 1./0.;
  static final double INTPAPOG_MAX_DIST_SPEED = 0.00000026577;
  static final double INTPAPOG_MIN_DIST_SPEED = -0.00000026575;
  static final double INTPAPOG_MAX_DIST_ACCEL = 0.0000000080677;
  static final double INTPAPOG_MIN_DIST_ACCEL = -0.000000006945;
  static final double INTPAPOG_MAX_TOPO_DIST_SPEED = 0.00000026584;
  static final double INTPAPOG_MIN_TOPO_DIST_SPEED = -0.00000026578;
  static final double INTPAPOG_MAX_TOPO_DIST_ACCEL = 0.0000000080677;
  static final double INTPAPOG_MIN_TOPO_DIST_ACCEL = -0.0000000069411;
  static final double INTPAPOG_MAX_HELIO_DIST_SPEED = 1./0.;
  static final double INTPAPOG_MIN_HELIO_DIST_SPEED = 1./0.;
  static final double INTPAPOG_MAX_HELIO_DIST_ACCEL = 1./0.;
  static final double INTPAPOG_MIN_HELIO_DIST_ACCEL = 1./0.;
///////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
  static final double INTPPERG_MAX_LON_SPEED = 0.583372;
  static final double INTPPERG_MIN_LON_SPEED = -2.33189;
  static final double INTPPERG_MAX_LON_ACCEL = 0.185425;
  static final double INTPPERG_MIN_LON_ACCEL = -0.185357;
  static final double INTPPERG_MAX_TOPO_LON_SPEED = 0.583371;
  static final double INTPPERG_MIN_TOPO_LON_SPEED = -2.33188;
  static final double INTPPERG_MAX_TOPO_LON_ACCEL = 0.185418;
  static final double INTPPERG_MIN_TOPO_LON_ACCEL = -0.185353;
  static final double INTPPERG_MAX_HELIO_LON_SPEED = 1./0.;
  static final double INTPPERG_MIN_HELIO_LON_SPEED = 1./0.;
  static final double INTPPERG_MAX_HELIO_LON_ACCEL = 1./0.;
  static final double INTPPERG_MIN_HELIO_LON_ACCEL = 1./0.;
  static final double INTPPERG_MAX_LAT_SPEED = 0.193078;
  static final double INTPPERG_MIN_LAT_SPEED = -0.193022;
  static final double INTPPERG_MAX_LAT_ACCEL = 0.016642;
  static final double INTPPERG_MIN_LAT_ACCEL = -0.016678;
  static final double INTPPERG_MAX_TOPO_LAT_SPEED = 0.193073;
  static final double INTPPERG_MIN_TOPO_LAT_SPEED = -0.193018;
  static final double INTPPERG_MAX_TOPO_LAT_ACCEL = 0.016639;
  static final double INTPPERG_MIN_TOPO_LAT_ACCEL = -0.016674;
  static final double INTPPERG_MAX_HELIO_LAT_SPEED = 1./0.;
  static final double INTPPERG_MIN_HELIO_LAT_SPEED = 1./0.;
  static final double INTPPERG_MAX_HELIO_LAT_ACCEL = 1./0.;
  static final double INTPPERG_MIN_HELIO_LAT_ACCEL = 1./0.;
  static final double INTPPERG_MAX_DIST_SPEED = 0.00000143617;
  static final double INTPPERG_MIN_DIST_SPEED = -0.00000143606;
  static final double INTPPERG_MAX_DIST_ACCEL = 0.0000000294169;
  static final double INTPPERG_MIN_DIST_ACCEL = -0.00000015879;
  static final double INTPPERG_MAX_TOPO_DIST_SPEED = 0.00000143615;
  static final double INTPPERG_MIN_TOPO_DIST_SPEED = -0.00000143607;
  static final double INTPPERG_MAX_TOPO_DIST_ACCEL = 0.000000029418;
  static final double INTPPERG_MIN_TOPO_DIST_ACCEL = -0.00000015880;
  static final double INTPPERG_MAX_HELIO_DIST_SPEED = 1./0.;
  static final double INTPPERG_MIN_HELIO_DIST_SPEED = 1./0.;
  static final double INTPPERG_MAX_HELIO_DIST_ACCEL = 1./0.;
  static final double INTPPERG_MIN_HELIO_DIST_ACCEL = 1./0.;
///////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
  // Speeds and accelerations in longitudinal direction:
  // Maximum geocentric speeds in longitudinal direction:
  static final double[] maxLonSpeed = new double[]
      {SURYA_MAX_LON_SPEED,   CHANDRA_MAX_LON_SPEED, BUDHA_MAX_LON_SPEED,
       SHUKRA_MAX_LON_SPEED,  MANGALA_MAX_LON_SPEED, GURU_MAX_LON_SPEED,
       SHANI_MAX_LON_SPEED,   URANUS_MAX_LON_SPEED,  NEPTUNE_MAX_LON_SPEED,
       PLUTO_MAX_LON_SPEED,   MNODE_MAX_LON_SPEED,   TNODE_MAX_LON_SPEED,
       MAPOGEE_MAX_LON_SPEED, OAPOGEE_MAX_LON_SPEED, 1./0,
       CHIRON_MAX_LON_SPEED,  PHOLUS_MAX_LON_SPEED,  CERES_MAX_LON_SPEED,
       PALLAS_MAX_LON_SPEED,  JUNO_MAX_LON_SPEED,    VESTA_MAX_LON_SPEED,
       INTPAPOG_MAX_LON_SPEED,INTPPERG_MAX_LON_SPEED};
  // Minimum geocentric speeds in longitudinal direction:
  static final double[] minLonSpeed = new double[]
      {SURYA_MIN_LON_SPEED,   CHANDRA_MIN_LON_SPEED, BUDHA_MIN_LON_SPEED,
       SHUKRA_MIN_LON_SPEED,  MANGALA_MIN_LON_SPEED, GURU_MIN_LON_SPEED,
       SHANI_MIN_LON_SPEED,   URANUS_MIN_LON_SPEED,  NEPTUNE_MIN_LON_SPEED,
       PLUTO_MIN_LON_SPEED,   MNODE_MIN_LON_SPEED,   TNODE_MIN_LON_SPEED,
       MAPOGEE_MIN_LON_SPEED, OAPOGEE_MIN_LON_SPEED, 1./0,
       CHIRON_MIN_LON_SPEED,  PHOLUS_MIN_LON_SPEED,  CERES_MIN_LON_SPEED,
       PALLAS_MIN_LON_SPEED,  JUNO_MIN_LON_SPEED,    VESTA_MIN_LON_SPEED,
       INTPAPOG_MIN_LON_SPEED,INTPPERG_MIN_LON_SPEED};
  // Maximum topocentric speeds in longitudinal direction, up to 50000m
  // altitude:
  static final double[] maxTopoLonSpeed = new double[]
      {SURYA_MAX_TOPO_LON_SPEED,   CHANDRA_MAX_TOPO_LON_SPEED,
       BUDHA_MAX_TOPO_LON_SPEED,   SHUKRA_MAX_TOPO_LON_SPEED,
       MANGALA_MAX_TOPO_LON_SPEED, GURU_MAX_TOPO_LON_SPEED,
       SHANI_MAX_TOPO_LON_SPEED,   URANUS_MAX_TOPO_LON_SPEED,
       NEPTUNE_MAX_TOPO_LON_SPEED, PLUTO_MAX_TOPO_LON_SPEED,
       MNODE_MAX_TOPO_LON_SPEED,   TNODE_MAX_TOPO_LON_SPEED,
       MAPOGEE_MAX_TOPO_LON_SPEED, OAPOGEE_MAX_TOPO_LON_SPEED,
       1./0,                       CHIRON_MAX_TOPO_LON_SPEED,
       PHOLUS_MAX_TOPO_LON_SPEED,  CERES_MAX_TOPO_LON_SPEED,
       PALLAS_MAX_TOPO_LON_SPEED,  JUNO_MAX_TOPO_LON_SPEED,
       VESTA_MAX_TOPO_LON_SPEED,   INTPAPOG_MAX_TOPO_LON_SPEED,
       INTPPERG_MAX_TOPO_LON_SPEED};
  // Minimum topocentric speeds in longitudinal direction, up to 50000m
  // altitude:
  static final double[] minTopoLonSpeed = new double[]
      {SURYA_MIN_TOPO_LON_SPEED,   CHANDRA_MIN_TOPO_LON_SPEED,
       BUDHA_MIN_TOPO_LON_SPEED,   SHUKRA_MIN_TOPO_LON_SPEED,
       MANGALA_MIN_TOPO_LON_SPEED, GURU_MIN_TOPO_LON_SPEED,
       SHANI_MIN_TOPO_LON_SPEED,   URANUS_MIN_TOPO_LON_SPEED,
       NEPTUNE_MIN_TOPO_LON_SPEED, PLUTO_MIN_TOPO_LON_SPEED,
       MNODE_MIN_TOPO_LON_SPEED,   TNODE_MIN_TOPO_LON_SPEED,
       MAPOGEE_MIN_TOPO_LON_SPEED, OAPOGEE_MIN_TOPO_LON_SPEED,
       1./0,                       CHIRON_MIN_TOPO_LON_SPEED,
       PHOLUS_MIN_TOPO_LON_SPEED,  CERES_MIN_TOPO_LON_SPEED,
       PALLAS_MIN_TOPO_LON_SPEED,  JUNO_MIN_TOPO_LON_SPEED,
       VESTA_MIN_TOPO_LON_SPEED,   INTPAPOG_MIN_TOPO_LON_SPEED,
       INTPPERG_MIN_TOPO_LON_SPEED};
  // Maximum heliocentric speeds in longitudinal direction:
  static final double[] maxHelioLonSpeed = new double[]
      {SURYA_MAX_HELIO_LON_SPEED,   CHANDRA_MAX_HELIO_LON_SPEED,
       BUDHA_MAX_HELIO_LON_SPEED,   SHUKRA_MAX_HELIO_LON_SPEED,
       MANGALA_MAX_HELIO_LON_SPEED, GURU_MAX_HELIO_LON_SPEED,
       SHANI_MAX_HELIO_LON_SPEED,   URANUS_MAX_HELIO_LON_SPEED,
       NEPTUNE_MAX_HELIO_LON_SPEED, PLUTO_MAX_HELIO_LON_SPEED,
       MNODE_MAX_HELIO_LON_SPEED,   TNODE_MAX_HELIO_LON_SPEED,
       MAPOGEE_MAX_HELIO_LON_SPEED, OAPOGEE_MAX_HELIO_LON_SPEED,
       1./0,                        CHIRON_MAX_HELIO_LON_SPEED,
       PHOLUS_MAX_HELIO_LON_SPEED,  CERES_MAX_HELIO_LON_SPEED,
       PALLAS_MAX_HELIO_LON_SPEED,  JUNO_MAX_HELIO_LON_SPEED,
       VESTA_MAX_HELIO_LON_SPEED,   INTPAPOG_MAX_HELIO_LON_SPEED,
       INTPPERG_MAX_HELIO_LON_SPEED};
  // Minimum heliocentric speeds in longitudinal direction:
  static final double[] minHelioLonSpeed = new double[]
      {SURYA_MIN_HELIO_LON_SPEED,   CHANDRA_MIN_HELIO_LON_SPEED,
       BUDHA_MIN_HELIO_LON_SPEED,   SHUKRA_MIN_HELIO_LON_SPEED,
       MANGALA_MIN_HELIO_LON_SPEED, GURU_MIN_HELIO_LON_SPEED,
       SHANI_MIN_HELIO_LON_SPEED,   URANUS_MIN_HELIO_LON_SPEED,
       NEPTUNE_MIN_HELIO_LON_SPEED, PLUTO_MIN_HELIO_LON_SPEED,
       MNODE_MIN_HELIO_LON_SPEED,   TNODE_MIN_HELIO_LON_SPEED,
       MAPOGEE_MIN_HELIO_LON_SPEED, OAPOGEE_MIN_HELIO_LON_SPEED,
       1./0,                        CHIRON_MIN_HELIO_LON_SPEED,
       PHOLUS_MIN_HELIO_LON_SPEED,  CERES_MIN_HELIO_LON_SPEED,
       PALLAS_MIN_HELIO_LON_SPEED,  JUNO_MIN_HELIO_LON_SPEED,
       VESTA_MIN_HELIO_LON_SPEED,   INTPAPOG_MIN_HELIO_LON_SPEED,
       INTPPERG_MIN_HELIO_LON_SPEED};
  // Maximum geocentric accelerations in longitudinal direction:
  static final double[] maxLonAccel = new double[]
      {SURYA_MAX_LON_ACCEL,   CHANDRA_MAX_LON_ACCEL, BUDHA_MAX_LON_ACCEL,
       SHUKRA_MAX_LON_ACCEL,  MANGALA_MAX_LON_ACCEL, GURU_MAX_LON_ACCEL,
       SHANI_MAX_LON_ACCEL,   URANUS_MAX_LON_ACCEL,  NEPTUNE_MAX_LON_ACCEL,
       PLUTO_MAX_LON_ACCEL,   MNODE_MAX_LON_ACCEL,   TNODE_MAX_LON_ACCEL,
       MAPOGEE_MAX_LON_ACCEL, OAPOGEE_MAX_LON_ACCEL, 1./0,
       CHIRON_MAX_LON_ACCEL,  PHOLUS_MAX_LON_ACCEL,  CERES_MAX_LON_ACCEL,
       PALLAS_MAX_LON_ACCEL,  JUNO_MAX_LON_ACCEL,    VESTA_MAX_LON_ACCEL,
       INTPAPOG_MAX_LON_ACCEL,INTPPERG_MAX_LON_ACCEL};
  // Minimum geocentric accelerations in longitudinal direction:
  static final double[] minLonAccel = new double[]
      {SURYA_MIN_LON_ACCEL,   CHANDRA_MIN_LON_ACCEL, BUDHA_MIN_LON_ACCEL,
       SHUKRA_MIN_LON_ACCEL,  MANGALA_MIN_LON_ACCEL, GURU_MIN_LON_ACCEL,
       SHANI_MIN_LON_ACCEL,   URANUS_MIN_LON_ACCEL,  NEPTUNE_MIN_LON_ACCEL,
       PLUTO_MIN_LON_ACCEL,   MNODE_MIN_LON_ACCEL,   TNODE_MIN_LON_ACCEL,
       MAPOGEE_MIN_LON_ACCEL, OAPOGEE_MIN_LON_ACCEL, 1./0,
       CHIRON_MIN_LON_ACCEL,  PHOLUS_MIN_LON_ACCEL,  CERES_MIN_LON_ACCEL,
       PALLAS_MIN_LON_ACCEL,  JUNO_MIN_LON_ACCEL,    VESTA_MIN_LON_ACCEL,
       INTPAPOG_MIN_LON_ACCEL,INTPPERG_MIN_LON_ACCEL};
  // Maximum topocentric accelerations in longitudinal direction, up to
  // 50000m altitude:
  static final double[] maxTopoLonAccel = new double[]
      {SURYA_MAX_TOPO_LON_ACCEL,   CHANDRA_MAX_TOPO_LON_ACCEL,
       BUDHA_MAX_TOPO_LON_ACCEL,   SHUKRA_MAX_TOPO_LON_ACCEL,
       MANGALA_MAX_TOPO_LON_ACCEL, GURU_MAX_TOPO_LON_ACCEL,
       SHANI_MAX_TOPO_LON_ACCEL,   URANUS_MAX_TOPO_LON_ACCEL,
       NEPTUNE_MAX_TOPO_LON_ACCEL, PLUTO_MAX_TOPO_LON_ACCEL,
       MNODE_MAX_TOPO_LON_ACCEL,   TNODE_MAX_TOPO_LON_ACCEL,
       MAPOGEE_MAX_TOPO_LON_ACCEL, OAPOGEE_MAX_TOPO_LON_ACCEL,
       1./0,                       CHIRON_MAX_TOPO_LON_ACCEL,
       PHOLUS_MAX_TOPO_LON_ACCEL,  CERES_MAX_TOPO_LON_ACCEL,
       PALLAS_MAX_TOPO_LON_ACCEL,  JUNO_MAX_TOPO_LON_ACCEL,
       VESTA_MAX_TOPO_LON_ACCEL,   INTPAPOG_MAX_TOPO_LON_ACCEL,
       INTPPERG_MAX_TOPO_LON_ACCEL};
  // Minimum topocentric accelerations in longitudinal direction, up to
  // 50000m altitude:
  static final double[] minTopoLonAccel = new double[]
      {SURYA_MIN_TOPO_LON_ACCEL,   CHANDRA_MIN_TOPO_LON_ACCEL,
       BUDHA_MIN_TOPO_LON_ACCEL,   SHUKRA_MIN_TOPO_LON_ACCEL,
       MANGALA_MIN_TOPO_LON_ACCEL, GURU_MIN_TOPO_LON_ACCEL,
       SHANI_MIN_TOPO_LON_ACCEL,   URANUS_MIN_TOPO_LON_ACCEL,
       NEPTUNE_MIN_TOPO_LON_ACCEL, PLUTO_MIN_TOPO_LON_ACCEL,
       MNODE_MIN_TOPO_LON_ACCEL,   TNODE_MIN_TOPO_LON_ACCEL,
       MAPOGEE_MIN_TOPO_LON_ACCEL, OAPOGEE_MIN_TOPO_LON_ACCEL,
       1./0,                       CHIRON_MIN_TOPO_LON_ACCEL,
       PHOLUS_MIN_TOPO_LON_ACCEL,  CERES_MIN_TOPO_LON_ACCEL,
       PALLAS_MIN_TOPO_LON_ACCEL,  JUNO_MIN_TOPO_LON_ACCEL,
       VESTA_MIN_TOPO_LON_ACCEL,   INTPAPOG_MIN_TOPO_LON_ACCEL,
       INTPPERG_MIN_TOPO_LON_ACCEL};
  // Maximum heliocentric accelerations in longitudinal direction:
  static final double[] maxHelioLonAccel = new double[]
      {SURYA_MAX_HELIO_LON_ACCEL,   CHANDRA_MAX_HELIO_LON_ACCEL,
       BUDHA_MAX_HELIO_LON_ACCEL,   SHUKRA_MAX_HELIO_LON_ACCEL,
       MANGALA_MAX_HELIO_LON_ACCEL, GURU_MAX_HELIO_LON_ACCEL,
       SHANI_MAX_HELIO_LON_ACCEL,   URANUS_MAX_HELIO_LON_ACCEL,
       NEPTUNE_MAX_HELIO_LON_ACCEL, PLUTO_MAX_HELIO_LON_ACCEL,
       MNODE_MAX_HELIO_LON_ACCEL,   TNODE_MAX_HELIO_LON_ACCEL,
       MAPOGEE_MAX_HELIO_LON_ACCEL, OAPOGEE_MAX_HELIO_LON_ACCEL,
       1./0,                        CHIRON_MAX_HELIO_LON_ACCEL,
       PHOLUS_MAX_HELIO_LON_ACCEL,  CERES_MAX_HELIO_LON_ACCEL,
       PALLAS_MAX_HELIO_LON_ACCEL,  JUNO_MAX_HELIO_LON_ACCEL,
       VESTA_MAX_HELIO_LON_ACCEL,   INTPAPOG_MAX_HELIO_LON_ACCEL,
       INTPPERG_MAX_HELIO_LON_ACCEL};
  // Minimum heliocentric accelerations in longitudinal direction:
  static final double[] minHelioLonAccel = new double[]
      {SURYA_MIN_HELIO_LON_ACCEL,   CHANDRA_MIN_HELIO_LON_ACCEL,
       BUDHA_MIN_HELIO_LON_ACCEL,   SHUKRA_MIN_HELIO_LON_ACCEL,
       MANGALA_MIN_HELIO_LON_ACCEL, GURU_MIN_HELIO_LON_ACCEL,
       SHANI_MIN_HELIO_LON_ACCEL,   URANUS_MIN_HELIO_LON_ACCEL,
       NEPTUNE_MIN_HELIO_LON_ACCEL, PLUTO_MIN_HELIO_LON_ACCEL,
       MNODE_MIN_HELIO_LON_ACCEL,   TNODE_MIN_HELIO_LON_ACCEL,
       MAPOGEE_MIN_HELIO_LON_ACCEL, OAPOGEE_MIN_HELIO_LON_ACCEL,
       1./0,                        CHIRON_MIN_HELIO_LON_ACCEL,
       PHOLUS_MIN_HELIO_LON_ACCEL,  CERES_MIN_HELIO_LON_ACCEL,
       PALLAS_MIN_HELIO_LON_ACCEL,  JUNO_MIN_HELIO_LON_ACCEL,
       VESTA_MIN_HELIO_LON_ACCEL,   INTPAPOG_MIN_HELIO_LON_ACCEL,
       INTPPERG_MIN_HELIO_LON_ACCEL};
  // Speeds and accelerations in latitudinal direction:
  // Maximum geocentric speeds in latitudinal direction:
  static final double[] maxLatSpeed = new double[]
      {SURYA_MAX_LAT_SPEED,   CHANDRA_MAX_LAT_SPEED, BUDHA_MAX_LAT_SPEED,
       SHUKRA_MAX_LAT_SPEED,  MANGALA_MAX_LAT_SPEED, GURU_MAX_LAT_SPEED,
       SHANI_MAX_LAT_SPEED,   URANUS_MAX_LAT_SPEED,  NEPTUNE_MAX_LAT_SPEED,
       PLUTO_MAX_LAT_SPEED,   MNODE_MAX_LAT_SPEED,   TNODE_MAX_LAT_SPEED,
       MAPOGEE_MAX_LAT_SPEED, OAPOGEE_MAX_LAT_SPEED, 1./0,
       CHIRON_MAX_LAT_SPEED,  PHOLUS_MAX_LAT_SPEED,  CERES_MAX_LAT_SPEED,
       PALLAS_MAX_LAT_SPEED,  JUNO_MAX_LAT_SPEED,    VESTA_MAX_LAT_SPEED,
       INTPAPOG_MAX_LAT_SPEED,INTPPERG_MAX_LAT_SPEED};
  // Minimum geocentric speeds in latitudinal direction:
  static final double[] minLatSpeed = new double[]
      {SURYA_MIN_LAT_SPEED,   CHANDRA_MIN_LAT_SPEED, BUDHA_MIN_LAT_SPEED,
       SHUKRA_MIN_LAT_SPEED,  MANGALA_MIN_LAT_SPEED, GURU_MIN_LAT_SPEED,
       SHANI_MIN_LAT_SPEED,   URANUS_MIN_LAT_SPEED,  NEPTUNE_MIN_LAT_SPEED,
       PLUTO_MIN_LAT_SPEED,   MNODE_MIN_LAT_SPEED,   TNODE_MIN_LAT_SPEED,
       MAPOGEE_MIN_LAT_SPEED, OAPOGEE_MIN_LAT_SPEED, 1./0,
       CHIRON_MIN_LAT_SPEED,  PHOLUS_MIN_LAT_SPEED,  CERES_MIN_LAT_SPEED,
       PALLAS_MIN_LAT_SPEED,  JUNO_MIN_LAT_SPEED,    VESTA_MIN_LAT_SPEED,
       INTPAPOG_MIN_LAT_SPEED,INTPPERG_MIN_LAT_SPEED};
  // Maximum topocentric speeds in latitudinal direction, up to 50000m
  // altitude:
  static final double[] maxTopoLatSpeed = new double[]
      {SURYA_MAX_TOPO_LAT_SPEED,   CHANDRA_MAX_TOPO_LAT_SPEED,
       BUDHA_MAX_TOPO_LAT_SPEED,   SHUKRA_MAX_TOPO_LAT_SPEED,
       MANGALA_MAX_TOPO_LAT_SPEED, GURU_MAX_TOPO_LAT_SPEED,
       SHANI_MAX_TOPO_LAT_SPEED,   URANUS_MAX_TOPO_LAT_SPEED,
       NEPTUNE_MAX_TOPO_LAT_SPEED, PLUTO_MAX_TOPO_LAT_SPEED,
       MNODE_MAX_TOPO_LAT_SPEED,   TNODE_MAX_TOPO_LAT_SPEED,
       MAPOGEE_MAX_TOPO_LAT_SPEED, OAPOGEE_MAX_TOPO_LAT_SPEED,
       1./0,                       CHIRON_MAX_TOPO_LAT_SPEED,
       PHOLUS_MAX_TOPO_LAT_SPEED,  CERES_MAX_TOPO_LAT_SPEED,
       PALLAS_MAX_TOPO_LAT_SPEED,  JUNO_MAX_TOPO_LAT_SPEED,
       VESTA_MAX_TOPO_LAT_SPEED,   INTPAPOG_MAX_TOPO_LAT_SPEED,
       INTPPERG_MAX_TOPO_LAT_SPEED};
  // Minimum topocentric speeds in latitudinal direction, up to 50000m
  // altitude:
  static final double[] minTopoLatSpeed = new double[]
      {SURYA_MIN_TOPO_LAT_SPEED,   CHANDRA_MIN_TOPO_LAT_SPEED,
       BUDHA_MIN_TOPO_LAT_SPEED,   SHUKRA_MIN_TOPO_LAT_SPEED,
       MANGALA_MIN_TOPO_LAT_SPEED, GURU_MIN_TOPO_LAT_SPEED,
       SHANI_MIN_TOPO_LAT_SPEED,   URANUS_MIN_TOPO_LAT_SPEED,
       NEPTUNE_MIN_TOPO_LAT_SPEED, PLUTO_MIN_TOPO_LAT_SPEED,
       MNODE_MIN_TOPO_LAT_SPEED,   TNODE_MIN_TOPO_LAT_SPEED,
       MAPOGEE_MIN_TOPO_LAT_SPEED, OAPOGEE_MIN_TOPO_LAT_SPEED,
       1./0,                       CHIRON_MIN_TOPO_LAT_SPEED,
       PHOLUS_MIN_TOPO_LAT_SPEED,  CERES_MIN_TOPO_LAT_SPEED,
       PALLAS_MIN_TOPO_LAT_SPEED,  JUNO_MIN_TOPO_LAT_SPEED,
       VESTA_MIN_TOPO_LAT_SPEED,   INTPAPOG_MIN_TOPO_LAT_SPEED,
       INTPPERG_MIN_TOPO_LAT_SPEED};
  // Maximum heliocentric speeds in latitudinal direction:
  static final double[] maxHelioLatSpeed = new double[]
      {SURYA_MAX_HELIO_LAT_SPEED,   CHANDRA_MAX_HELIO_LAT_SPEED,
       BUDHA_MAX_HELIO_LAT_SPEED,   SHUKRA_MAX_HELIO_LAT_SPEED,
       MANGALA_MAX_HELIO_LAT_SPEED, GURU_MAX_HELIO_LAT_SPEED,
       SHANI_MAX_HELIO_LAT_SPEED,   URANUS_MAX_HELIO_LAT_SPEED,
       NEPTUNE_MAX_HELIO_LAT_SPEED, PLUTO_MAX_HELIO_LAT_SPEED,
       MNODE_MAX_HELIO_LAT_SPEED,   TNODE_MAX_HELIO_LAT_SPEED,
       MAPOGEE_MAX_HELIO_LAT_SPEED, OAPOGEE_MAX_HELIO_LAT_SPEED,
       1./0,                        CHIRON_MAX_HELIO_LAT_SPEED,
       PHOLUS_MAX_HELIO_LAT_SPEED,  CERES_MAX_HELIO_LAT_SPEED,
       PALLAS_MAX_HELIO_LAT_SPEED,  JUNO_MAX_HELIO_LAT_SPEED,
       VESTA_MAX_HELIO_LAT_SPEED,   INTPAPOG_MAX_HELIO_LAT_SPEED,
       INTPPERG_MAX_HELIO_LAT_SPEED};
  // Minimum heliocentric speeds in latitudinal direction:
  static final double[] minHelioLatSpeed = new double[]
      {SURYA_MIN_HELIO_LAT_SPEED,   CHANDRA_MIN_HELIO_LAT_SPEED,
       BUDHA_MIN_HELIO_LAT_SPEED,   SHUKRA_MIN_HELIO_LAT_SPEED,
       MANGALA_MIN_HELIO_LAT_SPEED, GURU_MIN_HELIO_LAT_SPEED,
       SHANI_MIN_HELIO_LAT_SPEED,   URANUS_MIN_HELIO_LAT_SPEED,
       NEPTUNE_MIN_HELIO_LAT_SPEED, PLUTO_MIN_HELIO_LAT_SPEED,
       MNODE_MIN_HELIO_LAT_SPEED,   TNODE_MIN_HELIO_LAT_SPEED,
       MAPOGEE_MIN_HELIO_LAT_SPEED, OAPOGEE_MIN_HELIO_LAT_SPEED,
       1./0,                        CHIRON_MIN_HELIO_LAT_SPEED,
       PHOLUS_MIN_HELIO_LAT_SPEED,  CERES_MIN_HELIO_LAT_SPEED,
       PALLAS_MIN_HELIO_LAT_SPEED,  JUNO_MIN_HELIO_LAT_SPEED,
       VESTA_MIN_HELIO_LAT_SPEED,   INTPAPOG_MAX_HELIO_LAT_SPEED,
       INTPPERG_MIN_HELIO_LAT_SPEED};
  // Maximum geocentric accelerations in latitudinal direction:
  static final double[] maxLatAccel = new double[]
      {SURYA_MAX_LAT_ACCEL,   CHANDRA_MAX_LAT_ACCEL, BUDHA_MAX_LAT_ACCEL,
       SHUKRA_MAX_LAT_ACCEL,  MANGALA_MAX_LAT_ACCEL, GURU_MAX_LAT_ACCEL,
       SHANI_MAX_LAT_ACCEL,   URANUS_MAX_LAT_ACCEL,  NEPTUNE_MAX_LAT_ACCEL,
       PLUTO_MAX_LAT_ACCEL,   MNODE_MAX_LAT_ACCEL,   TNODE_MAX_LAT_ACCEL,
       MAPOGEE_MAX_LAT_ACCEL, OAPOGEE_MAX_LAT_ACCEL, 1./0,
       CHIRON_MAX_LAT_ACCEL,  PHOLUS_MAX_LAT_ACCEL,  CERES_MAX_LAT_ACCEL,
       PALLAS_MAX_LAT_ACCEL,  JUNO_MAX_LAT_ACCEL,    VESTA_MAX_LAT_ACCEL,
       INTPAPOG_MAX_LAT_ACCEL,INTPPERG_MAX_LAT_ACCEL};
  // Minimum geocentric accelerations in latitudinal direction:
  static final double[] minLatAccel = new double[]
      {SURYA_MIN_LAT_ACCEL,   CHANDRA_MIN_LAT_ACCEL, BUDHA_MIN_LAT_ACCEL,
       SHUKRA_MIN_LAT_ACCEL,  MANGALA_MIN_LAT_ACCEL, GURU_MIN_LAT_ACCEL,
       SHANI_MIN_LAT_ACCEL,   URANUS_MIN_LAT_ACCEL,  NEPTUNE_MIN_LAT_ACCEL,
       PLUTO_MIN_LAT_ACCEL,   MNODE_MIN_LAT_ACCEL,   TNODE_MIN_LAT_ACCEL,
       MAPOGEE_MIN_LAT_ACCEL, OAPOGEE_MIN_LAT_ACCEL, 1./0,
       CHIRON_MIN_LAT_ACCEL,  PHOLUS_MIN_LAT_ACCEL,  CERES_MIN_LAT_ACCEL,
       PALLAS_MIN_LAT_ACCEL,  JUNO_MIN_LAT_ACCEL,    VESTA_MIN_LAT_ACCEL,
       INTPAPOG_MIN_LAT_ACCEL,INTPPERG_MIN_LAT_ACCEL};
  // Maximum topocentric accelerations in latitudinal direction, up to
  // 50000m altitude:
  static final double[] maxTopoLatAccel = new double[]
      {SURYA_MAX_TOPO_LAT_ACCEL,   CHANDRA_MAX_TOPO_LAT_ACCEL,
       BUDHA_MAX_TOPO_LAT_ACCEL,   SHUKRA_MAX_TOPO_LAT_ACCEL,
       MANGALA_MAX_TOPO_LAT_ACCEL, GURU_MAX_TOPO_LAT_ACCEL,
       SHANI_MAX_TOPO_LAT_ACCEL,   URANUS_MAX_TOPO_LAT_ACCEL,
       NEPTUNE_MAX_TOPO_LAT_ACCEL, PLUTO_MAX_TOPO_LAT_ACCEL,
       MNODE_MAX_TOPO_LAT_ACCEL,   TNODE_MAX_TOPO_LAT_ACCEL,
       MAPOGEE_MAX_TOPO_LAT_ACCEL, OAPOGEE_MAX_TOPO_LAT_ACCEL,
       1./0,                       CHIRON_MAX_TOPO_LAT_ACCEL,
       PHOLUS_MAX_TOPO_LAT_ACCEL,  CERES_MAX_TOPO_LAT_ACCEL,
       PALLAS_MAX_TOPO_LAT_ACCEL,  JUNO_MAX_TOPO_LAT_ACCEL,
       VESTA_MAX_TOPO_LAT_ACCEL,   INTPAPOG_MAX_TOPO_LAT_ACCEL,
       INTPPERG_MAX_TOPO_LAT_ACCEL};
  // Minimum topocentric accelerations in latitudinal direction, up to
  // 50000m altitude:
  static final double[] minTopoLatAccel = new double[]
      {SURYA_MIN_TOPO_LAT_ACCEL,   CHANDRA_MIN_TOPO_LAT_ACCEL,
       BUDHA_MIN_TOPO_LAT_ACCEL,   SHUKRA_MIN_TOPO_LAT_ACCEL,
       MANGALA_MIN_TOPO_LAT_ACCEL, GURU_MIN_TOPO_LAT_ACCEL,
       SHANI_MIN_TOPO_LAT_ACCEL,   URANUS_MIN_TOPO_LAT_ACCEL,
       NEPTUNE_MIN_TOPO_LAT_ACCEL, PLUTO_MIN_TOPO_LAT_ACCEL,
       MNODE_MIN_TOPO_LAT_ACCEL,   TNODE_MIN_TOPO_LAT_ACCEL,
       MAPOGEE_MIN_TOPO_LAT_ACCEL, OAPOGEE_MIN_TOPO_LAT_ACCEL,
       1./0,                       CHIRON_MIN_TOPO_LAT_ACCEL,
       PHOLUS_MIN_TOPO_LAT_ACCEL,  CERES_MIN_TOPO_LAT_ACCEL,
       PALLAS_MIN_TOPO_LAT_ACCEL,  JUNO_MIN_TOPO_LAT_ACCEL,
       VESTA_MIN_TOPO_LAT_ACCEL,   INTPAPOG_MIN_TOPO_LAT_ACCEL,
       INTPPERG_MIN_TOPO_LAT_ACCEL};
  // Maximum heliocentric accelerations in latitudinal direction:
  static final double[] maxHelioLatAccel = new double[]
      {SURYA_MAX_HELIO_LAT_ACCEL,   CHANDRA_MAX_HELIO_LAT_ACCEL,
       BUDHA_MAX_HELIO_LAT_ACCEL,   SHUKRA_MAX_HELIO_LAT_ACCEL,
       MANGALA_MAX_HELIO_LAT_ACCEL, GURU_MAX_HELIO_LAT_ACCEL,
       SHANI_MAX_HELIO_LAT_ACCEL,   URANUS_MAX_HELIO_LAT_ACCEL,
       NEPTUNE_MAX_HELIO_LAT_ACCEL, PLUTO_MAX_HELIO_LAT_ACCEL,
       MNODE_MAX_HELIO_LAT_ACCEL,   TNODE_MAX_HELIO_LAT_ACCEL,
       MAPOGEE_MAX_HELIO_LAT_ACCEL, OAPOGEE_MAX_HELIO_LAT_ACCEL,
       1./0,                        CHIRON_MAX_HELIO_LAT_ACCEL,
       PHOLUS_MAX_HELIO_LAT_ACCEL,  CERES_MAX_HELIO_LAT_ACCEL,
       PALLAS_MAX_HELIO_LAT_ACCEL,  JUNO_MAX_HELIO_LAT_ACCEL,
       VESTA_MAX_HELIO_LAT_ACCEL,   INTPAPOG_MAX_HELIO_LAT_ACCEL,
       INTPPERG_MAX_HELIO_LAT_ACCEL};
  // Minimum heliocentric accelerations in latitudinal direction:
  static final double[] minHelioLatAccel = new double[]
      {SURYA_MIN_HELIO_LAT_ACCEL,   CHANDRA_MIN_HELIO_LAT_ACCEL,
       BUDHA_MIN_HELIO_LAT_ACCEL,   SHUKRA_MIN_HELIO_LAT_ACCEL,
       MANGALA_MIN_HELIO_LAT_ACCEL, GURU_MIN_HELIO_LAT_ACCEL,
       SHANI_MIN_HELIO_LAT_ACCEL,   URANUS_MIN_HELIO_LAT_ACCEL,
       NEPTUNE_MIN_HELIO_LAT_ACCEL, PLUTO_MIN_HELIO_LAT_ACCEL,
       MNODE_MIN_HELIO_LAT_ACCEL,   TNODE_MIN_HELIO_LAT_ACCEL,
       MAPOGEE_MIN_HELIO_LAT_ACCEL, OAPOGEE_MIN_HELIO_LAT_ACCEL,
       1./0,                        CHIRON_MIN_HELIO_LAT_ACCEL,
       PHOLUS_MIN_HELIO_LAT_ACCEL,  CERES_MIN_HELIO_LAT_ACCEL,
       PALLAS_MIN_HELIO_LAT_ACCEL,  JUNO_MIN_HELIO_LAT_ACCEL,
       VESTA_MIN_HELIO_LAT_ACCEL,   INTPAPOG_MIN_HELIO_LAT_ACCEL,
       INTPPERG_MIN_HELIO_LAT_ACCEL};
  // Speeds and accelerations in the distance to the earth:
  // Maximum geocentric speeds in the distance to the earth:
  static final double[] maxDistSpeed = new double[]
      {SURYA_MAX_DIST_SPEED,   CHANDRA_MAX_DIST_SPEED, BUDHA_MAX_DIST_SPEED,
       SHUKRA_MAX_DIST_SPEED,  MANGALA_MAX_DIST_SPEED, GURU_MAX_DIST_SPEED,
       SHANI_MAX_DIST_SPEED,   URANUS_MAX_DIST_SPEED,  NEPTUNE_MAX_DIST_SPEED,
       PLUTO_MAX_DIST_SPEED,   MNODE_MAX_DIST_SPEED,   TNODE_MAX_DIST_SPEED,
       MAPOGEE_MAX_DIST_SPEED, OAPOGEE_MAX_DIST_SPEED, 1./0.,
       CHIRON_MAX_DIST_SPEED,  PHOLUS_MAX_DIST_SPEED,  CERES_MAX_DIST_SPEED,
       PALLAS_MAX_DIST_SPEED,  JUNO_MAX_DIST_SPEED,    VESTA_MAX_DIST_SPEED,
       INTPAPOG_MAX_DIST_SPEED,INTPPERG_MAX_DIST_SPEED};
  // Minimum geocentric speeds in the direction of the distance to the earth:
  static final double[] minDistSpeed = new double[]
      {SURYA_MIN_DIST_SPEED,   CHANDRA_MIN_DIST_SPEED, BUDHA_MIN_DIST_SPEED,
       SHUKRA_MIN_DIST_SPEED,  MANGALA_MIN_DIST_SPEED, GURU_MIN_DIST_SPEED,
       SHANI_MIN_DIST_SPEED,   URANUS_MIN_DIST_SPEED,  NEPTUNE_MIN_DIST_SPEED,
       PLUTO_MIN_DIST_SPEED,   MNODE_MIN_DIST_SPEED,   TNODE_MIN_DIST_SPEED,
       MAPOGEE_MIN_DIST_SPEED, OAPOGEE_MIN_DIST_SPEED, 1./0.,
       CHIRON_MIN_DIST_SPEED,  PHOLUS_MIN_DIST_SPEED,  CERES_MIN_DIST_SPEED,
       PALLAS_MIN_DIST_SPEED,  JUNO_MIN_DIST_SPEED,    VESTA_MIN_DIST_SPEED,
       INTPAPOG_MIN_DIST_SPEED,INTPPERG_MIN_DIST_SPEED};
  // Maximum topocentric speeds in the distance to the earth:
  static final double[] maxTopoDistSpeed = new double[]
      {SURYA_MAX_TOPO_DIST_SPEED,   CHANDRA_MAX_TOPO_DIST_SPEED,
       BUDHA_MAX_TOPO_DIST_SPEED,   SHUKRA_MAX_TOPO_DIST_SPEED,
       MANGALA_MAX_TOPO_DIST_SPEED, GURU_MAX_TOPO_DIST_SPEED,
       SHANI_MAX_TOPO_DIST_SPEED,   URANUS_MAX_TOPO_DIST_SPEED,
       NEPTUNE_MAX_TOPO_DIST_SPEED, PLUTO_MAX_TOPO_DIST_SPEED,
       MNODE_MAX_TOPO_DIST_SPEED,   TNODE_MAX_TOPO_DIST_SPEED,
       MAPOGEE_MAX_TOPO_DIST_SPEED, OAPOGEE_MAX_TOPO_DIST_SPEED,
       1./0.,                       CHIRON_MAX_TOPO_DIST_SPEED,
       PHOLUS_MAX_TOPO_DIST_SPEED,  CERES_MAX_TOPO_DIST_SPEED,
       PALLAS_MAX_TOPO_DIST_SPEED,  JUNO_MAX_TOPO_DIST_SPEED,
       VESTA_MAX_TOPO_DIST_SPEED,   INTPAPOG_MAX_TOPO_DIST_SPEED,
       INTPPERG_MAX_TOPO_DIST_SPEED};
  // Minimum topocentric speeds in the distance to the earth:
  static final double[] minTopoDistSpeed = new double[]
      {SURYA_MIN_TOPO_DIST_SPEED,   CHANDRA_MIN_TOPO_DIST_SPEED,
       BUDHA_MIN_TOPO_DIST_SPEED,   SHUKRA_MIN_TOPO_DIST_SPEED,
       MANGALA_MIN_TOPO_DIST_SPEED, GURU_MIN_TOPO_DIST_SPEED,
       SHANI_MIN_TOPO_DIST_SPEED,   URANUS_MIN_TOPO_DIST_SPEED,
       NEPTUNE_MIN_TOPO_DIST_SPEED, PLUTO_MIN_TOPO_DIST_SPEED,
       MNODE_MIN_TOPO_DIST_SPEED,   TNODE_MIN_TOPO_DIST_SPEED,
       MAPOGEE_MIN_TOPO_DIST_SPEED, OAPOGEE_MIN_TOPO_DIST_SPEED,
       1./0.,                       CHIRON_MIN_TOPO_DIST_SPEED,
       PHOLUS_MIN_TOPO_DIST_SPEED,  CERES_MIN_TOPO_DIST_SPEED,
       PALLAS_MIN_TOPO_DIST_SPEED,  JUNO_MIN_TOPO_DIST_SPEED,
       VESTA_MIN_TOPO_DIST_SPEED,   INTPAPOG_MIN_TOPO_DIST_SPEED,
       INTPPERG_MIN_TOPO_DIST_SPEED};
  // Maximum speeds in the distance to the sun:
  static final double[] maxHelioDistSpeed = new double[]
      {SURYA_MAX_HELIO_DIST_SPEED,   CHANDRA_MAX_HELIO_DIST_SPEED,
       BUDHA_MAX_HELIO_DIST_SPEED,   SHUKRA_MAX_HELIO_DIST_SPEED,
       MANGALA_MAX_HELIO_DIST_SPEED, GURU_MAX_HELIO_DIST_SPEED,
       SHANI_MAX_HELIO_DIST_SPEED,   URANUS_MAX_HELIO_DIST_SPEED,
       NEPTUNE_MAX_HELIO_DIST_SPEED, PLUTO_MAX_HELIO_DIST_SPEED,
       MNODE_MAX_HELIO_DIST_SPEED,   TNODE_MAX_HELIO_DIST_SPEED,
       MAPOGEE_MAX_HELIO_DIST_SPEED, OAPOGEE_MAX_HELIO_DIST_SPEED,
       1./0.,                        CHIRON_MAX_HELIO_DIST_SPEED,
       PHOLUS_MAX_HELIO_DIST_SPEED,  CERES_MAX_HELIO_DIST_SPEED,
       PALLAS_MAX_HELIO_DIST_SPEED,  JUNO_MAX_HELIO_DIST_SPEED,
       VESTA_MAX_HELIO_DIST_SPEED,   INTPAPOG_MAX_HELIO_DIST_SPEED,
       INTPPERG_MAX_HELIO_DIST_SPEED};
  // Minimum speeds in the distance to the sun:
  static final double[] minHelioDistSpeed = new double[]
      {SURYA_MIN_HELIO_DIST_SPEED,   CHANDRA_MIN_HELIO_DIST_SPEED,
       BUDHA_MIN_HELIO_DIST_SPEED,   SHUKRA_MIN_HELIO_DIST_SPEED,
       MANGALA_MIN_HELIO_DIST_SPEED, GURU_MIN_HELIO_DIST_SPEED,
       SHANI_MIN_HELIO_DIST_SPEED,   URANUS_MIN_HELIO_DIST_SPEED,
       NEPTUNE_MIN_HELIO_DIST_SPEED, PLUTO_MIN_HELIO_DIST_SPEED,
       MNODE_MIN_HELIO_DIST_SPEED,   TNODE_MIN_HELIO_DIST_SPEED,
       MAPOGEE_MIN_HELIO_DIST_SPEED, OAPOGEE_MIN_HELIO_DIST_SPEED,
       1./0.,                        CHIRON_MIN_HELIO_DIST_SPEED,
       PHOLUS_MIN_HELIO_DIST_SPEED,  CERES_MIN_HELIO_DIST_SPEED,
       PALLAS_MIN_HELIO_DIST_SPEED,  JUNO_MIN_HELIO_DIST_SPEED,
       VESTA_MIN_HELIO_DIST_SPEED,   INTPAPOG_MIN_HELIO_DIST_SPEED,
       INTPPERG_MIN_HELIO_DIST_SPEED};
  // Maximum geocentric accelerations in the distance to the earth:
  static final double[] maxDistAccel = new double[]
      {SURYA_MAX_DIST_ACCEL,   CHANDRA_MAX_DIST_ACCEL, BUDHA_MAX_DIST_ACCEL,
       SHUKRA_MAX_DIST_ACCEL,  MANGALA_MAX_DIST_ACCEL, GURU_MAX_DIST_ACCEL,
       SHANI_MAX_DIST_ACCEL,   URANUS_MAX_DIST_ACCEL,  NEPTUNE_MAX_DIST_ACCEL,
       PLUTO_MAX_DIST_ACCEL,   MNODE_MAX_DIST_ACCEL,   TNODE_MAX_DIST_ACCEL,
       MAPOGEE_MAX_DIST_ACCEL, OAPOGEE_MAX_DIST_ACCEL, 1./0.,
       CHIRON_MAX_DIST_ACCEL,  PHOLUS_MAX_DIST_ACCEL,  CERES_MAX_DIST_ACCEL,
       PALLAS_MAX_DIST_ACCEL,  JUNO_MAX_DIST_ACCEL,    VESTA_MAX_DIST_ACCEL,
       INTPAPOG_MAX_DIST_ACCEL,INTPPERG_MAX_DIST_ACCEL};
  // Minimum geocentric accelerations in the distance to the earth:
  static final double[] minDistAccel = new double[]
      {SURYA_MIN_DIST_ACCEL,   CHANDRA_MIN_DIST_ACCEL, BUDHA_MIN_DIST_ACCEL,
       SHUKRA_MIN_DIST_ACCEL,  MANGALA_MIN_DIST_ACCEL, GURU_MIN_DIST_ACCEL,
       SHANI_MIN_DIST_ACCEL,   URANUS_MIN_DIST_ACCEL,  NEPTUNE_MIN_DIST_ACCEL,
       PLUTO_MIN_DIST_ACCEL,   MNODE_MIN_DIST_ACCEL,   TNODE_MIN_DIST_ACCEL,
       MAPOGEE_MIN_DIST_ACCEL, OAPOGEE_MIN_DIST_ACCEL, 1./0.,
       CHIRON_MIN_DIST_ACCEL,  PHOLUS_MIN_DIST_ACCEL,  CERES_MIN_DIST_ACCEL,
       PALLAS_MIN_DIST_ACCEL,  JUNO_MIN_DIST_ACCEL,    VESTA_MIN_DIST_ACCEL,
       INTPAPOG_MIN_DIST_ACCEL,INTPPERG_MIN_DIST_ACCEL};
  // Maximum topocentric accelerations in the distance to the earth:
  static final double[] maxTopoDistAccel = new double[]
      {SURYA_MAX_TOPO_DIST_ACCEL,   CHANDRA_MAX_TOPO_DIST_ACCEL,
       BUDHA_MAX_TOPO_DIST_ACCEL,   SHUKRA_MAX_TOPO_DIST_ACCEL,
       MANGALA_MAX_TOPO_DIST_ACCEL, GURU_MAX_TOPO_DIST_ACCEL,
       SHANI_MAX_TOPO_DIST_ACCEL,   URANUS_MAX_TOPO_DIST_ACCEL,
       NEPTUNE_MAX_TOPO_DIST_ACCEL, PLUTO_MAX_TOPO_DIST_ACCEL,
       MNODE_MAX_TOPO_DIST_ACCEL,   TNODE_MAX_TOPO_DIST_ACCEL,
       MAPOGEE_MAX_TOPO_DIST_ACCEL, OAPOGEE_MAX_TOPO_DIST_ACCEL,
       1./0.,                       CHIRON_MAX_TOPO_DIST_ACCEL,
       PHOLUS_MAX_TOPO_DIST_ACCEL,  CERES_MAX_TOPO_DIST_ACCEL,
       PALLAS_MAX_TOPO_DIST_ACCEL,  JUNO_MAX_TOPO_DIST_ACCEL,
       VESTA_MAX_TOPO_DIST_ACCEL,   INTPAPOG_MAX_TOPO_DIST_ACCEL,
       INTPPERG_MAX_TOPO_DIST_ACCEL};
  // Minimum topocentric accelerations in the distance to the earth:
  static final double[] minTopoDistAccel = new double[]
      {SURYA_MIN_TOPO_DIST_ACCEL,   CHANDRA_MIN_TOPO_DIST_ACCEL,
       BUDHA_MIN_TOPO_DIST_ACCEL,   SHUKRA_MIN_TOPO_DIST_ACCEL,
       MANGALA_MIN_TOPO_DIST_ACCEL, GURU_MIN_TOPO_DIST_ACCEL,
       SHANI_MIN_TOPO_DIST_ACCEL,   URANUS_MIN_TOPO_DIST_ACCEL,
       NEPTUNE_MIN_TOPO_DIST_ACCEL, PLUTO_MIN_TOPO_DIST_ACCEL,
       MNODE_MIN_TOPO_DIST_ACCEL,   TNODE_MIN_TOPO_DIST_ACCEL,
       MAPOGEE_MIN_TOPO_DIST_ACCEL, OAPOGEE_MIN_TOPO_DIST_ACCEL,
       1./0.,                       CHIRON_MIN_TOPO_DIST_ACCEL,
       PHOLUS_MIN_TOPO_DIST_ACCEL,  CERES_MIN_TOPO_DIST_ACCEL,
       PALLAS_MIN_TOPO_DIST_ACCEL,  JUNO_MIN_TOPO_DIST_ACCEL,
       VESTA_MIN_TOPO_DIST_ACCEL,   INTPAPOG_MIN_TOPO_DIST_ACCEL,
       INTPPERG_MIN_TOPO_DIST_ACCEL};
  // Maximum accelerations in the distance to the sun:
  static final double[] maxHelioDistAccel = new double[]
      {SURYA_MAX_HELIO_DIST_ACCEL,   CHANDRA_MAX_HELIO_DIST_ACCEL,
       BUDHA_MAX_HELIO_DIST_ACCEL,   SHUKRA_MAX_HELIO_DIST_ACCEL,
       MANGALA_MAX_HELIO_DIST_ACCEL, GURU_MAX_HELIO_DIST_ACCEL,
       SHANI_MAX_HELIO_DIST_ACCEL,   URANUS_MAX_HELIO_DIST_ACCEL,
       NEPTUNE_MAX_HELIO_DIST_ACCEL, PLUTO_MAX_HELIO_DIST_ACCEL,
       MNODE_MAX_HELIO_DIST_ACCEL,   TNODE_MAX_HELIO_DIST_ACCEL,
       MAPOGEE_MAX_HELIO_DIST_ACCEL, OAPOGEE_MAX_HELIO_DIST_ACCEL,
       1./0.,                        CHIRON_MAX_HELIO_DIST_ACCEL,
       PHOLUS_MAX_HELIO_DIST_ACCEL,  CERES_MAX_HELIO_DIST_ACCEL,
       PALLAS_MAX_HELIO_DIST_ACCEL,  JUNO_MAX_HELIO_DIST_ACCEL,
       VESTA_MAX_HELIO_DIST_ACCEL,   INTPAPOG_MAX_HELIO_DIST_ACCEL,
       INTPPERG_MAX_HELIO_DIST_ACCEL};
  // Minimum accelerations in the distance to the sun:
  static final double[] minHelioDistAccel = new double[]
      {SURYA_MIN_HELIO_DIST_ACCEL,   CHANDRA_MIN_HELIO_DIST_ACCEL,
       BUDHA_MIN_HELIO_DIST_ACCEL,   SHUKRA_MIN_HELIO_DIST_ACCEL,
       MANGALA_MIN_HELIO_DIST_ACCEL, GURU_MIN_HELIO_DIST_ACCEL,
       SHANI_MIN_HELIO_DIST_ACCEL,   URANUS_MIN_HELIO_DIST_ACCEL,
       NEPTUNE_MIN_HELIO_DIST_ACCEL, PLUTO_MIN_HELIO_DIST_ACCEL,
       MNODE_MIN_HELIO_DIST_ACCEL,   TNODE_MIN_HELIO_DIST_ACCEL,
       MAPOGEE_MIN_HELIO_DIST_ACCEL, OAPOGEE_MIN_HELIO_DIST_ACCEL,
       1./0.,                        CHIRON_MIN_HELIO_DIST_ACCEL,
       PHOLUS_MIN_HELIO_DIST_ACCEL,  CERES_MIN_HELIO_DIST_ACCEL,
       PALLAS_MIN_HELIO_DIST_ACCEL,  JUNO_MIN_HELIO_DIST_ACCEL,
       VESTA_MIN_HELIO_DIST_ACCEL,   INTPAPOG_MIN_HELIO_DIST_ACCEL,
       INTPPERG_MIN_HELIO_DIST_ACCEL};
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
  
  private SwephData() { }
}
class SwephJPL {
  static final int J_MERCURY =  0;
  static final int J_VENUS   =  1;
  static final int J_EARTH   =  2;
  static final int J_MARS    =  3;
  static final int J_JUPITER =  4;
  static final int J_SATURN  =  5;
  static final int J_URANUS  =  6;
  static final int J_NEPTUNE =  7;
  static final int J_PLUTO   =  8;
  static final int J_MOON    =  9;
  static final int J_SUN     = 10;
  static final int J_SBARY   = 11;
  static final int J_EMB     = 12;
  static final int J_NUT     = 13;
  static final int J_LIB     = 14;
  JplSave js=new JplSave();
  SwissEph  sw=null;
  SwissData swed=null;
  SwissLib  sl=null;
  SwephJPL(SwissEph sw, SwissData swed, SwissLib sl) {
    this.sw=sw;
    this.swed=swed;
    this.sl=sl;
    if (this.sw==null) { this.sw=new SwissEph(); }
    if (this.swed==null) { this.swed=new SwissData(); }
    if (this.sl==null) { this.sl=new SwissLib(); }
  }
  
  private int fsizer(StringBuffer serr) throws SwissephException {
    
    int ncon;
    double emrat;
    int numde;
    double au, ss[]=new double[3];
    int i;
    int ksize;
    String ttl="";  // JAVA: Not used???
    try {
      // throws SwissephException, if null or maybe for other reasons:
      js.jplfptr = sw.swi_fopen(SwephData.SEI_FILE_PLANET, js.jplfname, js.jplfpath, serr);
      
      for(int m=0; m<252; m++) {
        ttl+=(char)js.jplfptr.readByte();
      }
    
      for(int m=0; m<6*400; m++) {
        ttl+=(char)js.jplfptr.readByte();
      }
      
      for(int m=0; m<3; m++) {
        ss[m]=js.jplfptr.readDouble();
      }
      for (i = 0; i < 3; i++)
        js.eh_ss[i] = ss[i];
      
        ncon=js.jplfptr.readInt();
      
      au=js.jplfptr.readDouble();
      
      emrat=js.jplfptr.readDouble();
      
      for(int m=0; m<36; m++) {
        js.eh_ipt[m]=js.jplfptr.readInt();
      }
      
        numde=js.jplfptr.readInt();
      js.jplfptr.seek(0);
      
    } catch (java.io.IOException ioe) {
      throw new SwissephException(1./0., SwissephException.FILE_READ_ERROR,
          SweConst.ERR, ioe.getMessage());
    }
    switch (numde) {
      case 403:
      case 405:
        ksize = 2036;
        break;
      case 404:
      case 406:
        ksize = 1456;
        break;
      case 200:
        ksize = 1652;
        break;
      case 102:
        ksize = 1652;     
        break;
      default:
        if (serr != null) {
          serr.setLength(0);
          serr.append("unknown numde value "+numde+";");
        }
        throw new SwissephException(1./0., SwissephException.DATA_FILE_ERROR,
            SweConst.ERR, serr);
    }
    return ksize;
  }
  
  int swi_pleph(double et, int ntarg, int ncent, double[] rrd,
                StringBuffer serr) throws SwissephException {
    int i, retc;
    int list[]=new int[12];
    double[] pv = js.pv;
    double[] pvsun = js.pvsun;
    for (i = 0; i < 6; ++i)
      rrd[i] = 0.0;
    if (ntarg == ncent) {
      return 0;
    }
    for (i = 0; i < 12; ++i)
      list[i] = 0;
    
    if (ntarg == J_NUT) {
      if (js.eh_ipt[34] > 0) {
        list[10] = 2;
        return(state(et, list, false, pv, pvsun, rrd, serr));
      } else {
        if (serr != null) {
          serr.setLength(0);
          serr.append("No nutations on the JPL ephemeris file;");
        }
        throw new SwissephException(et, SwissephException.UNDEFINED,
            SwephData.NOT_AVAILABLE, serr);
      }
    }
    if (ntarg == J_LIB) {
      if (js.eh_ipt[37] > 0) {
        list[11] = 2;
        // throws SwissephException by itself:
        retc = state(et, list, false, pv, pvsun, rrd, serr);
        for (i = 0; i < 6; ++i) {
          rrd[i] = pv[i + 60];
        }
        return 0;
      } else {
        if (serr != null) {
          serr.setLength(0);
          serr.append("No librations on the ephemeris file;");
        }
        throw new SwissephException(et, SwissephException.DATA_FILE_ERROR,
            SwephData.NOT_AVAILABLE, serr);
      }
    }
    
    if (ntarg < J_SUN) {
      list[ntarg] = 2;
    }
    if (ntarg == J_MOON)   {
      list[J_EARTH] = 2;
    }
    if (ntarg == J_EARTH)          {
      list[J_MOON] = 2;
    }
    if (ntarg == J_EMB)    {
      list[J_EARTH] = 2;
    }
    if (ncent < J_SUN) {
      list[ncent] = 2;
    }
    if (ncent == J_MOON)   {
      list[J_EARTH] = 2;
    }
    if (ncent == J_EARTH)          {
      list[J_MOON] = 2;
    }
    if (ncent == J_EMB)    {
      list[J_EARTH] = 2;
    }
    // throws SwissephException by itself:
    retc = state(et, list, true, pv, pvsun, rrd, serr);
    if (ntarg == J_SUN || ncent == J_SUN) {
      for (i = 0; i < 6; ++i)
        pv[i + 6*J_SUN] = pvsun[i];
    }
    if (ntarg == J_SBARY || ncent == J_SBARY) {
      for (i = 0; i < 6; ++i) {
        pv[i + 6*J_SBARY] = 0.;
      }
    }
    if (ntarg == J_EMB || ncent == J_EMB) {
      for (i = 0; i < 6; ++i)
        pv[i + 6*J_EMB] = pv[i + 6*J_EARTH];
    }
    if ((ntarg==J_EARTH && ncent==J_MOON) || (ntarg == J_MOON && ncent==J_EARTH)){
      for (i = 0; i < 6; ++i)
        pv[i + 6*J_EARTH] = 0.;
    } else {
      if (list[J_EARTH] == 2) {
        for (i = 0; i < 6; ++i)
          pv[i + 6*J_EARTH] -= pv[i + 6*J_MOON] / (js.eh_emrat + 1.);
      }
      if (list[J_MOON] == 2) {
        for (i = 0; i < 6; ++i) {
          pv[i + 6*J_MOON] += pv[i + 6*J_EARTH];
        }
      }
    }
    for (i = 0; i < 6; ++i)
      rrd[i] = pv[i + ntarg * 6] - pv[i + ncent * 6];
    return SweConst.OK;
  }
  
  
  int np_interp, nv_interp;
  int nac_interp;
  int njk_interp;
  double twot = 0.;
  private int interp(double[] buf, int bufOffs, double t, double intv,
                     int ncfin, int ncmin, int nain, int ifl, double[] pv,
                     int pvOffs) {
    
    double[] pc = js.pc;
    double[] vc = js.vc;
    double[] ac = js.ac;
    double[] jc = js.jc;
    int ncf = (int) ncfin;
    int ncm = (int) ncmin;
    int na = (int) nain;
    
    double temp;
    int i, j, ni;
    double tc;
    double dt1, bma;
    double bma2, bma3;
    
    if (t >= 0) {
      dt1 = Math.floor(t);
    } else {
      dt1 = -Math.floor(-t);
    }
    temp = na * t;
    ni = (int) (temp - dt1);
    
    tc = ((temp % 1.0) + dt1) * 2. - 1.;
    
    if (tc != pc[1]) {
      np_interp = 2;
      nv_interp = 3;
      nac_interp = 4;
      njk_interp = 5;
      pc[1] = tc;
      twot = tc + tc;
    }
    
    if (np_interp < ncf) {
      for (i = np_interp; i < ncf; ++i)
        pc[i] = twot * pc[i - 1] - pc[i - 2];
      np_interp = ncf;
    }
    
    for (i = 0; i < ncm; ++i) {
      pv[pvOffs + i] = 0.;
      for (j = ncf-1; j >= 0; --j)
        pv[pvOffs + i] += pc[j] * buf[bufOffs + j + (i + ni * ncm) * ncf];
    }
    if (ifl <= 1) {
      return 0;
    }
    
    bma = (na + na) / intv;
    vc[2] = twot + twot;
    if (nv_interp < ncf) {
      for (i = nv_interp; i < ncf; ++i)
        vc[i] = twot * vc[i - 1] + pc[i - 1] + pc[i - 1] - vc[i - 2];
      nv_interp = ncf;
    }
    
    for (i = 0; i < ncm; ++i) {
      pv[pvOffs + i + ncm] = 0.;
      for (j = ncf-1; j >= 1; --j)
        pv[pvOffs + i + ncm] += vc[j] * buf[bufOffs + j + (i + ni * ncm) * ncf];
      pv[pvOffs + i + ncm] *= bma;
    }
    if (ifl == 2) {
      return 0;
    }
    
    
    bma2 = bma * bma;
    ac[3] = pc[1] * 24.;
    if (nac_interp < ncf) {
      nac_interp = ncf;
      for (i = nac_interp; i < ncf; ++i)
        ac[i] = twot * ac[i - 1] + vc[i - 1] * 4. - ac[i - 2];
    }
    
    for (i = 0; i < ncm; ++i) {
      pv[pvOffs + i + ncm * 2] = 0.;
      for (j = ncf-1; j >= 2; --j)
        pv[pvOffs + i + ncm * 2] += ac[j] * buf[bufOffs + j + (i + ni * ncm) * ncf];
      pv[pvOffs + i + ncm * 2] *= bma2;
    }
    if (ifl == 3) {
      return 0;
    }
    
    
    bma3 = bma * bma2;
    jc[4] = pc[1] * 192.;
    if (njk_interp < ncf) {
      njk_interp = ncf;
      for (i = njk_interp; i < ncf; ++i)
        jc[i] = twot * jc[i - 1] + ac[i - 1] * 6. - jc[i - 2];
    }
    
    for (i = 0; i < ncm; ++i) {
      pv[pvOffs + i + ncm * 3] = 0.;
      for (j = ncf-1; j >= 3; --j)
        pv[pvOffs + i + ncm * 3] += jc[j] * buf[bufOffs + j + (i + ni * ncm) * ncf];
      pv[pvOffs + i + ncm * 3] *= bma3;
    }
    return 0;
  }
  
  int irecsz_state;
  int nrl_state, lpt_state[]=new int[3], ncoeffs_state;
  private int state(double et, int[] list, boolean do_bary, double[] pv,
                    double[] pvsun, double[] nut, StringBuffer serr)
      throws SwissephException {
    int i, j, k;
    long flen;
    int nseg, nb;
    double[] buf = js.buf;
    double aufac=0., s, t=0., intv=0.;
    int nrecl, ksize;
    int nr;
    double et_mn, et_fr;
    int[] ipt = js.eh_ipt;
    String ch_ttl="";  // JAVA: Not used???
    boolean ferr=false;
    try {
      if (js.jplfptr == null ||
          (js.jplfptr.fp == null && js.jplfptr.sk == null)) {
        // fsizer() throws SwissephException
        ksize = fsizer(serr); 
        nrecl = 4;
        if (ksize < 0) {
          if (serr != null && ksize != SwephData.NOT_AVAILABLE) {
            serr.setLength(0);
            serr.append("fsizer does not work");
          }
          throw new SwissephException(et, SwissephException.DATA_FILE_ERROR,  // Or is it some other error???
              (int)ksize, serr);
        }
        irecsz_state = nrecl * ksize;     
        ncoeffs_state = ksize / 2;        
        
        for(int m=0;m<252;m++) {
          ch_ttl+=(char)js.jplfptr.readByte();
        }
        
        for(int m=0;m<2400;m++) {
          js.ch_cnam+=(char)js.jplfptr.readByte();
        }
        
        for(int m=0;m<3;m++) {
          js.eh_ss[m]=js.jplfptr.readDouble();
        }
        
        js.eh_ncon=js.jplfptr.readInt();
        
        js.eh_au=js.jplfptr.readDouble();
        
        js.eh_emrat=js.jplfptr.readDouble();
        
        for(int m=0;m<36;m++) {
          ipt[m]=js.jplfptr.readInt();
        }
        
        js.eh_denum=js.jplfptr.readInt();
        for(int m=0;m<3;m++) {
          lpt_state[m]=js.jplfptr.readInt();
        }
        
        js.jplfptr.seek(1L * irecsz_state);
        for(int m=0;m<400;m++) {
          js.eh_cval[m]=js.jplfptr.readDouble();
        }
        js.jplfptr.seek(2L * irecsz_state);
        for (i = 0; i < 3; ++i)
          ipt[i + 36] = lpt_state[i];
        nrl_state = 0;
        
        
        flen=js.jplfptr.length();
        
        nseg = (int) ((js.eh_ss[1] - js.eh_ss[0]) / js.eh_ss[2]);
        
        for(i = 0, nb = 0; i < 13; i++) {
          k = 3;
          if (i == 11) {
            k = 2;
          }
          nb += (ipt[i*3+1] * ipt[i*3+2]) * k * nseg;
        }
        
        nb += 2 * nseg;
        
        nb *= 8;
        
        nb += 2 * ksize * nrecl;
        if (flen != nb
          
          && flen - nb != ksize * nrecl) {
          if (serr != null) {
            serr.setLength(0);
            serr.append("JPL ephemeris file is mutilated; length = "+flen+" instead of "+nb+".");
            if (serr.length() + js.jplfname.length() < SwissData.AS_MAXCH - 1) {
              serr.setLength(0); // Nanu???
              serr.append("JPL ephemeris file "+js.jplfname+" is mutilated; length = "+flen+" instead of "+nb+".");
            }
          }
          throw new SwissephException(et, SwissephException.FILE_READ_ERROR,
              SweConst.ERR, serr);
        }
      }
      if (list == null) {
        return 0;
      }
      s = et - .5;
      et_mn = Math.floor(s);
      et_fr = s - et_mn;    
      et_mn += .5;  
      
      if (et < js.eh_ss[0] || et > js.eh_ss[1]) {
        if (serr != null) {
          serr.setLength(0);
          serr.append("jd "+et+" outside JPL eph. range "+js.eh_ss[0]+" .. "+js.eh_ss[1]+";");
        }
        throw new SwissephException(et, SwissephException.OUT_OF_TIME_RANGE,
            SwephData.BEYOND_EPH_LIMITS, serr);
      }
      
      nr = (int) ((et_mn - js.eh_ss[0]) / js.eh_ss[2]) + 2;
      if (et_mn == js.eh_ss[1]) {
        --nr;       
      }
      t = (et_mn - ((nr - 2) * js.eh_ss[2] + js.eh_ss[0]) + et_fr) / js.eh_ss[2];
      
      if (nr != nrl_state) {
        nrl_state = nr;
        js.jplfptr.seek(nr * irecsz_state);
        for (k = 1; k <= ncoeffs_state; ++k) {
          buf[k - 1]=js.jplfptr.readDouble();
        }
      }
      if (js.do_km) {
        intv = js.eh_ss[2] * 86400.;
        aufac = 1.;
      } else {
        intv = js.eh_ss[2];
        aufac = 1. / js.eh_au;
      }
      
    } catch (java.io.EOFException ef) {
      ferr=true;
    } catch (java.io.IOException ie) {
      ferr=true;
    }
    if (ferr) {
      if (serr != null) {
        serr.setLength(0);
        serr.append("Read error in JPL eph. at "+et+"\n");
      }
      throw new SwissephException(et, SwissephException.FILE_READ_ERROR,
          SweConst.ERR, serr);
    }
    interp(buf, (int) ipt[30] - 1, t, intv, ipt[31], 3, ipt[32], 2, pvsun, 0);
    for (i = 0; i < 6; ++i) {
      pvsun[i] *= aufac;
    }
    
    for (i = 0; i < 10; ++i) {
      if (list[i] > 0) {
        interp(buf, (int) ipt[i * 3] - 1, t, intv, ipt[i * 3 + 1], 3,
               ipt[i * 3 + 2], list[i], pv, i * 6);
        for (j = 0; j < 6; ++j) {
          if (i < 9 && ! do_bary) {
            pv[j + i * 6] = pv[j + i * 6] * aufac - pvsun[j];
          } else {
            pv[j + i * 6] *= aufac;
          }
        }
      }
    }
    
    if (list[10] > 0 && ipt[34] > 0) {
      interp(buf, (int) ipt[33] - 1, t, intv, ipt[34], 2, ipt[35],
               list[10], nut, 0);
    }
    
    if (list[11] > 0 && ipt[37] > 0) {
      interp(buf, (int) ipt[36] - 1, t, intv, ipt[37], 3, ipt[38], list[1],
              pv, 60);
    }
    return SweConst.OK;
  }
  
  private int read_const_jpl(double[] ss,  StringBuffer serr) throws SwissephException {
    int i;
    // throws SwissephException if !SweConst.OK:
    state(0.0, null, false, null, null, null, serr);
    for (i = 0; i < 3; i++)
      ss[i] = js.eh_ss[i];
    return SweConst.OK;
  }
  void swi_close_jpl_file() {
    if (js != null) {
      try {
        if (js.jplfptr != null) {
          js.jplfptr.close();
        }
      } catch (java.io.IOException e) {
      }
      if (js.jplfname != null) {
        js.jplfname = null;
      }
      if (js.jplfpath != null) {
        js.jplfpath = null;
      }
      js = null;
    }
  }
  int swi_open_jpl_file(double[] ss, String fname, String fpath,
                                StringBuffer serr) throws SwissephException {
    int retc = SweConst.OK;
    
    if (js != null && js.jplfptr != null) {
      return SweConst.OK;
    }
    js=new JplSave();
    js.jplfname=fname;
    js.jplfpath=fpath;
    try {
      retc = read_const_jpl(ss, serr);
    } catch (SwissephException se) {
      swi_close_jpl_file();
      throw se;
    }
    
    js.pc[0] = 1;
    js.pc[1] = 2;
    js.vc[1] = 1;
    js.ac[2] = 4;
    js.jc[3] = 24;
    return retc;
  }
  int swi_get_jpl_denum() {
    return js.eh_denum;
  }
  double[] getJPLRange(String fname) throws SwissephException {
    double start=0./0., end=0./0.;
    FilePtr fp = null;
    try {
      fp = sw.swi_fopen(SwephData.SEI_FILE_PLANET, fname, swed.ephepath, null);
      fp.seek(252+6*400);
      start = fp.readDouble();
      end = fp.readDouble();
    } catch (SwissephException e) {
      throw e;
    } catch (Exception e) {
    }
    try { fp.close(); } catch (Exception e) { }
    return new double[]{start, end};
  }
}
class JplSave {
  String jplfname=null;
  String jplfpath=null;
  FilePtr jplfptr=null;
  double eh_cval[]=new double[400];
  double eh_ss[]=new double[3], eh_au, eh_emrat;
  int eh_denum, eh_ncon, eh_ipt[]=new int[39];
  String ch_cnam="";
  double pv[]=new double[78];
  double pvsun[]=new double[6];
  double buf[]=new double[1500];
  double pc[]=new double[18], vc[]=new double[18],
         ac[]=new double[18], jc[]=new double[18];
  boolean do_km;
}
class SwephMosh {
  SwissLib sl=null;
  SwissEph sw=null;
  SwissData swed=null;
  Swemmoon sm=null;
  SweDate sd=null;
  private static final double TIMESCALE=3652500.0;
  private static final int FICT_GEO=1;
  private static final int pnoint2msh[] = {2, 2, 0, 1, 3, 4, 5, 6, 7, 8};
  
  private static final double freqs[] = {
  
    53810162868.8982,
    21066413643.3548,
    12959774228.3429,
    6890507749.3988,
    1092566037.7991,
    439960985.5372,
    154248119.3933,
    78655032.0744,
    52272245.1795
  };
  private static final double phases[] = {
  
    252.25090552 * 3600.,
    181.97980085 * 3600.,
    100.46645683 * 3600.,
    355.43299958 * 3600.,
    34.35151874 * 3600.,
    50.07744430 * 3600.,
    314.05500511 * 3600.,
    304.34866548 * 3600.,
    860492.1546,
  };
  double ss[][]=new double[9][24];
  double cc[][]=new double[9][24];
  SwephMosh(SwissLib sl, SwissEph sw, SwissData swed) {
    this.sl    = sl;
    this.sw    = sw;
    this.swed  = swed;
    this.sm    = new Swemmoon();
    if (this.sl   ==null) { this.sl   =new SwissLib(); }
    if (this.sw   ==null) { this.sw   =new SwissEph(); }
    if (this.swed ==null) { this.swed =new SwissData(); }
  }
  private int swi_moshplan2 (double J, int iplm, double[] pobj) {
    int i, j, k, m, k1, ip, np, nt;
    byte p[]; int pOff=0;
    double pl[], pb[], pr[]; int plOff=0, pbOff=0, prOff=0;
    double su, cu, sv, cv, T;
    double t, sl, sb, sr;
    Plantbl plan = planets[iplm];
    T = (J - SwephData.J2000) / TIMESCALE;
    
    for (i = 0; i < 9; i++) {
      if ((j = plan.max_harmonic[i]) > 0) {
        sr = (sm.mods3600 (freqs[i] * T) + phases[i]) * SwephData.STR;
        sscc (i, sr, j);
      }
    }
    
    p = plan.arg_tbl;
    
    pl = plan.lon_tbl;
    pb = plan.lat_tbl;
    pr = plan.rad_tbl;
    sl = 0.0;
    sb = 0.0;
    sr = 0.0;
    for (;;)
      {
        
        
        np = p[pOff++];
        if (np < 0) {
          break;
        }
        if (np == 0) {                       
            nt = p[pOff++];
            
            cu = pl[plOff++];
            for (ip = 0; ip < nt; ip++)
              {
                cu = cu * T + pl[plOff++];
              }
            sl +=  sm.mods3600 (cu);
            
            cu = pb[pbOff++];
            for (ip = 0; ip < nt; ip++)
              {
                cu = cu * T + pb[pbOff++];
              }
            sb += cu;
            
            cu = pr[prOff++];
            for (ip = 0; ip < nt; ip++)
              {
                cu = cu * T + pr[prOff++];
              }
            sr += cu;
            continue;
          }
        k1 = 0;
        cv = 0.0;
        sv = 0.0;
        for (ip = 0; ip < np; ip++)
          {
            
            j = p[pOff++];
            
            m = p[pOff++] - 1;
            if (j!=0) {
                k = j;
                if (j < 0) {
                  k = -k;
                }
                k -= 1;
                su = ss[m][k];    
                if (j < 0) {
                  su = -su;
                }
                cu = cc[m][k];
                if (k1 == 0) {               
                    sv = su;
                    cv = cu;
                    k1 = 1;
                  }
                else
                  {               
                    t = su * cv + cu * sv;
                    cv = cu * cv - su * sv;
                    sv = t;
                  }
              }
          }
        
        nt = p[pOff++];
        
        cu = pl[plOff++];
        su = pl[plOff++];
        for (ip = 0; ip < nt; ip++)
          {
            cu = cu * T + pl[plOff++];
            su = su * T + pl[plOff++];
          }
        sl += cu * cv + su * sv;
        
        cu = pb[pbOff++];
        su = pb[pbOff++];
        for (ip = 0; ip < nt; ip++)
          {
            cu = cu * T + pb[pbOff++];
            su = su * T + pb[pbOff++];
          }
        sb += cu * cv + su * sv;
        
        cu = pr[prOff++];
        su = pr[prOff++];
        for (ip = 0; ip < nt; ip++)
          {
            cu = cu * T + pr[prOff++];
            su = su * T + pr[prOff++];
          }
        sr += cu * cv + su * sv;
      }
    pobj[0] = SwephData.STR * sl;
    pobj[1] = SwephData.STR * sb;
    pobj[2] = SwephData.STR * plan.distance * sr + plan.distance;
    return SweConst.OK;
  }
  
  int swi_moshplan(double tjd, int ipli, boolean do_save, double[] xpret,
                   double[] xeret, StringBuffer serr) {
    int i;
    boolean do_earth = false;
    double dx[]=new double[3], x2[]=new double[3],
           xxe[]=new double[6], xxp[]=new double[6];
    double xp[], xe[];
    double dt;
    String s;
    int iplm = pnoint2msh[ipli];
    PlanData pdp = swed.pldat[ipli];
    PlanData pedp = swed.pldat[SwephData.SEI_EARTH];
    double seps2000 = swed.oec2000.seps;
    double ceps2000 = swed.oec2000.ceps;
    if (do_save) {
      xp = pdp.x;
      xe = pedp.x;
    } else {
      xp = xxp;
      xe = xxe;
    }
    if (do_save || ipli == SwephData.SEI_EARTH || xeret != null) {
      do_earth = true;
    }
    
    if (tjd < SwephData.MOSHPLEPH_START - 0.3 ||
        tjd > SwephData.MOSHPLEPH_END + 0.3) {
      if (serr != null) {
        serr.setLength(0);
        s="jd "+tjd+" outside Moshier planet range "+
          SwephData.MOSHPLEPH_START+" .. "+
          SwephData.MOSHPLEPH_END+" ";
        if (serr.length() + s.length() < SwissData.AS_MAXCH) {
          serr.append(s);
        }
      }
      return(SweConst.ERR);
    }
    
    if (do_earth) {
      if (tjd == pedp.teval && pedp.iephe == SweConst.SEFLG_MOSEPH) {
        xe = pedp.x;
      } else {
        
        swi_moshplan2(tjd, pnoint2msh[SwephData.SEI_EMB], xe); 
        sl.swi_polcart(xe, xe);                        
        sl.swi_coortrf2(xe, xe, -seps2000, ceps2000);
        embofs_mosh(tjd, xe);               
        if (do_save) {
          pedp.teval = tjd;
          pedp.xflgs = -1;
          pedp.iephe = SweConst.SEFLG_MOSEPH;
        }
        
        swi_moshplan2(tjd - SwephData.PLAN_SPEED_INTV, pnoint2msh[SwephData.SEI_EMB], x2);
        sl.swi_polcart(x2, x2);
        sl.swi_coortrf2(x2, x2, -seps2000, ceps2000);
        embofs_mosh(tjd - SwephData.PLAN_SPEED_INTV, x2);
        for (i = 0; i <= 2; i++)
          dx[i] = (xe[i] - x2[i]) / SwephData.PLAN_SPEED_INTV;
        
        for (i = 0; i <= 2; i++) {
          xe[i+3] = dx[i];
        }
      }
      if (xeret != null) {
        for (i = 0; i <= 5; i++) {
          xeret[i] = xe[i];
        }
      }
    }
    
    if (ipli == SwephData.SEI_EARTH) {
      xp = xe;
    } else {
      
      
      if (tjd == pdp.teval && pdp.iephe == SweConst.SEFLG_MOSEPH) {
        xp = pdp.x;
      } else {
        swi_moshplan2(tjd, iplm, xp);
        sl.swi_polcart(xp, xp);
        sl.swi_coortrf2(xp, xp, -seps2000, ceps2000);
        if (do_save) {
          pdp.teval = tjd;
          pdp.xflgs = -1;
          pdp.iephe = SweConst.SEFLG_MOSEPH;
        }
        
        dt = SwephData.PLAN_SPEED_INTV;
        swi_moshplan2(tjd - dt, iplm, x2);
        sl.swi_polcart(x2, x2);
        sl.swi_coortrf2(x2, x2, -seps2000, ceps2000);
        for (i = 0; i <= 2; i++)
          dx[i] = (xp[i] - x2[i]) / dt;
        
        for (i = 0; i <= 2; i++) {
          xp[i+3] = dx[i];
        }
      }
      if (xpret != null) {
        for (i = 0; i <= 5; i++) {
          xpret[i] = xp[i];
        }
      }
    }
    return(SweConst.OK);
  }
  
  private void sscc (int k, double arg, int n) {
    double cu, su, cv, sv, s;
    int i;
    su = Math.sin (arg);
    cu = Math.cos (arg);
    ss[k][0] = su;                
    cc[k][0] = cu;                
    sv = 2.0 * su * cu;
    cv = cu * cu - su * su;
    ss[k][1] = sv;                
    cc[k][1] = cv;
    for (i = 2; i < n; i++)
      {
        s = su * cv + cu * sv;
        cv = cu * cv - su * sv;
        sv = s;
        ss[k][i] = sv;            
        cc[k][i] = cv;
      }
  }
  
  private void embofs_mosh(double tjd, double xemb[]) {
    double T, M, a, L, B, p;
    double smp, cmp, s2mp, c2mp, s2d, c2d, sf, cf;
    double s2f, sx, cx, xyz[]=new double[6];
    double seps = swed.oec.seps;
    double ceps = swed.oec.ceps;
    int i;
    
    T = (tjd-SwephData.J1900)/36525.0;
    
    a = sl.swe_degnorm(((1.44e-5*T + 0.009192)*T + 477198.8491)*T + 296.104608);
    a *= SwissData.DEGTORAD;
    smp = Math.sin(a);
    cmp = Math.cos(a);
    s2mp = 2.0*smp*cmp;           
    c2mp = cmp*cmp - smp*smp;     
    
    a = sl.swe_degnorm(((1.9e-6*T - 0.001436)*T + 445267.1142)*T + 350.737486);
    a  = 2.0 * SwissData.DEGTORAD * a;
    s2d = Math.sin(a);
    c2d = Math.cos(a);
    
    a = sl.swe_degnorm((( -3.e-7*T - 0.003211)*T + 483202.0251)*T + 11.250889);
    a  *= SwissData.DEGTORAD;
    sf = Math.sin(a);
    cf = Math.cos(a);
    s2f = 2.0*sf*cf;      
    sx = s2d*cmp - c2d*smp;       
    cx = c2d*cmp + s2d*smp;       
    
    L = ((1.9e-6*T - 0.001133)*T + 481267.8831)*T + 270.434164;
    
    M = sl.swe_degnorm((( -3.3e-6*T - 1.50e-4)*T + 35999.0498)*T + 358.475833);
    
    L =   L
          + 6.288750*smp
          + 1.274018*sx
          + 0.658309*s2d
          + 0.213616*s2mp
          - 0.185596*Math.sin( SwissData.DEGTORAD * M )
          - 0.114336*s2f;
    
    a = smp*cf;
    sx = cmp*sf;
    B =     5.128189*sf
          + 0.280606*(a+sx)               
          + 0.277693*(a-sx)               
          + 0.173238*(s2d*cf - c2d*sf);   
    B *= SwissData.DEGTORAD;
    
    p =    0.950724
          +0.051818*cmp
          +0.009531*cx
          +0.007843*c2d
          +0.002824*c2mp;
    p *= SwissData.DEGTORAD;
    
    L = sl.swe_degnorm(L);
    L *= SwissData.DEGTORAD;
    
    a = 4.263523e-5/Math.sin(p);
    
    xyz[0] = L;
    xyz[1] = B;
    xyz[2] = a;
    sl.swi_polcart(xyz, xyz);
    
    sl.swi_coortrf2(xyz, xyz, -seps, ceps);
    
    sl.swi_precess(xyz, tjd, SwephData.J_TO_J2000);
    
    for (i = 0; i <= 2; i++)
      xemb[i] -= xyz[i] / (SwephData.EARTH_MOON_MRAT + 1.0);
  }
  
                                  
  static final String plan_fict_nam[] =
    {"Cupido", "Hades", "Zeus", "Kronos",
     "Apollon", "Admetos", "Vulkanus", "Poseidon",
     "Isis-Transpluto", "Nibiru", "Harrington",
     "Leverrier", "Adams",
     "Lowell", "Pickering",};
  String swi_get_fict_name(int ipl, String snam) {
    if (snam==null) { snam=""; }
    StringBuffer sbnam=new StringBuffer(snam);
    if (read_elements_file(ipl, 0, null, null,
         null, null, null, null, null, null,
         sbnam, null, null) == SweConst.ERR) {
      return "name not found";
    }
    return sbnam.toString();
  }
  private static final double plan_oscu_elem[][]=new double[][] {
    {SwephData.J1900, SwephData.J1900, 163.7409, 40.99837, 0.00460, 171.4333, 129.8325, 1.0833},
    {SwephData.J1900, SwephData.J1900,  27.6496, 50.66744, 0.00245, 148.1796, 161.3339, 1.0500},
    {SwephData.J1900, SwephData.J1900, 165.1232, 59.21436, 0.00120, 299.0440,   0.0000, 0.0000},
    {SwephData.J1900, SwephData.J1900, 169.0193, 64.81960, 0.00305, 208.8801,   0.0000, 0.0000},
    {SwephData.J1900, SwephData.J1900, 138.0533, 70.29949, 0.00000,   0.0000,   0.0000, 0.0000},
    {SwephData.J1900, SwephData.J1900, 351.3350, 73.62765, 0.00000,   0.0000,   0.0000, 0.0000},
    {SwephData.J1900, SwephData.J1900,  55.8983, 77.25568, 0.00000,   0.0000,   0.0000, 0.0000},
    {SwephData.J1900, SwephData.J1900, 165.5163, 83.66907, 0.00000,   0.0000,   0.0000, 0.0000},
    
    {2368547.66, 2431456.5, 0.0, 77.775, 0.3, 0.7, 0, 0},
    
    {1856113.380954, 1856113.380954, 0.0, 234.8921, 0.981092, 103.966, -44.567, 158.708},
    
    {2374696.5, SwephData.J2000, 0.0, 101.2, 0.411, 208.5, 275.4, 32.4},
    
    {2395662.5, 2395662.5, 34.05, 36.15, 0.10761, 284.75, 0, 0},
    
    {2395662.5, 2395662.5, 24.28, 37.25, 0.12062, 299.11, 0, 0},
    
    {2425977.5, 2425977.5, 281, 43.0, 0.202, 204.9, 0, 0},
    
    {2425977.5, 2425977.5, 48.95, 55.1, 0.31, 280.1, 100, 15}, 
  };
  
  int swi_osc_el_plan(double tjd, double xp[], int ipl, int ipli,
                      double[] xearth, double[] xsun, StringBuffer serr) {
    double pqr[]=new double[9], x[]=new double[6];
    double eps, K, fac, rho, cose, sine;
    double alpha, beta, zeta, sigma, M2, Msgn, M_180_or_0;
    DblObj tjd0=new DblObj();
    DblObj tequ=new DblObj();
    DblObj mano=new DblObj();
    DblObj sema=new DblObj();
    DblObj ecce=new DblObj();
    DblObj parg=new DblObj();
    DblObj node=new DblObj();
    DblObj incl=new DblObj();
    double dmot;
    double cosnode, sinnode, cosincl, sinincl, cosparg, sinparg;
    double M, E;
    PlanData pedp = swed.pldat[SwephData.SEI_EARTH];
    PlanData pdp = swed.pldat[ipli];
    IntObj fict_ifl = new IntObj(); fict_ifl.val = 0;
    int i;
    
    if (read_elements_file(ipl, tjd, tjd0, tequ,
         mano, sema, ecce, parg, node, incl,
         null, fict_ifl, serr) == SweConst.ERR) {
      return SweConst.ERR;
    }
    dmot = 0.9856076686 * SwissData.DEGTORAD / sema.val / Math.sqrt(sema.val);
                                                            
    if ((fict_ifl.val & FICT_GEO) != 0) {
      dmot /= Math.sqrt(SwephData.SUN_EARTH_MRAT);
    }
    cosnode = Math.cos(node.val);
    sinnode = Math.sin(node.val);
    cosincl = Math.cos(incl.val);
    sinincl = Math.sin(incl.val);
    cosparg = Math.cos(parg.val);
    sinparg = Math.sin(parg.val);
    
    pqr[0] = cosparg * cosnode - sinparg * cosincl * sinnode;
    pqr[1] = -sinparg * cosnode - cosparg * cosincl * sinnode;
    pqr[2] = sinincl * sinnode;
    pqr[3] = cosparg * sinnode + sinparg * cosincl * cosnode;
    pqr[4] = -sinparg * sinnode + cosparg * cosincl * cosnode;
    pqr[5] = -sinincl * cosnode;
    pqr[6] = sinparg * sinincl;
    pqr[7] = cosparg * sinincl;
    pqr[8] = cosincl;
    
    E = M = sl.swi_mod2PI(mano.val + (tjd - tjd0.val) * dmot); 
    
    if (ecce.val > 0.975) {
      M2 = M * SwissData.RADTODEG;
      if (M2 > 150 && M2 < 210) {
        M2 -= 180;
        M_180_or_0 = 180;
      } else
        M_180_or_0 = 0;
      if (M2 > 330) {
        M2 -= 360;
      }
      if (M2 < 0) {
        M2 = -M2;
        Msgn = -1;
      } else {
        Msgn = 1;
      }
      if (M2 < 30) {
        M2 *= SwissData.DEGTORAD;
        alpha = (1 - ecce.val) / (4 * ecce.val + 0.5);
        beta = M2 / (8 * ecce.val + 1);
        zeta = Math.pow(beta + Math.sqrt(beta * beta + alpha * alpha), 1/3);
        sigma = zeta - alpha / 2;
        sigma = sigma - 0.078 * sigma * sigma * sigma * sigma * sigma / (1 + ecce.val)
  ;
        E = Msgn * (M2 + ecce.val * (3 * sigma - 4 * sigma * sigma * sigma))
                          + M_180_or_0;
      }
    }
    E = sl.swi_kepler(E, M, ecce.val);
    
    if ((fict_ifl.val & FICT_GEO) != 0) {
      K = SwephData.KGAUSS_GEO / Math.sqrt(sema.val); 
    } else {
      K = SwephData.KGAUSS / Math.sqrt(sema.val);
    }
    cose = Math.cos(E);
    sine = Math.sin(E);
    fac = Math.sqrt((1 - ecce.val) * (1 + ecce.val));
    rho = 1 - ecce.val * cose;
    x[0] = sema.val * (cose - ecce.val);
    x[1] = sema.val * fac * sine;
    x[3] = -K * sine / rho;
    x[4] = K * fac * cose / rho;
    
    xp[0] = pqr[0] * x[0] + pqr[1] * x[1];
    xp[1] = pqr[3] * x[0] + pqr[4] * x[1];
    xp[2] = pqr[6] * x[0] + pqr[7] * x[1];
    xp[3] = pqr[0] * x[3] + pqr[1] * x[4];
    xp[4] = pqr[3] * x[3] + pqr[4] * x[4];
    xp[5] = pqr[6] * x[3] + pqr[7] * x[4];
    
    eps = sl.swi_epsiln(tequ.val);
    sl.swi_coortrf(xp, xp, -eps);
    sl.swi_coortrf(xp, 3, xp, 3, -eps);
    
    if (tequ.val != SwephData.J2000) {
      sl.swi_precess(xp, tequ.val, SwephData.J_TO_J2000);
      sl.swi_precess(xp, 3, tequ.val, SwephData.J_TO_J2000);
    }
    
    if ((fict_ifl.val & FICT_GEO) != 0) {
      for (i = 0; i <= 5; i++) {
        xp[i] += xearth[i];
      }
    } else {
      for (i = 0; i <= 5; i++) {    
        xp[i] += xsun[i];
      }
    }
    if (pdp.x == xp) {
      pdp.teval = tjd;   
      pdp.iephe = pedp.iephe;
    }
    return SweConst.OK;
  }
  
  private int read_elements_file(int ipl, double tjd,
                                 DblObj tjd0, DblObj tequ,
                                 DblObj mano, DblObj sema, DblObj ecce,
                                 DblObj parg, DblObj node, DblObj incl,
                                 StringBuffer pname, IntObj fict_ifl,
                                 StringBuffer serr) {
    int i, iline, iplan, retc, ncpos;
    FilePtr fp = null;
    String s, sp;
    int spIdx=0;
    String cpos[]=new String[20], serri="";
    boolean elem_found = false;
    double tt = 0;
    
    if ((fp = sw.swi_fopen(-1, SweConst.SE_FICTFILE, swed.ephepath, serr)) == null) {
      
      if (ipl >= SweConst.SE_NFICT_ELEM) {
        if (serr != null) {
          serr.append("error no elements for fictitious body no ").append(ipl);
        }
        return SweConst.ERR;
      }
      if (tjd0 != null) {
        tjd0.val = plan_oscu_elem[ipl][0];                   
      }
      if (tequ != null) {
        tequ.val = plan_oscu_elem[ipl][1];                   
      }
      if (mano != null) {
        mano.val = plan_oscu_elem[ipl][2] * SwissData.DEGTORAD; 
      }
      if (sema != null) {
        sema.val = plan_oscu_elem[ipl][3];                   
      }
      if (ecce != null) {
        ecce.val = plan_oscu_elem[ipl][4];                   
      }
      if (parg != null) {
        parg.val = plan_oscu_elem[ipl][5] * SwissData.DEGTORAD; 
      }
      if (node != null) {
        node.val = plan_oscu_elem[ipl][6] * SwissData.DEGTORAD;  
      }
      if (incl != null) {
        incl.val = plan_oscu_elem[ipl][7] * SwissData.DEGTORAD; 
      }
      if (pname != null) {
        pname.setLength(0);
        pname.append(plan_fict_nam[ipl]);
      }
      return SweConst.OK;
    }
    
    iline = 0;
    iplan = -1;
    try {
      while ((s=fp.readLine()) != null) {
        s=s.trim();
        sp = s;
        spIdx=0;
        char ch=s.charAt(spIdx);
        if (ch == '#' || ch=='\r' || ch=='\n' || ch=='\0') {
          continue;
        }
        sp = null;
        if ((spIdx = s.indexOf('#')) >= 0) {
          s = s.substring(0,s.indexOf('#'));
          sp = "";
        }
        ncpos = sl.swi_cutstr(s, ",", cpos, 20);
        serri="error in file "+SweConst.SE_FICTFILE+", line "+
              iline+":";
        if (ncpos < 9) {
          if (serr != null) {
            serr.setLength(0);
            serr.append(serri).append(" nine elements required");
          }
          return SweConst.ERR;
        }
        iplan++;
        if (iplan != ipl) {
          continue;
        }
        elem_found = true;
        
        if (tjd0 != null) {
          sp = cpos[0];
          sp=sp.length()<=5?sp.toLowerCase():
                               sp.substring(0,5).toLowerCase()+sp.substring(5);
          if (sp.startsWith("j2000")) {
            tjd0.val = SwephData.J2000;
          } else if (sp.startsWith("b1950")) {
            tjd0.val = SwephData.B1950;
          } else if (sp.startsWith("j1900")) {
            tjd0.val = SwephData.J1900;
          } else if (sp.charAt(0) == 'j' || sp.charAt(0) == 'b') {
            if (serr != null) {
              serr.setLength(0);
              serr.append(serri).append(" invalid epoch");
            }
            fp.close(); return SweConst.ERR;
          } else
            tjd0.val = SwissLib.atof(sp);
          tt = tjd - tjd0.val;
        }
        
        if (tequ != null) {
          sp = cpos[1];
          spIdx=0;
          while(sp.charAt(spIdx) == ' ' || sp.charAt(spIdx) == '\t')
            spIdx++;
          sp=sp.substring(spIdx);
          sp=sp.length()<5?sp.toLowerCase():
                               sp.substring(0,5).toLowerCase()+sp.substring(5);
          if (sp.startsWith("j2000")) {
            tequ.val = SwephData.J2000;
          } else if (sp.startsWith("b1950")) {
            tequ.val = SwephData.B1950;
          } else if (sp.startsWith("j1900")) {
            tequ.val = SwephData.J1900;
          } else if (sp.startsWith("jdate")) {
            tequ.val = tjd;
          } else if (sp.charAt(0) == 'j' || sp.charAt(0) == 'b') {
            if (serr != null) {
              serr.setLength(0);
              serr.append(serri).append(" invalid equinox");
            }
            fp.close(); return SweConst.ERR;
          } else {
            tequ.val = SwissLib.atof(sp);
          }
        }
        
        if (mano != null) {
          retc = check_t_terms(tt, cpos[2], mano);
          mano.val = sl.swe_degnorm(mano.val);
          if (retc == SweConst.ERR) {
            if (serr != null) {
              serr.append(serri).append(" mean anomaly value invalid");
            }
            fp.close(); return SweConst.ERR;
          }
          
          if (retc == 1) {
            tjd0.val = tjd;
          }
          mano.val *= SwissData.DEGTORAD;
        }
        
        if (sema != null) {
          retc = check_t_terms(tt, cpos[3], sema);
          if (sema.val <= 0 || retc == SweConst.ERR) {
            if (serr != null) {
              serr.append(serri).append(" semi-axis value invalid");
            }
            fp.close(); return SweConst.ERR;
          }
        }
        
        if (ecce != null) {
          retc = check_t_terms(tt, cpos[4], ecce);
          if (ecce.val >= 1 || ecce.val < 0 || retc == SweConst.ERR) {
            if (serr != null) {
              serr.setLength(0);
              serr.append(serri).append(" eccentricity invalid (no parabolic or hyperbolic or bits allowed)");
            }
            fp.close(); return SweConst.ERR;
          }
        }
        
        if (parg != null) {
          retc = check_t_terms(tt, cpos[5], parg);
          parg.val = sl.swe_degnorm(parg.val);
          if (retc == SweConst.ERR) {
            if (serr != null) {
              serr.setLength(0);
              serr.append(serri).append(" perihelion argument value invalid");
            }
            fp.close(); return SweConst.ERR;
          }
          parg.val *= SwissData.DEGTORAD;
        }
        
        if (node != null) {
          retc = check_t_terms(tt, cpos[6], node);
          node.val = sl.swe_degnorm(node.val);
          if (retc == SweConst.ERR) {
            if (serr != null) {
              serr.setLength(0);
              serr.append(serri).append(" node value invalid");
            }
            fp.close(); return SweConst.ERR;
          }
          node.val *= SwissData.DEGTORAD;
        }
        
        if (incl != null) {
          retc = check_t_terms(tt, cpos[7], incl);
          incl.val = sl.swe_degnorm(incl.val);
          if (retc == SweConst.ERR) {
            if (serr != null) {
              serr.setLength(0);
              serr.append(serri).append(" inclination value invalid");
            }
            fp.close(); return SweConst.ERR;
          }
          incl.val *= SwissData.DEGTORAD;
        }
        
        if (pname != null) {
          sp = cpos[8];
          spIdx=0;
          while(sp.charAt(spIdx) == ' ' || sp.charAt(spIdx) == '\t')
            spIdx++;
          sp=sp.substring(spIdx);
          sp=sp.trim();
          pname.setLength(0); pname.append(sp);
        }
        
        if (fict_ifl != null && ncpos > 9) {
          sp = sp.substring(0,Math.min(sp.length(),spIdx+9)) +
               sp.substring(Math.min(sp.length(),spIdx+9)).toLowerCase();
          if (cpos[9].indexOf("geo") >= 0) {
            fict_ifl.val |= FICT_GEO;
          }
        }
        break;
      }
      if (!elem_found) {
        if (serr != null) {
          serr.append(serri).append(" elements for planet ").append(ipl).append(" not found");
        }
        fp.close(); return SweConst.ERR;
      }
      fp.close();
      return SweConst.OK;
    } catch (java.io.IOException e) {
      if (fp!=null) { try { fp.close(); } catch (java.io.IOException ie) { } }
    }
    return SweConst.ERR;
  }
  private int check_t_terms(double t, String sinp, DblObj doutp) {
    int i, isgn = 1, z;
    int retc = 0;
    int spidx;
    double tt[]=new double[5], fac;
    tt[0] = t / 36525;
    tt[1] = tt[0];
    tt[2] = tt[1] * tt[1];
    tt[3] = tt[2] * tt[1];
    tt[4] = tt[3] * tt[1];
    if (sinp.indexOf('+') + sinp.indexOf('-') > -2) {
      retc = 1; 
    }
    spidx=0;
    doutp.val = 0;
    fac = 1;
    z = 0;
    while (true) {
      while(spidx<sinp.length() &&
            (sinp.charAt(spidx)==' ' || sinp.charAt(spidx)=='\t')) {
        spidx++;
      }
      if (spidx==sinp.length() ||
          sinp.charAt(spidx)=='+' || sinp.charAt(spidx)=='-') {
        if (z > 0) {
          doutp.val += fac;
        }
        isgn = 1;
        if (spidx!=sinp.length() && sinp.charAt(spidx) == '-') {
          isgn = -1;
        }
        fac = 1 * isgn;
        if (spidx==sinp.length()) {
          return retc;
        }
        spidx++;
      } else {
        while(spidx<sinp.length() &&
              (sinp.charAt(spidx)=='*' || sinp.charAt(spidx)==' '
              || sinp.charAt(spidx)=='\t')) {
          spidx++;
        }
        if (spidx<sinp.length() &&
            (sinp.charAt(spidx)=='t' || sinp.charAt(spidx)=='T')) {
                
          spidx++;
          if (spidx<sinp.length() &&
              (sinp.charAt(spidx)=='+' || sinp.charAt(spidx)=='-')) {
            fac *= tt[0];
          } else if ((i = SwissLib.atoi(sinp.substring(Math.min(sinp.length(),spidx)))) <= 4 && i >= 0) {
            fac *= tt[i];
          }
        } else {
          
          double db=SwissLib.atof(sinp.substring(spidx));
          if (db!=0 || sinp.charAt(spidx)=='0') {
            fac *= db;
          }
        }
        while (spidx<sinp.length() &&
               (Character.isDigit(sinp.charAt(spidx)) ||
                sinp.charAt(spidx)=='.'))
          spidx++;
      }
      z++;
    }
  }
  private Plantbl planets[] = {
    SwemptabMer.mer404,
    SwemptabVen.ven404,
    SwemptabEar.ear404,
    SwemptabMar.mar404,
    SwemptabJup.jup404,
    SwemptabSat.sat404,
    SwemptabUra.ura404,
    SwemptabNep.nep404,
    SwemptabPlu.plu404,
  };
}
class SwissData {
  
  public String ODEGREE_CHAR=""+'\u00b0'; // Unicode degree character 176
                                          // Identical in most ISO-8859 sets
  public static final String ayanamsa_name[] = {
     "Fagan/Bradley",
     "Lahiri",
     "De Luce",
     "Raman",
     "Ushashashi",
     "Krishnamurti",
     "Djwhal Khul",
     "Yukteshwar",
     "J.N. Bhasin",
     "Babylonian/Kugler 1",
     "Babylonian/Kugler 2",
     "Babylonian/Kugler 3",
     "Babylonian/Huber",
     "Babylonian/Eta Piscium",
     "Babylonian/Aldebaran = 15 Tau",
     "Hipparchos",
     "Sassanian",
     "Galact. Center = 0 Sag",
     "J2000",
     "J1900",
     "B1950",
  };
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
  static final double M_PI=3.14159265358979323846;
  public static final int AS_MAXCH=256; // used for string declarations,
                                        // allowing 255 char+\0
  static final double DEGTORAD=0.0174532925199433;
  static final double RADTODEG=57.2957795130823;
  static final int DEG=360000;  // degree expressed in centiseconds
  static final int DEG7_30=2700000;	// 7.5 degrees
  static final int DEG15=15 * DEG;
  static final int DEG24=24 * DEG;
  static final int DEG30=30 * DEG;
  static final int DEG60=60 * DEG;
  static final int DEG90=90 * DEG;
  static final int DEG120=120 * DEG;
  static final int DEG150=150 * DEG;
  static final int DEG180=180 * DEG;
  static final int DEG270=270 * DEG;
  static final int DEG360=360 * DEG;
  static final double CSTORAD=4.84813681109536E-08; // centisec to rad:
                                                    // pi / 180 /3600/100
  static final double RADTOCS=2.06264806247096E+07; // rad to centisec
                                                    // 180*3600*100/pi
  static final double CS2DEG=1.0/360000.0;	     // centisec to degree
  static final String BFILE_R_ACCESS="r";  // open binary file for reading
  static final String BFILE_RW_ACCESS="r+";// open binary file for writing and reading
  static final String BFILE_W_CREATE="w";  // create/open binary file for write
  static final String BFILE_A_ACCESS="a+"; // create/open binary file for append
  static final String FILE_R_ACCESS="r";   // open text file for reading
  static final String FILE_RW_ACCESS="r+"; // open text file for writing and reading
  static final String FILE_W_CREATE="w";   // create/open text file for write
  static final String FILE_A_ACCESS="a+";  // create/open text file for append
  static final int O_BINARY=0;	           // for open(), not defined in Unix
  static final int OPEN_MODE=0666;         // default file creation mode
  public String DIR_GLUE;              // glue string for directory/file
  public static final String PATH_SEPARATOR=";:"; // semicolon or colon may be used
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
  public static final int SE_NSIDM_PREDEF         =21;
//					// must allow twice this space for
//				        // the returned star name.
//
  static final int pnoext2int[] = {SwephData.SEI_SUN, SwephData.SEI_MOON,
    SwephData.SEI_MERCURY, SwephData.SEI_VENUS, SwephData.SEI_MARS,
    SwephData.SEI_JUPITER, SwephData.SEI_SATURN, SwephData.SEI_URANUS,
    SwephData.SEI_NEPTUNE, SwephData.SEI_PLUTO, 0, 0, 0, 0, SwephData.SEI_EARTH,
    SwephData.SEI_CHIRON, SwephData.SEI_PHOLUS, SwephData.SEI_CERES,
    SwephData.SEI_PALLAS, SwephData.SEI_JUNO, SwephData.SEI_VESTA, };
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
  boolean ephe_path_is_set=false;
  boolean jpl_file_is_open=false;
  FilePtr fixfp=null;
  String ephepath;
  String jplfnam;
  int jpldenum;
  boolean geopos_is_set=false;
  boolean ayana_is_set=false;
  FileData fidat[] = new FileData[SwephData.SEI_NEPHFILES];
  GenConst gcdat;
  PlanData pldat[] = new PlanData[SwephData.SEI_NPLANETS];
  PlanData nddat[] = new PlanData[SwephData.SEI_NNODE_ETC];
  SavePositions savedat[] = new SavePositions[SweConst.SE_NPLANETS+1];
  Epsilon oec, oec2000;
  Nut nut, nut2000, nutv;
  TopoData topd;
  SidData sidd;
  String astelem;
  double ast_G, ast_H, ast_diam;
  int i_saved_planet_name;
  String saved_planet_name;
  
  public SwissData() {
    // File separator character:
    DIR_GLUE = System.getProperty("file.separator");
    try {
      // ODEGREE_CHAR:
      String cp=System.getProperties().getProperty("file.encoding");
      if (cp!=null) {
        if (cp.toUpperCase().startsWith("CP")) {
          try {
            int cpn=Integer.parseInt(cp.substring(2));
            if (cpn>=437 && cpn<870) {
              ODEGREE_CHAR=""+'\u00f8';
            }
          } catch (NumberFormatException nfe) {
          }
          ODEGREE_CHAR=""+'\u00f8'; // DOS degree character 248
        } else if (cp.toUpperCase().startsWith("ISO-8859-")) {
          ODEGREE_CHAR=""+'\u00b0'; // Latin1 degree character 176
        } else if (cp.toUpperCase().startsWith("UTF")) {
          ODEGREE_CHAR=""+'\u00b0'; // Default Unicode...
        }
      }
    } catch (SecurityException ase) {
      if (DIR_GLUE.equals("/")) {
        ODEGREE_CHAR=""+'\u00b0'; // Latin1 degree character 176
      } else if (DIR_GLUE.equals("\\")) {
        ODEGREE_CHAR=""+'\u00f8'; // DOS degree character 248
      } else {
        ODEGREE_CHAR=""+'\u00b0'; // Default Unicode...
      }
    }
    // Macintoshs (prior to MacOS X) should use '\u00a1', but how to
    // identify more reasonably? Has the Mac an appropriate text window anyway?
    if (DIR_GLUE.equals(":")) {
      ODEGREE_CHAR=""+'\u00a1';
    }
    int i;
    for(i=0;i<SwephData.SEI_NEPHFILES;i++){ fidat[i] = new FileData(); }
    gcdat = new GenConst();
    for(i=0;i<SwephData.SEI_NPLANETS;i++){ pldat[i] = new PlanData(); }
    for(i=0;i<SwephData.SEI_NNODE_ETC;i++){ nddat[i] = new PlanData(); }
    for(i=0;i<SweConst.SE_NPLANETS+1;i++){ savedat[i] = new SavePositions(); }
    oec = new Epsilon();
    oec2000 = new Epsilon();
    nut = new Nut();
    nut2000 = new Nut();
    nutv = new Nut();
    topd = new TopoData();
    sidd = new SidData();
  }
}
class SwissephException extends RuntimeException {
  private double jdet=0;
  private int type=0;
  private int rc=0;
  public static final int UNDEFINED                     = 0;
  // FILE errors:
  public static final int FILE_ERROR                    = 1;
  public static final int UNSPECIFIED_FILE_ERROR        = FILE_ERROR | 2;
  public static final int INVALID_FILE_NAME             = FILE_ERROR | 4;
  public static final int FILE_NOT_FOUND                = FILE_ERROR | 8;
  public static final int FILE_OPEN_FAILED              = FILE_ERROR | 16;
  public static final int FILE_READ_ERROR               = FILE_ERROR | 32;
  public static final int DATA_FILE_ERROR               = FILE_ERROR | 64;
  // Parameter errors:
  public static final int PARAM_ERROR                   = 128;
  public static final int OUT_OF_TIME_RANGE             = PARAM_ERROR | 256;
  public static final int UNSUPPORTED_OBJECT            = PARAM_ERROR | 512;
  public static final int INVALID_PARAMETER_COMBINATION = PARAM_ERROR | 1024;
  // User requested:
  public static final int USER_ERROR                    = 2048;
  public static final int BEYOND_USER_TIME_LIMIT        = USER_ERROR | 4096;
  public SwissephException(double jdet, int type, int rc, StringBuffer sb) {
    super(sb==null?null:sb.toString());
    this.jdet = jdet;
    this.type = type;
    this.rc = rc;
  }
  public SwissephException(double jdet, int type, int rc, String s) {
    super(s);
    this.jdet = jdet;
    this.type = type;
    this.rc = rc;
  }
  public SwissephException(double jdet, int type, String s) {
    super(s);
    this.jdet = jdet;
    this.type = type;
  }
  public SwissephException(double jdet, String s) {
    super(s);
    this.jdet = jdet;
    this.type = UNDEFINED;
  }
  
  public double getJD() {
    return jdet;
  }
  public int getType() {
    return type;
  }
  int getRC() {
    return rc;
  }
}
class SwissEph {
    SwissData swed;
    SwephMosh smosh;
    SwephJPL sj;
    SwissLib sl;
    Swecl sc=null;
    Swemmoon sm;
    SweHouse sh=null;
    Extensions ext=null;
    double lastLat=0.;
    double lastLong=0.;
    int lastHSys=-1;
    
    //////////////////////////////////////////////////////////////////////////////
    // Constructors: /////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////////
    
    public SwissEph() {
        this(null);
    }
    public String getTmp() {
        String tmp = "";
        if(System.getProperty("os.name").toLowerCase().indexOf("windows") > -1){
            tmp = "c:/temp";
        } else {
            tmp = "/tmp";
        }
        return tmp;
    }    
    
    public SwissEph(String path) {
               
        swed     = new SwissData();
        sl       = new SwissLib(this.swed);
        sm       = new Swemmoon(this.swed, this.sl);
        smosh    = new SwephMosh(this.sl, this, this.swed);
        sj       = new SwephJPL(this, this.swed, this.sl);
        swed.ephe_path_is_set=false;
        swed.jpl_file_is_open=false;
        swed.fixfp=null;
        swed.ephepath=SweConst.SE_EPHE_PATH;
        swed.jplfnam=SweConst.SE_FNAME_DFT;
        swed.geopos_is_set=false;
        swed.ayana_is_set=false;
        swe_set_ephe_path(path);
    }
    //////////////////////////////////////////////////////////////////////////////
    // End of Constructors ///////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////////
    // Public Methods: ///////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////////
    private int httpBufSize=300;
    
    public void setHttpBufSize(int size) {
        httpBufSize=size;
        if (size<100) {
            httpBufSize=100;
        }
        swe_close();
    }
    
    private int swe_calc_epheflag_sv = 0;
    
    public int swe_calc_ut(double tjd_ut, int ipl, int iflag, double xx[],
                           StringBuffer serr) {
        return swe_calc(tjd_ut + SweDate.getDeltaT(tjd_ut), ipl, iflag, xx, serr);
    }
    
    public int swe_calc(double tjd, int ipl, int iflag, double xx[],
                        StringBuffer serr) {
        // It has been rewritten to be wrapper to the old interface without
        // exception handling like it was in C. The old routine can now be
        // found in the method _calc().
        int ret = 0;
        try {
            ret = _calc(tjd, ipl, iflag, xx, serr);
        } catch (SwissephException se) {
            ret = se.getRC();
            serr.setLength(0);
            serr.append(se.getMessage());
        }
        return ret;
    }
    // This is the new recommended interface for planetary calculations.
    // It should be rewritten to be used for fixstars as well.
    public int calc(double jdET, int ipl, int iflag, double xx[])
        throws SwissephException {
        return _calc(jdET, ipl, iflag, xx, new StringBuffer());
    }
    private int _calc(double tjd, int ipl, int iflag, double xx[],
                      StringBuffer serr) throws SwissephException {
        int i, j;
        int iflgcoor;
        int iflgsave = iflag;
        int epheflag;
        SavePositions sd;
        double x[]=new double[6], xs[];
        double x0[]=new double[24],
            x2[]=new double[24];
        double dt;
        
        epheflag = iflag & SweConst.SEFLG_EPHMASK;
        if ((epheflag & SweConst.SEFLG_DEFAULTEPH)!=0) {
            epheflag = 0;
        }
        if (swe_calc_epheflag_sv != epheflag && ipl != SweConst.SE_ECL_NUT) {
            swe_close();
            swe_calc_epheflag_sv = epheflag;
        }
        
        if ((iflag & SweConst.SEFLG_SPEED3)!=0 && (iflag & SweConst.SEFLG_SPEED)!=0) {
            iflag = iflag & ~SweConst.SEFLG_SPEED3;
        }
        
        if (((iflag & SweConst.SEFLG_XYZ)!=0) &&
            ((iflag & SweConst.SEFLG_RADIANS)!=0)) {
            iflag = iflag & ~SweConst.SEFLG_RADIANS;
        }
        
        
        if (ipl < SweConst.SE_NPLANETS && ipl >= SweConst.SE_SUN) {
            sd = swed.savedat[ipl];
        } else {
            
            sd = swed.savedat[SweConst.SE_NPLANETS];
        }
        
        iflgcoor = SweConst.SEFLG_EQUATORIAL | SweConst.SEFLG_XYZ |
            SweConst.SEFLG_RADIANS;
        try { // SwissephExceptions from swecalc
            if (sd.tsave != tjd || tjd == 0 || ipl != sd.ipl ||
                ((sd.iflgsave & ~iflgcoor) != (iflag & ~iflgcoor))) {
                
                if ((iflag & SweConst.SEFLG_SPEED3) == 0) {
                    
                    sd.tsave = tjd;
                    sd.ipl = ipl;
                    if ((sd.iflgsave = swecalc(tjd, ipl, iflag, sd.xsaves, serr)) ==
                        SweConst.ERR) {
                        return swe_calc_error(xx);
                    }
                } else {
                    
                    sd.tsave = tjd;
                    sd.ipl = ipl;
                    switch(ipl) {
                        case SweConst.SE_MOON:
                            dt = SwephData.MOON_SPEED_INTV;
                            break;
                        case SweConst.SE_OSCU_APOG:
                        case SweConst.SE_TRUE_NODE:
                            
                            dt = SwephData.NODE_CALC_INTV_MOSH;
                            break;
                        default:
                            dt = SwephData.PLAN_SPEED_INTV;
                            break;
                    }
                    sd.iflgsave = swecalc(tjd-dt, ipl, iflag, x0, serr);
                    if (sd.iflgsave == SweConst.ERR) {
                        return swe_calc_error(xx);
                    }
                    sd.iflgsave = swecalc(tjd+dt, ipl, iflag, x2, serr);
                    if (sd.iflgsave == SweConst.ERR) {
                        return swe_calc_error(xx);
                    }
                    sd.iflgsave = swecalc(tjd, ipl, iflag, sd.xsaves, serr);
                    if (sd.iflgsave == SweConst.ERR) {
                        return swe_calc_error(xx);
                    }
                    denormalize_positions(x0, sd.xsaves, x2);
                    calc_speed(x0, sd.xsaves, x2, dt);
                }
            }
        } catch (SwissephException se) {
            sd.iflgsave = SweConst.ERR;
            swe_calc_error(xx);
            throw se;
        }
        // end_swe_calc:
        int xsOffset=0;
        xs=sd.xsaves;
        if ((iflag & SweConst.SEFLG_EQUATORIAL) != 0) {
            xsOffset=12;        
            //    } else {
            //      xsOffset=0;         
        }
        if ((iflag & SweConst.SEFLG_XYZ)!=0) {
            xsOffset+=6;         
        }
        if (ipl == SweConst.SE_ECL_NUT) {
            i = 4;
        } else {
            i = 3;
        }
        for (j = 0; j < i; j++) { x[j] = xs[j+xsOffset]; }
        for (j = i; j < 6; j++) { x[j] = 0; }
        if ((iflag & (SweConst.SEFLG_SPEED3 | SweConst.SEFLG_SPEED))!=0) {
            for (j = 3; j < 6; j++) { x[j] = xs[j+xsOffset]; }
        }
        if ((iflag & SweConst.SEFLG_RADIANS)!=0) {
            if (ipl == SweConst.SE_ECL_NUT) {
                for (j = 0; j < 4; j++)
                    x[j] *= SwissData.DEGTORAD;
            } else {
                for (j = 0; j < 2; j++)
                    x[j] *= SwissData.DEGTORAD;
                if ((iflag & (SweConst.SEFLG_SPEED3 | SweConst.SEFLG_SPEED))!=0) {
                    for (j = 3; j < 5; j++)
                        x[j] *= SwissData.DEGTORAD;
                }
            }  
        } 
        for (i = 0; i <= 5; i++) {
            xx[i] = x[i];
        }
        iflag = sd.iflgsave;
        
        if ((iflgsave & SweConst.SEFLG_EPHMASK) == 0) {
            iflag = iflag & ~SweConst.SEFLG_DEFAULTEPH;
        }
        return iflag;
    }
    
    
    public void swe_close() {
        int i;
        try {
            
            for(i=0;i<SwephData.SEI_NEPHFILES;i++) {
                swed.fidat[i].clearData();
            }
            
            for(i=0;i<SwephData.SEI_NPLANETS;i++) {
                swed.pldat[i].clearData();
            }
            for (i=0; i <= SweConst.SE_NPLANETS; i++) {
                swed.savedat[i].clearData();
            }
            
            for(i=0;i<SwephData.SEI_NNODE_ETC;i++) {
                swed.nddat[i].clearData();
            }
            swed.oec.clearData();
            swed.oec2000.clearData();
            swed.nut.clearData();
            swed.nut2000.clearData();
            swed.nutv.clearData();
            
            sj.swi_close_jpl_file();
            swed.jpl_file_is_open=false;
            
            if (swed.fixfp!=null) {
                swed.fixfp.close();
                swed.fixfp=null;
            }
        } catch (java.io.IOException e) {
            // NBT
        }
    }
    
    
    public void swe_set_ephe_path(String path) {
        String s="";
        swed.ephe_path_is_set=true;
        
        swe_close();
        //  
        //  if ((sp = getenv("SE_EPHE_PATH")) != NULL
        //    && strlen(sp) != 0
        //    && strlen(sp) <= AS_MAXCH-1-13) {
        //    strcpy(s, sp);
        //  } else
        if (path == null || path.length() == 0) {
            s=SweConst.SE_EPHE_PATH;
        } else if (path.length() <= SwissData.AS_MAXCH-1-13) {
            s=path;
        } else {
            s=SweConst.SE_EPHE_PATH;
        }
        // JAVA: Skipping this code in the Java version - it does not do anything
        // meaningful anyway...
        //    if (! s.endsWith(swed.DIR_GLUE)) {
        //      s+=swed.DIR_GLUE;
        //    }
        swed.ephepath=s;
    }
    
    
    public void swe_set_jpl_file(String fname) {
        
        swe_close();
        
        if (fname.indexOf(swed.DIR_GLUE)>=0) {
            fname=fname.substring(fname.lastIndexOf(swed.DIR_GLUE));
        }
        if (fname.length() >= SwissData.AS_MAXCH) {
            fname=fname.substring(0,SwissData.AS_MAXCH);
        }
        swed.jplfnam=fname;
    }
    
    public void swe_set_sid_mode(int sid_mode, double t0, double ayan_t0) {
        SidData sip = swed.sidd;
        sip.sid_mode = sid_mode;
        if (sid_mode >= SweConst.SE_SIDBITS) {
            sid_mode %= SweConst.SE_SIDBITS;
        }
        
        if (sid_mode == SweConst.SE_SIDM_J2000
            || sid_mode == SweConst.SE_SIDM_J1900
            || sid_mode == SweConst.SE_SIDM_B1950) {
            sip.sid_mode |= SweConst.SE_SIDBIT_ECL_T0;
        }
        if (sid_mode >= SwissData.SE_NSIDM_PREDEF && sid_mode != SweConst.SE_SIDM_USER) {
            sip.sid_mode = sid_mode = SweConst.SE_SIDM_FAGAN_BRADLEY;
        }
        swed.ayana_is_set = true;
        if (sid_mode == SweConst.SE_SIDM_USER) {
            sip.t0 = t0;
            sip.ayan_t0 = ayan_t0;
        } else {
            sip.t0 = SwephData.ayanamsa[sid_mode].t0;
            sip.ayan_t0 = SwephData.ayanamsa[sid_mode].ayan_t0;
        }
        swi_force_app_pos_etc();
    }
    
    
    public double swe_get_ayanamsa(double tjd_et) {
        double x[]=new double[6], eps;
        SidData sip = swed.sidd;
        if (!swed.ayana_is_set) {
            swe_set_sid_mode(SweConst.SE_SIDM_FAGAN_BRADLEY, 0, 0);
        }
        
        x[0] = 1;
        x[1] = x[2] = 0;
        
        if (tjd_et != SwephData.J2000) {
            sl.swi_precess(x, tjd_et, SwephData.J_TO_J2000);
        }
        
        sl.swi_precess(x, sip.t0, SwephData.J2000_TO_J);
        
        eps = sl.swi_epsiln(sip.t0);
        sl.swi_coortrf(x, x, eps);
        
        sl.swi_cartpol(x, x);
        
        x[0] = x[0] * SwissData.RADTODEG - sip.ayan_t0;
        
        return sl.swe_degnorm(-x[0]);
    }
    
    public double swe_get_ayanamsa_ut(double tjd_ut) {
        return swe_get_ayanamsa(tjd_ut + SweDate.getDeltaT(tjd_ut));
    }
    
    
    public int swe_fixstar(StringBuffer star, double tjd, int iflag, double xx[],
                           StringBuffer serr) {
        int i;
        int star_nr = 0;
        boolean isnomclat = false;
        int cmplen;
        // Missing parameters are in "int swe_fixstar_found(...)"!
        String sstar=null;
        String fstar=null;
        String s, sp;
        int line = 0;
        int fline = 0;
        int epheflag, iflgsave;
        iflag |= SweConst.SEFLG_SPEED; 
        iflgsave = iflag;
        if (serr != null) {
            serr.setLength(0);
        }
        iflag = plaus_iflag(iflag);
        if (((iflag & SweConst.SEFLG_SIDEREAL)!=0) && !swed.ayana_is_set) {
            swe_set_sid_mode(SweConst.SE_SIDM_FAGAN_BRADLEY, 0, 0);
        }
        epheflag = iflag & SweConst.SEFLG_EPHMASK;
        
        swi_check_ecliptic(tjd);
        
        swi_check_nutation(tjd, iflag);
        if (swed.fixfp == null) {
            try {
                swed.fixfp = swi_fopen(SwephData.SEI_FILE_FIXSTAR, SweConst.SE_STARFILE,
                                       swed.ephepath, serr);
            } catch (SwissephException se) {
                return swe_fixstar_error(xx,SweConst.ERR);
            }
        }
        
        swed.fixfp.seek(0);
        sstar=star.toString().substring(0,
                                        Math.min(star.length(),SweConst.SE_MAX_STNAME));
        if (sstar.length()>0) {
            if (sstar.charAt(0) == ',') {
                isnomclat = true;
            } else if (Character.isDigit(sstar.charAt(0))) {
                // Use SwissLib.atoi(...)!!!
                star_nr = Integer.parseInt(sstar);
            } else {
                
                sstar=sstar.toLowerCase();
                if (sstar.indexOf(',')>=0) {
                    sstar=sstar.substring(0,sstar.indexOf(','));
                }
            }
            sstar=sstar.trim();
        }
        cmplen = sstar.length();
        if (cmplen == 0) {
            if (serr != null) {
                serr.setLength(0);
                serr.append("star name empty");
            }
            return swe_fixstar_error(xx,SweConst.ERR);
        }
        try {
            while ((s=swed.fixfp.readLine())!=null) {
                fline++;
                if (s.startsWith("#")) { continue; }
                line++;
                if (star_nr == line) {
                    return swe_fixstar_found(serr,s,star,tjd,iflag,iflgsave,epheflag,xx);
                }
                else if (star_nr > 0) {
                    continue;
                }
                if(s.indexOf(',')<0) {
                    if (serr != null) {
                        serr.setLength(0);
                        serr.append("star file "+SweConst.SE_STARFILE+" damaged at line "+
                                    fline);
                    }
                    return swe_fixstar_error(xx,SweConst.ERR);
                }
                sp=s.substring(s.indexOf(','));
                if (isnomclat) {
                    if (sp.substring(0,Math.min(sp.length(),cmplen)).equals(
                                                                            sstar.substring(0,Math.min(sstar.length(),cmplen)))) {
                        return swe_fixstar_found(serr,s,star,tjd,iflag,iflgsave,epheflag,xx);
                    } else {
                        continue;
                    }
                }
                fstar=s.substring(0,
                                  Math.min(SweConst.SE_MAX_STNAME,s.indexOf(','))).trim();
                i = fstar.length();
                if (i < cmplen) {
                    continue;
                }
                fstar=fstar.toLowerCase();
                if (fstar.substring(0,Math.min(fstar.length(),cmplen)).equals(
                                                                              sstar.substring(0,Math.min(sstar.length(),cmplen)))) {
                    return swe_fixstar_found(serr,s,star,tjd,iflag,iflgsave,epheflag,xx);
                }
            }
        } catch (java.io.IOException ioe) {
        }
        if (serr != null && star.length() < SwissData.AS_MAXCH - 20) {
            serr.setLength(0);
            serr.append("star "+star+" not found");
        }
        return swe_fixstar_error(xx,SweConst.ERR);
    }
    
    public int swe_fixstar_ut(StringBuffer star, double tjd_ut, int iflag,
                              double[] xx, StringBuffer serr) {
        return swe_fixstar(star, tjd_ut + SweDate.getDeltaT(tjd_ut),
                           iflag, xx, serr);
    }
    
    public String swe_get_planet_name(int ipl) {
        String s="";
        int i;
        int retc;
        double xp[]=new double[6];
        if (ipl != 0 && ipl == swed.i_saved_planet_name) {
            s=swed.saved_planet_name;
            return s;
        }
        switch(ipl) {
            case SweConst.SE_SUN:
                s = SwephData.SE_NAME_SUN;
                break;
            case SweConst.SE_MOON:
                s = SwephData.SE_NAME_MOON;
                break;
            case SweConst.SE_MERCURY:
                s = SwephData.SE_NAME_MERCURY;
                break;
            case SweConst.SE_VENUS:
                s = SwephData.SE_NAME_VENUS;
                break;
            case SweConst.SE_MARS:
                s = SwephData.SE_NAME_MARS;
                break;
            case SweConst.SE_JUPITER:
                s = SwephData.SE_NAME_JUPITER;
                break;
            case SweConst.SE_SATURN:
                s = SwephData.SE_NAME_SATURN;
                break;
            case SweConst.SE_URANUS:
                s = SwephData.SE_NAME_URANUS;
                break;
            case SweConst.SE_NEPTUNE:
                s = SwephData.SE_NAME_NEPTUNE;
                break;
            case SweConst.SE_PLUTO:
                s = SwephData.SE_NAME_PLUTO;
                break;
            case SweConst.SE_MEAN_NODE:
                s = SwephData.SE_NAME_MEAN_NODE;
                break;
            case SweConst.SE_TRUE_NODE:
                s = SwephData.SE_NAME_TRUE_NODE;
                break;
            case SweConst.SE_MEAN_APOG:
                s = SwephData.SE_NAME_MEAN_APOG;
                break;
            case SweConst.SE_OSCU_APOG:
                s = SwephData.SE_NAME_OSCU_APOG;
                break;
            case SweConst.SE_INTP_APOG: 
                s = SwephData.SE_NAME_INTP_APOG;
                break;  
            case SweConst.SE_INTP_PERG: 
                s = SwephData.SE_NAME_INTP_PERG;
                break;  
            case SweConst.SE_EARTH:
                s = SwephData.SE_NAME_EARTH;
                break;
            case SweConst.SE_CHIRON:
            case SweConst.SE_AST_OFFSET + SwephData.MPC_CHIRON:
                s = SwephData.SE_NAME_CHIRON;
                break;
            case SweConst.SE_PHOLUS:
            case SweConst.SE_AST_OFFSET + SwephData.MPC_PHOLUS:
                s = SwephData.SE_NAME_PHOLUS;
                break;
            case SweConst.SE_CERES:
            case SweConst.SE_AST_OFFSET + SwephData.MPC_CERES:
                s = SwephData.SE_NAME_CERES;
                break;
            case SweConst.SE_PALLAS:
            case SweConst.SE_AST_OFFSET + SwephData.MPC_PALLAS:
                s = SwephData.SE_NAME_PALLAS;
                break;
            case SweConst.SE_JUNO:
            case SweConst.SE_AST_OFFSET + SwephData.MPC_JUNO:
                s = SwephData.SE_NAME_JUNO;
                break;
            case SweConst.SE_VESTA:
            case SweConst.SE_AST_OFFSET + SwephData.MPC_VESTA:
                s = SwephData.SE_NAME_VESTA;
                break;
            default:
                
                if (ipl >= SweConst.SE_FICT_OFFSET && ipl <= SweConst.SE_FICT_MAX) {
                    return smosh.swi_get_fict_name(ipl - SweConst.SE_FICT_OFFSET, s);
                }
                
                if (ipl > SweConst.SE_AST_OFFSET) {
                    
                    if (ipl == swed.fidat[SwephData.SEI_FILE_ANY_AST].ipl[0]) {
                        s=swed.fidat[SwephData.SEI_FILE_ANY_AST].astnam;
                        
                    } else {
                        retc = sweph(SwephData.J2000, ipl, SwephData.SEI_FILE_ANY_AST, 0,
                                     null, SwephData.NO_SAVE, xp, null);
                        if (retc != SweConst.ERR && retc != SwephData.NOT_AVAILABLE) {
                            s=swed.fidat[SwephData.SEI_FILE_ANY_AST].astnam;
                        } else {
                            s=(ipl - SweConst.SE_AST_OFFSET)+": not found";
                        }
                    }
                    
                    // Hopefully, I did understand the whole thing correctly...
                    if (s.charAt(0) == '?' || Character.isDigit(s.charAt(1))) {
                        int ipli = (int) (ipl - SweConst.SE_AST_OFFSET), iplf = 0;
                        FilePtr fp = null;
                        String si;
                        try {
                            fp = swi_fopen(-1, SweConst.SE_ASTNAMFILE, swed.ephepath, null);
                        } catch (SwissephException se) {
                        }
                        if (fp != null) {
                            while(ipli != iplf) {
                                try {
                                    si=fp.readLine();
                                    if (si==null) { break; }
                                    StringTokenizer tk= "**********"
                                    String sk= "**********"
                                    if (sk.startsWith("#") ||
                                        Character.isWhitespace(sk.charAt(0))) {
                                        continue;
                                    }
                                    
                                    iplf = Double.valueOf(sk).intValue();
                                    if (ipli != iplf) {
                                        continue;
                                    }
                                    s= "**********"
                                    fp.close();
                                } catch (java.io.IOException ioe) {
                                    // NBT
                                } catch (NoSuchElementException nse) {
                                    continue; 
                                }
                            }
                        }
                    }
                } else  {
                    i = ipl;
                    s=""+i;
                }
                break;
                // End of default
        } // End of switch()
        if (s.length() < 80) {
            swed.i_saved_planet_name = ipl;
            swed.saved_planet_name = s;
        }
        return s;
    }
    public String swe_get_ayanamsa_name(int isidmode) {
        if (isidmode < SwissData.SE_NSIDM_PREDEF)
            return SwissData.ayanamsa_name[isidmode];
        return null;
    }
    
    
    public void swe_set_topo(double geolon, double geolat, double geoalt) {
        swed.topd.geolon = geolon;
        swed.topd.geolat = geolat;
        swed.topd.geoalt = geoalt;
        swed.geopos_is_set = true;
        
        swed.topd.teval = 0;
        
        swi_force_app_pos_etc();
    }
    ////////////////////////////////////////////////////////////////////////////
    // Methods from SwephJPL.java: /////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////
    public double[] getJPLRange(String fname) {
        if (sj==null) {
            sj=new SwephJPL(this, swed, sl);
        }
        return sj.getJPLRange(fname);
    }
    ////////////////////////////////////////////////////////////////////////////
    // Methods from Swecl.java: ////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////
    
    public void swe_azalt(double tjd_ut, int calc_flag, double[] geopos,
                          double atpress, double attemp, double[] xin,
                          double[] xaz) {
        if (sc==null) {
            sc=new Swecl(this, sl, sm, swed);
        }
        sc.swe_azalt(tjd_ut, calc_flag, geopos, atpress, attemp, xin, xaz);
    }
    
    public void swe_azalt_rev(double tjd_ut, int calc_flag, double[] geopos,
                              double[] xin, double[] xout) {
        if (sc==null) {
            sc=new Swecl(this, sl, sm, swed);
        }
        sc.swe_azalt_rev(tjd_ut, calc_flag, geopos, xin, xout);
    }
    
    public int swe_lun_eclipse_how(double tjd_ut, int ifl, double[] geopos,
                                   double[] attr, StringBuffer serr) {
        if (sc==null) {
            sc=new Swecl(this, sl, sm, swed);
        }
        return sc.swe_lun_eclipse_how(tjd_ut, ifl, geopos, attr, serr);
    }
    
    public int swe_lun_eclipse_when(double tjd_start, int ifl, int ifltype,
                                    double[] tret, int backward,
                                    StringBuffer serr) {
        if (sc==null) {
            sc=new Swecl(this, sl, sm, swed);
        }
        return sc.swe_lun_eclipse_when(tjd_start,ifl,ifltype,tret,backward,serr);
    }
    
    public int swe_nod_aps(double tjd_et, int ipl, int iflag, int  method,
                           double[] xnasc, double[] xndsc,
                           double[] xperi, double[] xaphe,
                           StringBuffer serr) {
        if (sc==null) {
            sc=new Swecl(this, sl, sm, swed);
        }
        return sc.swe_nod_aps(tjd_et, ipl, iflag, method, xnasc, xndsc,
                              xperi, xaphe, serr);
    }
    
    public int swe_nod_aps_ut(double tjd_ut, int ipl, int iflag, int  method,
                              double[] xnasc, double[] xndsc,
                              double[] xperi, double[] xaphe,
                              StringBuffer serr) {
        if (sc==null) {
            sc=new Swecl(this, sl, sm, swed);
        }
        return sc.swe_nod_aps_ut(tjd_ut, ipl, iflag, method, xnasc, xndsc,
                                 xperi, xaphe, serr);
    }
    
    public int swe_pheno(double tjd, int ipl, int iflag, double[] attr,
                         StringBuffer serr) {
        if (sc==null) {
            sc=new Swecl(this, sl, sm, swed);
        }
        return sc.swe_pheno(tjd, ipl, iflag, attr, serr);
    }
    
    public int swe_pheno_ut(double tjd_ut, int ipl, int iflag, double[] attr,
                            StringBuffer serr) {
        if (sc==null) {
            sc=new Swecl(this, sl, sm, swed);
        }
        return sc.swe_pheno_ut(tjd_ut, ipl, iflag, attr, serr);
    }
    
    public double swe_refrac(double inalt, double atpress, double attemp,
                             int calc_flag) {
        if (sc==null) {
            sc=new Swecl(this, sl, sm, swed);
        }
        return sc.swe_refrac(inalt, atpress, attemp, calc_flag);
    }
    
    public int swe_rise_trans(double tjd_ut, int ipl, StringBuffer starname,
                              int epheflag, int rsmi, double[] geopos,
                              double atpress, double attemp, DblObj tret,
                              StringBuffer serr) {
        if (sc==null) {
            sc=new Swecl(this, sl, sm, swed);
        }
        return sc.swe_rise_trans(tjd_ut, ipl, starname, epheflag, rsmi, geopos,
                                 atpress, attemp, tret, serr);
    }
    
    public int swe_sol_eclipse_how(double tjd_ut, int ifl, double[] geopos,
                                   double[] attr, StringBuffer serr) {
        if (sc==null) {
            sc=new Swecl(this, sl, sm, swed);
        }
        return sc.swe_sol_eclipse_how(tjd_ut, ifl, geopos, attr, serr);
    }
    
    public int swe_sol_eclipse_when_glob(double tjd_start, int ifl, int ifltype,
                                         double tret[], int backward,
                                         StringBuffer serr) {
        if (sc==null) {
            sc=new Swecl(this, sl, sm, swed);
        }
        return sc.swe_sol_eclipse_when_glob(tjd_start, ifl, ifltype, tret,
                                            backward, serr);
    }
    
    public int swe_sol_eclipse_when_loc(double tjd_start, int ifl,
                                        double[] geopos, double[] tret,
                                        double[] attr, int backward,
                                        StringBuffer serr) {
        if (sc==null) {
            sc=new Swecl(this, sl, sm, swed);
        }
        return sc.swe_sol_eclipse_when_loc(tjd_start, ifl, geopos, tret, attr,
                                           backward, serr);
    }
    
    public int swe_sol_eclipse_where(double tjd_ut, int ifl, double[] geopos,
                                     double[] attr, StringBuffer serr) {
        if (sc==null) {
            sc=new Swecl(this, sl, sm, swed);
        }
        return sc.swe_sol_eclipse_where(tjd_ut, ifl, geopos, attr, serr);
    }
    
    
    public int swe_lun_occult_when_loc(double tjd_start, int ipl, StringBuffer starname, int ifl,
                                       double[] geopos, double[] tret, double[] attr, int backward, StringBuffer serr) {
        if (sc==null) {
            sc=new Swecl(this, sl, sm, swed);
        }
        return sc.swe_lun_occult_when_loc(tjd_start, ipl, starname, ifl, geopos, tret, attr, backward, serr);
    }
    
    public int swe_lun_occult_where(double tjd_ut,
                                    int ipl,
                                    StringBuffer starname,
                                    int ifl,
                                    double[] geopos,
                                    double[] attr,
                                    StringBuffer serr) {
        if (sc==null) {
            sc=new Swecl(this, sl, sm, swed);
        }
        return sc.swe_lun_occult_where(tjd_ut, ipl, starname, ifl, geopos, attr, serr);
    }
    
    
    public int swe_lun_occult_when_glob(
                                        double tjd_start, int ipl, StringBuffer starname, int ifl, int ifltype,
                                        double[] tret, int backward, StringBuffer serr) {
        if (sc==null) {
            sc=new Swecl(this, sl, sm, swed);
        }
        return sc.swe_lun_occult_when_glob(tjd_start, ipl, starname, ifl, ifltype, tret, backward, serr);
    }
    
    
    public int swe_gauquelin_sector(double t_ut, int ipl, StringBuffer starname, int iflag, int imeth, double[] geopos, double atpress, double attemp, DblObj dgsect, StringBuffer serr) {
        if (sc==null) {
            sc=new Swecl(this, sl, sm, swed);
        }
        return sc.swe_gauquelin_sector(t_ut, ipl, starname, iflag, imeth, geopos, atpress, attemp, dgsect, serr);
    }
    ////////////////////////////////////////////////////////////////////////////
    // Methods from SweHouse.java: /////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////
    
    public double swe_house_pos(double armc, double geolat, double eps,
                                int hsys, double xpin[], StringBuffer serr) {
        if (sh==null) {
            sh=new SweHouse(sl, this, swed);
        }
        return sh.swe_house_pos(armc, geolat, eps, hsys, xpin, serr);
    }
    
    public int swe_houses_armc(double armc, double geolat, double eps,
                               int hsys, double[] cusp, double[] ascmc) {
        if (sh==null) {
            sh=new SweHouse(sl, this, swed);
        }
        return sh.swe_houses_armc(armc, geolat, eps, hsys, cusp, ascmc, 0);
    }
      
    public int swe_houses(double tjd_ut, int iflag, double geolat,
                          double geolon, int hsys, double[] cusp,
                          double[] ascmc) {
        return swe_houses(tjd_ut, iflag, geolat, geolon, hsys, cusp, ascmc, 0);
    }
    public int swe_houses(double tjd_ut, int iflag, double geolat,
                          double geolon, int hsys, double[] cusp,
                          double[] ascmc, int aOffs) {
        if (sh==null) {
            sh=new SweHouse(sl, this, swed);
        }
        return sh.swe_houses(tjd_ut, iflag, geolat, geolon, hsys, cusp, ascmc, aOffs);
    }
    
    public double getTransitET(TransitCalculator tc, double jdET, boolean backwards)
        throws IllegalArgumentException, SwissephException {
        return getTransitET(tc,
                            jdET,
                            backwards,
                            (backwards?-Double.MAX_VALUE:Double.MAX_VALUE));
    }
    
    public double getTransitET(TransitCalculator tc, double jdET, boolean backwards, double jdLimit)
        throws IllegalArgumentException, SwissephException {
        if (ext==null) { ext=new Extensions(this); }
        return ext.getTransit(tc, jdET, backwards, jdLimit);
    }
    
    public double getTransitUT(
                               TransitCalculator tc,
                               double jdUT,
                               boolean backwards)
        throws IllegalArgumentException, SwissephException {
        if (ext==null) { ext=new Extensions(this); }
        double jdET = ext.getTransit(
                                     tc,
                                     jdUT + SweDate.getDeltaT(jdUT),
                                     backwards,
                                     (backwards?-Double.MAX_VALUE:Double.MAX_VALUE));
        return jdET - SweDate.getDeltaT(jdET);
    }
    
    public double getTransitUT(
                               TransitCalculator tc,
                               double jdUT,
                               boolean backwards,
                               double jdLimit)
        throws IllegalArgumentException, SwissephException {
        if (ext==null) { ext=new Extensions(this); }
        double jdET = ext.getTransit(
                                     tc,
                                     jdUT + SweDate.getDeltaT(jdUT),
                                     backwards,
                                     jdLimit + SweDate.getDeltaT(jdLimit));
        return jdET - SweDate.getDeltaT(jdET);
    }
    //////////////////////////////////////////////////////////////////////////////
    // End of public methods /////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////////
    private int swe_calc_error(double[] xx) {
        for (int i = 0; i < xx.length; i++) {
            xx[i] = 0;
        }
        return SweConst.ERR;
    }
    int swecalc(double tjd, int ipl, int iflag, double[] x, StringBuffer serr) 
        throws SwissephException {
        int i;
        int ipli, ipli_ast, ifno;
        int retc;
        int epheflag = SweConst.SEFLG_DEFAULTEPH;
        PlanData pdp;
        PlanData pedp = swed.pldat[SwephData.SEI_EARTH];
        PlanData psdp = swed.pldat[SwephData.SEI_SUNBARY];
        PlanData ndp;
        double xp[], xp2[];
        double ss[]=new double[3];
        String serr2="";
        if (serr!=null) { serr.setLength(0); }
        
        iflag = plaus_iflag(iflag);
        
        if ((iflag & SweConst.SEFLG_MOSEPH)!=0) {
            epheflag = SweConst.SEFLG_MOSEPH;
        }
        if ((iflag & SweConst.SEFLG_SWIEPH)!=0) {
            epheflag = SweConst.SEFLG_SWIEPH;
        }
        if ((iflag & SweConst.SEFLG_JPLEPH)!=0) {
            epheflag = SweConst.SEFLG_JPLEPH;
        }
        
        if (((iflag & SweConst.SEFLG_BARYCTR)!=0) &&
            ((iflag & SweConst.SEFLG_MOSEPH)!=0)) {
            if (serr != null) {
                serr.append("barycentric Moshier positions are not supported.");
            }
            throw new SwissephException(tjd, SwissephException.INVALID_PARAMETER_COMBINATION,
                                        SweConst.ERR, serr);
        }
        if (epheflag != SweConst.SEFLG_MOSEPH && !swed.ephe_path_is_set) {
            swe_set_ephe_path(null);
        }
        if ((iflag & SweConst.SEFLG_SIDEREAL)!=0 && !swed.ayana_is_set) {
            swe_set_sid_mode(SweConst.SE_SIDM_FAGAN_BRADLEY, 0, 0);
        }
        
        swi_check_ecliptic(tjd);
        
        swi_check_nutation(tjd, iflag);
        
        if (ipl == SweConst.SE_ECL_NUT) {
            x[0] = swed.oec.eps + swed.nut.nutlo[1];	
            x[1] = swed.oec.eps;			
            x[2] = swed.nut.nutlo[0];		
            x[3] = swed.nut.nutlo[1];		
            
            for (i = 0; i <= 3; i++)
                x[i] *= SwissData.RADTODEG;
            return(iflag);
            
        } else if (ipl == SweConst.SE_MOON) {
            
            ipli = SwephData.SEI_MOON;
            pdp = swed.pldat[ipli];
            xp = pdp.xreturn;
            switch(epheflag) {
                case SweConst.SEFLG_JPLEPH:
                    retc = jplplan(tjd, ipli, iflag, SwephData.DO_SAVE, null,null,null, serr);
                    
                    if (retc == SweConst.ERR) {
                        swecalc_error(x);
                        throw new SwissephException(tjd, SwissephException.DATA_FILE_ERROR,
                                                    SweConst.ERR, serr);
                    }
                    
                    if (retc == SwephData.NOT_AVAILABLE) {
                        iflag = (iflag & ~SweConst.SEFLG_JPLEPH) | SweConst.SEFLG_SWIEPH;
                        if (serr != null && serr.length() + 30 < SwissData.AS_MAXCH) {
                            serr.append(" \ntrying Swiss Eph; ");
                        }
                        retc =  sweph_moon(tjd, ipli, iflag, serr);
                        if (retc == SweConst.ERR) {
                            return swecalc_error(x);
                        }
                    } else if (retc == SwephData.BEYOND_EPH_LIMITS) {
                        if (tjd > SwephData.MOSHLUEPH_START &&
                            tjd < SwephData.MOSHLUEPH_END) {
                            iflag = (iflag & ~SweConst.SEFLG_JPLEPH) | SweConst.SEFLG_MOSEPH;
                            if (serr != null && serr.length() + 30 < SwissData.AS_MAXCH) {
                                serr.append(" \nusing Moshier Eph; ");
                            }
                            //              goto moshier_moon;
                            retc = moshier_moon(tjd, SwephData.DO_SAVE, null, serr);
                            if (retc == SweConst.ERR) {
                                return swecalc_error(x);
                            }
                        } else
                            return swecalc_error(x);
                    }
                    break;
                case SweConst.SEFLG_SWIEPH:
                    retc =  sweph_moon(tjd, ipli,iflag, serr);
                    if (retc == SweConst.ERR) {
                        return swecalc_error(x);
                    }
                    break;
                case SweConst.SEFLG_MOSEPH:
                    //          moshier_moon:
                    retc = moshier_moon(tjd, SwephData.DO_SAVE, null, serr);
                    if (retc == SweConst.ERR) {
                        return swecalc_error(x);
                    }
                    break;
                default:
                    break;
            }
            
            if ((retc = app_pos_etc_moon(iflag, serr))!=SweConst.OK) {
                return swecalc_error(x); // retc may be wrong with sidereal calculation
            }
            
        } else if (ipl == SweConst.SE_SUN &&
                   ((iflag & SweConst.SEFLG_BARYCTR)!=0)) {
            
            ipli = SwephData.SEI_SUN;	
            xp = pedp.xreturn;
            switch (epheflag) {
                case SweConst.SEFLG_JPLEPH:
                    
                    if (!swed.jpl_file_is_open) {
                        retc = sj.swi_open_jpl_file(ss, swed.jplfnam, swed.ephepath, serr);
                        swed.jpldenum = sj.swi_get_jpl_denum();
                        if (retc != SweConst.OK) {
                            retc = sweph_sbar(tjd, iflag, psdp, pedp, serr);
                        }
                        if (retc == SweConst.ERR) {
                            return swecalc_error(x);
                        }
                        swed.jpl_file_is_open = true;
                    }
                    retc = sj.swi_pleph(tjd, SwephJPL.J_SUN, SwephJPL.J_SBARY, psdp.x, serr);
                    if (retc == SweConst.ERR || retc == SwephData.BEYOND_EPH_LIMITS) {
                        sj.swi_close_jpl_file();
                        swed.jpl_file_is_open = false;
                        return swecalc_error(x);
                    }
                    
                    if (retc == SwephData.NOT_AVAILABLE) {
                        iflag = (iflag & ~SweConst.SEFLG_JPLEPH) | SweConst.SEFLG_SWIEPH;
                        if (serr != null && serr.length() + 30 < SwissData.AS_MAXCH) {
                            serr.append(" \ntrying Swiss Eph; ");
                        }
                        retc = sweph_sbar(tjd, iflag, psdp, pedp, serr);
                        if (retc == SweConst.ERR) {
                            return swecalc_error(x);
                        }
                    }
                    psdp.teval = tjd;
                    break;
                case SweConst.SEFLG_SWIEPH:
                    retc = sweph_sbar(tjd, iflag, psdp, pedp, serr);
                    if (retc == SweConst.ERR) {
                        return swecalc_error(x);
                    }
                    break;
                default:
                    return SweConst.ERR;
            }
            
            if ((retc = app_pos_etc_sbar(iflag, serr)) != SweConst.OK) {
                return swecalc_error(x);
            }
            
            iflag = pedp.xflgs;
            
            pedp.xflgs = -1;
            
        } else if (ipl == SweConst.SE_SUN 	
                   || ipl == SweConst.SE_MERCURY
                   || ipl == SweConst.SE_VENUS
                   || ipl == SweConst.SE_MARS
                   || ipl == SweConst.SE_JUPITER
                   || ipl == SweConst.SE_SATURN
                   || ipl == SweConst.SE_URANUS
                   || ipl == SweConst.SE_NEPTUNE
                   || ipl == SweConst.SE_PLUTO
                   || ipl == SweConst.SE_EARTH) {
            if ((iflag & SweConst.SEFLG_HELCTR)!=0) {
                if (ipl == SweConst.SE_SUN) {
                    
                    for (i = 0; i < 24; i++) {
                        x[i] = 0;
                    }
                    return iflag;
                }
            } else if ((iflag & SweConst.SEFLG_BARYCTR)!=0) {
                // NOOP
            } else {		
                if (ipl == SweConst.SE_EARTH) {
                    
                    for (i = 0; i < 24; i++) {
                        x[i] = 0;
                    }
                    return iflag;
                }
            }
            
            ipli = SwissData.pnoext2int[ipl];
            pdp = swed.pldat[ipli];
            xp = pdp.xreturn;
            retc = main_planet(tjd, ipli, epheflag, iflag, serr);
            if (retc == SweConst.ERR) {
                return swecalc_error(x);
            }
            
            iflag = pdp.xflgs;
            
        } else if (ipl == SweConst.SE_MEAN_NODE) {
            if (((iflag & SweConst.SEFLG_HELCTR)!=0) ||
                ((iflag & SweConst.SEFLG_BARYCTR)!=0)) {
                
                for (i = 0; i < 24; i++) {
                    x[i] = 0;
                }
                return iflag;
            }
            ndp = swed.nddat[SwephData.SEI_MEAN_NODE];
            xp = ndp.xreturn;
            xp2 = ndp.x;
            retc = sm.swi_mean_node(tjd, xp2, serr);
            if (retc == SweConst.ERR) {
                return swecalc_error(x);
            }
            
            retc = sm.swi_mean_node(tjd - SwephData.MEAN_NODE_SPEED_INTV, xp2, 3, serr);
            if (retc == SweConst.ERR) {
                return swecalc_error(x);
            }
            xp2[3] = sl.swe_difrad2n(xp2[0], xp2[3]) / SwephData.MEAN_NODE_SPEED_INTV;
            xp2[4] = xp2[5] = 0;
            ndp.teval = tjd;
            ndp.xflgs = -1;
            
            retc = app_pos_etc_mean(SwephData.SEI_MEAN_NODE, iflag, serr);
            if (retc != SweConst.OK) {
                return swecalc_error(x);
            }
            
            if ((iflag & SweConst.SEFLG_SIDEREAL)==0 &&
                (iflag & SweConst.SEFLG_J2000)==0) {
                ndp.xreturn[1] = 0.0;	
                ndp.xreturn[4] = 0.0;	
                ndp.xreturn[5] = 0.0;	
                ndp.xreturn[8] = 0.0;	
                ndp.xreturn[11] = 0.0;	
            }
            if (retc == SweConst.ERR) {
                return swecalc_error(x);
            }
            
        } else if (ipl == SweConst.SE_MEAN_APOG) {
            if (((iflag & SweConst.SEFLG_HELCTR)!=0) ||
                ((iflag & SweConst.SEFLG_BARYCTR)!=0)) {
                
                for (i = 0; i < 24; i++) {
                    x[i] = 0;
                }
                return iflag;
            }
            ndp = swed.nddat[SwephData.SEI_MEAN_APOG];
            xp = ndp.xreturn;
            xp2 = ndp.x;
            retc = sm.swi_mean_apog(tjd, xp2, serr);
            if (retc == SweConst.ERR) {
                return swecalc_error(x);
            }
            
            retc = sm.swi_mean_apog(tjd - SwephData.MEAN_NODE_SPEED_INTV, xp2, 3, serr);
            if (retc == SweConst.ERR) {
                return swecalc_error(x);
            }
            for(i = 0; i <= 1; i++) {
                xp2[3+i] = sl.swe_difrad2n(xp2[i], xp2[3+i]) / SwephData.MEAN_NODE_SPEED_INTV;
            }
            xp2[5] = 0;
            ndp.teval = tjd;
            ndp.xflgs = -1;
            
            if ((retc = app_pos_etc_mean(SwephData.SEI_MEAN_APOG, iflag, serr)) !=
                SweConst.OK) {
                return swecalc_error(x);
            }
            
            ndp.xreturn[5] = 0.0;	
            if (retc == SweConst.ERR) {
                return swecalc_error(x);
            }
            
        } else if (ipl == SweConst.SE_TRUE_NODE) {
            if (((iflag & SweConst.SEFLG_HELCTR)!=0) ||
                ((iflag & SweConst.SEFLG_BARYCTR)!=0)) {
                
                for (i = 0; i < 24; i++) {
                    x[i] = 0;
                }
                return iflag;
            }
            ndp = swed.nddat[SwephData.SEI_TRUE_NODE];
            xp = ndp.xreturn;
            retc = lunar_osc_elem(tjd, SwephData.SEI_TRUE_NODE, iflag, serr);
            iflag = ndp.xflgs;
            
            if ((iflag & SweConst.SEFLG_SIDEREAL)==0 &&
                (iflag & SweConst.SEFLG_J2000)==0) {
                ndp.xreturn[1] = 0.0;	
                ndp.xreturn[4] = 0.0;	
                ndp.xreturn[8] = 0.0;	
                ndp.xreturn[11] = 0.0;	
            }
            if (retc == SweConst.ERR) {
                return swecalc_error(x);
            }
            
        } else if (ipl == SweConst.SE_OSCU_APOG) {
            if (((iflag & SweConst.SEFLG_HELCTR)!=0) ||
                ((iflag & SweConst.SEFLG_BARYCTR)!=0)) {
                
                for (i = 0; i < 24; i++) {
                    x[i] = 0;
                }
                return iflag;
            }
            ndp = swed.nddat[SwephData.SEI_OSCU_APOG];
            xp = ndp.xreturn;
            retc = lunar_osc_elem(tjd, SwephData.SEI_OSCU_APOG, iflag, serr);
            iflag = ndp.xflgs;
            if (retc == SweConst.ERR) {
                return swecalc_error(x);
            }
            
        } else if (ipl == SweConst.SE_INTP_APOG) {
            if ((iflag & SweConst.SEFLG_HELCTR)!=0 ||
                (iflag & SweConst.SEFLG_BARYCTR)!=0) {
                
                for (i = 0; i < 24; i++) {
                    x[i] = 0;
                }
                return iflag;
            }
            ndp = swed.nddat[SwephData.SEI_INTP_APOG];
            xp = ndp.xreturn;
            retc = intp_apsides(tjd, SwephData.SEI_INTP_APOG, iflag, serr); 
            iflag = ndp.xflgs;
            if (retc == SweConst.ERR)
                return swecalc_error(x);
            
        } else if (ipl == SweConst.SE_INTP_PERG) {
            if ((iflag & SweConst.SEFLG_HELCTR)!=0 ||
                (iflag & SweConst.SEFLG_BARYCTR)!=0) {
                
                for (i = 0; i < 24; i++) {
                    x[i] = 0;
                }
                return iflag;
            }
            ndp = swed.nddat[SwephData.SEI_INTP_PERG];
            xp = ndp.xreturn;
            retc = intp_apsides(tjd, SwephData.SEI_INTP_PERG, iflag, serr); 
            iflag = ndp.xflgs;
            if (retc == SweConst.ERR)
                return swecalc_error(x);
            
        } else if (ipl == SweConst.SE_CHIRON
                   || ipl == SweConst.SE_PHOLUS
                   || ipl == SweConst.SE_CERES		
                   || ipl == SweConst.SE_PALLAS
                   || ipl == SweConst.SE_JUNO
                   || ipl == SweConst.SE_VESTA
                   || ipl > SweConst.SE_AST_OFFSET) {
            
            if (ipl < SweConst.SE_NPLANETS) {
                ipli = SwissData.pnoext2int[ipl];
            } else if (ipl <= SweConst.SE_AST_OFFSET + SwephData.MPC_VESTA) {
                ipli = SwephData.SEI_CERES + ipl - SweConst.SE_AST_OFFSET - 1;
                ipl = SweConst.SE_CERES + ipl - SweConst.SE_AST_OFFSET - 1;
            } else {		
                ipli = SwephData.SEI_ANYBODY;
            }
            if (ipli == SwephData.SEI_ANYBODY) {
                ipli_ast = ipl;
            } else {
                ipli_ast = ipli;
            }
            pdp = swed.pldat[ipli];
            xp = pdp.xreturn;
            if (ipli_ast > SweConst.SE_AST_OFFSET) {
                ifno = SwephData.SEI_FILE_ANY_AST;
            } else {
                ifno = SwephData.SEI_FILE_MAIN_AST;
            }
            if (ipli == SwephData.SEI_CHIRON &&
                (tjd < SwephData.CHIRON_START || tjd > SwephData.CHIRON_END)) {
                if (serr != null) {
                    serr.setLength(0);
                    serr.append("Chiron's ephemeris is restricted to JD "+
                                SwephData.CHIRON_START+" - JD "+
                                SwephData.CHIRON_END);
                }
                return SweConst.ERR;
            }
            if (ipli == SwephData.SEI_PHOLUS && tjd < SwephData.PHOLUS_START) {
                if (serr != null) {
                    serr.setLength(0);
                    serr.append("Pholus's ephemeris is restricted to the time after JD "+
                                SwephData.PHOLUS_START);
                }
                return SweConst.ERR;
            }
            //  do_asteroid:
            while (true) {
                
                retc = main_planet(tjd, SwephData.SEI_EARTH, epheflag, iflag, serr);
                if (retc == SweConst.ERR) {
                    return swecalc_error(x);
                }
                
                iflag = swed.pldat[SwephData.SEI_EARTH].xflgs;
                
                if (serr != null) {
                    serr2=serr.toString();
                    serr.setLength(0);
                }
                
                retc = sweph(tjd, ipli_ast, ifno, iflag, psdp.x, SwephData.DO_SAVE,
                             null, serr);
                if (retc == SweConst.ERR || retc == SwephData.NOT_AVAILABLE) {
                    return swecalc_error(x);
                }
                retc = app_pos_etc_plan(ipli_ast, iflag, serr);
                if (retc == SweConst.ERR) {
                    return swecalc_error(x);
                }
                
                if (retc == SwephData.NOT_AVAILABLE ||
                    retc == SwephData.BEYOND_EPH_LIMITS) {
                    if (epheflag != SweConst.SEFLG_MOSEPH) {
                        iflag = (iflag & ~SweConst.SEFLG_EPHMASK) | SweConst.SEFLG_MOSEPH;
                        epheflag = SweConst.SEFLG_MOSEPH;
                        if (serr != null && serr.length() + 30 < SwissData.AS_MAXCH) {
                            serr.append("\nusing Moshier eph.; ");
                        }
                        //          goto do_asteroid;
                        continue;
                    } else
                        return swecalc_error(x);
                }
                break;
            }
            
            if (serr != null && serr.length()==0 && serr2.length()!=0) {
                serr.setLength(0);
                serr2=serr2.substring(0,Math.min(serr2.length(),SwissData.AS_MAXCH-5));
                serr.append("sun: "+serr2);
            }
            
            // JAVA: Geht nur mit Moshier Routinen???
        } else if (ipl >= SweConst.SE_FICT_OFFSET && ipl <= SweConst.SE_FICT_MAX) {
            
            ipli = SwephData.SEI_ANYBODY;
            pdp = swed.pldat[ipli];
            xp = pdp.xreturn;
            //  do_fict_plan:
            while (true) {
                
                retc = main_planet(tjd, SwephData.SEI_EARTH, epheflag, iflag, serr);
                
                iflag = swed.pldat[SwephData.SEI_EARTH].xflgs;
                
                if (smosh.swi_osc_el_plan(tjd, pdp.x, ipl-SweConst.SE_FICT_OFFSET,
                                          ipli, pedp.x, psdp.x, serr) != SweConst.OK) {
                    return swecalc_error(x);
                }
                if (retc == SweConst.ERR) {
                    return swecalc_error(x);
                }
                retc = app_pos_etc_plan_osc(ipl, ipli, iflag, serr);
                if (retc == SweConst.ERR) {
                    return swecalc_error(x);
                }
                
                if (retc == SwephData.NOT_AVAILABLE ||
                    retc == SwephData.BEYOND_EPH_LIMITS) {
                    if (epheflag != SweConst.SEFLG_MOSEPH) {
                        iflag = (iflag & ~SweConst.SEFLG_EPHMASK) | SweConst.SEFLG_MOSEPH;
                        epheflag = SweConst.SEFLG_MOSEPH;
                        if (serr != null && serr.length() + 30 < SwissData.AS_MAXCH) {
                            serr.append("\nusing Moshier eph.; ");
                        }
                        //        goto do_fict_plan;
                        continue;
                    } else
                        return swecalc_error(x);
                }
                break;
            }
            
        } else {
            if (serr != null) {
                serr.setLength(0);
                serr.append("illegal planet number "+ipl+".");
            }
            return swecalc_error(x);
        }
        for (i = 0; i < 24; i++) {
            x[i] = xp[i];
        }
        return(iflag);
    }
    int moshier_moon(double tjd, boolean do_save, double[] xpmret,
                     StringBuffer serr) {
        int retc = sm.swi_moshmoon(tjd, do_save, null, serr);
        if (retc == SweConst.ERR) {
            return SweConst.ERR;
        }
        
        retc = smosh.swi_moshplan(tjd, SwephData.SEI_EARTH, do_save, null, null, serr);
        if (retc == SweConst.ERR) {
            return SweConst.ERR;
        }
        return SweConst.OK;
    }
    int swecalc_error(double x[]) {
        
        //  return_error:;
        for (int i = 0; i < 24; i++) {
            x[i] = 0.;
        }
        return SweConst.ERR;
    }
    int sweph_sbar(double tjd, int iflag, PlanData psdp, PlanData pedp,
                   StringBuffer serr) {
        int retc;
        
        retc = sweplan(tjd, SwephData.SEI_EARTH, SwephData.SEI_FILE_PLANET, iflag,
                       SwephData.DO_SAVE, null, null, null, null, serr);
        if (retc == SweConst.ERR || retc == SwephData.NOT_AVAILABLE) {
            return SweConst.ERR;
        }
        psdp.teval = tjd;
        
        return SweConst.OK;
    }
    int sweph_moon(double tjd, int ipli, int iflag, StringBuffer serr) {
        int retc;
        retc = sweplan(tjd, ipli, SwephData.SEI_FILE_MOON, iflag, SwephData.DO_SAVE,
                       null, null, null, null, serr);
        if (retc == SweConst.ERR) {
            return SweConst.ERR;
        }
        
        if (retc == SwephData.NOT_AVAILABLE) {
            if (tjd > SwephData.MOSHLUEPH_START && tjd < SwephData.MOSHLUEPH_END) {
                iflag = (iflag & ~SweConst.SEFLG_SWIEPH) | SweConst.SEFLG_MOSEPH;
                if (serr != null && serr.length() + 30 < SwissData.AS_MAXCH) {
                    serr.append(" \nusing Moshier eph.; ");
                }
                //        goto moshier_moon;
                retc = moshier_moon(tjd, SwephData.DO_SAVE, null, serr);
                if (retc == SweConst.ERR) {
                    return SweConst.ERR;
                }
            } else
                return SweConst.ERR;
        }
        return SweConst.OK;
    }
    
    void calc_epsilon(double tjd, Epsilon e) {
        e.teps = tjd;
        e.eps = sl.swi_epsiln(tjd);
        e.seps = Math.sin(e.eps);
        e.ceps = Math.cos(e.eps);
    }
    
    int main_planet(double tjd, int ipli, int epheflag, int iflag,
                    StringBuffer serr) {
        int retc;
        boolean calc_swieph=false;
        boolean calc_moshier=false;
        if (epheflag == SweConst.SEFLG_JPLEPH) {
            retc = jplplan(tjd, ipli, iflag, SwephData.DO_SAVE,
                           null, null, null,serr);
            
            if (retc == SweConst.ERR) {
                return SweConst.ERR;
            }
            
            if (retc == SwephData.NOT_AVAILABLE) {
                iflag = (iflag & ~SweConst.SEFLG_JPLEPH) | SweConst.SEFLG_SWIEPH;
                if (serr != null && serr.length() + 30 < SwissData.AS_MAXCH) {
                    serr.append(" \ntrying Swiss Eph; ");
                }
                calc_swieph=true;
                //        goto sweph_planet;
            } else if (retc == SwephData.BEYOND_EPH_LIMITS) {
                if (tjd > SwephData.MOSHPLEPH_START && tjd < SwephData.MOSHPLEPH_END) {
                    iflag = (iflag & ~SweConst.SEFLG_JPLEPH) | SweConst.SEFLG_MOSEPH;
                    if (serr != null && serr.length() + 30 < SwissData.AS_MAXCH) {
                        serr.append(" \nusing Moshier Eph; ");
                    }
                    calc_moshier=true;
                    //          goto moshier_planet;
                } else {
                    return SweConst.ERR;
                }
            }
            if (!calc_swieph && !calc_moshier) {
                
                if (ipli == SwephData.SEI_SUN) {
                    retc = app_pos_etc_sun(iflag, serr);
                } else {
                    retc = app_pos_etc_plan(ipli, iflag, serr);
                }
                if (retc == SweConst.ERR) {
                    return SweConst.ERR;
                }
                
                if (retc == SwephData.NOT_AVAILABLE) {
                    iflag = (iflag & ~SweConst.SEFLG_JPLEPH) | SweConst.SEFLG_SWIEPH;
                    if (serr != null && serr.length() + 30 < SwissData.AS_MAXCH) {
                        serr.append(" \ntrying Swiss Eph; ");
                    }
                    calc_swieph=true;
                    //          goto sweph_planet;
                } else if (retc == SwephData.BEYOND_EPH_LIMITS) {
                    if (tjd > SwephData.MOSHPLEPH_START &&
                        tjd < SwephData.MOSHPLEPH_END) {
                        iflag = (iflag & ~SweConst.SEFLG_JPLEPH) | SweConst.SEFLG_MOSEPH;
                        if (serr != null && serr.length() + 30 < SwissData.AS_MAXCH) {
                            serr.append(" \nusing Moshier Eph; ");
                        }
                        calc_moshier=true;
                        //            goto moshier_planet;
                    } else {
                        return SweConst.ERR;
                    }
                }
            }
        } // SweConst.SEFLG_JPLEPH
        if (epheflag == SweConst.SEFLG_SWIEPH || calc_swieph) {
            //      sweph_planet:
            
            retc = sweplan(tjd, ipli, SwephData.SEI_FILE_PLANET, iflag, SwephData.DO_SAVE,
                           null, null, null, null, serr);
            if (retc == SweConst.ERR) {
                return SweConst.ERR;
            }
            
            if (retc == SwephData.NOT_AVAILABLE) {
                if (tjd > SwephData.MOSHPLEPH_START && tjd < SwephData.MOSHPLEPH_END) {
                    iflag = (iflag & ~SweConst.SEFLG_SWIEPH) | SweConst.SEFLG_MOSEPH;
                    if (serr != null && serr.length() + 30 < SwissData.AS_MAXCH) {
                        serr.append(" \nusing Moshier eph.; ");
                    }
                    calc_moshier=true;
                    //          goto moshier_planet;
                } else {
                    return SweConst.ERR;
                }
            }
            if (!calc_moshier) {
                
                if (ipli == SwephData.SEI_SUN) {
                    retc = app_pos_etc_sun(iflag, serr);
                } else {
                    retc = app_pos_etc_plan(ipli, iflag, serr);
                }
                if (retc == SweConst.ERR) {
                    return SweConst.ERR;
                }
                
                if (retc == SwephData.NOT_AVAILABLE) {
                    if (tjd > SwephData.MOSHPLEPH_START &&
                        tjd < SwephData.MOSHPLEPH_END) {
                        iflag = (iflag & ~SweConst.SEFLG_SWIEPH) | SweConst.SEFLG_MOSEPH;
                        if (serr != null && serr.length() + 30 < SwissData.AS_MAXCH) {
                            serr.append(" \nusing Moshier eph.; ");
                        }
                        calc_moshier=true;
                        //          goto moshier_planet;
                    } else {
                        return SweConst.ERR;
                    }
                }
            } // SweConst.SEFLG_SWIEPH
        } // !calc_moshier
        if (epheflag == SweConst.SEFLG_MOSEPH || calc_moshier) {
            //      moshier_planet:
            retc = smosh.swi_moshplan(tjd, ipli, SwephData.DO_SAVE, null, null, serr);
            if (retc == SweConst.ERR) {
                return SweConst.ERR;
            }
            
            if (ipli == SwephData.SEI_SUN) {
                retc = app_pos_etc_sun(iflag, serr);
            } else {
                retc = app_pos_etc_plan(ipli, iflag, serr);
            }
            if (retc == SweConst.ERR) {
                return SweConst.ERR;
            }
        }
        return SweConst.OK;
    }
    
    int main_planet_bary(double tjd, int ipli, int epheflag, int iflag,
                         boolean do_save,
                         double xp[], double xe[], double xs[], double xm[],
                         StringBuffer serr) {
        int i;
        int retc;
        boolean calc_moshier=false;
        boolean calc_swieph=false;
        if (epheflag == SweConst.SEFLG_JPLEPH) {
            retc = jplplan(tjd, ipli, iflag, do_save, xp, xe, xs, serr);
            
            if (retc == SweConst.ERR || retc == SwephData.BEYOND_EPH_LIMITS) {
                return retc;
            }
            
            if (retc == SwephData.NOT_AVAILABLE) {
                iflag = (iflag & ~SweConst.SEFLG_JPLEPH) | SweConst.SEFLG_SWIEPH;
                if (serr != null && serr.length() + 30 < SwissData.AS_MAXCH) {
                    serr.append(" \ntrying Swiss Eph; ");
                }
                calc_swieph=true;
                //        goto sweph_planet;
            }
        }
        if (epheflag == SweConst.SEFLG_SWIEPH || calc_swieph) {
            //      sweph_planet:
            
            retc = sweplan(tjd, ipli, SwephData.SEI_FILE_PLANET, iflag, do_save,
                           xp, xe, xs, xm, serr);
            if (retc == SweConst.ERR || retc == SwephData.NOT_AVAILABLE) {
                return retc;
            }
        }
        if (epheflag == SweConst.SEFLG_MOSEPH || calc_moshier) {
            retc = smosh.swi_moshplan(tjd, ipli, do_save, xp, xe, serr);
            if (retc == SweConst.ERR) {
                return SweConst.ERR;
            }
            for (i = 0; i <= 5; i++) {
                xs[i] = 0;
            }
        }
        return SweConst.OK;
    }
    
    int swemoon(double tjd, int iflag, boolean do_save, double xpret[],
                StringBuffer serr) {
        int i, retc;
        PlanData pdp = swed.pldat[SwephData.SEI_MOON];
        int speedf1, speedf2;
        double xx[]=new double[6], xp[];
        if (do_save) {
            xp = pdp.x;
        }
        else
            xp = xx;
        
        speedf1 = pdp.xflgs & SweConst.SEFLG_SPEED;
        speedf2 = iflag & SweConst.SEFLG_SPEED;
        if (tjd == pdp.teval
            && pdp.iephe == SweConst.SEFLG_SWIEPH
            && ((speedf2==0) || (speedf1!=0))) {
            xp = pdp.x;
        } else {
            
            retc = sweph(tjd, SwephData.SEI_MOON, SwephData.SEI_FILE_MOON, iflag,
                         null, do_save, xp, serr);
            if (retc != SweConst.OK) {
                return(retc);
            }
            if (do_save) {
                pdp.teval = tjd;
                pdp.xflgs = -1;
                pdp.iephe = SweConst.SEFLG_SWIEPH;
            }
        }
        if (xpret != null) {
            for (i = 0; i <= 5; i++) {
                xpret[i] = xp[i];
            }
        }
        return SweConst.OK;
    }
    
    int sweplan(double tjd, int ipli, int ifno, int iflag, boolean do_save,
                double xpret[], double xperet[], double xpsret[],
                double xpmret[], StringBuffer serr) {
        int i, retc;
        boolean do_earth = false, do_moon = false, do_sunbary = false;
        PlanData pdp = swed.pldat[ipli];
        PlanData pebdp = swed.pldat[SwephData.SEI_EMB];
        PlanData psbdp = swed.pldat[SwephData.SEI_SUNBARY];
        PlanData pmdp = swed.pldat[SwephData.SEI_MOON];
        double xxp[]=new double[6], xxm[]=new double[6],
            xxs[]=new double[6], xxe[]=new double[6];
        double xp[], xpe[], xpm[], xps[];
        int speedf1, speedf2;
        
        if (do_save || ipli == SwephData.SEI_SUNBARY
            || (pdp.iflg & SwephData.SEI_FLG_HELIO)!=0
            || xpsret != null || (iflag & SweConst.SEFLG_HELCTR)!=0) {
            do_sunbary = true;
        }
        if (do_save || ipli == SwephData.SEI_EARTH || xperet != null) {
            do_earth = true;
        }
        if (ipli == SwephData.SEI_MOON) {
            do_earth = true;
            do_sunbary = true;
        }
        if (do_save || ipli == SwephData.SEI_MOON || ipli == SwephData.SEI_EARTH ||
            xperet != null || xpmret != null) {
            do_moon = true;
        }
        if (do_save) {
            xp = pdp.x;
            xpe = pebdp.x;
            xps = psbdp.x;
            xpm = pmdp.x;
        } else {
            xp = xxp;
            xpe = xxe;
            xps = xxs;
            xpm = xxm;
        }
        speedf2 = iflag & SweConst.SEFLG_SPEED;
        
        if (do_sunbary) {
            speedf1 = psbdp.xflgs & SweConst.SEFLG_SPEED;
            
            if (tjd == psbdp.teval
                && psbdp.iephe == SweConst.SEFLG_SWIEPH
                && ((speedf2==0) || (speedf1!=0))) {
                for (i = 0; i <= 5; i++) {
                    xps[i] = psbdp.x[i];
                }
            } else {
                retc = sweph(tjd, SwephData.SEI_SUNBARY, SwephData.SEI_FILE_PLANET, iflag,
                             null, do_save, xps, serr);
                if (retc != SweConst.OK) {
                    return(retc);
                }
            }
            if (xpsret != null) {
                for (i = 0; i <= 5; i++) {
                    xpsret[i] = xps[i];
                }
            }
        }
        
        if (do_moon) {
            speedf1 = pmdp.xflgs & SweConst.SEFLG_SPEED;
            if (tjd == pmdp.teval
                && pmdp.iephe == SweConst.SEFLG_SWIEPH
                && ((speedf2==0) || (speedf1!=0))) {
                for (i = 0; i <= 5; i++) {
                    xpm[i] = pmdp.x[i];
                }
            } else {
                retc = sweph(tjd, SwephData.SEI_MOON, SwephData.SEI_FILE_MOON, iflag, null,
                             do_save, xpm, serr);
                if (retc == SweConst.ERR) {
                    return(retc);
                }
                
                if (swed.fidat[SwephData.SEI_FILE_MOON].fptr == null) {
                    if (serr != null && serr.length() + 35 < SwissData.AS_MAXCH) {
                        serr.append(" \nusing Moshier eph. for moon; ");
                    }
                    retc = sm.swi_moshmoon(tjd, do_save, xpm, serr);
                    if (retc != SweConst.OK) {
                        return(retc);
                    }
                }
            }
            if (xpmret != null) {
                for (i = 0; i <= 5; i++) {
                    xpmret[i] = xpm[i];
                }
            }
        }
        
        if (do_earth) {
            speedf1 = pebdp.xflgs & SweConst.SEFLG_SPEED;
            if (tjd == pebdp.teval
                && pebdp.iephe == SweConst.SEFLG_SWIEPH
                && ((speedf2==0) || (speedf1!=0))) {
                for (i = 0; i <= 5; i++) {
                    xpe[i] = pebdp.x[i];
                }
            } else {
                retc = sweph(tjd, SwephData.SEI_EMB, SwephData.SEI_FILE_PLANET, iflag, null,
                             do_save, xpe, serr);
                if (retc != SweConst.OK) {
                    return(retc);
                }
                
                embofs(xpe, 0, xpm, 0);
                
                if (xpe == pebdp.x || ((iflag & SweConst.SEFLG_SPEED)!=0)) {
                    embofs(xpe, 3, xpm, 3);
                }
            }
            if (xperet != null) {
                for (i = 0; i <= 5; i++) {
                    xperet[i] = xpe[i];
                }
            }
        }
        if (ipli == SwephData.SEI_MOON) {
            for (i = 0; i <= 5; i++) {
                xp[i] = xpm[i];
            }
        } else if (ipli == SwephData.SEI_EARTH) {
            for (i = 0; i <= 5; i++) {
                xp[i] = xpe[i];
            }
        } else if (ipli == SwephData.SEI_SUN) {
            for (i = 0; i <= 5; i++) {
                xp[i] = xps[i];
            }
        } else {
            
            speedf1 = pdp.xflgs & SweConst.SEFLG_SPEED;
            if (tjd == pdp.teval
                && pdp.iephe == SweConst.SEFLG_SWIEPH
                && ((speedf2==0) || (speedf1!=0))) {
                for (i = 0; i <= 5; i++) {
                    xp[i] = pdp.x[i];
                }
                return(SweConst.OK);
            } else {
                retc = sweph(tjd, ipli, ifno, iflag, null, do_save, xp, serr);
                if (retc != SweConst.OK) {
                    return(retc);
                }
                
                if ((pdp.iflg & SwephData.SEI_FLG_HELIO)!=0) {
                    
                    for (i = 0; i <= 2; i++) {
                        xp[i] += xps[i];
                    }
                    if (do_save || ((iflag & SweConst.SEFLG_SPEED)!=0)) {
                        for (i = 3; i <= 5; i++) {
                            xp[i] += xps[i];
                        }
                    }
                }
            }
        }
        if (xpret != null) {
            for (i = 0; i <= 5; i++) {
                xpret[i] = xp[i];
            }
        }
        return SweConst.OK;
    }
    
    int jplplan(double tjd, int ipli, int iflag, boolean do_save,
                double xpret[], double xperet[], double xpsret[],
                StringBuffer serr) throws SwissephException {
        int i, retc;
        boolean do_earth = false, do_sunbary = false;
        double ss[]=new double[3];
        double xxp[]=new double[6], xxe[]=new double[6], xxs[]=new double[6];
        double xp[], xpe[], xps[];
        int ictr = SwephJPL.J_SBARY;
        PlanData pdp = swed.pldat[ipli];
        PlanData pedp = swed.pldat[SwephData.SEI_EARTH];
        PlanData psdp = swed.pldat[SwephData.SEI_SUNBARY];
        
        
        if (do_save) {
            xp = pdp.x;
            xpe = pedp.x;
            xps = psdp.x;
        } else {
            xp = xxp;
            xpe = xxe;
            xps = xxs;
        }
        if (do_save || ipli == SwephData.SEI_EARTH || xperet != null
            || (ipli == SwephData.SEI_MOON)) {
            
            do_earth = true;
        }
        if (do_save || ipli == SwephData.SEI_SUNBARY || xpsret != null
            || (ipli == SwephData.SEI_MOON)) {
            
            do_sunbary = true;
        }
        if (ipli == SwephData.SEI_MOON) {
            ictr = SwephJPL.J_EARTH;
        }
        
        if (!swed.jpl_file_is_open) {
            retc = sj.swi_open_jpl_file(ss, swed.jplfnam, swed.ephepath, serr);
            swed.jpldenum = sj.swi_get_jpl_denum();
            if (retc != SweConst.OK) {
                throw new SwissephException(tjd, SwissephException.FILE_OPEN_FAILED,
                                            retc, serr);
            }
            swed.jpl_file_is_open = true;
        }
        if (do_earth) {
            
            if (tjd != pedp.teval || tjd == 0) {
                retc = sj.swi_pleph(tjd, SwephJPL.J_EARTH, SwephJPL.J_SBARY, xpe, serr);
                if (retc != SweConst.OK) {
                    sj.swi_close_jpl_file();
                    swed.jpl_file_is_open = false;
                    return retc;
                }
                if (do_save) {
                    pedp.teval = tjd;
                    pedp.xflgs = -1;       
                    pedp.iephe = SweConst.SEFLG_JPLEPH;
                }
            } else {
                xpe = pedp.x;
            }
            if (xperet != null) {
                for (i = 0; i <= 5; i++) {
                    xperet[i] = xpe[i];
                }
            }
  
        }
        if (do_sunbary) {
            
            if (tjd != psdp.teval || tjd == 0) {
                retc = sj.swi_pleph(tjd, SwephJPL.J_SUN, SwephJPL.J_SBARY, xps, serr);
                if (retc != SweConst.OK) {
                    sj.swi_close_jpl_file();
                    swed.jpl_file_is_open = false;
                    return retc;
                }
                if (do_save) {
                    psdp.teval = tjd;
                    psdp.xflgs = -1;
                    psdp.iephe = SweConst.SEFLG_JPLEPH;
                }
            } else {
                xps = psdp.x;
            }
            if (xpsret != null) {
                for (i = 0; i <= 5; i++) {
                    xpsret[i] = xps[i];
                }
            }
        }
        
        if (ipli == SwephData.SEI_EARTH) {
            for (i = 0; i <= 5; i++) {
                xp[i] = xpe[i];
            }
            
        } if (ipli == SwephData.SEI_SUNBARY) {
            for (i = 0; i <= 5; i++) {
                xp[i] = xps[i];
            }
            
        } else {
            
            if (tjd == pdp.teval && pdp.iephe == SweConst.SEFLG_JPLEPH) {
                xp = pdp.x;
            } else {
                retc = sj.swi_pleph(tjd, SwephData.pnoint2jpl[ipli], ictr, xp, serr);
                if (retc != SweConst.OK) {
                    sj.swi_close_jpl_file();
                    swed.jpl_file_is_open = false;
                    return retc;
                }
                if (do_save) {
                    pdp.teval = tjd;
                    pdp.xflgs = -1;
                    pdp.iephe = SweConst.SEFLG_JPLEPH;
                }
            }
        }
        if (xpret != null) {
            for (i = 0; i <= 5; i++) {
                xpret[i] = xp[i];
            }
        }
        return (SweConst.OK);
    }
    
    int sweph(double tjd, int ipli, int ifno, int iflag, double xsunb[],
              boolean do_save, double xpret[], StringBuffer serr) {
        int i, ipl, retc, subdirlen;
        String s="", subdirnam, fname;
        double t, tsv;
        double xemb[]=new double[6], xx[]=new double[6], xp[];
        PlanData pdp;
        PlanData pedp = swed.pldat[SwephData.SEI_EARTH];
        PlanData psdp = swed.pldat[SwephData.SEI_SUNBARY];
        FileData fdp = swed.fidat[ifno];
        int speedf1, speedf2;
        boolean need_speed;
        ipl = ipli;
        if (ipli > SweConst.SE_AST_OFFSET) {
            ipl = SwephData.SEI_ANYBODY;
        }
        pdp = swed.pldat[ipl];
        if (do_save) {
            xp = pdp.x;
        } else {
            xp = xx;
        }
        
        speedf1 = pdp.xflgs & SweConst.SEFLG_SPEED;
        speedf2 = iflag & SweConst.SEFLG_SPEED;
        if (tjd == pdp.teval
            && pdp.iephe == SweConst.SEFLG_SWIEPH
            && ((speedf2==0) || (speedf1!=0))
            && ipl < SwephData.SEI_ANYBODY) {
            if (xpret != null) {
                for (i = 0; i <= 5; i++) {
                    xpret[i] = pdp.x[i];
                }
            }
            return SweConst.OK;
        }
        
        if (fdp.fptr != null) {
            
            if (tjd < fdp.tfstart || tjd > fdp.tfend
                || (ipl == SwephData.SEI_ANYBODY && ipli != pdp.ibdy)) {
                try {
                    fdp.fptr.close();
                } catch (java.io.IOException e) {
                    // NBT
                }
                fdp.fptr = null;
                if (pdp.refep != null) {
                    pdp.refep = null;
                }
                if (pdp.segp != null) {
                    pdp.segp = null;
                }
            }
        }
        
        if (fdp.fptr == null) {
            fname=sl.swi_gen_filename(new SweDate(tjd), ipli);
            subdirnam=fname;
            if (subdirnam.lastIndexOf(swed.DIR_GLUE)>0) {
                subdirnam=subdirnam.substring(0,subdirnam.indexOf(swed.DIR_GLUE));
                subdirlen=subdirnam.length();
            } else {
                subdirlen=0;
            }
            s=fname;
            while (fdp.fptr==null) {
                try {
                    fdp.fptr=swi_fopen(ifno,s,swed.ephepath, serr);
                } catch (SwissephException se) {
                }
                if (fdp.fptr == null ||
                    (fdp.fptr!=null && fdp.fptr.fp==null && fdp.fptr.sk==null)) {
                    
                    if (ipli > SweConst.SE_AST_OFFSET) {
                        if (s.indexOf("s.")<=0) {
                            s=s.substring(0,s.indexOf("."))+"s."+SwephData.SE_FILE_SUFFIX;
                            continue;
                        } else {
                            
                            s=s.substring(0,s.indexOf("s."))+s.substring(s.indexOf("s.")+1);
                            if (subdirlen>0 &&
                                s.startsWith(subdirnam.substring(
                                                                 0,Math.min(subdirnam.length(),subdirlen)))) {
                                s=s.substring(subdirlen+1);
                                continue;
                            }
                        }
                    }
                    return(SwephData.NOT_AVAILABLE);
                }
                if (fdp.fptr!=null) { break; }
            }
            
            if (serr != null) {
                serr.setLength(0);
            }
            retc = swed.fidat[ifno].read_const(ifno, serr, swed);
            if (retc != SweConst.OK) {
                return(retc);
            }
        }
        
        if (tjd < fdp.tfstart || tjd > fdp.tfend) {
            if (serr != null) {
                if (tjd < fdp.tfstart) {
                    s="jd "+tjd+" < Swiss Eph. lower limit "+fdp.tfstart+";";
                } else {
                    s="jd "+tjd+" > Swiss Eph. upper limit "+fdp.tfend+";";
                }
                if (serr.length()+s.length() < SwissData.AS_MAXCH) {
                    serr.append(s);
                }
            }
            return(SwephData.NOT_AVAILABLE);
        }
        
        
        if (pdp.segp == null || tjd < pdp.tseg0 || tjd > pdp.tseg1) {
            retc = swed.fidat[ifno].get_new_segment(swed, tjd, ipl, ifno, serr);
            if (retc != SweConst.OK) {
                return(retc);
            }
            
            if ((pdp.iflg & SwephData.SEI_FLG_ROTATE)!=0) {
                rot_back(ipl); 
            } else {
                pdp.neval = pdp.ncoe;
            }
        }
        
        t = (tjd - pdp.tseg0) / pdp.dseg;
        t = t * 2 - 1;
        
        need_speed = (do_save || ((iflag & SweConst.SEFLG_SPEED)!=0));
        for (i = 0; i <= 2; i++) {
            xp[i]  = sl.swi_echeb (t, pdp.segp, i*pdp.ncoe, pdp.neval);
            if (need_speed) {
                xp[i+3] = sl.swi_edcheb(t, pdp.segp, i*pdp.ncoe, pdp.neval) / pdp.dseg * 2;
            } else
                xp[i+3] = 0;      
        }
        
        if (ipl == SwephData.SEI_SUNBARY &&
            (pdp.iflg & SwephData.SEI_FLG_EMBHEL)!=0) {
            
            tsv = pedp.teval;
            pedp.teval = 0;
            retc = sweph(tjd, SwephData.SEI_EMB, ifno, iflag | SweConst.SEFLG_SPEED,
                         null, SwephData.NO_SAVE, xemb, serr);
            if (retc != SweConst.OK) {
                return(retc);
            }
            pedp.teval = tsv;
            for (i = 0; i <= 2; i++) {
                xp[i] = xemb[i] - xp[i];
            }
            if (need_speed) {
                for (i = 3; i <= 5; i++) {
                    xp[i] = xemb[i] - xp[i];
                }
            }
        }
        
        if ((iflag & SweConst.SEFLG_JPLEPH)!=0 ||
            (iflag & SweConst.SEFLG_SWIEPH)!=0) {
            if (ipl >= SwephData.SEI_ANYBODY) {
                for (i = 0; i <= 2; i++) {
                    xp[i] += xsunb[i];
                }
                if (need_speed) {
                    for (i = 3; i <= 5; i++) {
                        xp[i] += xsunb[i];
                    }
                }
            }
        }
        if (do_save) {
            pdp.teval = tjd;
            pdp.xflgs = -1;    
            if (ifno == SwephData.SEI_FILE_PLANET ||
                ifno == SwephData.SEI_FILE_MOON) {
                pdp.iephe = SweConst.SEFLG_SWIEPH;
            } else {
                pdp.iephe = psdp.iephe;
            }
        }
        if (xpret != null) {
            for (i = 0; i <= 5; i++) {
                xpret[i] = xp[i];
            }
        }
        return SweConst.OK;
    }
    
    FilePtr swi_fopen(int ifno, String fname, String ephepath,
                      StringBuffer serr) throws SwissephException {
        int np, i;
        java.io.RandomAccessFile fp = null;
        String fnamp;
        String[] cpos=new String[20];
        String path, s, s1;
        //s1=ephepath;
        s1=getTmp();
        
        np = sl.swi_cutstr(s1, SwissData.PATH_SEPARATOR, cpos, 20);
        for (i = 0; i < np; i++) {
            path=cpos[i];
            if ("".equals(path)) { path="."; }
            fnamp=path+swed.DIR_GLUE;
            if (fnamp.length() + fname.length() < SwissData.AS_MAXCH) {
                fnamp+=fname;
            } else {
                if (serr != null) {
                    serr.setLength(0);
                    serr.append("error: file path and name must be shorter than "+
                                SwissData.AS_MAXCH+".");
                }
                throw new SwissephException(1./0., SwissephException.INVALID_FILE_NAME,
                                            SweConst.ERR, serr);
            }
            try {          
                fp = new java.io.RandomAccessFile(fnamp, SwissData.BFILE_R_ACCESS);
                if (ifno >= 0) {
                    swed.fidat[ifno].fnam=fnamp;
                }
                FilePtr sfp = new FilePtr(fp,null,null,null,fnamp,-1,httpBufSize);
                return sfp;
            } catch (java.io.IOException ex) {
                // Maybe it is an URL...
                FilePtr f=tryFileAsURL(path+"/"+fname, ifno);
                if (f!=null) {
                    return f;
                }
            } catch (SecurityException ex) {
                // Probably an applet, we try fnamp as an URL:
                FilePtr f=tryFileAsURL(path+"/"+fname, ifno);
                if (f!=null) {
                    return f;
                }
            }
        }
        return null;
    }
    private FilePtr tryFileAsURL(String fnamp, int ifno) {
        Socket sk=null;
        try {
            URL u=new URL(fnamp);
            sk=new Socket(u.getHost(),(u.getPort()<0?80:u.getPort()));
            String sht="HEAD "+fnamp+" HTTP/1.1\r\n"+
                "User-Agent: "+FilePtr.useragent+"\r\n"+
                "Host: "+u.getHost()+":"+(u.getPort()<0?80:u.getPort())+
                "\r\n\r\n";
            sk.setSoTimeout(5000);
            InputStream is=sk.getInputStream();
            BufferedOutputStream os=new BufferedOutputStream(sk.getOutputStream());
            for(int n=0; n<sht.length(); n++) {
                os.write((byte)sht.charAt(n));
            }
            os.flush();
            String sret=""+(char)is.read();
            while (is.available()>0) {
                sret+=(char)is.read();
            }
            int idx=sret.indexOf("Content-Length:");
            if (idx < 0) {
                sk.close();
                return null;
            }
            // We need to query ranges, otherwise it will not make much sense...
            if (sret.indexOf("Accept-Ranges: none")>=0) {
                System.err.println("Server does not accept HTTP range requests. "+
                                   "Aborting!");
                sk.close();

                return null;
            }
            sret=sret.substring(idx+"Content-Length:".length());
            sret=sret.substring(0,sret.indexOf("\n")).trim();
            // We might want to check for a minimum length?
            long len=Long.parseLong(sret);
            if (ifno >= 0) {
                swed.fidat[ifno].fnam=fnamp;
            }
            return new FilePtr(null,sk,is,os,fnamp,len,httpBufSize);
        } catch (MalformedURLException m) {
        } catch (IOException ie) {
        } catch (NumberFormatException nf) {
            // Why this? Should not be able to happen...
        } catch (SecurityException se) {
        }
        try { sk.close(); }
        catch (IOException e) { }
        catch (NullPointerException np) { }

        return null;
    }
    
    int app_pos_etc_plan(int ipli, int iflag, StringBuffer serr) {
        int i, j, niter, retc = SweConst.OK;
        int ipl;
        int ifno, ibody;
        int flg1, flg2;
        double xx[]=new double[6], dx[]=new double[3], dt, t, dtsave_for_defl;
        double xobs[]=new double[6], xobs2[]=new double[6];
        double xearth[]=new double[6], xsun[]=new double[6];
        double xxsp[]=new double[6], xxsv[]=new double[6];
        PlanData pedp = swed.pldat[SwephData.SEI_EARTH];
        PlanData pdp;
        Epsilon oe = swed.oec2000;
        int epheflag = iflag & SweConst.SEFLG_EPHMASK;
        t = dtsave_for_defl = 0;      
        
        if (ipli > SweConst.SE_AST_OFFSET) {
            ifno = SwephData.SEI_FILE_ANY_AST;
            ibody = SwephData.IS_ANY_BODY;
            pdp = swed.pldat[SwephData.SEI_ANYBODY];
        } else if (ipli == SwephData.SEI_CHIRON
                   || ipli == SwephData.SEI_PHOLUS
                   || ipli == SwephData.SEI_CERES
                   || ipli == SwephData.SEI_PALLAS
                   || ipli == SwephData.SEI_JUNO
                   || ipli == SwephData.SEI_VESTA) {
            ifno = SwephData.SEI_FILE_MAIN_AST;
            ibody = SwephData.IS_MAIN_ASTEROID;
            pdp = swed.pldat[ipli];
        } else {
            ifno = SwephData.SEI_FILE_PLANET;
            ibody = SwephData.IS_PLANET;
            pdp = swed.pldat[ipli];
        }
        
        flg1 = iflag & ~SweConst.SEFLG_EQUATORIAL & ~SweConst.SEFLG_XYZ;
        flg2 = pdp.xflgs & ~SweConst.SEFLG_EQUATORIAL & ~SweConst.SEFLG_XYZ;
        if (flg1 == flg2) {
            pdp.xflgs = iflag;
            pdp.iephe = iflag & SweConst.SEFLG_EPHMASK;
            return SweConst.OK;
        }
        
        for (i = 0; i <= 5; i++) {
            xx[i] = pdp.x[i];
        }
        
        if ((iflag & SweConst.SEFLG_HELCTR)!=0) {
            if (pdp.iephe == SweConst.SEFLG_JPLEPH ||
                pdp.iephe == SweConst.SEFLG_SWIEPH) {
                for (i = 0; i <= 5; i++) {
                    xx[i] -= swed.pldat[SwephData.SEI_SUNBARY].x[i];
                }
            }
        }
        
        
        if ((iflag & SweConst.SEFLG_TOPOCTR)!=0) {
            if (swed.topd.teval != pedp.teval
                || pedp.teval == 0) {
                if (swi_get_observer(pedp.teval, iflag, SwephData.DO_SAVE, xobs, serr)
                    != SweConst.OK) {
                    return SweConst.ERR;
                }
            } else {
                for (i = 0; i <= 5; i++) {
                    xobs[i] = swed.topd.xobs[i];
                }
            }
            
            for (i = 0; i <= 5; i++) {
                xobs[i] = xobs[i] + pedp.x[i];
            }
        } else {
            
            for (i = 0; i <= 5; i++) {
                xobs[i] = pedp.x[i];
            }
        }
        
        if ((iflag & SweConst.SEFLG_TRUEPOS)==0) {
            
            if (pdp.iephe == SweConst.SEFLG_JPLEPH ||
                pdp.iephe == SweConst.SEFLG_SWIEPH) {
                niter = 1;
            } else {      
                niter = 0;
            }
            if ((iflag & SweConst.SEFLG_SPEED)!=0) {
                
                for (i = 0; i <= 2; i++) {
                    xxsv[i] = xxsp[i] = xx[i] - xx[i+3];
                }
                for (j = 0; j <= niter; j++) {
                    for (i = 0; i <= 2; i++) {
                        dx[i] = xxsp[i];
                        if (((iflag & SweConst.SEFLG_HELCTR)==0) &&
                            (iflag & SweConst.SEFLG_BARYCTR)==0) {
                            dx[i] -= (xobs[i] - xobs[i+3]);
                        }
                    }
                    
                    dt = Math.sqrt(sl.square_sum(dx)) * SweConst.AUNIT / SwephData.CLIGHT /
                        86400.0;
                    for (i = 0; i <= 2; i++) {      
                        xxsp[i] = xxsv[i] - dt * pdp.x[i+3];
                    }
                }
                
                for (i = 0; i <= 2; i++) {
                    xxsp[i] = xxsv[i] - xxsp[i];
                }
            }
            
            for (j = 0; j <= niter; j++) {
                for (i = 0; i <= 2; i++) {
                    dx[i] = xx[i];
                    if ((iflag & SweConst.SEFLG_HELCTR)==0 &&
                        (iflag & SweConst.SEFLG_BARYCTR)==0) {
                        dx[i] -= xobs[i];
                    }
                }
                dt = Math.sqrt(sl.square_sum(dx)) *SweConst.AUNIT / SwephData.CLIGHT / 86400.0;
                
                t = pdp.teval - dt;
                dtsave_for_defl = dt;
                for (i = 0; i <= 2; i++) {        
                    xx[i] = pdp.x[i] - dt * pdp.x[i+3];
                }
            }
            
            if ((iflag & SweConst.SEFLG_SPEED)!=0) {
                for (i = 0; i <= 2; i++) {
                    xxsp[i] = pdp.x[i] - xx[i] - xxsp[i];
                }
            }
            
            switch(epheflag) {
                case SweConst.SEFLG_JPLEPH:
                    if (ibody == SwephData.IS_PLANET) {
                        ipl = SwephData.pnoint2jpl[ipli];
                        retc = sj.swi_pleph(t, ipl, SwephJPL.J_SBARY, xx, serr);
                        if (retc != SweConst.OK) {
                            sj.swi_close_jpl_file();
                            swed.jpl_file_is_open = false;
                        }
                    } else {        
                        
                        retc = sj.swi_pleph(t, SwephJPL.J_SUN, SwephJPL.J_SBARY, xsun, serr);
                        if (retc != SweConst.OK) {
                            sj.swi_close_jpl_file();
                            swed.jpl_file_is_open = false;
                        }
                        
                        retc = sweph(t, ipli, ifno, iflag, xsun, SwephData.NO_SAVE, xx, serr);
                    }
                    if (retc != SweConst.OK) {
                        return(retc);
                    }
                    
                    if ((iflag & SweConst.SEFLG_SPEED)!=0
                        && (iflag & SweConst.SEFLG_HELCTR)==0
                        && (iflag & SweConst.SEFLG_BARYCTR)==0) {
                        retc = sj.swi_pleph(t, SwephJPL.J_EARTH, SwephJPL.J_SBARY, xearth, serr);
                        if (retc != SweConst.OK) {
                            sj.swi_close_jpl_file();
                            swed.jpl_file_is_open = false;
                            return(retc);
                        }
                    }
                    break;
                case SweConst.SEFLG_SWIEPH:
                    if (ibody == SwephData.IS_PLANET) {
                        retc = sweplan(t, ipli, ifno, iflag, SwephData.NO_SAVE, xx, xearth,
                                       xsun, null, serr);
                    } else {          
                        retc = sweplan(t, SwephData.SEI_EARTH, SwephData.SEI_FILE_PLANET,
                                       iflag, SwephData.NO_SAVE, xearth, null, xsun, null,
                                       serr);
                        if (retc == SweConst.OK) {
                            retc = sweph(t, ipli, ifno, iflag, xsun, SwephData.NO_SAVE, xx,
                                         serr);
                        }
                    }
                    if (retc != SweConst.OK) {
                        return(retc);
                    }
                    break;
                case SweConst.SEFLG_MOSEPH:
                default:
                    
                    
                    if ((iflag & SweConst.SEFLG_SPEED)!=0
                        && (iflag & (SweConst.SEFLG_HELCTR | SweConst.SEFLG_BARYCTR))==0) {
                        if (ibody == SwephData.IS_PLANET) {
                            retc = smosh.swi_moshplan(t, ipli, SwephData.NO_SAVE, xxsv,
                                                      xearth, serr);
                        } else {                
                            retc = sweph(t, ipli, ifno, iflag, null, SwephData.NO_SAVE, xxsv,
                                         serr);
                            if (retc == SweConst.OK) {
                                retc = smosh.swi_moshplan(t, SwephData.SEI_EARTH,
                                                          SwephData.NO_SAVE, xearth, xearth,
                                                          serr);
                            }
                        }
                        if (retc != SweConst.OK) {
                            return(retc);
                        }
                        
                        for (i = 3; i <= 5; i++) {
                            xx[i] = xxsv[i];
                        }
                    }
                    break;
            }
            if ((iflag & SweConst.SEFLG_HELCTR)!=0) {
                if (pdp.iephe == SweConst.SEFLG_JPLEPH ||
                    pdp.iephe == SweConst.SEFLG_SWIEPH) {
                    for (i = 0; i <= 5; i++) {
                        xx[i] -= swed.pldat[SwephData.SEI_SUNBARY].x[i];
                    }
                }
            }
            if ((iflag & SweConst.SEFLG_SPEED)!=0) {
                
                if ((iflag & SweConst.SEFLG_TOPOCTR)!=0) {
                    if (swi_get_observer(t, iflag, SwephData.NO_SAVE, xobs2, serr) !=
                        SweConst.OK) {
                        return SweConst.ERR;
                    }
                    for (i = 0; i <= 5; i++) {
                        xobs2[i] += xearth[i];
                    }
                } else {
                    for (i = 0; i <= 5; i++) {
                        xobs2[i] = xearth[i];
                    }
                }
            }
        }
        
        if ((iflag & SweConst.SEFLG_HELCTR)==0 &&
            (iflag & SweConst.SEFLG_BARYCTR)==0) {
            
            for (i = 0; i <= 5; i++) {
                xx[i] -= xobs[i];
            }
            if ((iflag & SweConst.SEFLG_TRUEPOS) == 0 ) {
                
                if ((iflag & SweConst.SEFLG_SPEED)!=0) {
                    for (i = 3; i <= 5; i++) {
                        xx[i] -= xxsp[i-3];
                    }
                }
            }
        }
        if ((iflag & SweConst.SEFLG_SPEED)==0) {
            for (i = 3; i <= 5; i++) {
                xx[i] = 0;
            }
        }
        
        if ((iflag & SweConst.SEFLG_TRUEPOS)==0 &&
            (iflag & SweConst.SEFLG_NOGDEFL)==0) {
            
            swi_deflect_light(xx, 0, dtsave_for_defl, iflag);
        }
        
        if ((iflag & SweConst.SEFLG_TRUEPOS)==0 &&
            (iflag & SweConst.SEFLG_NOABERR)==0) {
            
            swi_aberr_light(xx, xobs, iflag);
            
            if ((iflag & SweConst.SEFLG_SPEED)!=0) {
                for (i = 3; i <= 5; i++) {
                    xx[i] += xobs[i] - xobs2[i];
                }
            }
        }
        if ((iflag & SweConst.SEFLG_SPEED) == 0) {
            for (i = 3; i <= 5; i++) {
                xx[i] = 0;
            }
        }
        
        if ((iflag & SweConst.SEFLG_ICRS) == 0 && swed.jpldenum >= 403) {
            sl.swi_bias(xx, iflag, false);
        }
        
        for (i = 0; i <= 5; i++) {
            xxsv[i] = xx[i];
        }
        
        if ((iflag & SweConst.SEFLG_J2000)==0) {
            sl.swi_precess(xx, pdp.teval, SwephData.J2000_TO_J);
            if ((iflag & SweConst.SEFLG_SPEED)!=0) {
                swi_precess_speed(xx, pdp.teval, SwephData.J2000_TO_J);
            }
            oe = swed.oec;
        } else {
            oe = swed.oec2000;
        }
        return app_pos_rest(pdp, iflag, xx, xxsv, oe, serr);
    }
    int app_pos_rest(PlanData pdp, int iflag,
                     double[] xx, double[] x2000,
                     Epsilon oe, StringBuffer serr) {
        int i;
        
        if ((iflag & SweConst.SEFLG_NONUT)==0) {
            swi_nutate(xx, 0, iflag, false);
        }
        
        for (i = 0; i <= 5; i++) {
            pdp.xreturn[18+i] = xx[i];
        }
        
        sl.swi_coortrf2(xx, xx, oe.seps, oe.ceps);
        if ((iflag & SweConst.SEFLG_SPEED) !=0) {
            sl.swi_coortrf2(xx, 3, xx, 3, oe.seps, oe.ceps);
        }
        if ((iflag & SweConst.SEFLG_NONUT)==0) {
            sl.swi_coortrf2(xx, xx, swed.nut.snut, swed.nut.cnut);
            if ((iflag & SweConst.SEFLG_SPEED)!=0) {
                sl.swi_coortrf2(xx, 3, xx, 3, swed.nut.snut, swed.nut.cnut);
            }
        }
        
        for (i = 0; i <= 5; i++) {
            pdp.xreturn[6+i] = xx[i];
        }
        
        if ((iflag & SweConst.SEFLG_SIDEREAL)!=0) {
            
            if ((swed.sidd.sid_mode & SweConst.SE_SIDBIT_ECL_T0)!=0) {
                if (swi_trop_ra2sid_lon(x2000, pdp.xreturn, 6, pdp.xreturn, 18, iflag,
                                        serr) != SweConst.OK) {
                    return SweConst.ERR;
                }
                
            } else if ((swed.sidd.sid_mode & SweConst.SE_SIDBIT_SSY_PLANE)!=0) {
                if (swi_trop_ra2sid_lon_sosy(x2000, pdp.xreturn, 6, pdp.xreturn, 18,
                                             iflag, serr) != SweConst.OK) {
                    return SweConst.ERR;
                }
            } else {
                
                sl.swi_cartpol_sp(pdp.xreturn, 6, pdp.xreturn, 0);
                pdp.xreturn[0] -= swe_get_ayanamsa(pdp.teval) * SwissData.DEGTORAD;
                sl.swi_polcart_sp(pdp.xreturn, 0, pdp.xreturn, 6);
            }
        }
        
        sl.swi_cartpol_sp(pdp.xreturn, 18, pdp.xreturn, 12);
        sl.swi_cartpol_sp(pdp.xreturn, 6, pdp.xreturn, 0);
        
        
        for (i = 0; i < 2; i++) {
            pdp.xreturn[i] *= SwissData.RADTODEG;                
            pdp.xreturn[i+3] *= SwissData.RADTODEG;
            pdp.xreturn[i+12] *= SwissData.RADTODEG;     
            pdp.xreturn[i+15] *= SwissData.RADTODEG;
        }
        
        
        pdp.xflgs = iflag;
        pdp.iephe = iflag & SweConst.SEFLG_EPHMASK;
        return SweConst.OK;
    }
    
    int swi_trop_ra2sid_lon(double[] xin, double[] xout, double[] xoutr,
                            int iflag, StringBuffer serr) {
        return swi_trop_ra2sid_lon(xin, xout, 0, xoutr, 0, iflag, serr);
    }
    int swi_trop_ra2sid_lon(double[] xin, double[] xout, int xoOffs,
                            double[] xoutr, int xrOffs, int iflag,
                            StringBuffer serr) {
        double x[]=new double[6];
        int i;
        SidData sip = swed.sidd;
        Epsilon oectmp=new Epsilon();
        for (i = 0; i <= 5; i++) {
            x[i] = xin[i];
        }
        if (sip.t0 != SwephData.J2000) {
            sl.swi_precess(x, sip.t0, SwephData.J2000_TO_J);
            sl.swi_precess(x, 3, sip.t0, SwephData.J2000_TO_J);      
        }
        for (i = 0; i <= 5; i++) {
            xoutr[i+xrOffs] = x[i];
        }
        calc_epsilon(swed.sidd.t0, oectmp);
        sl.swi_coortrf2(x, x, oectmp.seps, oectmp.ceps);
        if ((iflag & SweConst.SEFLG_SPEED)!=0) {
            sl.swi_coortrf2(x, 3, x, 3, oectmp.seps, oectmp.ceps);
        }
        
        sl.swi_cartpol_sp(x, x);
        
        x[0] -= sip.ayan_t0 * SwissData.DEGTORAD;
        
        sl.swi_polcart_sp(x, 0, xout, xoOffs);
        return SweConst.OK;
    }
    
    int swi_trop_ra2sid_lon_sosy(double[] xin, double[] xout, double[] xoutr,
                                 int iflag, StringBuffer serr) {
        return swi_trop_ra2sid_lon_sosy(xin, xout, 0, xoutr, 0, iflag, serr);
    }
    int swi_trop_ra2sid_lon_sosy(double[] xin, double[] xout, int xoOffs,
                                 double[] xoutr, int xrOffs, int iflag,
                                 StringBuffer serr) {
        double x[]=new double[6], x0[]=new double[6];
        int i;
        SidData sip = swed.sidd;
        Epsilon oe = swed.oec2000;
        double plane_node = SwephData.SSY_PLANE_NODE_E2000;
        double plane_incl = SwephData.SSY_PLANE_INCL;
        for (i = 0; i <= 5; i++) {
            x[i] = xin[i];
        }
        
        sl.swi_coortrf2(x, x, oe.seps, oe.ceps);
        if ((iflag & SweConst.SEFLG_SPEED)!=0) {
            sl.swi_coortrf2(x, 3, x, 3, oe.seps, oe.ceps);
        }
        
        sl.swi_cartpol_sp(x, x);
        
        x[0] -= plane_node;
        sl.swi_polcart_sp(x, x);
        sl.swi_coortrf(x, x, plane_incl);
        sl.swi_coortrf(x, 3, x, 3, plane_incl);
        sl.swi_cartpol_sp(x, x);
        
        x0[0] = 1;
        x0[1] = x0[2] = 0;
        if (sip.t0 != SwephData.J2000) {
            sl.swi_precess(x0, sip.t0, SwephData.J_TO_J2000);
        }
        
        sl.swi_coortrf2(x0, x0, oe.seps, oe.ceps);
        
        sl.swi_cartpol(x0, x0);
        
        x0[0] -= plane_node;
        sl.swi_polcart(x0, x0);
        sl.swi_coortrf(x0, x0, plane_incl);
        sl.swi_cartpol(x0, x0);
        
        x[0] -= x0[0];
        x[0] *= SwissData.RADTODEG;
        
        x[0] -= sip.ayan_t0;
        x[0] = sl.swe_degnorm(x[0]) * SwissData.DEGTORAD;
        
        sl.swi_polcart_sp(x, 0, xout, xoOffs);
        return SweConst.OK;
    }
    
    int app_pos_etc_plan_osc(int ipl, int ipli, int iflag, StringBuffer serr) {
        int i, j, niter, retc;
        double xx[]=new double[6], dx[]=new double[3], dt, dtsave_for_defl;
        double xearth[]=new double[6], xsun[]=new double[6], xmoon[]=new double[6];
        double xxsv[]=new double[6], xxsp[]=new double[6],
            xobs[]=new double[6], xobs2[]=new double[6];
        double t;
        PlanData pdp = swed.pldat[ipli];
        PlanData pedp = swed.pldat[SwephData.SEI_EARTH];
        PlanData psdp = swed.pldat[SwephData.SEI_SUNBARY];
        Epsilon oe = swed.oec2000;
        int epheflag = SweConst.SEFLG_DEFAULTEPH;
        dt = dtsave_for_defl = 0;     
        if ((iflag & SweConst.SEFLG_MOSEPH)!=0) {
            epheflag = SweConst.SEFLG_MOSEPH;
        } else if ((iflag & SweConst.SEFLG_SWIEPH)!=0) {
            epheflag = SweConst.SEFLG_SWIEPH;
        } else if ((iflag & SweConst.SEFLG_JPLEPH)!=0) {
            epheflag = SweConst.SEFLG_JPLEPH;
        }
        
        for (i = 0; i <= 5; i++) {
            xx[i] = pdp.x[i];
        }
        
        
        
        
        if ((iflag & SweConst.SEFLG_TOPOCTR)!=0) {
            if (swed.topd.teval != pedp.teval
                || swed.topd.teval != 0) {
                if (swi_get_observer(pedp.teval, iflag, SwephData.DO_SAVE, xobs, serr)
                    != SweConst.OK) {
                    return SweConst.ERR;
                }
            } else {
                for (i = 0; i <= 5; i++) {
                    xobs[i] = swed.topd.xobs[i];
                }
            }
            
            for (i = 0; i <= 5; i++) {
                xobs[i] = xobs[i] + pedp.x[i];
            }
        } else if ((iflag & SweConst.SEFLG_BARYCTR)!=0) {
            for (i = 0; i <= 5; i++) {
                xobs[i] = 0;
            }
        } else if ((iflag & SweConst.SEFLG_HELCTR)!=0) {
            if ((iflag & SweConst.SEFLG_MOSEPH)!=0) {
                for (i = 0; i <= 5; i++) {
                    xobs[i] = 0;
                }
            } else {
                for (i = 0; i <= 5; i++) {
                    xobs[i] = psdp.x[i];
                }
            }
        } else {
            for (i = 0; i <= 5; i++) {
                xobs[i] = pedp.x[i];
            }
        }
        
        if ((iflag & SweConst.SEFLG_TRUEPOS)==0) {
            niter = 1;
            if ((iflag & SweConst.SEFLG_SPEED)!=0) {
                
                for (i = 0; i <= 2; i++) {
                    xxsv[i] = xxsp[i] = xx[i] - xx[i+3];
                }
                for (j = 0; j <= niter; j++) {
                    for (i = 0; i <= 2; i++) {
                        dx[i] = xxsp[i];
                        if ((iflag & SweConst.SEFLG_HELCTR)==0 &&
                            (iflag & SweConst.SEFLG_BARYCTR)==0) {
                            dx[i] -= (xobs[i] - xobs[i+3]);
                        }
                    }
                    
                    dt = Math.sqrt(sl.square_sum(dx)) * SweConst.AUNIT / SwephData.CLIGHT /
                        86400.0;
                    for (i = 0; i <= 2; i++) {
                        xxsp[i] = xxsv[i] - dt * pdp.x[i+3];
                    }
                }
                
                for (i = 0; i <= 2; i++) {
                    xxsp[i] = xxsv[i] - xxsp[i];
                }
            }
            
            for (j = 0; j <= niter; j++) {
                for (i = 0; i <= 2; i++) {
                    dx[i] = xx[i];
                    if ((iflag & SweConst.SEFLG_HELCTR)==0 &&
                        (iflag & SweConst.SEFLG_BARYCTR)==0) {
                        dx[i] -= xobs[i];
                    }
                }
                
                dt = Math.sqrt(sl.square_sum(dx)) *SweConst.AUNIT / SwephData.CLIGHT / 86400.0;
                dtsave_for_defl = dt;
                
                for (i = 0; i <= 2; i++) {
                    xx[i] = pdp.x[i] - dt * pdp.x[i+3];
                    xx[i+3] = pdp.x[i+3];
                }
            }
            if ((iflag & SweConst.SEFLG_SPEED)!=0) {
                
                for (i = 0; i <= 2; i++) {
                    xxsp[i] = pdp.x[i] - xx[i] - xxsp[i];
                }
                t = pdp.teval - dt;
                
                retc = main_planet_bary(t, SwephData.SEI_EARTH, epheflag, iflag,
                                        SwephData.NO_SAVE, xearth, xearth, xsun,
                                        xmoon, serr);
                if (smosh.swi_osc_el_plan(t, xx, ipl-SweConst.SE_FICT_OFFSET, ipli,
                                          xearth, xsun, serr) != SweConst.OK) {
                    return(SweConst.ERR);
                }
                if (retc != SweConst.OK) {
                    return(retc);
                }
                if ((iflag & SweConst.SEFLG_TOPOCTR)!=0) {
                    if (swi_get_observer(t, iflag, SwephData.NO_SAVE, xobs2, serr) !=
                        SweConst.OK) {
                        return SweConst.ERR;
                    }
                    for (i = 0; i <= 5; i++) {
                        xobs2[i] += xearth[i];
                    }
                } else {
                    for (i = 0; i <= 5; i++) {
                        xobs2[i] = xearth[i];
                    }
                }
            }
        }
        
        for (i = 0; i <= 5; i++) {
            xx[i] -= xobs[i];
        }
        if ((iflag & SweConst.SEFLG_TRUEPOS)==0) {
            
            if ((iflag & SweConst.SEFLG_SPEED)!=0) {
                for (i = 3; i <= 5; i++) {
                    xx[i] -= xxsp[i-3];
                }
            }
        }
        if ((iflag & SweConst.SEFLG_SPEED)==0) {
            for (i = 3; i <= 5; i++) {
                xx[i] = 0;
            }
        }
        
        if ((iflag & SweConst.SEFLG_TRUEPOS)==0 &&
            (iflag & SweConst.SEFLG_NOGDEFL)==0) {
            
            swi_deflect_light(xx, 0, dtsave_for_defl, iflag);
        }
        
        if ((iflag & SweConst.SEFLG_TRUEPOS)==0 &&
            (iflag & SweConst.SEFLG_NOABERR)==0) {
            
            swi_aberr_light(xx, xobs, iflag);
            
            if ((iflag & SweConst.SEFLG_SPEED)!=0) {
                for (i = 3; i <= 5; i++) {
                    xx[i] += xobs[i] - xobs2[i];
                }
            }
        }
        
        for (i = 0; i <= 5; i++) {
            xxsv[i] = xx[i];
        }
        
        if ((iflag & SweConst.SEFLG_J2000)==0) {
            sl.swi_precess(xx, pdp.teval, SwephData.J2000_TO_J);
            if ((iflag & SweConst.SEFLG_SPEED)!=0) {
                swi_precess_speed(xx, pdp.teval, SwephData.J2000_TO_J);
            }
            oe = swed.oec;
        } else
            oe = swed.oec2000;
        return app_pos_rest(pdp, iflag, xx, xxsv, oe, serr);
    }
    
    void swi_precess_speed(double xx[], double t, int direction) {
        swi_precess_speed(xx, 0, t, direction);
    }
    void swi_precess_speed(double xx[], int xOffs, double t, int direction) {
        Epsilon oe;
        double fac;
        double tprec = (t - SwephData.J2000) / 36525.0;
        if (direction == SwephData.J2000_TO_J) {
            fac = 1;
            oe = swed.oec;
        } else {
            fac = -1;
            oe = swed.oec2000;
        }
        
        sl.swi_precess(xx, 3+xOffs, t, direction);
        
        sl.swi_coortrf2(xx, xOffs, xx, xOffs, oe.seps, oe.ceps);
        sl.swi_coortrf2(xx, 3+xOffs, xx, 3+xOffs, oe.seps, oe.ceps);
        sl.swi_cartpol_sp(xx, xOffs, xx, xOffs);
        xx[3+xOffs] += (50.290966 + 0.0222226 * tprec) /
            3600 / 365.25 * SwissData.DEGTORAD * fac;
        
        sl.swi_polcart_sp(xx, xOffs, xx, xOffs);
        sl.swi_coortrf2(xx, xOffs, xx, xOffs, -oe.seps, oe.ceps);
        sl.swi_coortrf2(xx, 3+xOffs, xx, 3+xOffs, -oe.seps, oe.ceps);
    }
    
    void swi_nutate(double xx[], int offs, int iflag, boolean backward) {
        int i;
        double x[]=new double[6], xv[]=new double[6];
        for (i = 0; i <= 2; i++) {
            if (backward) {
                x[i] = xx[0+offs] * swed.nut.matrix[i][0] +
                    xx[1+offs] * swed.nut.matrix[i][1] +
                    xx[2+offs] * swed.nut.matrix[i][2];
            } else {
                x[i] = xx[0+offs] * swed.nut.matrix[0][i] +
                    xx[1+offs] * swed.nut.matrix[1][i] +
                    xx[2+offs] * swed.nut.matrix[2][i];
            }
        }
        if ((iflag & SweConst.SEFLG_SPEED)!=0) {
            
            for (i = 0; i <= 2; i++) {
                if (backward) {
                    x[i+3] = xx[3+offs] * swed.nut.matrix[i][0] +
                        xx[4+offs] * swed.nut.matrix[i][1] +
                        xx[5+offs] * swed.nut.matrix[i][2];
                } else {
                    x[i+3] = xx[3+offs] * swed.nut.matrix[0][i] +
                        xx[4+offs] * swed.nut.matrix[1][i] +
                        xx[5+offs] * swed.nut.matrix[2][i];
                }
            }
            
            for (i = 0; i <= 2; i++) {
                if (backward) {
                    xv[i] = xx[0+offs] * swed.nutv.matrix[i][0] +
                        xx[1+offs] * swed.nutv.matrix[i][1] +
                        xx[2+offs] * swed.nutv.matrix[i][2];
                } else {
                    xv[i] = xx[0+offs] * swed.nutv.matrix[0][i] +
                        xx[1+offs] * swed.nutv.matrix[1][i] +
                        xx[2+offs] * swed.nutv.matrix[2][i];
                }
                
                xx[3+i+offs] = x[3+i] + (x[i] - xv[i]) / SwephData.NUT_SPEED_INTV;
            }
        }
        
        for (i = 0; i <= 2; i++) {
            xx[i+offs] = x[i];
        }
    }
    
    void swi_aberr_light(double xx[], double xe[], int iflag) {
        swi_aberr_light(xx, 0, xe, iflag);
    }
    void swi_aberr_light(double xx[], int xxOffs, double xe[], int iflag) {
        int i;
        double xxs[]=new double[6], v[]=new double[6], u[]=new double[6], ru;
        double xx2[]=new double[6], dx1, dx2;
        double b_1, f1, f2;
        double v2;
        double intv = SwephData.PLAN_SPEED_INTV;
        for (i = 0; i <= 5; i++) {
            u[i] = xxs[i] = xx[i+xxOffs];
        }
        ru = Math.sqrt(sl.square_sum(u));
        for (i = 0; i <= 2; i++) {
            v[i] = xe[i+3] / 24.0 / 3600.0 / SwephData.CLIGHT * SweConst.AUNIT;
        }
        v2 = sl.square_sum(v);
        b_1 = Math.sqrt(1 - v2);
        f1 = dot_prod(u, v) / ru;
        f2 = 1.0 + f1 / (1.0 + b_1);
        for (i = 0; i <= 2; i++) {
            xx[i+xxOffs] = (b_1*xx[i+xxOffs] + f2*ru*v[i]) / (1.0 + f1);
        }
        if ((iflag & SweConst.SEFLG_SPEED)!=0) {
            
            for (i = 0; i <= 2; i++) {
                u[i] = xxs[i] - intv * xxs[i+3];
            }
            ru = Math.sqrt(sl.square_sum(u));
            f1 = dot_prod(u, v) / ru;
            f2 = 1.0 + f1 / (1.0 + b_1);
            for (i = 0; i <= 2; i++) {
                xx2[i] = (b_1*u[i] + f2*ru*v[i]) / (1.0 + f1);
            }
            for (i = 0; i <= 2; i++) {
                dx1 = xx[i+xxOffs] - xxs[i];
                dx2 = xx2[i] - u[i];
                dx1 -= dx2;
                xx[i+3+xxOffs] += dx1 / intv;
            }
        }
    }
    
    void swi_deflect_light(double xx[], int offs, double dt, int iflag) {
        int i;
        double xx2[]=new double[6];
        double u[]=new double[6], e[]=new double[6], q[]=new double[6];
        double ru, re, rq, uq, ue, qe, g1, g2;
        double xx3[]=new double[6], dx1, dx2, dtsp;
        double xsun[]=new double[6], xearth[]=new double[6];
        double sina, sin_sunr, meff_fact;
        PlanData pedp = swed.pldat[SwephData.SEI_EARTH];
        PlanData psdp = swed.pldat[SwephData.SEI_SUNBARY];
        int iephe = pedp.iephe;
        for (i = 0; i <= 5; i++) {
            xearth[i] = pedp.x[i];
        }
        if ((iflag & SweConst.SEFLG_TOPOCTR)!=0) {
            for (i = 0; i <= 5; i++) {
                xearth[i] += swed.topd.xobs[i];
            }
        }
        
        for (i = 0; i <= 2; i++) {
            u[i] = xx[i+offs];
        }
        
        if (iephe == SweConst.SEFLG_JPLEPH || iephe == SweConst.SEFLG_SWIEPH) {
            for (i = 0; i <= 2; i++) {
                e[i] = xearth[i] - psdp.x[i];
            }
        } else {
            for (i = 0; i <= 2; i++) {
                e[i] = xearth[i];
            }
        }
        
        
        if (iephe == SweConst.SEFLG_JPLEPH || iephe == SweConst.SEFLG_SWIEPH) {
            for (i = 0; i <= 2; i++) {
                
                xsun[i] = psdp.x[i] - dt * psdp.x[i+3];
            }
            for (i = 3; i <= 5; i++) {
                xsun[i] = psdp.x[i];
            }
        } else {
            for (i = 0; i <= 5; i++) {
                xsun[i] = psdp.x[i];
            }
        }
        for (i = 0; i <= 2; i++) {
            q[i] = xx[i+offs] + xearth[i] - xsun[i];
        }
        ru = Math.sqrt(sl.square_sum(u));
        rq = Math.sqrt(sl.square_sum(q));
        re = Math.sqrt(sl.square_sum(e));
        for (i = 0; i <= 2; i++) {
            u[i] /= ru;
            q[i] /= rq;
            e[i] /= re;
        }
        uq = dot_prod(u,q);
        ue = dot_prod(u,e);
        qe = dot_prod(q,e);
        
        sina = Math.sqrt(1 - ue * ue);      
        sin_sunr = SwephData.SUN_RADIUS / re;   
        if (sina < sin_sunr) {
            meff_fact = meff(sina / sin_sunr);
        } else {
            meff_fact = 1;
        }
        g1 = 2.0 * SwephData.HELGRAVCONST * meff_fact / SwephData.CLIGHT / SwephData.CLIGHT / SweConst.AUNIT / re;
        g2 = 1.0 + qe;
        
        for (i = 0; i <= 2; i++) {
            xx2[i] = ru * (u[i] + g1/g2 * (uq * e[i] - ue * q[i]));
        }
        if ((iflag & SweConst.SEFLG_SPEED)!=0) {
            
            dtsp = -SwephData.DEFL_SPEED_INTV;
            
            for (i = 0; i <= 2; i++) {
                u[i] = xx[i+offs] - dtsp * xx[i+3+offs];
            }
            
            if (iephe == SweConst.SEFLG_JPLEPH || iephe == SweConst.SEFLG_SWIEPH) {
                for (i = 0; i <= 2; i++) {
                    e[i] = xearth[i] - psdp.x[i] - dtsp * (xearth[i+3] - psdp.x[i+3]);
                }
            } else {
                for (i = 0; i <= 2; i++) {
                    e[i] = xearth[i] - dtsp * xearth[i+3];
                }
            }
            
            for (i = 0; i <= 2; i++) {
                q[i] = u[i] + xearth[i] - xsun[i] - dtsp * (xearth[i+3] - xsun[i+3]);
            }
            ru = Math.sqrt(sl.square_sum(u));
            rq = Math.sqrt(sl.square_sum(q));
            re = Math.sqrt(sl.square_sum(e));
            for (i = 0; i <= 2; i++) {
                u[i] /= ru;
                q[i] /= rq;
                e[i] /= re;
            }
            uq = dot_prod(u,q);
            ue = dot_prod(u,e);
            qe = dot_prod(q,e);
            sina = Math.sqrt(1 - ue * ue);    
            sin_sunr = SwephData.SUN_RADIUS / re; 
            if (sina < sin_sunr) {
                meff_fact = meff(sina / sin_sunr);
            } else {
                meff_fact = 1;
            }
            g1 = 2.0 * SwephData.HELGRAVCONST * meff_fact / SwephData.CLIGHT /
                SwephData.CLIGHT / SweConst.AUNIT / re;
            g2 = 1.0 + qe;
            for (i = 0; i <= 2; i++) {
                xx3[i] = ru * (u[i] + g1/g2 * (uq * e[i] - ue * q[i]));
            }
            for (i = 0; i <= 2; i++) {
                dx1 = xx2[i] - xx[i+offs];
                dx2 = xx3[i] - u[i] * ru;
                dx1 -= dx2;
                xx[i+3+offs] += dx1 / dtsp;
            }
        } 
        
        for (i = 0; i <= 2; i++) {
            xx[i+offs] = xx2[i];
        }
    }
    
    int app_pos_etc_sun(int iflag, StringBuffer serr) {
        int i, j, niter, retc = SweConst.OK;
        int flg1, flg2;
        double xx[]=new double[6], xxsv[]=new double[6], dx[]=new double[3], dt, t;
        double xearth[]=new double[6], xsun[]=new double[6], xobs[]=new double[6];
        PlanData pedp = swed.pldat[SwephData.SEI_EARTH];
        PlanData psdp = swed.pldat[SwephData.SEI_SUNBARY];
        Epsilon oe = swed.oec2000;
        
        flg1 = iflag & ~SweConst.SEFLG_EQUATORIAL & ~SweConst.SEFLG_XYZ;
        flg2 = pedp.xflgs & ~SweConst.SEFLG_EQUATORIAL & ~SweConst.SEFLG_XYZ;
        if (flg1 == flg2) {
            pedp.xflgs = iflag;
            pedp.iephe = iflag & SweConst.SEFLG_EPHMASK;
            return SweConst.OK;
        }
        
        
        if ((iflag & SweConst.SEFLG_TOPOCTR)!=0) {
            if (swed.topd.teval != pedp.teval
                || swed.topd.teval == 0) {
                if (swi_get_observer(pedp.teval, iflag, SwephData.DO_SAVE, xobs, serr)
                    != SweConst.OK) {
                    return SweConst.ERR;
                }
            } else {
                for (i = 0; i <= 5; i++) {
                    xobs[i] = swed.topd.xobs[i];
                }
            }
            
            for (i = 0; i <= 5; i++) {
                xobs[i] = xobs[i] + pedp.x[i];
            }
        } else {
            
            for (i = 0; i <= 5; i++) {
                xobs[i] = pedp.x[i];
            }
        }
        
        if (pedp.iephe == SweConst.SEFLG_MOSEPH ||
            (iflag & SweConst.SEFLG_BARYCTR)!=0) {
            for (i = 0; i <= 5; i++) {
                xx[i] = xobs[i];
            }
        } else {
            for (i = 0; i <= 5; i++) {
                xx[i] = xobs[i] - psdp.x[i];
            }
        }
        
        if ((iflag & SweConst.SEFLG_TRUEPOS)==0) {
            
            if (pedp.iephe == SweConst.SEFLG_JPLEPH ||
                pedp.iephe == SweConst.SEFLG_SWIEPH ||
                (iflag & SweConst.SEFLG_HELCTR)!=0 ||
                (iflag & SweConst.SEFLG_BARYCTR)!=0) {
                for (i = 0; i <= 5; i++) {
                    xearth[i] = xobs[i];
                    if (pedp.iephe == SweConst.SEFLG_MOSEPH) {
                        xsun[i] = 0;
                    } else {
                        xsun[i] = psdp.x[i];
                    }
                }
                niter = 1;        
                for (j = 0; j <= niter; j++) {
                    
                    for (i = 0; i <= 2; i++) {
                        dx[i] = xearth[i];
                        if ((iflag & SweConst.SEFLG_BARYCTR)==0) {
                            dx[i] -= xsun[i];
                        }
                    }
                    
                    dt = Math.sqrt(sl.square_sum(dx)) * SweConst.AUNIT / SwephData.CLIGHT /
                        86400.0;
                    t = pedp.teval - dt;
                    
                    switch(pedp.iephe) {
                        
                        case SweConst.SEFLG_JPLEPH:
                            if ((iflag & SweConst.SEFLG_HELCTR)!=0 ||
                                (iflag & SweConst.SEFLG_BARYCTR)!=0) {
                                retc = sj.swi_pleph(t, SwephJPL.J_EARTH, SwephJPL.J_SBARY, xearth, serr);
                            } else {
                                retc = sj.swi_pleph(t, SwephJPL.J_SUN, SwephJPL.J_SBARY, xsun, serr);
                            }
                            if (retc != SweConst.OK) {
                                sj.swi_close_jpl_file();
                                swed.jpl_file_is_open = false;
                                return(retc);
                            }
                            break;
                        case SweConst.SEFLG_SWIEPH:
                            
                            if ((iflag & SweConst.SEFLG_HELCTR)!=0 ||
                                (iflag & SweConst.SEFLG_BARYCTR)!=0) {
                                retc = sweplan(t, SwephData.SEI_EARTH,
                                               SwephData.SEI_FILE_PLANET, iflag,
                                               SwephData.NO_SAVE, xearth, null, xsun, null,
                                               serr);
                            } else {
                                retc = sweph(t, SwephData.SEI_SUNBARY,
                                             SwephData.SEI_FILE_PLANET, iflag, null,
                                             SwephData.NO_SAVE, xsun, serr);
                            }
                            break;
                        case SweConst.SEFLG_MOSEPH:
                            if ((iflag & SweConst.SEFLG_HELCTR)!=0 ||
                                (iflag & SweConst.SEFLG_BARYCTR)!=0) {
                                retc = smosh.swi_moshplan(t, SwephData.SEI_EARTH,
                                                          SwephData.NO_SAVE, xearth, xearth,
                                                          serr);
                            }
                            
                            break;
                        default:
                            retc = SweConst.ERR;
                            break;
                    }
                    if (retc != SweConst.OK) {
                        return(retc);
                    }
                }
                
                for (i = 0; i <= 5; i++) {
                    xx[i] = xearth[i];
                    if ((iflag & SweConst.SEFLG_BARYCTR)==0) {
                        xx[i] -= xsun[i];
                    }
                }
            }
        }
        if ((iflag & SweConst.SEFLG_SPEED)==0) {
            for (i = 3; i <= 5; i++) {
                xx[i] = 0;
            }
        }
        
        if ((iflag & SweConst.SEFLG_HELCTR)==0 &&
            (iflag & SweConst.SEFLG_BARYCTR)==0) {
            for (i = 0; i <= 5; i++) {
                xx[i] = -xx[i];
            }
        }
        
        if ((iflag & SweConst.SEFLG_TRUEPOS)==0 &&
            (iflag & SweConst.SEFLG_NOABERR)==0) {
            
            swi_aberr_light(xx, xobs, iflag);
        }
        if ((iflag & SweConst.SEFLG_SPEED) == 0) {
            for (i = 3; i <= 5; i++) {
                xx[i] = 0;
            }
        }
        
        if ((iflag & SweConst.SEFLG_ICRS) == 0 && swed.jpldenum >= 403) {
            sl.swi_bias(xx, iflag, false);
        }
        
        for (i = 0; i <= 5; i++) {
            xxsv[i] = xx[i];
        }
        
        if ((iflag & SweConst.SEFLG_J2000)==0) {
            sl.swi_precess(xx, pedp.teval, SwephData.J2000_TO_J);
            if ((iflag & SweConst.SEFLG_SPEED)!=0) {
                swi_precess_speed(xx, pedp.teval, SwephData.J2000_TO_J);
            }
            oe = swed.oec;
        } else
            oe = swed.oec2000;
        return app_pos_rest(pedp, iflag, xx, xxsv, oe, serr);
    }
    
    int app_pos_etc_moon(int iflag, StringBuffer serr) {
        int i;
        int flg1, flg2;
        double xx[]=new double[6], xxsv[]=new double[6], xobs[]=new double[6],
            xxm[]=new double[6], xs[]=new double[6], xe[]=new double[6],
            xobs2[]=new double[6], dt;
        PlanData pedp = swed.pldat[SwephData.SEI_EARTH];
        PlanData psdp = swed.pldat[SwephData.SEI_SUNBARY];
        PlanData pdp = swed.pldat[SwephData.SEI_MOON];
        Epsilon oe = swed.oec;
        double t;
        int retc;
        
        flg1 = iflag & ~SweConst.SEFLG_EQUATORIAL & ~SweConst.SEFLG_XYZ;
        flg2 = pdp.xflgs & ~SweConst.SEFLG_EQUATORIAL & ~SweConst.SEFLG_XYZ;
        if (flg1 == flg2) {
            pdp.xflgs = iflag;
            pdp.iephe = (iflag & SweConst.SEFLG_EPHMASK);
            return SweConst.OK;
        }
        
        for (i = 0; i <= 5; i++) {
            xx[i] = pdp.x[i];
            xxm[i] = xx[i];
        }
        
        for (i = 0; i <= 5; i++) {
            xx[i] += pedp.x[i];
        }
        
        if ((iflag & SweConst.SEFLG_TOPOCTR)!=0) {
            if (swed.topd.teval != pdp.teval
                || swed.topd.teval == 0) {
                if (swi_get_observer(pdp.teval, iflag, SwephData.DO_SAVE, xobs, null) !=
                    SweConst.OK) {
                    return SweConst.ERR;
                }
            } else {
                for (i = 0; i <= 5; i++) {
                    xobs[i] = swed.topd.xobs[i];
                }
            }
            for (i = 0; i <= 5; i++) {
                xxm[i] -= xobs[i];
            }
            for (i = 0; i <= 5; i++) {
                xobs[i] += pedp.x[i];
            }
        } else if ((iflag & SweConst.SEFLG_BARYCTR)!=0) {
            for (i = 0; i <= 5; i++) {
                xobs[i] = 0;
            }
            for (i = 0; i <= 5; i++) {
                xxm[i] += pedp.x[i];
            }
        } else if ((iflag & SweConst.SEFLG_HELCTR)!=0) {
            for (i = 0; i <= 5; i++) {
                xobs[i] = psdp.x[i];
            }
            for (i = 0; i <= 5; i++) {
                xxm[i] += pedp.x[i] - psdp.x[i];
            }
        } else {
            for (i = 0; i <= 5; i++) {
                xobs[i] = pedp.x[i];
            }
        }
        
        if ((iflag & SweConst.SEFLG_TRUEPOS) == 0) {
            dt = Math.sqrt(sl.square_sum(xxm)) * SweConst.AUNIT /
                SwephData.CLIGHT / 86400.0;
            t = pdp.teval - dt;
            switch(pdp.iephe) {
                case SweConst.SEFLG_JPLEPH:
                    retc = sj.swi_pleph(t, SwephJPL.J_MOON, SwephJPL.J_EARTH, xx, serr);
                    if (retc == SweConst.OK) {
                        retc = sj.swi_pleph(t, SwephJPL.J_EARTH, SwephJPL.J_SBARY, xe, serr);
                    }
                    if (retc == SweConst.OK && (iflag & SweConst.SEFLG_HELCTR)!=0) {
                        retc = sj.swi_pleph(t, SwephJPL.J_SUN, SwephJPL.J_SBARY, xs, serr);
                    }
                    if (retc != SweConst.OK) {
                        sj.swi_close_jpl_file();
                        swed.jpl_file_is_open = false;
                    }
                    for (i = 0; i <= 5; i++) {
                        xx[i] += xe[i];
                    }
                    break;
                case SweConst.SEFLG_SWIEPH:
                    retc = sweplan(t, SwephData.SEI_MOON, SwephData.SEI_FILE_MOON, iflag, SwephData.NO_SAVE, xx, xe, xs, null, serr);
                    if (retc != SweConst.OK) {
                        return(retc);
                    }
                    for (i = 0; i <= 5; i++) {
                        xx[i] += xe[i];
                    }
                    break;
                case SweConst.SEFLG_MOSEPH:
                    
                    for (i = 0; i <= 2; i++) {
                        xx[i] -= dt * xx[i+3];
                        xe[i] = pedp.x[i] - dt * pedp.x[i+3];
                        xe[i+3] = pedp.x[i+3];
                        xs[i] = 0;
                        xs[i+3] = 0;
                    }
                    break;
            }
            if ((iflag & SweConst.SEFLG_TOPOCTR)!=0) {
                if (swi_get_observer(t, iflag, SwephData.NO_SAVE, xobs2, null) !=
                    SweConst.OK) {
                    return SweConst.ERR;
                }
                for (i = 0; i <= 5; i++) {
                    xobs2[i] += xe[i];
                }
            } else if ((iflag & SweConst.SEFLG_BARYCTR)!=0) {
                for (i = 0; i <= 5; i++) {
                    xobs2[i] = 0;
                }
            } else if ((iflag & SweConst.SEFLG_HELCTR)!=0) {
                for (i = 0; i <= 5; i++) {
                    xobs2[i] = xs[i];
                }
            } else {
                for (i = 0; i <= 5; i++) {
                    xobs2[i] = xe[i];
                }
            }
        }
        
        for (i = 0; i <= 5; i++) {
            xx[i] -= xobs[i];
        }
        
        if ((iflag & SweConst.SEFLG_TRUEPOS)==0 &&
            (iflag & SweConst.SEFLG_NOABERR)==0) {
            
            swi_aberr_light(xx, xobs, iflag);
            
            if ((iflag & SweConst.SEFLG_SPEED)!=0) {
                for (i = 3; i <= 5; i++) {
                    xx[i] += xobs[i] - xobs2[i];
                }
            }
        }
        
        if ((iflag & SweConst.SEFLG_SPEED)==0) {
            for (i = 3; i <= 5; i++) {
                xx[i] = 0;
            }
        }
        
        if ((iflag & SweConst.SEFLG_ICRS) == 0 && swed.jpldenum >= 403) {
            sl.swi_bias(xx, iflag, false);
        }
        
        for (i = 0; i <= 5; i++) {
            xxsv[i] = xx[i];
        }
        
        if ((iflag & SweConst.SEFLG_J2000) == 0) {
            sl.swi_precess(xx, pdp.teval, SwephData.J2000_TO_J);
            if ((iflag & SweConst.SEFLG_SPEED)!=0) {
                swi_precess_speed(xx, pdp.teval, SwephData.J2000_TO_J);
            }
            oe = swed.oec;
        } else {
            oe = swed.oec2000;
        }
        return app_pos_rest(pdp, iflag, xx, xxsv, oe, serr);
    }
    
    int app_pos_etc_sbar(int iflag, StringBuffer serr) {
        int i;
        double xx[]=new double[6], xxsv[]=new double[6], dt;
        PlanData psdp = swed.pldat[SwephData.SEI_EARTH];
        PlanData psbdp = swed.pldat[SwephData.SEI_SUNBARY];
        Epsilon oe = swed.oec;
        
        for (i = 0; i <= 5; i++) {
            xx[i] = psbdp.x[i];
        }
        
        if ((iflag & SweConst.SEFLG_TRUEPOS)==0) {
            dt = Math.sqrt(sl.square_sum(xx)) * SweConst.AUNIT / SwephData.CLIGHT / 86400.0;
            for (i = 0; i <= 2; i++) {
                xx[i] -= dt * xx[i+3];    
            }
        }
        if ((iflag & SweConst.SEFLG_SPEED)==0) {
            for (i = 3; i <= 5; i++) {
                xx[i] = 0;
            }
        }
        
        if ((iflag & SweConst.SEFLG_ICRS) == 0 && swed.jpldenum >= 403) {
            sl.swi_bias(xx, iflag, false);
        }
        
        for (i = 0; i <= 5; i++) {
            xxsv[i] = xx[i];
        }
        
        if ((iflag & SweConst.SEFLG_J2000)==0) {
            sl.swi_precess(xx, psbdp.teval, SwephData.J2000_TO_J);
            if ((iflag & SweConst.SEFLG_SPEED)!=0) {
                swi_precess_speed(xx, psbdp.teval, SwephData.J2000_TO_J);
            }
            oe = swed.oec;
        } else {
            oe = swed.oec2000;
        }
        return app_pos_rest(psdp, iflag, xx, xxsv, oe, serr);
    }
    
    int app_pos_etc_mean(int ipl, int iflag, StringBuffer serr) {
        int i;
        int flg1, flg2;
        double xx[]=new double[6], xxsv[]=new double[6];
        PlanData pdp = swed.nddat[ipl];
        Epsilon oe;
        
        flg1 = iflag & ~SweConst.SEFLG_EQUATORIAL & ~SweConst.SEFLG_XYZ;
        flg2 = pdp.xflgs & ~SweConst.SEFLG_EQUATORIAL & ~SweConst.SEFLG_XYZ;
        if (flg1 == flg2) {
            pdp.xflgs = iflag;
            pdp.iephe = iflag & SweConst.SEFLG_EPHMASK;
            return SweConst.OK;
        }
        for (i = 0; i <= 5; i++) {
            xx[i] = pdp.x[i];
        }
        
        sl.swi_polcart_sp(xx, xx);
        sl.swi_coortrf2(xx, xx, -swed.oec.seps, swed.oec.ceps);
        sl.swi_coortrf2(xx, 3, xx, 3, -swed.oec.seps, swed.oec.ceps);
        if ((iflag & SweConst.SEFLG_SPEED)==0) {
            for (i = 3; i <= 5; i++) {
                xx[i] = 0;
            }
        }
        
        if (((iflag & SweConst.SEFLG_SIDEREAL)!=0
             && (swed.sidd.sid_mode & SweConst.SE_SIDBIT_ECL_T0)!=0)
            || (swed.sidd.sid_mode & SweConst.SE_SIDBIT_SSY_PLANE)!=0) {
            for (i = 0; i <= 5; i++) {
                xxsv[i] = xx[i];
            }
            
            if (pdp.teval != SwephData.J2000) {
                sl.swi_precess(xxsv, pdp.teval, SwephData.J_TO_J2000);
                if ((iflag & SweConst.SEFLG_SPEED)!=0) {
                    swi_precess_speed(xxsv, pdp.teval, SwephData.J_TO_J2000);
                }
            }
        }
        
        if ((iflag & SweConst.SEFLG_J2000)!=0) {
            sl.swi_precess(xx, pdp.teval, SwephData.J_TO_J2000);
            if ((iflag & SweConst.SEFLG_SPEED)!=0) {
                swi_precess_speed(xx, pdp.teval, SwephData.J_TO_J2000);
            }
            oe = swed.oec2000;
        } else {
            oe = swed.oec;
        }
        return app_pos_rest(pdp, iflag, xx, xxsv, oe, serr);
    }
    
    void rot_back(int ipli) {
        int i;
        double t, tdiff;
        double qav, pav, dn;
        double omtild, com, som, cosih2;
        double x[][]=new double[SwephData.MAXORD+1][3];
        double uix[]=new double[3], uiy[]=new double[3], uiz[]=new double[3];
        double xrot, yrot, zrot;
        double chcfx[];
        double refepx[];
        double seps2000 = swed.oec2000.seps;
        double ceps2000 = swed.oec2000.ceps;
        PlanData pdp = swed.pldat[ipli];
        int nco = pdp.ncoe;
        int chcfyOffs;
        int chcfzOffs;
        int refepyOffs;
        t = pdp.tseg0 + pdp.dseg / 2;
        chcfx = pdp.segp;
        chcfyOffs = nco;
        chcfzOffs = 2 * nco;
        refepx = pdp.refep;
        refepyOffs = nco;
        tdiff= (t - pdp.telem) / 365250.0;
        if (ipli == SwephData.SEI_MOON) {
            dn = pdp.prot + tdiff * pdp.dprot;
            i = (int) (dn / SwephData.TWOPI);
            dn -= i * SwephData.TWOPI;
            qav = (pdp.qrot + tdiff * pdp.dqrot) * Math.cos(dn);
            pav = (pdp.qrot + tdiff * pdp.dqrot) * Math.sin(dn);
        } else {
            qav = pdp.qrot + tdiff * pdp.dqrot;
            pav = pdp.prot + tdiff * pdp.dprot;
        }
        
        for (i = 0; i < nco; i++) {
            x[i][0] = chcfx[i];
            x[i][1] = chcfx[i+chcfyOffs];
            x[i][2] = chcfx[i+chcfzOffs];
        }
        if ((pdp.iflg & SwephData.SEI_FLG_ELLIPSE)!=0) {
            omtild = pdp.peri + tdiff * pdp.dperi;
            i = (int) (omtild / SwephData.TWOPI);
            omtild -= i * SwephData.TWOPI;
            com = Math.cos(omtild);
            som = Math.sin(omtild);
            
            for (i = 0; i < nco; i++) {
                x[i][0] = chcfx[i] + com * refepx[i] - som * refepx[i+refepyOffs];
                x[i][1] = chcfx[i+chcfyOffs] + com * refepx[i+refepyOffs] + som * refepx[i];
            }
        }
        
        cosih2 = 1.0 / (1.0 + qav * qav + pav * pav);
        
        uiz[0] = 2.0 * pav * cosih2;
        uiz[1] = -2.0 * qav * cosih2;
        uiz[2] = (1.0 - qav * qav - pav * pav) * cosih2;
        
        uix[0] = (1.0 + qav * qav - pav * pav) * cosih2;
        uix[1] = 2.0 * qav * pav * cosih2;
        uix[2] = -2.0 * pav * cosih2;
        
        uiy[0] =2.0 * qav * pav * cosih2;
        uiy[1] =(1.0 - qav * qav + pav * pav) * cosih2;
        uiy[2] =2.0 * qav * cosih2;
        
        for (i = 0; i < nco; i++) {
            xrot = x[i][0] * uix[0] + x[i][1] * uiy[0] + x[i][2] * uiz[0];
            yrot = x[i][0] * uix[1] + x[i][1] * uiy[1] + x[i][2] * uiz[1];
            zrot = x[i][0] * uix[2] + x[i][1] * uiy[2] + x[i][2] * uiz[2];
            if (Math.abs(xrot) + Math.abs(yrot) + Math.abs(zrot) >= 1e-14) {
                pdp.neval = i;
            }
            x[i][0] = xrot;
            x[i][1] = yrot;
            x[i][2] = zrot;
            if (ipli == SwephData.SEI_MOON) {
                
                x[i][1] = ceps2000 * yrot - seps2000 * zrot;
                x[i][2] = seps2000 * yrot + ceps2000 * zrot;
            }
        }
        for (i = 0; i < nco; i++) {
            chcfx[i] = x[i][0];
            chcfx[i+chcfyOffs] = x[i][1];
            chcfx[i+chcfzOffs] = x[i][2];
        }
    }
    
    void embofs(double xemb[], int eOffs, double xmoon[], int mOffs) {
        int i;
        for (i = 0; i <= 2; i++) {
            xemb[i+eOffs] -= xmoon[i+mOffs] / (SwephData.EARTH_MOON_MRAT + 1.0);
        }
    }
    
    void nut_matrix(Nut nu, Epsilon oe) {
        double psi, eps;
        double sinpsi, cospsi, sineps, coseps, sineps0, coseps0;
        psi = nu.nutlo[0];
        eps = oe.eps + nu.nutlo[1];
        sinpsi = Math.sin(psi);
        cospsi = Math.cos(psi);
        sineps0 = oe.seps;
        coseps0 = oe.ceps;
        sineps = Math.sin(eps);
        coseps = Math.cos(eps);
        nu.matrix[0][0] = cospsi;
        nu.matrix[0][1] = sinpsi * coseps;
        nu.matrix[0][2] = sinpsi * sineps;
        nu.matrix[1][0] = -sinpsi * coseps0;
        nu.matrix[1][1] = cospsi * coseps * coseps0 + sineps * sineps0;
        nu.matrix[1][2] = cospsi * sineps * coseps0 - coseps * sineps0;
        nu.matrix[2][0] = -sinpsi * sineps0;
        nu.matrix[2][1] = cospsi * coseps * sineps0 - sineps * coseps0;
        nu.matrix[2][2] = cospsi * sineps * sineps0 + coseps * coseps0;
    }
    
    private int lunar_osc_elem(double tjd, int ipl, int iflag, StringBuffer serr) {
        int i, j, istart;
        int ipli = SwephData.SEI_MOON;
        int epheflag = SweConst.SEFLG_DEFAULTEPH;
        int retc = SweConst.ERR;
        int flg1, flg2;
        PlanData ndp, ndnp, ndap;
        Epsilon oe;
        double speed_intv = SwephData.NODE_CALC_INTV;   
        double a, b;
        double xpos[][]=new double[3][6], xx[][]=new double[3][6],
            xxa[][]=new double[3][6];
        double xp[];
        double xnorm[]=new double[6], r[]=new double[6];
        double rxy, rxyz, t, dt, fac, sgn;
        double sinnode, cosnode, sinincl, cosincl, sinu, cosu, sinE, cosE;
        double uu, ny, sema, ecce, Gmsm, c2, v2, pp;
        int speedf1, speedf2;
        oe = swed.oec;
        ndp = swed.nddat[ipl];
        
        flg1 = iflag & ~SweConst.SEFLG_EQUATORIAL & ~SweConst.SEFLG_XYZ;
        flg2 = ndp.xflgs & ~SweConst.SEFLG_EQUATORIAL & ~SweConst.SEFLG_XYZ;
        speedf1 = ndp.xflgs & SweConst.SEFLG_SPEED;
        speedf2 = iflag & SweConst.SEFLG_SPEED;
        if (tjd == ndp.teval
            && tjd != 0
            && flg1 == flg2
            && ((speedf2==0) || (speedf1!=0))) {
            ndp.xflgs = iflag;
            ndp.iephe = iflag & SweConst.SEFLG_EPHMASK;
            return SweConst.OK;
        }
        
        
        if ((iflag & SweConst.SEFLG_MOSEPH)!=0) {
            epheflag = SweConst.SEFLG_MOSEPH;
        } else if ((iflag & SweConst.SEFLG_SWIEPH)!=0) {
            epheflag = SweConst.SEFLG_SWIEPH;
        } else if ((iflag & SweConst.SEFLG_JPLEPH)!=0) {
            epheflag = SweConst.SEFLG_JPLEPH;
        }
        
        swed.pldat[SwephData.SEI_MOON].teval = 0;
        if ((iflag & SweConst.SEFLG_SPEED)!=0) {
            istart = 0;
        } else {
            istart = 2;
        }
        if (serr != null) {
            serr.setLength(0);
        }
        //  three_positions:
        do {
            switch(epheflag) {
                case SweConst.SEFLG_JPLEPH:
                    speed_intv = SwephData.NODE_CALC_INTV;
                    for (i = istart; i <= 2; i++) {
                        if (i == 0) {
                            t = tjd - speed_intv;
                        } else if (i == 1) {
                            t = tjd + speed_intv;
                        } else {
                            t = tjd;
                        }
                        xp = xpos[i];
                        retc = jplplan(t, ipli, iflag, SwephData.NO_SAVE, xp, null, null,
                                       serr);
                        
                        if (retc == SweConst.ERR) {
                            return(SweConst.ERR);
                        }
                        
                        if ((iflag & SweConst.SEFLG_TRUEPOS) == 0 && retc >= SweConst.OK) {
                            dt = Math.sqrt(sl.square_sum(xpos[i])) * SweConst.AUNIT /
                                SwephData.CLIGHT / 86400.0;
                            retc = jplplan(t-dt, ipli, iflag, SwephData.NO_SAVE, xpos[i],
                                           null, null, serr); 
                            
                            if (retc == SweConst.ERR) {
                                return(SweConst.ERR);
                            }
                        }
                        
                        if (retc == SwephData.NOT_AVAILABLE) {
                            iflag = (iflag & ~SweConst.SEFLG_JPLEPH) | SweConst.SEFLG_SWIEPH;
                            epheflag = SweConst.SEFLG_SWIEPH;
                            if (serr != null && serr.length() + 30 < SwissData.AS_MAXCH) {
                                serr.append(" \ntrying Swiss Eph; ");
                            }
                            break;
                        } else if (retc == SwephData.BEYOND_EPH_LIMITS) {
                            if (tjd > SwephData.MOSHLUEPH_START &&
                                tjd < SwephData.MOSHLUEPH_END) {
                                iflag = (iflag & ~SweConst.SEFLG_JPLEPH) |
                                    SweConst.SEFLG_MOSEPH;
                                epheflag = SweConst.SEFLG_MOSEPH;
                                if (serr != null && serr.length() + 30 < SwissData.AS_MAXCH) {
                                    serr.append(" \nusing Moshier Eph; ");
                                }
                                break;
                            } else
                                return SweConst.ERR;
                        }
                        
                        retc = swi_plan_for_osc_elem(iflag|SweConst.SEFLG_SPEED, t, xpos[i]); 
                    }
                    break;
                case SweConst.SEFLG_SWIEPH:
                    speed_intv = SwephData.NODE_CALC_INTV;
                    for (i = istart; i <= 2; i++) {
                        if (i == 0) {
                            t = tjd - speed_intv;
                        } else if (i == 1) {
                            t = tjd + speed_intv;
                        } else {
                            t = tjd;
                        }
                        retc = swemoon(t, iflag | SweConst.SEFLG_SPEED, SwephData.NO_SAVE,
                                       xpos[i], serr);
                        if (retc == SweConst.ERR) {
                            return(SweConst.ERR);
                        }
                        
                        if ((iflag & SweConst.SEFLG_TRUEPOS) == 0 && retc >= SweConst.OK) {
                            dt = Math.sqrt(sl.square_sum(xpos[i])) * SweConst.AUNIT /
                                SwephData.CLIGHT / 86400.0;
                            retc = swemoon(t-dt, iflag | SweConst.SEFLG_SPEED,
                                           SwephData.NO_SAVE, xpos[i], serr);
                            if (retc == SweConst.ERR) {
                                return(SweConst.ERR);
                            }
                        }
                        if (retc == SwephData.NOT_AVAILABLE) {
                            if (tjd > SwephData.MOSHPLEPH_START &&
                                tjd < SwephData.MOSHPLEPH_END) {
                                iflag = (iflag & ~SweConst.SEFLG_SWIEPH) | SweConst.SEFLG_MOSEPH;
                                epheflag = SweConst.SEFLG_MOSEPH;
                                if (serr != null && serr.length() + 30 < SwissData.AS_MAXCH) {
                                    serr.append(" \nusing Moshier eph.; ");
                                }
                                break;
                            } else
                                return SweConst.ERR;
                        }
                        
                        retc = swi_plan_for_osc_elem(iflag|SweConst.SEFLG_SPEED, t, xpos[i]); 
                    }
                    break;
                case SweConst.SEFLG_MOSEPH:
                    
                    speed_intv = SwephData.NODE_CALC_INTV_MOSH;
                    for (i = istart; i <= 2; i++) {
                        if (i == 0) {
                            t = tjd - speed_intv;
                        } else if (i == 1) {
                            t = tjd + speed_intv;
                        } else {
                            t = tjd;
                        }
                        retc = sm.swi_moshmoon(t, SwephData.NO_SAVE, xpos[i], serr);
                        if (retc == SweConst.ERR) {
                            return(retc);
                        }
                        
                        retc = swi_plan_for_osc_elem(iflag|SweConst.SEFLG_SPEED, t, xpos[i]); 
                    }
                    break;
                default:
                    break;
            }
        } while (retc == SwephData.NOT_AVAILABLE || retc == SwephData.BEYOND_EPH_LIMITS);
        //    goto three_positions;
        
        
        ndnp = swed.nddat[SwephData.SEI_TRUE_NODE];
        
        for (i = istart; i <= 2; i++) {
            if (Math.abs(xpos[i][5]) < 1e-15) {
                xpos[i][5] = 1e-15;
            }
            fac = xpos[i][2] / xpos[i][5];
            sgn = xpos[i][5] / Math.abs(xpos[i][5]);
            for (j = 0; j <= 2; j++) {
                xx[i][j] = (xpos[i][j] - fac * xpos[i][j+3]) * sgn;
            }
        }
        
        
        for (i = 0; i <= 2; i++) {
            ndnp.x[i] = xx[2][i];
            if ((iflag & SweConst.SEFLG_SPEED)!=0) {
                b = (xx[1][i] - xx[0][i]) / 2;
                a = (xx[1][i] + xx[0][i]) / 2 - xx[2][i];
                ndnp.x[i+3] = (2 * a + b) / speed_intv;
            } else
                ndnp.x[i+3] = 0;
            ndnp.teval = tjd;
            ndnp.iephe = epheflag;
        }
        
        ndap = swed.nddat[SwephData.SEI_OSCU_APOG];
        Gmsm = SwephData.GEOGCONST * (1 + 1 / SwephData.EARTH_MOON_MRAT) /
            SweConst.AUNIT/SweConst.AUNIT/SweConst.AUNIT*86400.0*86400.0;
        
        for (i = istart; i <= 2; i++) {
            
            rxy =  Math.sqrt(xx[i][0] * xx[i][0] + xx[i][1] * xx[i][1]);
            cosnode = xx[i][0] / rxy;
            sinnode = xx[i][1] / rxy;
            
            sl.swi_cross_prod(xpos[i], 0, xpos[i], 3, xnorm, 0);
            rxy =  xnorm[0] * xnorm[0] + xnorm[1] * xnorm[1];
            c2 = (rxy + xnorm[2] * xnorm[2]);
            rxyz = Math.sqrt(c2);
            rxy = Math.sqrt(rxy);
            sinincl = rxy / rxyz;
            cosincl = Math.sqrt(1 - sinincl * sinincl);
            
            cosu = xpos[i][0] * cosnode + xpos[i][1] * sinnode;
            sinu = xpos[i][2] / sinincl;
            uu = Math.atan2(sinu, cosu);
            
            rxyz = Math.sqrt(sl.square_sum(xpos[i]));
            v2 = sl.square_sum(xpos[i], 3);
            sema = 1 / (2 / rxyz - v2 / Gmsm);
            
            pp = c2 / Gmsm;
            ecce = Math.sqrt(1 - pp / sema);
            
            cosE = 1 / ecce * (1 - rxyz / sema);
            sinE = 1 / ecce / Math.sqrt(sema * Gmsm) * dot_prod(xpos[i], xpos[i], 3);
            
            ny = 2 * Math.atan(Math.sqrt((1+ecce)/(1-ecce)) * sinE / (1 + cosE));
            
            xxa[i][0] = sl.swi_mod2PI(uu - ny + SwephData.PI);
            xxa[i][1] = 0;                      
            xxa[i][2] = sema * (1 + ecce);      
            
            sl.swi_polcart(xxa[i], xxa[i]);
            sl.swi_coortrf2(xxa[i], xxa[i], -sinincl, cosincl);
            sl.swi_cartpol(xxa[i], xxa[i]);
            
            xxa[i][0] += Math.atan2(sinnode, cosnode);
            sl.swi_polcart(xxa[i], xxa[i]);
            
            ny = sl.swi_mod2PI(ny - uu);
            
            cosE = Math.cos(2 * Math.atan(Math.tan(ny / 2) / Math.sqrt((1+ecce) / (1-ecce))));
            
            r[0] = sema * (1 - ecce * cosE);
            
            r[1] = Math.sqrt(sl.square_sum(xx[i]));
            
            for (j = 0; j <= 2; j++) {
                xx[i][j] *= r[0] / r[1];
            }
        }
        
        for (i = 0; i <= 2; i++) {
            
            ndap.x[i] = xxa[2][i];
            if ((iflag & SweConst.SEFLG_SPEED)!=0) {
                ndap.x[i+3] = (xxa[1][i] - xxa[0][i]) / speed_intv / 2;
            } else {
                ndap.x[i+3] = 0;
            }
            ndap.teval = tjd;
            ndap.iephe = epheflag;
            
            ndnp.x[i] = xx[2][i];
            if ((iflag & SweConst.SEFLG_SPEED)!=0) {
                ndnp.x[i+3] = (xx[1][i] - xx[0][i]) / speed_intv / 2;
            } else {
                ndnp.x[i+3] = 0;
            }
        }
        
        double[] x=new double[6];
        for (j = 0; j <= 1; j++) {
            if (j == 0) {
                ndp = swed.nddat[SwephData.SEI_TRUE_NODE];
            } else {
                ndp = swed.nddat[SwephData.SEI_OSCU_APOG];
            }
            //  memset((void *) ndp.xreturn, 0, 24 * sizeof(double));
            for (int z=0; z<ndp.xreturn.length; z++) { ndp.xreturn[z]=0.0; }
            
            for (i = 0; i <= 5; i++) {
                ndp.xreturn[6+i] = ndp.x[i];
            }
            
            sl.swi_cartpol_sp(ndp.xreturn, 6, ndp.xreturn, 0);
            
            sl.swi_coortrf2(ndp.xreturn, 6, ndp.xreturn, 18, -oe.seps, oe.ceps);
            if ((iflag & SweConst.SEFLG_SPEED)!=0) {
                sl.swi_coortrf2(ndp.xreturn, 9, ndp.xreturn, 21, -oe.seps, oe.ceps);
            }
            if ((iflag & SweConst.SEFLG_NONUT) == 0) {
                sl.swi_coortrf2(ndp.xreturn, 18, ndp.xreturn, 18, -swed.nut.snut,
                                swed.nut.cnut);
                if ((iflag & SweConst.SEFLG_SPEED)!=0) {
                    sl.swi_coortrf2(ndp.xreturn, 21, ndp.xreturn, 21, -swed.nut.snut,
                                    swed.nut.cnut);
                }
            }
            
            sl.swi_cartpol_sp(ndp.xreturn, 18, ndp.xreturn, 12);
            ndp.xflgs = iflag;
            ndp.iephe = iflag & SweConst.SEFLG_EPHMASK;
            if ((iflag & SweConst.SEFLG_SIDEREAL)!=0) {
                
                
                if ((swed.sidd.sid_mode & SweConst.SE_SIDBIT_ECL_T0)!=0
                    || (swed.sidd.sid_mode & SweConst.SE_SIDBIT_SSY_PLANE)!=0) {
                    for (i = 0; i <= 5; i++) {
                        x[i] = ndp.xreturn[18+i];
                    }
                    
                    if ((iflag & SweConst.SEFLG_NONUT)==0) {
                        swi_nutate(x, 0, iflag, true);
                    }
                    
                    sl.swi_precess(x, tjd, SwephData.J_TO_J2000);
                    if ((iflag & SweConst.SEFLG_SPEED)!=0) {
                        swi_precess_speed(x, tjd, SwephData.J_TO_J2000);
                    }
                    if ((swed.sidd.sid_mode & SweConst.SE_SIDBIT_ECL_T0)!=0) {
                        swi_trop_ra2sid_lon(x, ndp.xreturn, 6, ndp.xreturn, 18, iflag,
                                            null);
                        
                    } else if ((swed.sidd.sid_mode & SweConst.SE_SIDBIT_SSY_PLANE)!=0) {
                        swi_trop_ra2sid_lon_sosy(x, ndp.xreturn, 6, ndp.xreturn, 18, iflag,
                                                 null);
                    }
                    
                    sl.swi_cartpol_sp(ndp.xreturn, 6, ndp.xreturn, 0);
                    sl.swi_cartpol_sp(ndp.xreturn, 18, ndp.xreturn, 12);
                    
                } else {
                    sl.swi_cartpol_sp(ndp.xreturn, 6, ndp.xreturn, 0);
                    ndp.xreturn[0] -= swe_get_ayanamsa(ndp.teval) * SwissData.DEGTORAD;
                    sl.swi_polcart_sp(ndp.xreturn, 0, ndp.xreturn, 6);
                }
            } else if ((iflag & SweConst.SEFLG_J2000)!=0) {
                
                for (i = 0; i <= 5; i++) {
                    x[i] = ndp.xreturn[18+i];
                }
                
                sl.swi_precess(x, tjd, SwephData.J_TO_J2000);
                if ((iflag & SweConst.SEFLG_SPEED)!=0) {
                    swi_precess_speed(x, tjd, SwephData.J_TO_J2000);
                }
                for (i = 0; i <= 5; i++) {
                    ndp.xreturn[18+i] = x[i];
                }
                sl.swi_cartpol_sp(ndp.xreturn, 18, ndp.xreturn, 12);
                sl.swi_coortrf2(ndp.xreturn, 18, ndp.xreturn, 6, swed.oec2000.seps,
                                swed.oec2000.ceps);
                if ((iflag & SweConst.SEFLG_SPEED)!=0) {
                    sl.swi_coortrf2(ndp.xreturn, 21, ndp.xreturn, 9, swed.oec2000.seps,
                                    swed.oec2000.ceps);
                }
                sl.swi_cartpol_sp(ndp.xreturn, 6, ndp.xreturn, 0);
            }
            
            
            for (i = 0; i < 2; i++) {
                ndp.xreturn[i] *= SwissData.RADTODEG;              
                ndp.xreturn[i+3] *= SwissData.RADTODEG;
                ndp.xreturn[i+12] *= SwissData.RADTODEG;   
                ndp.xreturn[i+15] *= SwissData.RADTODEG;
            }
            ndp.xreturn[0] = sl.swe_degnorm(ndp.xreturn[0]);
            ndp.xreturn[12] = sl.swe_degnorm(ndp.xreturn[12]);
            
        }
        return SweConst.OK;
    }
     
    private int intp_apsides(double tjd, int ipl, int iflag, StringBuffer serr) {
        int i;
        int flg1, flg2;
        PlanData ndp;
        Epsilon oe;
        Nut nut;
        double speed_intv = 0.1;
        double t, dt;
        double xpos[][] = new double[3][6], xx[] = new double[6], x[] = new double[6];
        int speedf1, speedf2;
        oe = swed.oec;
        nut = swed.nut;
        ndp = swed.nddat[ipl];
        
        flg1 = iflag & ~SweConst.SEFLG_EQUATORIAL & ~SweConst.SEFLG_XYZ;
        flg2 = ndp.xflgs & ~SweConst.SEFLG_EQUATORIAL & ~SweConst.SEFLG_XYZ;
        speedf1 = ndp.xflgs & SweConst.SEFLG_SPEED;
        speedf2 = iflag & SweConst.SEFLG_SPEED;
        if (tjd == ndp.teval 
            && tjd != 0 
            && flg1 == flg2
            && ((speedf2==0) || (speedf1!=0))) {
            ndp.xflgs = iflag;
            ndp.iephe = iflag & SweConst.SEFLG_MOSEPH;
            return SweConst.OK;
        }
        
        for (t = tjd - speed_intv, i = 0; i < 3; t += speed_intv, i++) {
            if ( ((iflag & SweConst.SEFLG_SPEED)==0) && i != 1) continue;
            sm.swi_intp_apsides(t, xpos[i], ipl);
        }
        
        for (i = 0; i < 3; i++) {
            xx[i] = xpos[1][i];
            xx[i+3] = 0;
        }
        if ((iflag & SweConst.SEFLG_SPEED) != 0) {
            xx[3] = sl.swe_difrad2n(xpos[2][0], xpos[0][0]) / speed_intv / 2.0;
            xx[4] = (xpos[2][1] - xpos[0][1]) / speed_intv / 2.0;
            xx[5] = (xpos[2][2] - xpos[0][2]) / speed_intv / 2.0;
        }
        // memset((void *) ndp.xreturn, 0, 24 * sizeof(double));
        for(int p=0;p<24;p++) { ndp.xreturn[p]=0.; }
        
        sl.swi_polcart_sp(xx, xx);
        
        if ((iflag & SweConst.SEFLG_TRUEPOS) == 0) {
            dt = Math.sqrt(sl.square_sum(xx)) * SweConst.AUNIT / SwephData.CLIGHT / 86400.0;     
            for (i = 1; i < 3; i++)
                xx[i] -= dt * xx[i+3];
        }
        for (i = 0; i <= 5; i++) {
            ndp.xreturn[i+6] = xx[i];
        }
        
        
        sl.swi_coortrf2(ndp.xreturn, 6, ndp.xreturn, 18, -oe.seps, oe.ceps);
        if ((iflag & SweConst.SEFLG_SPEED) != 0)
            sl.swi_coortrf2(ndp.xreturn, 9, ndp.xreturn, 21, -oe.seps, oe.ceps);
        ndp.teval = tjd;
        ndp.xflgs = iflag;
        ndp.iephe = iflag & SweConst.SEFLG_EPHMASK;
        if ((iflag & SweConst.SEFLG_SIDEREAL) != 0) {
            
            
            if ((swed.sidd.sid_mode & SweConst.SE_SIDBIT_ECL_T0) != 0
                || (swed.sidd.sid_mode & SweConst.SE_SIDBIT_SSY_PLANE) != 0) {
                for (i = 0; i <= 5; i++)
                    x[i] = ndp.xreturn[18+i];
                
                sl.swi_precess(x, tjd, SwephData.J_TO_J2000);
                if ((iflag & SweConst.SEFLG_SPEED) != 0)
                    swi_precess_speed(x, tjd, SwephData.J_TO_J2000);
                if ((swed.sidd.sid_mode & SweConst.SE_SIDBIT_ECL_T0) != 0) 
                    swi_trop_ra2sid_lon(x, ndp.xreturn, 6, ndp.xreturn, 18, iflag, null);
                
                else if ((swed.sidd.sid_mode & SweConst.SE_SIDBIT_SSY_PLANE) != 0)
                    swi_trop_ra2sid_lon_sosy(x, ndp.xreturn, 6, ndp.xreturn, 18, iflag, null);
                
                sl.swi_cartpol_sp(ndp.xreturn, 6, ndp.xreturn, 0);
                sl.swi_cartpol_sp(ndp.xreturn, 18, ndp.xreturn, 12);
            } else {
                
                sl.swi_cartpol_sp(ndp.xreturn, 6, ndp.xreturn, 0); 
                ndp.xreturn[0] -= swe_get_ayanamsa(ndp.teval) * SwissData.DEGTORAD;
                sl.swi_polcart_sp(ndp.xreturn, 0, ndp.xreturn, 6); 
                sl.swi_cartpol_sp(ndp.xreturn, 18, ndp.xreturn, 12);
            }
        } else if ((iflag & SweConst.SEFLG_J2000) != 0) {
            
            for (i = 0; i <= 5; i++)
                x[i] = ndp.xreturn[18+i];
            
            sl.swi_precess(x, tjd, SwephData.J_TO_J2000);
            if ((iflag & SweConst.SEFLG_SPEED) != 0)
                swi_precess_speed(x, tjd, SwephData.J_TO_J2000);
            for (i = 0; i <= 5; i++)
                ndp.xreturn[18+i] = x[i];
            sl.swi_cartpol_sp(ndp.xreturn, 18, ndp.xreturn, 12);
            sl.swi_coortrf2(ndp.xreturn, 18, ndp.xreturn, 6, swed.oec2000.seps, swed.oec2000.ceps);
            if ((iflag & SweConst.SEFLG_SPEED) != 0)
                sl.swi_coortrf2(ndp.xreturn, 21, ndp.xreturn, 9, swed.oec2000.seps, swed.oec2000.ceps);
            sl.swi_cartpol_sp(ndp.xreturn, 6, ndp.xreturn, 0);
        } else {
            
            
            if ((iflag & SweConst.SEFLG_NONUT) == 0) {
                swi_nutate(ndp.xreturn, 18, iflag, false);
            }
            
            sl.swi_cartpol_sp(ndp.xreturn, 18, ndp.xreturn, 12);
            
            sl.swi_coortrf2(ndp.xreturn, 18, ndp.xreturn, 6, oe.seps, oe.ceps);
            if ((iflag & SweConst.SEFLG_SPEED) != 0)
                sl.swi_coortrf2(ndp.xreturn, 21, ndp.xreturn, 9, oe.seps, oe.ceps);
            if ((iflag & SweConst.SEFLG_NONUT) == 0) {
                sl.swi_coortrf2(ndp.xreturn, 6, ndp.xreturn, 6, nut.snut, nut.cnut);
                if ((iflag & SweConst.SEFLG_SPEED) != 0)
                    sl.swi_coortrf2(ndp.xreturn, 9, ndp.xreturn, 9, nut.snut, nut.cnut);
            }
            
            sl.swi_cartpol_sp(ndp.xreturn, 6, ndp.xreturn, 0);
        }
        
        
        for (i = 0; i < 2; i++) {
            ndp.xreturn[i] *= SwissData.RADTODEG;		
            ndp.xreturn[i+3] *= SwissData.RADTODEG;
            ndp.xreturn[i+12] *= SwissData.RADTODEG;	
            ndp.xreturn[i+15] *= SwissData.RADTODEG;
        }
        ndp.xreturn[0] = sl.swe_degnorm(ndp.xreturn[0]);
        ndp.xreturn[12] = sl.swe_degnorm(ndp.xreturn[12]);
        
        return SweConst.OK;
    }
  
    
    int swi_plan_for_osc_elem(int iflag, double tjd, double xx[]) {
        int i;
        double x[]=new double[6];
        Nut nuttmp=new Nut();
        Nut nutp = nuttmp;   
        Epsilon oe = swed.oec;
        Epsilon oectmp=new Epsilon();
        
        if ((iflag & SweConst.SEFLG_ICRS)==0 && swed.jpldenum >= 403) {
            sl.swi_bias(xx, iflag, false);
        }
        
        sl.swi_precess(xx, tjd, SwephData.J2000_TO_J);
        sl.swi_precess(xx, 3, tjd, SwephData.J2000_TO_J);
        
        if (tjd == swed.oec.teps) {
            oe = swed.oec;
        } else if (tjd == SwephData.J2000) {
            oe = swed.oec2000;
        } else {
            calc_epsilon(tjd, oectmp);
            oe = oectmp;
        }
        
        if ((iflag & SweConst.SEFLG_NONUT) == 0) {
            if (tjd == swed.nut.tnut) {
                nutp = swed.nut;
            } else if (tjd == SwephData.J2000) {
                nutp = swed.nut2000;
            } else if (tjd == swed.nutv.tnut) {
                nutp = swed.nutv;
            } else {
                nutp = nuttmp;
                sl.swi_nutation(tjd, nutp.nutlo);
                nutp.tnut = tjd;
                nutp.snut = Math.sin(nutp.nutlo[1]);
                nutp.cnut = Math.cos(nutp.nutlo[1]);
                nut_matrix(nutp, oe);
            }
            for (i = 0; i <= 2; i++) {
                x[i] = xx[0] * nutp.matrix[0][i] +
                    xx[1] * nutp.matrix[1][i] +
                    xx[2] * nutp.matrix[2][i];
            }
            
            for (i = 0; i <= 2; i++) {
                x[i+3] = xx[3] * nutp.matrix[0][i] +
                    xx[4] * nutp.matrix[1][i] +
                    xx[5] * nutp.matrix[2][i];
            }
            for (i = 0; i <= 5; i++) {
                xx[i] = x[i];
            }
        }
        
        sl.swi_coortrf2(xx, xx, oe.seps, oe.ceps);
        sl.swi_coortrf2(xx, 3, xx, 3, oe.seps, oe.ceps);
        if ((iflag & SweConst.SEFLG_NONUT) == 0) {
            sl.swi_coortrf2(xx, xx, nutp.snut, nutp.cnut);
            sl.swi_coortrf2(xx, 3, xx, 3, nutp.snut, nutp.cnut);
        }
        return SweConst.OK;
    }
    static final MeffEle eff_arr[] = {
        
        new MeffEle(1.000, 1.000000),
        new MeffEle(0.990, 0.999979),
        new MeffEle(0.980, 0.999940),
        new MeffEle(0.970, 0.999881),
        new MeffEle(0.960, 0.999811),
        new MeffEle(0.950, 0.999724),
        new MeffEle(0.940, 0.999622),
        new MeffEle(0.930, 0.999497),
        new MeffEle(0.920, 0.999354),
        new MeffEle(0.910, 0.999192),
        new MeffEle(0.900, 0.999000),
        new MeffEle(0.890, 0.998786),
        new MeffEle(0.880, 0.998535),
        new MeffEle(0.870, 0.998242),
        new MeffEle(0.860, 0.997919),
        new MeffEle(0.850, 0.997571),
        new MeffEle(0.840, 0.997198),
        new MeffEle(0.830, 0.996792),
        new MeffEle(0.820, 0.996316),
        new MeffEle(0.810, 0.995791),
        new MeffEle(0.800, 0.995226),
        new MeffEle(0.790, 0.994625),
        new MeffEle(0.780, 0.993991),
        new MeffEle(0.770, 0.993326),
        new MeffEle(0.760, 0.992598),
        new MeffEle(0.750, 0.991770),
        new MeffEle(0.740, 0.990873),
        new MeffEle(0.730, 0.989919),
        new MeffEle(0.720, 0.988912),
        new MeffEle(0.710, 0.987856),
        new MeffEle(0.700, 0.986755),
        new MeffEle(0.690, 0.985610),
        new MeffEle(0.680, 0.984398),
        new MeffEle(0.670, 0.982986),
        new MeffEle(0.660, 0.981437),
        new MeffEle(0.650, 0.979779),
        new MeffEle(0.640, 0.978024),
        new MeffEle(0.630, 0.976182),
        new MeffEle(0.620, 0.974256),
        new MeffEle(0.610, 0.972253),
        new MeffEle(0.600, 0.970174),
        new MeffEle(0.590, 0.968024),
        new MeffEle(0.580, 0.965594),
        new MeffEle(0.570, 0.962797),
        new MeffEle(0.560, 0.959758),
        new MeffEle(0.550, 0.956515),
        new MeffEle(0.540, 0.953088),
        new MeffEle(0.530, 0.949495),
        new MeffEle(0.520, 0.945741),
        new MeffEle(0.510, 0.941838),
        new MeffEle(0.500, 0.937790),
        new MeffEle(0.490, 0.933563),
        new MeffEle(0.480, 0.928668),
        new MeffEle(0.470, 0.923288),
        new MeffEle(0.460, 0.917527),
        new MeffEle(0.450, 0.911432),
        new MeffEle(0.440, 0.905035),
        new MeffEle(0.430, 0.898353),
        new MeffEle(0.420, 0.891022),
        new MeffEle(0.410, 0.882940),
        new MeffEle(0.400, 0.874312),
        new MeffEle(0.390, 0.865206),
        new MeffEle(0.380, 0.855423),
        new MeffEle(0.370, 0.844619),
        new MeffEle(0.360, 0.833074),
        new MeffEle(0.350, 0.820876),
        new MeffEle(0.340, 0.808031),
        new MeffEle(0.330, 0.793962),
        new MeffEle(0.320, 0.778931),
        new MeffEle(0.310, 0.763021),
        new MeffEle(0.300, 0.745815),
        new MeffEle(0.290, 0.727557),
        new MeffEle(0.280, 0.708234),
        new MeffEle(0.270, 0.687583),
        new MeffEle(0.260, 0.665741),
        new MeffEle(0.250, 0.642597),
        new MeffEle(0.240, 0.618252),
        new MeffEle(0.230, 0.592586),
        new MeffEle(0.220, 0.565747),
        new MeffEle(0.210, 0.537697),
        new MeffEle(0.200, 0.508554),
        new MeffEle(0.190, 0.478420),
        new MeffEle(0.180, 0.447322),
        new MeffEle(0.170, 0.415454),
        new MeffEle(0.160, 0.382892),
        new MeffEle(0.150, 0.349955),
        new MeffEle(0.140, 0.316691),
        new MeffEle(0.130, 0.283565),
        new MeffEle(0.120, 0.250431),
        new MeffEle(0.110, 0.218327),
        new MeffEle(0.100, 0.186794),
        new MeffEle(0.090, 0.156287),
        new MeffEle(0.080, 0.128421),
        new MeffEle(0.070, 0.102237),
        new MeffEle(0.060, 0.077393),
        new MeffEle(0.050, 0.054833),
        new MeffEle(0.040, 0.036361),
        new MeffEle(0.030, 0.020953),
        new MeffEle(0.020, 0.009645),
        new MeffEle(0.010, 0.002767),
        new MeffEle(0.000, 0.000000)
    };
    double meff(double r) {
        double f, m;
        int i;
        if (r <= 0) {
            return 0.0;
        } else if (r >= 1) {
            return 1.0;
        }
        for (i = 0; eff_arr[i].r > r; i++) {
            ; 
        }
        f = (r - eff_arr[i-1].r) / (eff_arr[i].r - eff_arr[i-1].r);
        m = eff_arr[i-1].m + f * (eff_arr[i].m - eff_arr[i-1].m);
        return m;
    }
    // Only used with SEFLG_SPEED3
    void denormalize_positions(double[] x0, double[] x1, double[] x2) {
        int i;
        
        for (i = 0; i <= 12; i += 12) {
            if (x1[i] - x0[i] < -180) {
                x0[i] -= 360;
            }
            if (x1[i] - x0[i] > 180) {
                x0[i] += 360;
            }
            if (x1[i] - x2[i] < -180) {
                x2[i] -= 360;
            }
            if (x1[i] - x2[i] > 180) {
                x2[i] += 360;
            }
        }
    }
    // Only used with SEFLG_SPEED3
    void calc_speed(double[] x0, double[] x1, double[] x2, double dt) {
        int i, j, k;
        double a, b;
        for (j = 0; j <= 18; j += 6) {
            for (i = 0; i < 3; i++) {
                k = j + i;
                b = (x2[k] - x0[k]) / 2;
                a = (x2[k] + x0[k]) / 2 - x1[k];
                x1[k+3] = (2 * a + b) / dt;
            }
        }
    }
    void swi_check_ecliptic(double tjd) {
        if (swed.oec2000.teps != SwephData.J2000) {
            calc_epsilon(SwephData.J2000, swed.oec2000);
        }
        if (tjd == SwephData.J2000) {
            swed.oec.teps = swed.oec2000.teps;
            swed.oec.eps = swed.oec2000.eps;
            swed.oec.seps = swed.oec2000.seps;
            swed.oec.ceps = swed.oec2000.ceps;
            return;
        }
        if (swed.oec.teps != tjd || tjd == 0) {
            calc_epsilon(tjd, swed.oec);
        }
    }
    
    int chck_nut_nutflag = 0;
    void swi_check_nutation(double tjd, int iflag) {
        int speedf1, speedf2;
        double t;
        speedf1 = chck_nut_nutflag & SweConst.SEFLG_SPEED;
        speedf2 = iflag & SweConst.SEFLG_SPEED;
        if ((iflag & SweConst.SEFLG_NONUT) == 0
            && (tjd != swed.nut.tnut || tjd == 0
                || ((speedf1==0) && (speedf2!=0)))) {
            sl.swi_nutation(tjd, swed.nut.nutlo);
            swed.nut.tnut = tjd;
            swed.nut.snut = Math.sin(swed.nut.nutlo[1]);
            swed.nut.cnut = Math.cos(swed.nut.nutlo[1]);
            chck_nut_nutflag = iflag;
            nut_matrix(swed.nut, swed.oec);
            if ((iflag & SweConst.SEFLG_SPEED)!=0) {
                
                t = tjd - SwephData.NUT_SPEED_INTV;
                sl.swi_nutation(t, swed.nutv.nutlo);
                swed.nutv.tnut = t;
                swed.nutv.snut = Math.sin(swed.nutv.nutlo[1]);
                swed.nutv.cnut = Math.cos(swed.nutv.nutlo[1]);
                nut_matrix(swed.nutv, swed.oec);
            }
        }
    }
    int plaus_iflag(int iflag) {
        int epheflag = 0;
        
        if ((iflag & SweConst.SEFLG_TOPOCTR)!=0) {
            iflag = iflag & ~(SweConst.SEFLG_HELCTR | SweConst.SEFLG_BARYCTR);
        }
        
        if ((iflag & SweConst.SEFLG_HELCTR)!=0) {
            iflag |= SweConst.SEFLG_NOABERR | SweConst.SEFLG_NOGDEFL;
            
        }
        
        if ((iflag & SweConst.SEFLG_BARYCTR)!=0) {
            iflag |= SweConst.SEFLG_NOABERR | SweConst.SEFLG_NOGDEFL;
            
        }
        
        if ((iflag & SweConst.SEFLG_J2000)!=0) {
            iflag |= SweConst.SEFLG_NONUT;
        }
        
        if ((iflag & SweConst.SEFLG_TRUEPOS)!=0) {
            iflag |= (SweConst.SEFLG_NOGDEFL | SweConst.SEFLG_NOABERR);
        }
        
        if ((iflag & SweConst.SEFLG_SIDEREAL)!=0) {
            iflag |= SweConst.SEFLG_NONUT;
        }
        if ((iflag & SweConst.SEFLG_MOSEPH)!=0) {
            epheflag = SweConst.SEFLG_MOSEPH;
        }
        if ((iflag & SweConst.SEFLG_SWIEPH)!=0) {
            epheflag = SweConst.SEFLG_SWIEPH;
        }
        if ((iflag & SweConst.SEFLG_JPLEPH)!=0) {
            epheflag = SweConst.SEFLG_JPLEPH;
        }
        if (epheflag == 0) {
            epheflag = SweConst.SEFLG_DEFAULTEPH;
        }
        
        iflag = (iflag & ~SweConst.SEFLG_EPHMASK) | epheflag;
        return iflag;
    }
    int swe_fixstar_found(StringBuffer serr, String s, StringBuffer star,
                          double tjd, int iflag, int iflgsave, int epheflag,
                          double[] xx) {
        double xpo[] = null;
        double ra_s, ra_pm, de_pm, ra, de, t, cosra, cosde, sinra, sinde;
        double ra_h, ra_m, de_d, de_m, de_s;
        String sde_d;
        double epoch, radv, parall, u;
        double x[]=new double[6];
        double xxsv[]=new double[6];
        double xobs[]=new double[6];
        int retc;
        PlanData pedp = swed.pldat[SwephData.SEI_EARTH];
        PlanData psdp = swed.pldat[SwephData.SEI_SUNBARY];
        Epsilon oe = swed.oec2000;
        String[] cpos=new String[20];
        StringTokenizer tk= "**********"
        int i= "**********"
        int n=0;
        while(tk.hasMoreTokens() && n<20) {
            cpos[n++]= "**********"
        }
        cpos[0]=cpos[0].trim();
        cpos[1]=cpos[1].trim();
        if (i < 13) {
            if (serr!=null) {
                serr.setLength(0);
                serr.append("data of star '"+cpos[0]+","+cpos[1]+"' incomplete");
            }
            return swe_fixstar_error(xx,SweConst.ERR);
        }
        // JAVA: Grrr: zumindest cpos[2] muss keine Zahl sein, aber es FAENGT
        // moeglicherweise mit einer Zahl AN!!!
        int idx=cpos[2].length();
        while(true) {
            try {
                epoch = Double.valueOf(cpos[2].substring(0,idx)).doubleValue();
                break;
            } catch (NumberFormatException nf) {
                idx--;
                if (idx==0) { epoch=0.; break; }
            }
        }
        ra_h = new Double(cpos[3]).doubleValue();
        ra_m = new Double(cpos[4]).doubleValue();
        ra_s = new Double(cpos[5]).doubleValue();
        de_d = new Double(cpos[6]).doubleValue();
        sde_d = cpos[6];
        de_m = new Double(cpos[7]).doubleValue();
        de_s = new Double(cpos[8]).doubleValue();
        ra_pm = new Double(cpos[9]).doubleValue();
        de_pm = new Double(cpos[10]).doubleValue();
        radv = new Double(cpos[11]).doubleValue();
        parall = new Double(cpos[12]).doubleValue();
        
        if (cpos[0].length() > SweConst.SE_MAX_STNAME) {
            cpos[0]=cpos[0].substring(0,SweConst.SE_MAX_STNAME);
        }
        if (cpos[1].length() > SweConst.SE_MAX_STNAME-1) {
            cpos[1]=cpos[1].substring(0,SweConst.SE_MAX_STNAME-1);
        }
        star.setLength(0);
        star.append(cpos[0]+","+cpos[1]);
        
        
        ra = (ra_s / 3600.0 + ra_m / 60.0 + ra_h) * 15.0;
        if (sde_d.indexOf('-') < 0) {
            de = de_s / 3600.0 + de_m / 60.0 + de_d;
        } else {
            de = -de_s / 3600.0 - de_m / 60.0 + de_d;
        }
        
        ra_pm = ra_pm * 15 / 3600.0;
        de_pm /= 3600.0;
        
        if (parall > 1) {
            parall = (1 / parall / 3600);
        } else {
            parall /= 3600;
        }
        
        radv *= SwephData.KM_S_TO_AU_CTY;
        
        ra *= SwissData.DEGTORAD;
        de *= SwissData.DEGTORAD;
        ra_pm *= SwissData.DEGTORAD;
        de_pm *= SwissData.DEGTORAD;
        parall *= SwissData.DEGTORAD;
        x[0] = ra;
        x[1] = de;
        x[2] = 1;     
        
        sl.swi_polcart(x, x);
        
        cosra = Math.cos(ra);
        cosde = Math.cos(de);
        sinra = Math.sin(ra);
        sinde = Math.sin(de);
        x[3] = -ra_pm * cosde * sinra - de_pm * sinde * cosra
            + radv * parall * cosde * cosra;
        x[4] = ra_pm * cosde * cosra - de_pm * sinde * sinra
            + radv * parall * cosde * sinra;
        x[5] = de_pm * cosde + radv * parall * sinde;
        x[3] /= 36525;
        x[4] /= 36525;
        x[5] /= 36525;
        
        if (epoch == 1950) {
            sl.swi_FK4_FK5(x, SwephData.B1950);
            sl.swi_precess(x, SwephData.B1950, SwephData.J_TO_J2000);
            sl.swi_precess(x, 3, SwephData.B1950, SwephData.J_TO_J2000);
        }
        
        if (epoch != 0) {
            sl.swi_icrs2fk5(x, iflag, true);
            
            if (swed.jpldenum < 403)
                sl.swi_bias(x, iflag, false);
        }
        
        retc = main_planet(tjd, SwephData.SEI_EARTH, epheflag, iflag, serr);
        if (retc != SweConst.OK) {
            return swe_fixstar_error(xx,SweConst.ERR);
        }
        
        iflag = swed.pldat[SwephData.SEI_EARTH].xflgs;
        
        
        if ((iflag & SweConst.SEFLG_TOPOCTR)!=0) {
            if (swed.topd.teval != pedp.teval
                || swed.topd.teval == 0) {
                if (swi_get_observer(pedp.teval, iflag, SwephData.DO_SAVE, xobs, serr)!=
                    SweConst.OK) {
                    return SweConst.ERR;
                }
            } else {
                for (i = 0; i <= 5; i++) {
                    xobs[i] = swed.topd.xobs[i];
                }
            }
            
            for (i = 0; i <= 5; i++) {
                xobs[i] = xobs[i] + pedp.x[i];
            }
        } else {
            
            for (i = 0; i <= 5; i++) {
                xobs[i] = pedp.x[i];
            }
        }
        
        if (epoch == 1950) {
            t= (tjd - SwephData.B1950);   
        } else { 
            t= (tjd - SwephData.J2000);   
        }
        
        if ((iflag & SweConst.SEFLG_HELCTR)!=0 &&
            (iflag & SweConst.SEFLG_MOSEPH)!=0) {
            xpo = null;         
        } else if ((iflag & SweConst.SEFLG_HELCTR)!=0) {
            xpo = psdp.x;
        } else if ((iflag & SweConst.SEFLG_BARYCTR)!=0) {
            xpo = null;         
        } else {
            xpo = xobs;
        }
        if (xpo == null) {
            for (i = 0; i <= 2; i++) {
                x[i] += t * x[i+3];
            }
        } else {
            for (i = 0; i <= 2; i++) {
                x[i] += t * x[i+3] - parall * xpo[i];
                x[i+3] -= parall * xpo[i+3];
            }
        }
        
        for (i = 0; i <= 5; i++) {
            x[i] *= 10000;      
        }
        if ((iflag & SweConst.SEFLG_TRUEPOS) == 0 &&
            (iflag & SweConst.SEFLG_NOGDEFL) == 0) {
            swi_deflect_light(x, 0, 0, iflag & SweConst.SEFLG_SPEED);
        }
        
        if ((iflag & SweConst.SEFLG_TRUEPOS) == 0 &&
            (iflag & SweConst.SEFLG_NOABERR) == 0) {
            swi_aberr_light(x, xpo, iflag & SweConst.SEFLG_SPEED);
        }
        
        if ((iflag & SweConst.SEFLG_ICRS) == 0 && swed.jpldenum >= 403) {
            sl.swi_bias(x, iflag, false);
        }
        
        for (i = 0; i <= 5; i++) {
            xxsv[i] = x[i];
        }
        
        
        if ((iflag & SweConst.SEFLG_J2000) == 0) {
            sl.swi_precess(x, tjd, SwephData.J2000_TO_J);
            if ((iflag & SweConst.SEFLG_SPEED)!=0) {
                swi_precess_speed(x, tjd, SwephData.J2000_TO_J);
            }
            oe = swed.oec;
        } else {
            oe = swed.oec2000;
        }
        
        if ((iflag & SweConst.SEFLG_NONUT) == 0) {
            swi_nutate(x, 0, 0, false);
        }
        
        u = Math.sqrt(sl.square_sum(x));
        for (i = 0; i <= 5; i++) {
            x[i] /= u;
        }
        u = Math.sqrt(sl.square_sum(xxsv));
        for (i = 0; i <= 5; i++) {
            xxsv[i] /= u;
        }
        
        for (i = 3; i <= 5; i++) {
            x[i] = xxsv[i] = 0;
        }
        
        if ((iflag & SweConst.SEFLG_EQUATORIAL) == 0) {
            sl.swi_coortrf2(x, x, oe.seps, oe.ceps);
            if ((iflag & SweConst.SEFLG_SPEED)!=0) {
                sl.swi_coortrf2(x, 3, x, 3, oe.seps, oe.ceps);
            }
            if ((iflag & SweConst.SEFLG_NONUT) == 0) {
                sl.swi_coortrf2(x, x, swed.nut.snut, swed.nut.cnut);
                if ((iflag & SweConst.SEFLG_SPEED)!=0) {
                    sl.swi_coortrf2(x, 3, x, 3, swed.nut.snut, swed.nut.cnut);
                }
            }
        }
        
        if ((iflag & SweConst.SEFLG_SIDEREAL)!=0) {
            
            if ((swed.sidd.sid_mode & SweConst.SE_SIDBIT_ECL_T0)!=0) {
                if (swi_trop_ra2sid_lon(xxsv, x, xxsv, iflag, serr) != SweConst.OK) {
                    return SweConst.ERR;
                }
                if ((iflag & SweConst.SEFLG_EQUATORIAL)!=0) {
                    for (i = 0; i <= 5; i++) {
                        x[i] = xxsv[i];
                    }
                }
                
            } else if ((swed.sidd.sid_mode & SweConst.SE_SIDBIT_SSY_PLANE)!=0) {
                if (swi_trop_ra2sid_lon_sosy(xxsv, x, xxsv, iflag, serr) !=
                    SweConst.OK) {
                    return SweConst.ERR;
                }
                if ((iflag & SweConst.SEFLG_EQUATORIAL)!=0) {
                    for (i = 0; i <= 5; i++) {
                        x[i] = xxsv[i];
                    }
                }
                
            } else {
                sl.swi_cartpol_sp(x, x);
                x[0] -= swe_get_ayanamsa(tjd) * SwissData.DEGTORAD;
                sl.swi_polcart_sp(x, x);
            }
        }
        
        if ((iflag & SweConst.SEFLG_XYZ) == 0) {
            sl.swi_cartpol_sp(x, x);
        }
        
        if ((iflag & SweConst.SEFLG_RADIANS) == 0 &&
            (iflag & SweConst.SEFLG_XYZ) == 0) {
            for (i = 0; i < 2; i++) {
                x[i] *= SwissData.RADTODEG;
                x[i+3] *= SwissData.RADTODEG;
            }
        }
        for (i = 0; i <= 5; i++) {
            xx[i] = x[i];
        }
        
        if ((iflgsave & SweConst.SEFLG_EPHMASK) == 0) {
            iflag = iflag & ~SweConst.SEFLG_DEFAULTEPH;
        }
        iflag = iflag & ~SweConst.SEFLG_SPEED;
        return iflag;
    }
    int swe_fixstar_error(double[] xx, int retc) {
        for (int i = 0; i <= 5; i++) {
            xx[i] = 0;
        }
        return retc;
    }
    void swi_force_app_pos_etc() {
        int i;
        for (i = 0; i < SwephData.SEI_NPLANETS; i++) {
            swed.pldat[i].xflgs = -1;
        }
        for (i = 0; i < SwephData.SEI_NNODE_ETC; i++) {
            swed.nddat[i].xflgs = -1;
        }
        for (i = 0; i < SweConst.SE_NPLANETS; i++) {
            swed.savedat[i].tsave = 0;
            swed.savedat[i].iflgsave = -1;
        }
    }
    int swi_get_observer(double tjd, int iflag, boolean do_save, double xobs[],
                         StringBuffer serr) {
        int i;
        double sidt, delt, tjd_ut, eps, nut, nutlo[]=new double[2];
        double f = SwephData.EARTH_OBLATENESS;
        double re = SwephData.EARTH_RADIUS;
        double cosfi, sinfi, cc, ss, cosl, sinl, h;
        if (!swed.geopos_is_set) {
            if (serr != null) {
                serr.setLength(0);
                serr.append("geographic position has not been set");
            }
            return SweConst.ERR;
        }
        
        delt = SweDate.getDeltaT(tjd);
        tjd_ut = tjd - delt;
        if (swed.oec.teps == tjd && swed.nut.tnut == tjd) {
            eps = swed.oec.eps;
            nutlo[1] = swed.nut.nutlo[1];
            nutlo[0] = swed.nut.nutlo[0];
        } else {
            eps = sl.swi_epsiln(tjd);
            if ((iflag & SweConst.SEFLG_NONUT)==0) {
                sl.swi_nutation(tjd, nutlo);
            }
        }
        if ((iflag & SweConst.SEFLG_NONUT)!=0) {
            nut = 0;
        } else {
            eps += nutlo[1];
            nut = nutlo[0];
        }
        
        sidt = sl.swe_sidtime0(tjd_ut, eps, nut);
        sidt *= 15;   
        
        cosfi = Math.cos(swed.topd.geolat * SwissData.DEGTORAD);
        sinfi = Math.sin(swed.topd.geolat * SwissData.DEGTORAD);
        cc= 1 / Math.sqrt(cosfi * cosfi + (1-f) * (1-f) * sinfi * sinfi);
        ss= (1-f) * (1-f) * cc;
        
        
        
        cosl = Math.cos((swed.topd.geolon + sidt) * SwissData.DEGTORAD);
        sinl = Math.sin((swed.topd.geolon + sidt) * SwissData.DEGTORAD);
        h = swed.topd.geoalt;
        xobs[0] = (re * cc + h) * cosfi * cosl;
        xobs[1] = (re * cc + h) * cosfi * sinl;
        xobs[2] = (re * ss + h) * sinfi;
        
        sl.swi_cartpol(xobs, xobs);
        
        xobs[3] = SwephData.EARTH_ROT_SPEED;
        xobs[4] = xobs[5] = 0;
        sl.swi_polcart_sp(xobs, xobs);
        
        for (i = 0; i <= 5; i++) {
            xobs[i] /= SweConst.AUNIT;
        }
        
        if ((iflag & SweConst.SEFLG_NONUT)==0) {
            sl.swi_coortrf2(xobs, xobs, -swed.nut.snut, swed.nut.cnut);
            if ((iflag & SweConst.SEFLG_SPEED)!=0) {
                sl.swi_coortrf2(xobs, 3, xobs, 3, -swed.nut.snut, swed.nut.cnut);
            }
            swi_nutate(xobs, 0, iflag, true);
        }
        
        sl.swi_precess(xobs, tjd, SwephData.J_TO_J2000);
        if ((iflag & SweConst.SEFLG_SPEED)!=0) {
            swi_precess_speed(xobs, tjd, SwephData.J_TO_J2000);
        }
        
        
        
        if (do_save) {
            for (i = 0; i <= 5; i++) {
                swed.topd.xobs[i] = xobs[i];
            }
            swed.topd.teval = tjd;
            swed.topd.tjd_ut = tjd_ut;  
        }
        return SweConst.OK;
    }
    
    
    public int swe_time_equ(double tjd, DblObj E, StringBuffer serr) {
        double L0, dpsi, eps, x[]=new double[6], nutlo[]=new double[2];
        double tau = (tjd - SwephData.J2000) / 365250;
        double tau2 = tau * tau;
        double tau3 = tau * tau2;
        double tau4 = tau * tau3;
        double tau5 = tau * tau4;
        L0 = 280.4664567 + sl.swe_degnorm(tau * 360007.6982779)
            + tau2 * 0.03032028
            + tau3 * 1 / 49931
            - tau4 * 1 / 15299
            - tau5 * 1 / 1988000;
        sl.swi_nutation(tjd, nutlo);
        eps = (sl.swi_epsiln(tjd) + nutlo[1]) * SwissData.RADTODEG;
        dpsi = nutlo[0] * SwissData.RADTODEG;
        if (swe_calc(tjd, SweConst.SE_SUN, SweConst.SEFLG_EQUATORIAL, x, serr) ==
            SweConst.ERR) {
            return SweConst.ERR;
        }
        E.val = sl.swe_degnorm(L0 - 0.0057183 - x[0] + dpsi *
                               Math.cos(eps * SwissData.DEGTORAD));
        if (E.val > 180) {
            E.val -= 360;
        }
        E.val *= 4 / 1440.0;
        return SweConst.OK;
    }
    double dot_prod(double x[], double y[]) {

        return x[0]*y[0]+x[1]*y[1]+x[2]*y[2];
    }
    double dot_prod(double x[], double y[], int yOffs) {

        return x[0]*y[yOffs]+x[1]*y[1+yOffs]+x[2]*y[2+yOffs];
    }
    
} // Ende class SwissEph
class MeffEle {
    double r;
    double m;
    MeffEle(double r, double m) {

        this.r=r; this.m=m;

    }
}
class SwissLib {
static final boolean PREC_WILLIAMS_1994  = true;
static final boolean PREC_SIMON_1994     = false;
static final boolean PREC_LASKAR_1986    = false;
static final boolean PREC_BRETAGNON_2003 = false;
static final boolean PREC_IAU_1976       = false;
static final boolean PREC_IAU_2003       = true;
static final boolean NUT_IAU_1980        = false;
static final boolean NUT_IAU_2000A       = false;   
static final boolean NUT_IAU_2000B       = true;  
  
  static final double PREC_IAU_1976_CTIES=2.0;
  
  
  static final double PREC_IAU_2003_CTIES=75.0;
  SwissData swed;
  // Konstruktor(en):
  public SwissLib() {
    this(null);
  }
  public SwissLib(SwissData swed) {
    this.swed=swed;
    if (this.swed ==null) { this.swed=new SwissData(); }
  }

  public double square_sum(double x[]) {

    return x[0]*x[0]+x[1]*x[1]+x[2]*x[2];
  }
  public double square_sum(double x[], int offset) {
    return x[offset]*x[offset]+x[1+offset]*x[1+offset]+x[2+offset]*x[2+offset];
  }
  
  
  public double swe_degnorm(double x) {
if (Double.doubleToLongBits(x) == 0xc11cd9d69f7e189dL) {
  x = Double.longBitsToDouble(0xc11cd9d69f7e189eL);  // Zeile 66: keine Vernderung...
} else if (Double.doubleToLongBits(x) == 0xc11d376e20594b20L) {
  x = Double.longBitsToDouble(0xc11d376e20594b21L);  // Zeile 68: keine Vernderung...
} else if (Double.doubleToLongBits(x) == 0xc11ae8edd4666694L) {
  x = Double.longBitsToDouble(0xc11ae8edd4666695L);  // Zeile 70: keine Vernderung...
} else if (Double.doubleToLongBits(x) == 0x409fe5e10f4cc528L) {
  x = Double.longBitsToDouble(0x409fe5e10f4cc527L);  // Zeile 79: keine Vernderung...
}
    double y;
    y = x%360.0;
    if (Math.abs(y) < 1e-13) {
      y = 0;   
    }
    if( y < 0.0 ) {
      y += 360.0;
    }
    return(y);
  }
  
  
  public double swe_radnorm(double x) {
    double y;
    y = x % SwephData.TWOPI;
    if (Math.abs(y) < 1e-13) {
      y = 0;   
    }
    if( y < 0.0 ) {
      y += SwephData.TWOPI;
    }
    return(y);
  }
  public double swe_deg_midp(double x1, double x0) {
    double y;
    y = swe_degnorm((x1 + x0)/2);
    return(y);
  }
  public double swe_rad_midp(double x1, double x0) {
    return SwissData.DEGTORAD * swe_deg_midp(x1 * SwissData.RADTODEG, x0 * SwissData.RADTODEG);
  }
  
  public double swi_mod2PI(double x) {
    double y;
    y = x%SwephData.TWOPI;
    if( y < 0.0 ) {
      y += SwephData.TWOPI;
    }
    return(y);
  }
  public double swi_angnorm(double x) {
    if (x < 0.0 ) {
      return x + SwephData.TWOPI;
    } else if (x >= SwephData.TWOPI) {
      return x - SwephData.TWOPI;
    } else {
      return x;
    }
  }
  public void swi_cross_prod(double a[], int aOffs, double b[], int bOffs,
                             double x[], int xOffs) {
    x[0+xOffs] = a[1+aOffs]*b[2+bOffs] - a[2+aOffs]*b[1+bOffs];
    x[1+xOffs] = a[2+aOffs]*b[0+bOffs] - a[0+aOffs]*b[2+bOffs];
    x[2+xOffs] = a[0+aOffs]*b[1+bOffs] - a[1+aOffs]*b[0+bOffs];
  }
  
  public double swi_echeb(double x, double coef[], int offs, int ncf) {
if (Double.doubleToLongBits(coef[0]) == 0xbfbf6c9bdfa87a8eL) {
  coef[0] = Double.longBitsToDouble(0xbfbf6c9bdfa87a8dL);  // Zeile 3456: keine Vernderung...
}
if (Double.doubleToLongBits(coef[5]) == 0x3FB87AA86131C716L) {
  coef[5] = Double.longBitsToDouble(0x3fb87aa86131c717L);  // Zeile 3461: keine Vernderung...
}
if (Double.doubleToLongBits(coef[6]) == 0xBF75E01D9A8A9A34L) {
  coef[6] = Double.longBitsToDouble(0xBF75E01D9A8A9A35L);  // Zeile 3462: keine Vernderung...
}
if (Double.doubleToLongBits(coef[10]) == 0x3EF5D0AE131F86EEL) {
  coef[10] = Double.longBitsToDouble(0x3EF5D0AE131F86EDL);  // Zeile 3466: keine Vernderung...
}
    int j;
    double x2, br, brp2, brpp;
    x2 = x * 2.;
    br = 0.;
    brp2 = 0.;    
    brpp = 0.;
    for (j = ncf - 1; j >= 0; j--) {
      brp2 = brpp;
      brpp = br;
      br = x2 * brpp - brp2 + coef[j+offs];
    }
    return (br - brp2) * .5;
  }
  
  public double swi_edcheb(double x, double coef[], int offs, int ncf) {
    double bjpl, xjpl;
    int j;
    double x2, bf, bj, dj, xj, bjp2, xjp2;
    x2 = x * 2.;
    bf = 0.;      
    bj = 0.;      
    xjp2 = 0.;
    xjpl = 0.;
    bjp2 = 0.;
    bjpl = 0.;
    for (j = ncf - 1; j >= 1; j--) {
      dj = (double) (j + j);
      xj = coef[j+offs] * dj + xjp2;
      bj = x2 * bjpl - bjp2 + xj;
      bf = bjp2;
      bjp2 = bjpl;
      bjpl = bj;
      xjp2 = xjpl;
      xjpl = xj;
    }
    return (bj - bf) * .5;
  }
  
  public void swe_cotrans(double xpo[],double xpn[],double eps) {
    swe_cotrans(xpo, 0, xpn, 0, eps);
  }
  public void swe_cotrans(double xpo[],int oOffs, double xpn[],
                          int nOffs, double eps) {
    int i;
    double x[]=new double[6], e = eps * SwissData.DEGTORAD;
    for(i = 0; i <= 1; i++)
      x[i] = xpo[i+oOffs];
    x[0] *= SwissData.DEGTORAD;
    x[1] *= SwissData.DEGTORAD;
    x[2] = 1;
    for(i = 3; i <= 5; i++)
      x[i] = 0;
    swi_polcart(x, x);
    swi_coortrf(x, x, e);
    swi_cartpol(x, x);
    xpn[  nOffs] = x[0] * SwissData.RADTODEG;
    xpn[1+nOffs] = x[1] * SwissData.RADTODEG;
    xpn[2+nOffs] = xpo[2+oOffs];
  }
  
  public void swe_cotrans_sp(double xpo[], double xpn[], double eps) {
    int i;
    double x[]=new double[6], e = eps * SwissData.DEGTORAD;
    for (i = 0; i <= 5; i++)
      x[i] = xpo[i];
    x[0] *= SwissData.DEGTORAD;
    x[1] *= SwissData.DEGTORAD;
    x[2] = 1;     
    x[3] *= SwissData.DEGTORAD;
    x[4] *= SwissData.DEGTORAD;
    swi_polcart_sp(x, x);
    swi_coortrf(x, x, e);
    swi_coortrf(x, 3, x, 3, e);
    swi_cartpol_sp(x, xpn);
    xpn[0] *= SwissData.RADTODEG;
    xpn[1] *= SwissData.RADTODEG;
    xpn[2] = xpo[2];
    xpn[3] *= SwissData.RADTODEG;
    xpn[4] *= SwissData.RADTODEG;
    xpn[5] = xpo[5];
  }
  
  public void swi_coortrf(double xpo[], double xpn[], double eps) {
    swi_coortrf(xpo, 0, xpn, 0, eps);
  }
  public void swi_coortrf(double xpo[], int oOffs, double xpn[],
                          int nOffs, double eps) {
    double sineps, coseps;
    double x[]=new double[3];
    sineps = Math.sin(eps);
    coseps = Math.cos(eps);
    x[0] = xpo[oOffs];
    x[1] = xpo[1+oOffs] * coseps + xpo[2+oOffs] * sineps;
    x[2] = -xpo[1+oOffs] * sineps + xpo[2+oOffs] * coseps;
    xpn[0+nOffs] = x[0];
    xpn[1+nOffs] = x[1];
    xpn[2+nOffs] = x[2];
  }
  
  public void swi_coortrf2(double xpo[], double xpn[], double sineps,
                           double coseps) {
    swi_coortrf2(xpo, 0, xpn, 0, sineps, coseps);
  }
  public void swi_coortrf2(double xpo[], int oOffs, double xpn[], int nOffs,
                    double sineps, double coseps) {
    double x[]=new double[3];
    x[0] = xpo[0+oOffs];
    x[1] = xpo[1+oOffs] * coseps + xpo[2+oOffs] * sineps;
    x[2] = -xpo[1+oOffs] * sineps + xpo[2+oOffs] * coseps;
    xpn[0+nOffs] = x[0];
    xpn[1+nOffs] = x[1];
    xpn[2+nOffs] = x[2];
  }
  
  public void swi_cartpol(double x[], double l[]) {
    swi_cartpol(x, 0, l, 0);
  }
  public void swi_cartpol(double x[], int xOffs, double l[], int lOffs) {
    double rxy;
    double ll[]=new double[3];
    if (x[0+xOffs] == 0 && x[1+xOffs] == 0 && x[2+xOffs] == 0) {
      l[0+lOffs] = l[1+lOffs] = l[2+lOffs] = 0;
      return;
    }
    rxy = x[0+xOffs]*x[0+xOffs] + x[1+xOffs]*x[1+xOffs];
    ll[2] = Math.sqrt(rxy + x[2+xOffs]*x[2+xOffs]);
    rxy = Math.sqrt(rxy);
    ll[0] = Math.atan2(x[1+xOffs], x[0+xOffs]);
    if (ll[0] < 0.0) {
      ll[0] += SwephData.TWOPI;
    }
    ll[1] = Math.atan(x[2+xOffs] / rxy);
    l[0+lOffs] = ll[0];
    l[1+lOffs] = ll[1];
    l[2+lOffs] = ll[2];
  }
  
  public void swi_polcart(double l[], double x[]) {
    swi_polcart(l, 0, x, 0);
  }
  public void swi_polcart(double l[], int lOffs, double x[], int xOffs) {
    double xx[]=new double[3];
    double cosl1;
    cosl1 = Math.cos(l[lOffs+1]);
    xx[0] = l[lOffs+2] * cosl1 * Math.cos(l[lOffs]);
    xx[1] = l[lOffs+2] * cosl1 * Math.sin(l[lOffs]);
    xx[2] = l[lOffs+2] * Math.sin(l[lOffs+1]);
    x[xOffs] = xx[0];
    x[xOffs+1] = xx[1];
    x[xOffs+2] = xx[2];
  }
  
  public void swi_cartpol_sp(double x[], double l[]) {
    swi_cartpol_sp(x, 0, l, 0);
  }
  public void swi_cartpol_sp(double x[], int xOffs, double l[], int lOffs) {
    double xx[]=new double[6], ll[]=new double[6];
    double rxy, coslon, sinlon, coslat, sinlat;
    
    if (x[0+xOffs] == 0 && x[1+xOffs] == 0 && x[2+xOffs] == 0) {
      l[0+lOffs] = l[1+lOffs] = l[3+lOffs] = l[4+lOffs] = 0;
      l[5+lOffs] = Math.sqrt(square_sum(x, 3+xOffs));
      swi_cartpol(x, 3+xOffs, l, 0+lOffs);
      l[2+lOffs] = 0;
      return;
    }
    
    if (x[3+xOffs] == 0 && x[4+xOffs] == 0 && x[5+xOffs] == 0) {
      l[3+lOffs] = l[4+lOffs] = l[5+lOffs] = 0;
      swi_cartpol(x, xOffs, l, lOffs);
      return;
    }
    
    rxy = x[0+xOffs]*x[0+xOffs] + x[1+xOffs]*x[1+xOffs];
    ll[2] = Math.sqrt(rxy + x[2+xOffs]*x[2+xOffs]);
    rxy = Math.sqrt(rxy);
    ll[0] = Math.atan2(x[1+xOffs], x[0+xOffs]);
    if (ll[0] < 0.0) {
      ll[0] += SwephData.TWOPI;
    }
    ll[1] = Math.atan(x[2+xOffs] / rxy);
    
    coslon = x[0+xOffs] / rxy;          
    sinlon = x[1+xOffs] / rxy;          
    coslat = rxy / ll[2];         
    sinlat = x[2+xOffs] / ll[2];        
    xx[3] = x[3+xOffs] * coslon + x[4+xOffs] * sinlon;
    xx[4] = -x[3+xOffs] * sinlon + x[4+xOffs] * coslon;
    l[3+lOffs] = xx[4] / rxy;           
    xx[4] = -sinlat * xx[3] + coslat * x[5+xOffs];
    xx[5] =  coslat * xx[3] + sinlat * x[5+xOffs];
    l[4+lOffs] = xx[4] / ll[2];         
    l[5+lOffs] = xx[5];                 
    l[0+lOffs] = ll[0];                 
    l[1+lOffs] = ll[1];
    l[2+lOffs] = ll[2];
  }
  
  public void swi_polcart_sp(double l[], double x[]) {
    swi_polcart_sp(l, 0, x, 0);
  }
  public void swi_polcart_sp(double l[], int lOffs, double x[], int xOffs) {
    double sinlon, coslon, sinlat, coslat;
    double xx[]=new double[6], rxy, rxyz;
    
    if (l[3+lOffs] == 0 && l[4+lOffs] == 0 && l[5+lOffs] == 0) {
      x[3+xOffs] = x[4+xOffs] = x[5+xOffs] = 0;
      swi_polcart(l, lOffs, x, xOffs);
      return;
    }
    
    coslon = Math.cos(l[0+lOffs]);
    sinlon = Math.sin(l[0+lOffs]);
    coslat = Math.cos(l[1+lOffs]);
    sinlat = Math.sin(l[1+lOffs]);
    xx[0] = l[2+lOffs] * coslat * coslon;
    xx[1] = l[2+lOffs] * coslat * sinlon;
    xx[2] = l[2+lOffs] * sinlat;
    
    rxyz = l[2+lOffs];
    rxy = Math.sqrt(xx[0] * xx[0] + xx[1] * xx[1]);
    xx[5] = l[5+lOffs];
    xx[4] = l[4+lOffs] * rxyz;
    x[5+xOffs] = sinlat * xx[5] + coslat * xx[4];       
    xx[3] = coslat * xx[5] - sinlat * xx[4];
    xx[4] = l[3+lOffs] * rxy;
    x[3+xOffs] = coslon * xx[3] - sinlon * xx[4];       
    x[4+xOffs] = sinlon * xx[3] + coslon * xx[4];       
    x[0+xOffs] = xx[0];                                 
    x[1+xOffs] = xx[1];
    x[2+xOffs] = xx[2];
  }
  public double swi_dot_prod_unit(double[] x, double[] y) {
    double dop = x[0]*y[0]+x[1]*y[1]+x[2]*y[2];
    double e1 = Math.sqrt(x[0]*x[0]+x[1]*x[1]+x[2]*x[2]);
    double e2 = Math.sqrt(y[0]*y[0]+y[1]*y[1]+y[2]*y[2]);
    dop /= e1;
    dop /= e2;
    if (dop > 1) {
      dop = 1;
    }
    if (dop < -1) {
      dop = -1;
    }
    return dop;
  }
  
  public double swi_epsiln(double J) {
    double T, eps;
    T = (J - 2451545.0)/36525.0;
    if (PREC_IAU_1976 && Math.abs(T) <= PREC_IAU_1976_CTIES ) {
      eps = (((1.813e-3*T-5.9e-4)*T-46.8150)*T+84381.448)*SwissData.DEGTORAD/3600;
    } else if (PREC_IAU_2003 && Math.abs(T) <= PREC_IAU_2003_CTIES) {
      eps =  (((((-4.34e-8 * T -5.76e-7) * T +2.0034e-3) * T -1.831e-4) * T -46.836769) * T + 84381.406) * SwissData.DEGTORAD / 3600.0;
    } else if (PREC_BRETAGNON_2003) {
      eps =  ((((((-3e-11 * T - 2.48e-8) * T -5.23e-7) * T +1.99911e-3) * T -1.667e-4) * T -46.836051) * T + 84381.40880) * SwissData.DEGTORAD / 3600.0;
    } else if (PREC_SIMON_1994) {
      eps =  (((((2.5e-8 * T -5.1e-7) * T +1.9989e-3) * T -1.52e-4) * T -46.80927) * T + 84381.412) * SwissData.DEGTORAD / 3600.0;
    } else if (PREC_WILLIAMS_1994) {
      eps =  ((((-1.0e-6 * T +2.0e-3) * T -1.74e-4) * T -46.833960) * T + 84381.409) * SwissData.DEGTORAD / 3600.0;
    } else { 
      T /= 10.0;
      eps = ((((((((( 2.45e-10*T + 5.79e-9)*T + 2.787e-7)*T
      + 7.12e-7)*T - 3.905e-5)*T - 2.4967e-3)*T
      - 5.138e-3)*T + 1.99925)*T - 0.0155)*T - 468.093)*T
      + 84381.448;
      eps *= SwissData.DEGTORAD/3600;
    }
    return(eps);
  }
  
  
  static final double pAcof[] = {
   -8.66e-10, -4.759e-8, 2.424e-7, 1.3095e-5, 1.7451e-4, -1.8055e-3,
   -0.235316, 0.076, 110.5407, 50287.70000 };
  static final double nodecof[] = {
    6.6402e-16, -2.69151e-15, -1.547021e-12, 7.521313e-12, 1.9e-10,
    -3.54e-9, -1.8103e-7,  1.26e-7,  7.436169e-5,
    -0.04207794833,  3.052115282424};
  static final double inclcof[] = {
    1.2147e-16, 7.3759e-17, -8.26287e-14, 2.503410e-13, 2.4650839e-11,
    -5.4000441e-11, 1.32115526e-9, -6.012e-7, -1.62442e-5,
    0.00227850649, 0.0 };
  
  
  public int swi_precess(double R[], double J, int direction ) {
    return swi_precess(R, 0, J, direction);
  }
  public int swi_precess(double R[], int rOffs, double J, int direction ) {
    double sinth, costh, sinZ, cosZ, sinz, cosz;
    double eps, sineps, coseps;
    double A, B, T, Z, z, TH, pA, W;
    double x[]=new double[3];
    int pn;
    int i;
    if( J == SwephData.J2000 ) {
      return(0);
    }
    
    T = (J - SwephData.J2000)/36525.0;
    
    if (PREC_IAU_1976 && Math.abs(T) <= PREC_IAU_1976_CTIES) {
      Z =  (( 0.017998*T + 0.30188)*T + 2306.2181)*T*SwissData.DEGTORAD/3600;
      z =  (( 0.018203*T + 1.09468)*T + 2306.2181)*T*SwissData.DEGTORAD/3600;
      TH = ((-0.041833*T - 0.42665)*T + 2004.3109)*T*SwissData.DEGTORAD/3600;
    } else if (PREC_IAU_2003 && Math.abs(T) <= PREC_IAU_2003_CTIES) {
      Z =  (((((- 0.0000003173*T - 0.000005971)*T + 0.01801828)*T + 0.2988499)*T + 2306.083227)*T + 2.650545)*SwissData.DEGTORAD/3600;
      z =  (((((- 0.0000002904*T - 0.000028596)*T + 0.01826837)*T + 1.0927348)*T + 2306.077181)*T - 2.650545)*SwissData.DEGTORAD/3600;
      TH = ((((-0.00000011274*T - 0.000007089)*T - 0.04182264)*T - 0.4294934)*T + 2004.191903)*T*SwissData.DEGTORAD/3600;
      
    } else if (PREC_BRETAGNON_2003) {
      Z =  ((((((-0.00000000013*T - 0.0000003040)*T - 0.000005708)*T + 0.01801752)*T + 0.3023262)*T + 2306.080472)*T + 2.72767)*SwissData.DEGTORAD/3600;
      z =  ((((((-0.00000000005*T - 0.0000002486)*T - 0.000028276)*T + 0.01826676)*T + 1.0956768)*T + 2306.076070)*T - 2.72767)*SwissData.DEGTORAD/3600;
      TH = ((((((0.000000000009*T + 0.00000000036)*T -0.0000001127)*T - 0.000007291)*T - 0.04182364)*T - 0.4266980)*T + 2004.190936)*T*SwissData.DEGTORAD/3600;
    } else {
      
      if( direction == 1 ) {
        eps = swi_epsiln(J); 
      } else {
        eps = swi_epsiln(SwephData.J2000); 
      }
      sineps = Math.sin(eps);
      coseps = Math.cos(eps);
      x[0] = R[0+rOffs];
      z = coseps*R[1+rOffs] + sineps*R[2+rOffs];
      x[2] = -sineps*R[1+rOffs] + coseps*R[2+rOffs];
      x[1] = z;
      
      T /= 10.0; 
      pn=0; //p = pAcof;
      pA = pAcof[pn]; pn++;
      for( i=0; i<9; i++ ) {
        pA = pA * T + pAcof[pn]; pn++;
      }
      pA *= SwissData.DEGTORAD/3600 * T;
      
      pn=0; // p = nodecof;
      W = nodecof[pn]; pn++;
      for( i=0; i<10; i++ ) {
        W = W * T + nodecof[pn]; pn++;
      }
      
      if( direction == 1 ) {
        z = W + pA;
      } else {
        z = W;
      }
      B = Math.cos(z);
      A = Math.sin(z);
      z = B * x[0] + A * x[1];
      x[1] = -A * x[0] + B * x[1];
      x[0] = z;
      
      pn=0; // p = inclcof;
      z = inclcof[pn]; pn++;
      for( i=0; i<10; i++ ) {
        z = z * T + inclcof[pn]; pn++;
      }
      if( direction == 1 ) {
        z = -z;
      }
      B = Math.cos(z);
      A = Math.sin(z);
      z = B * x[1] + A * x[2];
      x[2] = -A * x[1] + B * x[2];
      x[1] = z;
      
      if( direction == 1 ) {
        z = -W;
      } else {
        z = -W - pA;
      }
      B = Math.cos(z);
      A = Math.sin(z);
      z = B * x[0] + A * x[1];
      x[1] = -A * x[0] + B * x[1];
      x[0] = z;
      
      if( direction == 1 ) {
        eps = swi_epsiln(SwephData.J2000);
      } else {
        eps = swi_epsiln(J);
      }
      sineps = Math.sin(eps);
      coseps = Math.cos(eps);
      z = coseps * x[1] - sineps * x[2];
      x[2] = sineps * x[1] + coseps * x[2];
      x[1] = z;
      for( i=0; i<3; i++ )
        R[i+rOffs] = x[i];
      return(0);
    }
    sinth = Math.sin(TH);
    costh = Math.cos(TH);
    sinZ = Math.sin(Z);
    cosZ = Math.cos(Z);
    sinz = Math.sin(z);
    cosz = Math.cos(z);
    A = cosZ*costh;
    B = sinZ*costh;
    if( direction < 0 ) { 
      x[0] =    (A*cosz - sinZ*sinz)*R[0+rOffs]
              - (B*cosz + cosZ*sinz)*R[1+rOffs]
                        - sinth*cosz*R[2+rOffs];
      x[1] =    (A*sinz + sinZ*cosz)*R[0+rOffs]
              - (B*sinz - cosZ*cosz)*R[1+rOffs]
                        - sinth*sinz*R[2+rOffs];
      x[2] =              cosZ*sinth*R[0+rOffs]
                        - sinZ*sinth*R[1+rOffs]
                        + costh*R[2+rOffs];
    }
    else { 
      x[0] =    (A*cosz - sinZ*sinz)*R[0+rOffs]
              + (A*sinz + sinZ*cosz)*R[1+rOffs]
                        + cosZ*sinth*R[2+rOffs];
      x[1] =  - (B*cosz + cosZ*sinz)*R[0+rOffs]
              - (B*sinz - cosZ*cosz)*R[1+rOffs]
                        - sinZ*sinth*R[2+rOffs];
      x[2] =            - sinth*cosz*R[0+rOffs]
                        - sinth*sinz*R[1+rOffs]
                        + costh*R[2+rOffs];
    }
    for( i=0; i<3; i++ )
      R[i+rOffs] = x[i];
    return(0);
  }
  
  int swi_nutation(double J, double nutlo[]) {
    int i, j, k, inls;
    double M, SM, F, D, OM;
    double darg, sinarg, cosarg;
    double dpsi = 0, deps = 0;
    double T = (J - SwephData.J2000 ) / 36525.0;
    
    
    
    M  = swe_degnorm(( 485868.249036 +
                T*( 1717915923.2178 +
                T*(         31.8792 +
                T*(          0.051635 +
                T*(        - 0.00024470 ))))) / 3600.0) * SwissData.DEGTORAD;
    
    SM = swe_degnorm((1287104.79305 +
                T*(  129596581.0481 +
                T*(        - 0.5532 +
                T*(          0.000136 +
                T*(        - 0.00001149 ))))) / 3600.0) * SwissData.DEGTORAD;
    
    F   = swe_degnorm(( 335779.526232 +
                T*( 1739527262.8478 +
                T*(       - 12.7512 +
                T*(       -  0.001037 +
                T*(          0.00000417 ))))) / 3600.0) * SwissData.DEGTORAD;
    
    D   = swe_degnorm((1072260.70369 +
                T*( 1602961601.2090 +
                T*(        - 6.3706 +
                T*(          0.006593 +
                T*(        - 0.00003169 ))))) / 3600.0) * SwissData.DEGTORAD;
    
    OM  = swe_degnorm(( 450160.398036 +
                T*(  - 6962890.5431 +
                T*(          7.4722 +
                T*(          0.007702 +
                T*(        - 0.00005939 ))))) / 3600.0) * SwissData.DEGTORAD;
    
    inls = Swenut2000a.NLS_2000B;
    for (i = inls - 1; i >= 0; i--) {
      j = i * 5;
      darg = swe_radnorm((double) Swenut2000a.nls[j + 0] * M  +
                         (double) Swenut2000a.nls[j + 1] * SM +
                         (double) Swenut2000a.nls[j + 2] * F   +
                         (double) Swenut2000a.nls[j + 3] * D   +
                         (double) Swenut2000a.nls[j + 4] * OM);
      sinarg = Math.sin(darg);
      cosarg = Math.cos(darg);
      k = i * 6;
      dpsi += (Swenut2000a.cls[k+0] + Swenut2000a.cls[k+1] * T) * sinarg + Swenut2000a.cls[k+2] * cosarg;
      deps += (Swenut2000a.cls[k+3] + Swenut2000a.cls[k+4] * T) * cosarg + Swenut2000a.cls[k+5] * sinarg;
    }
    nutlo[0] = dpsi * Swenut2000a.O1MAS2DEG;
    nutlo[1] = deps * Swenut2000a.O1MAS2DEG;
    nutlo[0] *= SwissData.DEGTORAD;
    nutlo[1] *= SwissData.DEGTORAD;
    return 0;
  }
  
  void swi_bias(double[] x, int iflag, boolean backward) {
    double xx[]=new double[6], rb[][]=new double[3][3];
    int i;
    rb[0][0] = +0.9999999999999942;
    rb[0][1] = +0.0000000707827948;
    rb[0][2] = -0.0000000805621738;
    rb[1][0] = -0.0000000707827974;
    rb[1][1] = +0.9999999999999969;
    rb[1][2] = -0.0000000330604088;
    rb[2][0] = +0.0000000805621715;
    rb[2][1] = +0.0000000330604145;
    rb[2][2] = +0.9999999999999962;
    if (backward) {
      for (i = 0; i <= 2; i++) {
        xx[i] = x[0] * rb[i][0] +
                x[1] * rb[i][1] +
                x[2] * rb[i][2];
        if ((iflag & SweConst.SEFLG_SPEED) != 0)
          xx[i+3] = x[3] * rb[i][0] +
                x[4] * rb[i][1] +
                x[5] * rb[i][2];
      }
    } else {
      for (i = 0; i <= 2; i++) {
        xx[i] = x[0] * rb[0][i] +
                x[1] * rb[1][i] +
                x[2] * rb[2][i];
        if ((iflag & SweConst.SEFLG_SPEED) != 0)
          xx[i+3] = x[3] * rb[0][i] +
                x[4] * rb[1][i] +
                x[5] * rb[2][i];
      }
    }
    for (i = 0; i <= 2; i++) x[i] = xx[i];
    if ((iflag & SweConst.SEFLG_SPEED) != 0) {
      for (i = 3; i <= 5; i++) x[i] = xx[i];
    }
  }
  
  void swi_icrs2fk5(double[] x, int iflag, boolean backward) {
    double xx[]=new double[6], rb[][]=new double[3][3];
    int i;
    rb[0][0] = +0.9999999999999928;
    rb[0][1] = +0.0000001110223287;
    rb[0][2] = +0.0000000441180557;
    rb[1][0] = -0.0000001110223330;
    rb[1][1] = +0.9999999999999891;
    rb[1][2] = +0.0000000964779176;
    rb[2][0] = -0.0000000441180450;
    rb[2][1] = -0.0000000964779225;
    rb[2][2] = +0.9999999999999943;
    if (backward) {
      for (i = 0; i <= 2; i++) {
        xx[i] = x[0] * rb[i][0] +
                x[1] * rb[i][1] +
                x[2] * rb[i][2];
        if ((iflag & SweConst.SEFLG_SPEED) != 0)
          xx[i+3] = x[3] * rb[i][0] +
                x[4] * rb[i][1] +
                x[5] * rb[i][2];
      }
    } else {
      for (i = 0; i <= 2; i++) {
        xx[i] = x[0] * rb[0][i] +
                x[1] * rb[1][i] +
                x[2] * rb[2][i];
        if ((iflag & SweConst.SEFLG_SPEED) != 0)
          xx[i+3] = x[3] * rb[0][i] +
                x[4] * rb[1][i] +
                x[5] * rb[2][i];
      }
    }
    for (i = 0; i <= 5; i++) x[i] = xx[i];
  }
  
  
  public int swi_cutstr(String s, String cutlist, String cpos[], int nmax) {
    s=s.trim();
    if (s.indexOf('\n')>=0) { s=s.substring(0,s.indexOf('\n')); }
    if (s.indexOf('\r')>=0) { s=s.substring(0,s.indexOf('\r')); }
    java.util.StringTokenizer tk= "**********"
    int n=0;
    while(tk.hasMoreTokens() && n<20) {
      String g= "**********"
      // Characters in cutlist can be valid characters of the String. If
      // escaped with "\\", join together, what the StringTokenizer separated
      while (g.endsWith("\\") && tk.hasMoreTokens()) {
        g= "**********"
        if (tk.hasMoreTokens()) {
          g+= "**********"
        }
      }
      cpos[n]=g;
      n++;
      if (tk.hasMoreTokens()) { tk.nextToken(); }
    }
    cpos[19]="";
    while(tk.hasMoreTokens()) {
      cpos[19]+= "**********"
    }
    if (n < nmax) {
      cpos[n] = null;
    }
    return n;
  }       
  
  
  public double swe_sidtime0( double tjd, double eps, double nut ) {
    double jd0;           
    double secs;          
    double eqeq, jd, tu, tt, msday;
    double gmst;
    
    jd = tjd;
    jd0 = Math.floor(jd);
    secs = tjd - jd0;
    if( secs < 0.5 ) {
      jd0 -= 0.5;
      secs += 0.5;
    } else {
      jd0 += 0.5;
      secs -= 0.5;
    }
    secs *= 86400.0;
    tu = (jd0 - SwephData.J2000)/36525.0; 
    if (PREC_IAU_2003) {
      tt = (jd0 + SweDate.getDeltaT(jd0) - SwephData.J2000)/36525.0; 
      gmst = (((-0.000000002454*tt - 0.00000199708)*tt - 0.0000002926)*tt + 0.092772110)*tt*tt + 307.4771013*(tt-tu) + 8640184.79447825*tu + 24110.5493771;
      
      msday = 1 + ((((-0.000000012270*tt - 0.00000798832)*tt - 0.0000008778)*tt + 0.185544220)*tt + 8640184.79447825)/(86400.*36525.);
    } else {
      
      gmst = (( -6.2e-6*tu + 9.3104e-2)*tu + 8640184.812866)*tu + 24110.54841;
      
      msday = 1.0 + ((-1.86e-5*tu + 0.186208)*tu + 8640184.812866)/(86400.*36525.);
    }
    
    eqeq = 240.0 * nut * Math.cos(eps * SwissData.DEGTORAD);
    gmst = gmst + msday*secs + eqeq  ;
    
    gmst = gmst - 86400.0 * Math.floor( gmst/86400.0 );
    
    gmst /= 3600;
    return gmst;
  }
  
  
  public double swe_sidtime(double tjd_ut) {
    int i;
    double eps, nutlo[]=new double[2], tsid;
    double tjde = tjd_ut + SweDate.getDeltaT(tjd_ut);
    eps = swi_epsiln(tjde) * SwissData.RADTODEG;
    swi_nutation(tjde, nutlo);
    for (i = 0; i < 2; i++)
      nutlo[i] *= SwissData.RADTODEG;
    tsid = swe_sidtime0(tjd_ut, eps + nutlo[1], nutlo[0]);
    return tsid;
  }
  
  public String swi_gen_filename(SweDate sd, int ipli) {

    int icty;
    int ncties = (int) SwephData.NCTIES;
    int sgn;
    String fname;
    switch(ipli) {
      case SwephData.SEI_MOON:
        fname="semo";
        break;
      case SwephData.SEI_EMB:
      case SwephData.SEI_MERCURY:
      case SwephData.SEI_VENUS:
      case SwephData.SEI_MARS:
      case SwephData.SEI_JUPITER:
      case SwephData.SEI_SATURN:
      case SwephData.SEI_URANUS:
      case SwephData.SEI_NEPTUNE:
      case SwephData.SEI_PLUTO:
      case SwephData.SEI_SUNBARY:
        fname="sepl";
        break;
      case SwephData.SEI_CERES:
      case SwephData.SEI_PALLAS:
      case SwephData.SEI_JUNO:
      case SwephData.SEI_VESTA:
      case SwephData.SEI_CHIRON:
      case SwephData.SEI_PHOLUS:
        fname="seas";
        break;
      default:    
        String iplNr="00000" + (ipli - SweConst.SE_AST_OFFSET);
        iplNr = iplNr.substring(iplNr.length()-6);
        if ((ipli - SweConst.SE_AST_OFFSET <= 99999)) {
          iplNr = iplNr.substring(1);
        }
        fname = "ast" + ((ipli - SweConst.SE_AST_OFFSET) / 1000) +
                swed.DIR_GLUE + "se" + iplNr + "." + SwephData.SE_FILE_SUFFIX;
        return fname;   
        
    }
    
    
    if (sd.getJulDay() >= 2305447.5) {
      sd.setCalendarType(SweDate.SE_GREG_CAL, SweDate.SE_KEEP_JD);
    
    } else {
      sd.setCalendarType(SweDate.SE_JUL_CAL, SweDate.SE_KEEP_JD);
    }
    
    int year = sd.getYear();
    if (year < 0) {
      sgn = -1;
    } else {
      sgn = 1;
    }
    icty = year / 100;
    if (sgn < 0 && year % 100 != 0) {
      icty -=1;
    }
    while(icty % ncties != 0) {
      icty--;
    }
    
    if (icty < 0) {
      fname+="m";
    } else {
      fname+="_";
    }
    icty = Math.abs(icty);
    fname+=(icty<10?"0":"")+icty+"."+SwephData.SE_FILE_SUFFIX;
    return fname;
  }
  
  public void swe_split_deg(double ddeg, int roundflag, IntObj ideg,
                            IntObj imin, IntObj isec, DblObj dsecfr,
                            IntObj isgn) {
    double dadd = 0;
    isgn.val = 1;
    if (ddeg < 0) {
      isgn.val = -1;
      ddeg = -ddeg;
    }
    if ((roundflag & SweConst.SE_SPLIT_DEG_ROUND_DEG)!=0) {
      dadd = 0.5;
    } else if ((roundflag & SweConst.SE_SPLIT_DEG_ROUND_MIN)!=0) {
      dadd = 0.5 / 60;
    } else if ((roundflag & SweConst.SE_SPLIT_DEG_ROUND_SEC)!=0) {
      dadd = 0.5 / 3600;
    }
    if ((roundflag & SweConst.SE_SPLIT_DEG_KEEP_DEG)!=0) {
      if ((int) (ddeg + dadd) - (int) ddeg > 0) {
        dadd = 0;
      }
    } else if ((roundflag & SweConst.SE_SPLIT_DEG_KEEP_SIGN)!=0) {
      if ((ddeg % 30) + dadd >= 30) {
        dadd = 0;
      }
    }
    ddeg += dadd;
    if ((roundflag & SweConst.SE_SPLIT_DEG_ZODIACAL)!=0) {
      isgn.val = (int) (ddeg / 30);
      ddeg = ddeg % 30;
    }
    ideg.val = (int) ddeg;
    ddeg -= ideg.val;
    imin.val = (int) (ddeg * 60);
    ddeg -= imin.val / 60.0;
    isec.val = (int) (ddeg * 3600);
    if ((roundflag & (SweConst.SE_SPLIT_DEG_ROUND_DEG | SweConst.SE_SPLIT_DEG_ROUND_MIN | SweConst.SE_SPLIT_DEG_ROUND_SEC))==0) {
      dsecfr.val = ddeg * 3600 - isec.val;
    }
  }  
  public double swi_kepler(double E, double M, double ecce) {
    double dE = 1, E0;
    double x;
    
    if (ecce < 0.4) {
      while(dE > 1e-12) {
        E0 = E;
        E = M + ecce * Math.sin(E0);
        dE = Math.abs(E - E0);
      }
    
    } else {
      while(dE > 1e-12) {
        E0 = E;
        
        x = (M + ecce * Math.sin(E0) - E0) / (1 - ecce * Math.cos(E0));
        dE = Math.abs(x);
        if (dE < 1e-2) {
          E = E0 + x;
        } else {
          E = swi_mod2PI(E0 + x);
          dE = Math.abs(E - E0);
        }
      }
    }
    return E;
  }
  public void swi_FK4_FK5(double xp[], double tjd) {
    if (xp[0] == 0 && xp[1] == 0 && xp[2] == 0) {
      return;
    }
    swi_cartpol(xp, xp);
    
    xp[0] += (0.035 + 0.085 * (tjd - SwephData.B1950) / 36524.2198782) / 3600 * 15 * SwissData.DEGTORAD;
    xp[3] += (0.085 / 36524.2198782) / 3600 * 15 * SwissData.DEGTORAD;
    swi_polcart(xp, xp);
  }
  public void swi_FK5_FK4(double[] xp, double tjd) {
    if (xp[0] == 0 && xp[1] == 0 && xp[2] == 0) {
      return;
    }
    swi_cartpol(xp, xp);
    
    xp[0] -= (0.035 + 0.085 * (tjd - SwephData.B1950) / 36524.2198782) / 3600 * 15 * SwissData.DEGTORAD;
    xp[3] -= (0.085 / 36524.2198782) / 3600 * 15 * SwissData.DEGTORAD;
    swi_polcart(xp, xp);
  }
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
  
  public int swe_d2l(double x) {
    if (x >=0.) {
      return ((int) (x + 0.5));
    } else {
      return (- (int) (0.5 - x));
    }
  }
  
  public double swe_difdeg2n(double p1, double p2) {
    double dif;
    dif = swe_degnorm(p1 - p2);
    if (dif  >= 180.0) {
      return (dif - 360.0);
    }
    return (dif);
  }
  public double swe_difrad2n(double p1, double p2) {
    double dif;
    dif = swe_radnorm(p1 - p2);
    if (dif  >= SwephData.TWOPI / 2) {
      return (dif - SwephData.TWOPI);
    }
    return (dif);
  }
  
  public static synchronized double atof(String src) {
    // atof() (in C) allows extra strings after the number, and even no number
    // at all, so we have to work around this...
    int idx=0;
    src=src.trim();
    while(idx<src.length() &&
         (Character.isDigit(src.charAt(idx)) || src.charAt(idx)=='.')) {
      idx++;
    }
    String sout=src.substring(0,idx).trim();
    if (sout.length()==0 || sout.replace('.',' ').trim().length()==0) {
      return 0.;
    }
    return Double.valueOf(sout).doubleValue();
  }
  
  public static synchronized int atoi(String src) {
    // atoi() (in C) allows extra strings after the number, and even no number
    // at all, so we have to work around this...
    int idx=0;
    src=src.trim();
    while(idx<src.length() && Character.isDigit(src.charAt(idx))) {
      idx++;
    }
    String sout=src.substring(0,idx).trim();
    if (sout.length()==0 || sout.replace('.',' ').trim().length()==0) {
      return 0;
    }
    return Integer.valueOf(sout).intValue();
  }
static final double PREC_IAU_CTIES=2.0; // J2000 +/- two centuries
} // End of class SwissLib.
class TCPlanet extends TransitCalculator {
  private int planet;
  private int idx = 0; // The index into the xx[] array in swe_calc() to use:
  private int tflags = 0; // The transit flags
  private  int flags = 0;  // The calculation flags for swe_calc()
  private  double min = 0;
  private  double max = 0;
  // The y = f(x) value to reach, speaking mathematically...
  private double offset = 0.;
double minVal = 0., maxVal = 0.;  // Thinking about it...
  
  public TCPlanet(SwissEph sw, int planet, int flags, double offset) {
    // Check parameter: //////////////////////////////////////////////////////
    // List of all valid flags:
    this.tflags = flags;
    int vFlags = SweConst.SEFLG_EPHMASK |
                 SweConst.SEFLG_TOPOCTR |
                 SweConst.SEFLG_HELCTR |
                 SweConst.SEFLG_NOABERR |
                 SweConst.SEFLG_NOGDEFL |
                 SweConst.SEFLG_SIDEREAL |
                 SweConst.SEFLG_TRANSIT_LONGITUDE |
                 SweConst.SEFLG_TRANSIT_LATITUDE |
                 SweConst.SEFLG_TRANSIT_DISTANCE |
                 SweConst.SEFLG_TRANSIT_SPEED;
    // NOABERR and NOGDEFL is allowed for HELCTR, as they get set
    // anyway.
    if ((flags & SweConst.SEFLG_HELCTR) != 0) {
      vFlags |= SweConst.SEFLG_NOABERR | SweConst.SEFLG_NOGDEFL;
    }
    if ((flags&~vFlags) != 0) {
      throw new IllegalArgumentException("Invalid flag(s): "+(flags&~vFlags));
    }
    // Allow only one of SEFLG_TRANSIT_LONGITUDE, SEFLG_TRANSIT_LATITUDE, SEFLG_TRANSIT_DISTANCE:
    int type = flags&(SweConst.SEFLG_TRANSIT_LONGITUDE |
                      SweConst.SEFLG_TRANSIT_LATITUDE |
                      SweConst.SEFLG_TRANSIT_DISTANCE);
    if (type != SweConst.SEFLG_TRANSIT_LONGITUDE &&
        type != SweConst.SEFLG_TRANSIT_LATITUDE &&
        type != SweConst.SEFLG_TRANSIT_DISTANCE) {
      throw new IllegalArgumentException("Invalid flag combination '" + flags +
        "': specify at least exactly one of SEFLG_TRANSIT_LONGITUDE (" +
        SweConst.SEFLG_TRANSIT_LONGITUDE + "), SEFLG_TRANSIT_LATITUDE (" +
        SweConst.SEFLG_TRANSIT_LATITUDE + "), SEFLG_TRANSIT_DISTANCE (" +
        SweConst.SEFLG_TRANSIT_DISTANCE + ").");
    }
    if (planet<SweConst.SE_SUN ||
        planet>SweConst.SE_INTP_PERG ||
        planet==SweConst.SE_EARTH) {
      throw new IllegalArgumentException(
          "Unsupported planet number " + planet + " ("+
              sw.swe_get_planet_name(planet) + ")");
    }
    if ((flags & SweConst.SEFLG_HELCTR) != 0 &&
        (planet == SweConst.SE_MEAN_APOG ||
         planet == SweConst.SE_OSCU_APOG ||
         planet == SweConst.SE_MEAN_NODE ||
         planet == SweConst.SE_TRUE_NODE)) {
      throw new IllegalArgumentException(
          "Unsupported planet number " + planet + " (" +
              sw.swe_get_planet_name(planet) + ") for heliocentric " +
              "calculations");
    }
    this.planet = planet;
    this.sw = sw;
    if (this.sw == null) {
      this.sw = new SwissEph();
    }
    // The index into the xx[] array in swe_calc() to use:
    if ((flags&SweConst.SEFLG_TRANSIT_LATITUDE) != 0) { // Calculate latitudinal transits
      idx = 1;
    } else if ((flags&SweConst.SEFLG_TRANSIT_DISTANCE) != 0) { // Calculate distance transits
      idx = 2;
    }
    if ((flags&SweConst.SEFLG_TRANSIT_SPEED) != 0) { // Calculate speed transits
      idx += 3;
      flags |= SweConst.SEFLG_SPEED;
    }
    // Eliminate SEFLG_TRANSIT_* flags for use in swe_calc():
    flags &= ~(SweConst.SEFLG_TRANSIT_LONGITUDE |
               SweConst.SEFLG_TRANSIT_LATITUDE |
               SweConst.SEFLG_TRANSIT_DISTANCE |
               SweConst.SEFLG_TRANSIT_SPEED);
    this.flags = flags;
    rollover = (idx == 0);
    this.offset = checkOffset(offset);
    max = getSpeed(false);
    min = getSpeed(true);
  }
  
  public boolean getRollover() {
    return rollover;
  }
  
  public void setOffset(double value) {
    offset = checkOffset(value);
  }
  
  public double getOffset() {
    return offset;
  }
  
  public Object[] getObjectIdentifiers() {
    return new Object[]{"" + planet};
  }
  //////////////////////////////////////////////////////////////////////////////
  protected double calc(double jdET) {
    StringBuffer serr = new StringBuffer();
    double[] xx = new double[6];
    int ret = sw.swe_calc(jdET, planet, flags, xx, serr);
    if (ret<0) {
      throw new SwissephException(jdET, SwissephException.UNDEFINED,
          "Calculation failed with return code "+ret+":\n"+serr.toString());
    }
    return xx[idx];
  }
  protected double getMaxSpeed() {
    return max;
  }
  protected double getMinSpeed() {
    return min;
  }
  protected double getTimePrecision(double degPrec) {
    // Recalculate degPrec to mean the minimum  time, in which the planet can
    // possibly move that degree:
    double maxTimePerDeg = Math.max(Math.abs(min),Math.abs(max));
    if (maxTimePerDeg != 0.) {
      return degPrec / maxTimePerDeg;
    }
    return 1E-9;
  }
  protected double getDegreePrecision(double jd) {
    // Calculate the planet's minimum movement regarding the maximum available
    // precision.
    //
    // For all calculations, we assume the following minimum exactnesses
    // based on the discussions on http://www.astro.com/swisseph, even though
    // these values are nothing more than very crude estimations which should
    // leave us on the save side always, even more, when seeing that we always
    // consider the maximum possible speed / acceleration of a planet in the
    // transit calculations and not the real speed.
    //
    // Take degPrec to be the minimum exact degree in longitude
    double degPrec = 0.005;
    if (idx>2) { // Speed
      // "The speed precision is now better than 0.002" for all planets"
      degPrec = 0.002;
    } else { // Degrees
      // years 1980 to 2099:              0.005"
      // years before 1980:               0.08"   (from sun to jupiter)
      // years 1900 to 1980:              0.08"   (from saturn to neptune) (added: nodes)
      // years before 1900:               1"      (from saturn to neptune) (added: nodes)
      // years after 2099:                same as before 1900
      //
      if (planet>=SweConst.SE_SUN && planet<=SweConst.SE_JUPITER) {
        if (jd<1980 || jd>2099) {
          degPrec = 0.08;
        }
      } else {
        if (jd>=1900 && jd<1980) {
          degPrec = 0.08;
        } else if (jd<1900 || jd>2099) { // Unclear about true nodes...
          degPrec = 1;
        }
      }
    }
    degPrec/=3600.;
    degPrec*=0.5; // We take the precision to BETTER THAN ... as it is stated somewhere
    // We recalculate these degrees to the minimum time difference that CAN
    // possibly give us data differing more than the above given precision.
    switch (idx) {
      case 0: // Longitude
      case 1: // Latitude
      case 3: // Speed in longitude
      case 4: // Speed in latitude
        break;
      case 2: // Distance
      case 5: // Speed in distance
        // We need to recalculate the precision in degrees to a distance value.
        // For this we need the maximum distance to the centre of calculation,
        // which is the barycentre for the main planets.
        degPrec *= sw.ext.maxBaryDist[planet];
    }
    return degPrec;
    // Barycentre:
    //            0.981683040      1.017099581  (Barycenter of the earth!)
    // Sun:       0.982747149 AU   1.017261973 AU
    // Moon:      0.980136691 AU   1.019846623 AU
    // Mercury:   0.307590579 AU   0.466604085 AU
    // Venus:     0.717960758 AU   0.728698831 AU
    // Mars:      1.382830768 AU   0.728698831 AU
    // Jupiter:   5.448547595 AU   4.955912195 AU
    // Saturn:   10.117683425 AU   8.968685733 AU
    // Uranus:   18.327870391 AU  19.893326756 AU
    // Neptune:  29.935653168 AU  30.326750627 AU
    // Pluto:    29.830132096 AU  41.499626899 AU
    // MeanNode:  0.002569555 AU   0.002569555 AU
    // TrueNode:  0.002361814 AU   0.002774851 AU
    //
    // Minimum and maximum (barycentric) distances:
    // Sun:       0.000095 AU      0.01034 AU
    // Moon:      0.972939 AU      1.02625 AU
    // Mercury:   0.298782 AU      0.47569 AU
    // Venus:     0.709190 AU      0.73723 AU
    // Mars:      1.370003 AU      1.67685 AU
    // Jupiter:   4.912031 AU      5.47705 AU
    // Saturn:    8.948669 AU     10.13792 AU
    // Uranus:   18.257511 AU     20.12033 AU
    // Neptune:  29.780622 AU     30.36938 AU
    // Pluto:    29.636944 AU     49.43648 AU
    // MeanNode:  -        AU      -       AU ?
    // TrueNode:  -        AU      -       AU ?
    // Maximum and minimum (geocentric) distances:
    // Sun:        1.016688129 AU   0.983320477 AU
    // Moon:       0.002710279 AU   0.002439921 AU
    // Mercury:    0.549188094 AU   1.448731236 AU
    // Saturn:     7.84 / 7.85 AU  11.25/11.26  AU
    // Uranus:    21.147/21.148 AU              AU
  }
  //////////////////////////////////////////////////////////////////////////////
  private double checkOffset(double val) {
    // Similar rollover considerations for the latitude will be necessary, if
    // swe_calc() would return latitudinal values beyond -90 and +90 degrees.
    if (rollover) {        // Longitude from 0 to 360 degrees:
      while (val < 0.) { val += 360.; }
      val %= 360.;
      minVal = 0.;
      maxVal = 360.;
    } else if (idx == 1) { // Latitude from -90 to +90 degrees:
      while (val < -90.) { val += 180.; }
      while (val >  90.) { val -= 180.; }
      minVal = -90.;
      maxVal = +90.;
    }
    return val;
  }
  private double getSpeed(boolean min) {
    boolean lat = ((tflags&SweConst.SEFLG_TRANSIT_LATITUDE) != 0);
    boolean dist = ((tflags&SweConst.SEFLG_TRANSIT_DISTANCE) != 0);
    boolean speed = ((tflags&SweConst.SEFLG_TRANSIT_SPEED) != 0);
    boolean topo = ((tflags&SweConst.SEFLG_TOPOCTR) != 0);
    boolean helio = ((tflags&SweConst.SEFLG_HELCTR) != 0);
    // Some topocentric speeds are very different to the geocentric
    // speeds, so we use other values than for geocentric calculations:
    if (topo) {
      if (!sw.swed.geopos_is_set) {
        throw new IllegalArgumentException("Geographic position is not set for "+
                                           "requested topocentric calculations.");
      }
      if (sw.swed.topd.geoalt>50000.) {
        throw new IllegalArgumentException("Topocentric transit calculations "+
                                           "are restricted to a maximum "+
                                           "altitude of 50km so far.");
      } else if (sw.swed.topd.geoalt<-12000000) {
        throw new IllegalArgumentException("Topocentric transit calculations "+
                                           "are restricted to a minimum "+
                                           "altitude of -12000km so far.");
      }
      if (speed) {
        if (lat) {
          return (min?SwephData.minTopoLatAccel[planet]:SwephData.maxTopoLatAccel[planet]);
        } else if (dist) {
          return (min?SwephData.minTopoDistAccel[planet]:SwephData.maxTopoDistAccel[planet]);
        } else {
          return (min?SwephData.minTopoLonAccel[planet]:SwephData.maxTopoLonAccel[planet]);
        }
      } else {
        if (lat) {
          return (min?SwephData.minTopoLatSpeed[planet]:SwephData.maxTopoLatSpeed[planet]);
        } else if (dist) {
          return (min?SwephData.minTopoDistSpeed[planet]:SwephData.maxTopoDistSpeed[planet]);
        } else {
          return (min?SwephData.minTopoLonSpeed[planet]:SwephData.maxTopoLonSpeed[planet]);
        }
      }
    }
    // Heliocentric speeds are very different to the geocentric speeds, so
    // we use other values than for geocentric calculations:
    if (helio) {
      if (speed) {
        if (lat) {
          return (min?SwephData.minHelioLatAccel[planet]:SwephData.maxHelioLatAccel[planet]);
        } else if (dist) {
          return (min?SwephData.minHelioDistAccel[planet]:SwephData.maxHelioDistAccel[planet]);
        } else {
          return (min?SwephData.minHelioLonAccel[planet]:SwephData.maxHelioLonAccel[planet]);
        }
      } else {
        if (lat) {
          return (min?SwephData.minHelioLatSpeed[planet]:SwephData.maxHelioLatSpeed[planet]);
        } else if (dist) {
          return (min?SwephData.minHelioDistSpeed[planet]:SwephData.maxHelioDistSpeed[planet]);
        } else {
          return (min?SwephData.minHelioLonSpeed[planet]:SwephData.maxHelioLonSpeed[planet]);
        }
      }
    }
    // Geocentric:
    if (speed) {
      if (lat) {
        return (min?SwephData.minLatAccel[planet]:SwephData.maxLatAccel[planet]);
      } else if (dist) {
        return (min?SwephData.minDistAccel[planet]:SwephData.maxDistAccel[planet]);
      } else {
        return (min?SwephData.minLonAccel[planet]:SwephData.maxLonAccel[planet]);
      }
    } else {
      if (lat) {
        return (min?SwephData.minLatSpeed[planet]:SwephData.maxLatSpeed[planet]);
      } else if (dist) {
        return (min?SwephData.minDistSpeed[planet]:SwephData.maxDistSpeed[planet]);
      } else {
        return (min?SwephData.minLonSpeed[planet]:SwephData.maxLonSpeed[planet]);
      }
    }
  }
  public String toString() {
    return "[Planet:" + planet + "];Offset:" + getOffset();
  }
}
class TCPlanetPlanet extends TransitCalculator {
  private int pl1, pl2;
  private int idx = 0; // The index into the xx[] array in swe_calc() to use:
  private int tflags = 0; // The transit flags
  private int flags = 0;  // The calculation flags for swe_calc()
  private boolean calcYoga = false;
  private double maxSpeed1;
  private double minSpeed1;
  private double maxSpeed2;
  private double minSpeed2;
  private double minSpeed, maxSpeed;
  // The y = f(x) value to reach, speaking mathematically...
  private double offset = 0.;
double minVal = 0., maxVal = 0.;  // Thinking about it...
  
  public TCPlanetPlanet(SwissEph sw, int pl1, int pl2, int flags, double offset) {
    this.sw = sw;
    if (this.sw == null) {
      this.sw = new SwissEph();
    }
    // Check parameter: //////////////////////////////////////////////////////
    // List of all valid flags:
    this.tflags = flags;
    int vFlags = SweConst.SEFLG_EPHMASK |
                 SweConst.SEFLG_TOPOCTR |
                 SweConst.SEFLG_HELCTR |
                 SweConst.SEFLG_NOABERR |
                 SweConst.SEFLG_NOGDEFL |
                 SweConst.SEFLG_SIDEREAL |
                 SweConst.SEFLG_YOGA_TRANSIT |
                 SweConst.SEFLG_TRANSIT_LONGITUDE |
                 SweConst.SEFLG_TRANSIT_LATITUDE |
                 SweConst.SEFLG_TRANSIT_DISTANCE |
                 SweConst.SEFLG_TRANSIT_SPEED;
    // NOABERR and NOGDEFL is allowed for HELCTR, as they get set
    // anyway.
    if ((flags & SweConst.SEFLG_HELCTR) != 0) {
      vFlags |= SweConst.SEFLG_NOABERR | SweConst.SEFLG_NOGDEFL;
    }
    if ((flags&~vFlags) != 0) {
      throw new IllegalArgumentException("Invalid flag(s): "+(flags&~vFlags));
    }
    // Allow only one of SEFLG_TRANSIT_LONGITUDE, SEFLG_TRANSIT_LATITUDE, SEFLG_TRANSIT_DISTANCE:
    int type = flags&(SweConst.SEFLG_TRANSIT_LONGITUDE |
                      SweConst.SEFLG_TRANSIT_LATITUDE |
                      SweConst.SEFLG_TRANSIT_DISTANCE);
    if (type != SweConst.SEFLG_TRANSIT_LONGITUDE &&
        type != SweConst.SEFLG_TRANSIT_LATITUDE &&
        type != SweConst.SEFLG_TRANSIT_DISTANCE) {
      throw new IllegalArgumentException("Invalid flag combination '" + flags +
        "': specify at least exactly one of SEFLG_TRANSIT_LONGITUDE (" +
        SweConst.SEFLG_TRANSIT_LONGITUDE + "), SEFLG_TRANSIT_LATITUDE (" +
        SweConst.SEFLG_TRANSIT_LATITUDE + "), SEFLG_TRANSIT_DISTANCE (" +
        SweConst.SEFLG_TRANSIT_DISTANCE + ").");
    }
    if (pl1<SweConst.SE_SUN ||
        pl1>SweConst.SE_INTP_PERG ||
        pl1==SweConst.SE_EARTH) {
      throw new IllegalArgumentException(
          "Unsupported planet number " + pl1 + " ("+
              sw.swe_get_planet_name(pl1) + ")");
    }
    if (pl2<SweConst.SE_SUN ||
        pl2>SweConst.SE_INTP_PERG ||
        pl2==SweConst.SE_EARTH) {
      throw new IllegalArgumentException(
          "Unsupported planet number " + pl1 + " ("+
              sw.swe_get_planet_name(pl1) + ")");
    }
    if ((flags & SweConst.SEFLG_HELCTR) != 0 &&
        (pl1 == SweConst.SE_MEAN_APOG ||
         pl1 == SweConst.SE_OSCU_APOG ||
         pl1 == SweConst.SE_MEAN_NODE ||
         pl1 == SweConst.SE_TRUE_NODE)) {
      throw new IllegalArgumentException(
          "Unsupported planet number " + pl1 + " (" +
              sw.swe_get_planet_name(pl1) + ") for heliocentric " +
              "calculations");
    }
    if ((flags & SweConst.SEFLG_HELCTR) != 0 &&
        (pl2 == SweConst.SE_MEAN_APOG ||
         pl2 == SweConst.SE_OSCU_APOG ||
         pl2 == SweConst.SE_MEAN_NODE ||
         pl2 == SweConst.SE_TRUE_NODE)) {
      throw new IllegalArgumentException(
          "Unsupported planet number " + pl2 + " (" +
              sw.swe_get_planet_name(pl2) + ") for heliocentric " +
              "calculations");
    }
    if (pl1 == pl2) {
      throw new IllegalArgumentException(
                   "Transiting and referred planet have to be different!");
    }
    this.pl1 = pl1;
    this.pl2 = pl2;
    calcYoga = ((flags & SweConst.SEFLG_YOGA_TRANSIT) != 0);
    // The index into the xx[] array in swe_calc() to use:
    if ((flags&SweConst.SEFLG_TRANSIT_LATITUDE) != 0) { // Calculate latitudinal transits
      idx = 1;
    } else if ((flags&SweConst.SEFLG_TRANSIT_DISTANCE) != 0) { // Calculate distance transits
      idx = 2;
    }
    if ((flags&SweConst.SEFLG_TRANSIT_SPEED) != 0) { // Calculate speed transits
      idx += 3;
      flags |= SweConst.SEFLG_SPEED;
    }
    // Eliminate SEFLG_TRANSIT_* flags for use in swe_calc():
    flags &= ~(SweConst.SEFLG_TRANSIT_LONGITUDE |
               SweConst.SEFLG_TRANSIT_LATITUDE |
               SweConst.SEFLG_TRANSIT_DISTANCE |
               SweConst.SEFLG_YOGA_TRANSIT |
               SweConst.SEFLG_TRANSIT_SPEED);
    this.flags = flags;
    // Calculate basic parameters: ///////////////////////////////////////////
    rollover = (idx == 0);
    this.offset = checkOffset(offset);
    maxSpeed1=getSpeed(false,pl1);
    minSpeed1=getSpeed(true,pl1);
    maxSpeed2=getSpeed(false,pl2);
    minSpeed2=getSpeed(true,pl2);
    if (calcYoga) {
      minSpeed = minSpeed1+minSpeed2;
      maxSpeed = maxSpeed1+maxSpeed2;
    } else {
      if (rollover) {
        minSpeed = (maxSpeed1>maxSpeed2)?minSpeed1-maxSpeed2:minSpeed2-maxSpeed1;
        maxSpeed = (maxSpeed1>maxSpeed2)?maxSpeed1-minSpeed2:maxSpeed2-minSpeed1;
      } else {
        minSpeed = Math.max(minSpeed1-maxSpeed2, minSpeed2-maxSpeed1);
        maxSpeed = Math.max(maxSpeed1-minSpeed2, maxSpeed2-minSpeed1);
      }
    }
  }
  
  public boolean getRollover() {
    return rollover;
  }
  
  public void setOffset(double value) {
    offset = checkOffset(value);
  }
  
  public double getOffset() {
    return offset;
  }
  
  public Object[] getObjectIdentifiers() {
    return new Object[]{"" + pl1, "" + pl2};
  }
  ///////////////////////////////////////////////////////////////////////////////
  protected double getMaxSpeed() {
    return maxSpeed;
  }
  protected double getMinSpeed() {
    return minSpeed;
  }
  protected double calc(double jdET) {
    StringBuffer serr = new StringBuffer();
    double[] xx1 = new double[6];
    double[] xx2 = new double[6];
    int ret = sw.swe_calc(jdET, pl1, flags, xx1, serr);
    if (ret<0) {
      throw new SwissephException(jdET, SwissephException.UNDEFINED,
          "Calculation failed with return code " + ret + ":\n" +
          serr.toString());
    }
    ret = sw.swe_calc(jdET, pl2, flags, xx2, serr);
    if (ret<0) {
      throw new SwissephException(jdET, SwissephException.UNDEFINED,
          "Calculation failed with return code " + ret + ":\n" +
          serr.toString());
    }
    return xx1[idx] + (calcYoga?xx2[idx]:-xx2[idx]);
  }
  protected double getTimePrecision(double degPrec) {
    // Recalculate degPrec to mean the minimum  time, in which the planet can
    // possibly move that degree:
    double amin = Math.min(Math.abs(minSpeed1),Math.abs(minSpeed2));
    double amax = Math.min(Math.abs(maxSpeed1),Math.abs(maxSpeed2));
    double maxVal = Math.max(Math.abs(amin),Math.abs(amax));
    if (maxVal != 0.) {
      return degPrec / maxVal;
    }
    return 1E-9;
  }
  protected double getDegreePrecision(double jd) {
    // Calculate the planet's minimum movement regarding the maximum available
    // precision.
    //
    // For all calculations, we assume the following minimum exactnesses
    // based on the discussions on http://www.astro.com/swisseph, even though
    // these values are nothing more than very crude estimations which should
    // leave us on the save side always, even more, when seeing that we always
    // consider the maximum possible speed / acceleration of a planet in the
    // transit calculations and not the real speed.
    //
    // Take degPrec to be the minimum exact degree in longitude
    double degPrec = 0.005;
    if (idx>2) { // Speed
      // "The speed precision is now better than 0.002" for all planets"
      degPrec = 0.002;
    } else { // Degrees
      // years 1980 to 2099:              0.005"
      // years before 1980:               0.08"   (from sun to jupiter)
      // years 1900 to 1980:              0.08"   (from saturn to neptune) (added: nodes)
      // years before 1900:               1"      (from saturn to neptune) (added: nodes)
      // years after 2099:                same as before 1900
      //
      if (pl1>=SweConst.SE_SUN && pl1<=SweConst.SE_JUPITER) {
        if (jd<1980 || jd>2099) {
          degPrec = 0.08;
        }
      } else {
        if (jd>=1900 && jd<1980) {
          degPrec = 0.08;
        } else if (jd<1900 || jd>2099) { // Unclear about true nodes...
          degPrec = 1;
        }
      }
      if (pl2>=SweConst.SE_SUN && pl2<=SweConst.SE_JUPITER) {
        if (jd<1980 || jd>2099) {
          degPrec = Math.max(0.08,degPrec);
        }
      } else {
        if (jd>=1900 && jd<1980) {
          degPrec = Math.max(0.08,degPrec);
        } else if (jd<1900 || jd>2099) { // Unclear about true nodes...
          degPrec = Math.max(1,degPrec);
        }
      }
    }
    degPrec/=3600.;
    degPrec*=0.5; // We take the precision to be BETTER THAN ... as it is stated somewhere
    // We recalculate these degrees to the minimum time difference that CAN
    // possibly give us data differing more than the above given precision.
    switch (idx) {
      case 0: // Longitude
      case 1: // Latitude
      case 3: // Speed in longitude
      case 4: // Speed in latitude
        break;
      case 2: // Distance
      case 5: // Speed in distance
        // We need to recalculate the precision in degrees to a distance value.
        // For this we need the maximum distance to the centre of calculation,
        // which is the barycentre for the main planets.
        degPrec *= Math.max(sw.ext.maxBaryDist[pl1],
                            sw.ext.maxBaryDist[pl2]);
    }
    return degPrec;
  }
  private double checkOffset(double val) {
    // Similar rollover considerations for the latitude will be necessary, if
    // swe_calc() would return latitudinal values beyond -90 and +90 degrees.
    if (rollover) {        // Longitude from 0 to 360 degrees:
      while (val < 0.) { val += 360.; }
      val %= 360.;
      minVal = 0.;
      maxVal = 360.;
    } else if (idx == 1) { // Latitude from -90 to +90 degrees:
      while (val < -90.) { val += 180.; }
      while (val >  90.) { val -= 180.; }
      minVal = -90.;
      maxVal = +90.;
    }
    return val;
  }
  private double getSpeed(boolean min, int planet) {
    boolean lat = ((tflags&SweConst.SEFLG_TRANSIT_LATITUDE) != 0);
    boolean dist = ((tflags&SweConst.SEFLG_TRANSIT_DISTANCE) != 0);
    boolean speed = ((tflags&SweConst.SEFLG_TRANSIT_SPEED) != 0);
    boolean topo = ((tflags&SweConst.SEFLG_TOPOCTR) != 0);
    boolean helio = ((tflags&SweConst.SEFLG_HELCTR) != 0);
    // Some topocentric speeds are very different to the geocentric
    // speeds, so we use other values than for geocentric calculations:
    if (topo) {
      if (!sw.swed.geopos_is_set) {
        throw new IllegalArgumentException("Geographic position is not set for "+
                                           "requested topocentric calculations.");
      }
      if (sw.swed.topd.geoalt>50000.) {
        throw new IllegalArgumentException("Topocentric transit calculations "+
                                           "are restricted to a maximum "+
                                           "altitude of 50km so far.");
      } else if (sw.swed.topd.geoalt<-12000000) {
        throw new IllegalArgumentException("Topocentric transit calculations "+
                                           "are restricted to a minimum "+
                                           "altitude of -12000km so far.");
      }
      if (speed) {
        if (lat) {
          return (min?SwephData.minTopoLatAccel[planet]:SwephData.maxTopoLatAccel[planet]);
        } else if (dist) {
          return (min?SwephData.minTopoDistAccel[planet]:SwephData.maxTopoDistAccel[planet]);
        } else {
          return (min?SwephData.minTopoLonAccel[planet]:SwephData.maxTopoLonAccel[planet]);
        }
      } else {
        if (lat) {
          return (min?SwephData.minTopoLatSpeed[planet]:SwephData.maxTopoLatSpeed[planet]);
        } else if (dist) {
          return (min?SwephData.minTopoDistSpeed[planet]:SwephData.maxTopoDistSpeed[planet]);
        } else {
          return (min?SwephData.minTopoLonSpeed[planet]:SwephData.maxTopoLonSpeed[planet]);
        }
      }
    }
    // Heliocentric speeds are very different to the geocentric speeds, so
    // we use other values than for geocentric calculations:
    if (helio) {
      if (speed) {
        if (lat) {
          return (min?SwephData.minHelioLatAccel[planet]:SwephData.maxHelioLatAccel[planet]);
        } else if (dist) {
          return (min?SwephData.minHelioDistAccel[planet]:SwephData.maxHelioDistAccel[planet]);
        } else {
          return (min?SwephData.minHelioLonAccel[planet]:SwephData.maxHelioLonAccel[planet]);
        }
      } else {
        if (lat) {
          return (min?SwephData.minHelioLatSpeed[planet]:SwephData.maxHelioLatSpeed[planet]);
        } else if (dist) {
          return (min?SwephData.minHelioDistSpeed[planet]:SwephData.maxHelioDistSpeed[planet]);
        } else {
          return (min?SwephData.minHelioLonSpeed[planet]:SwephData.maxHelioLonSpeed[planet]);
        }
      }
    }
    // Geocentric:
    if (speed) {
      if (lat) {
        return (min?SwephData.minLatAccel[planet]:SwephData.maxLatAccel[planet]);
      } else if (dist) {
        return (min?SwephData.minDistAccel[planet]:SwephData.maxDistAccel[planet]);
      } else {
        return (min?SwephData.minLonAccel[planet]:SwephData.maxLonAccel[planet]);
      }
    } else {
      if (lat) {
        return (min?SwephData.minLatSpeed[planet]:SwephData.maxLatSpeed[planet]);
      } else if (dist) {
        return (min?SwephData.minDistSpeed[planet]:SwephData.maxDistSpeed[planet]);
      } else {
        return (min?SwephData.minLonSpeed[planet]:SwephData.maxLonSpeed[planet]);
      }
    }
  }
  public String toString() {
    return "[Planets:" + pl1 + "/" + pl2 + "];Offset:" + getOffset();
  }
}
class TopoData {
  double geolon, geolat, geoalt;
  double teval;
  double tjd_ut;
  double xobs[]=new double[6];
}
abstract class TransitCalculator {
  SwissEph sw;
  // This method changes the offset value for the transit
  
  public abstract boolean getRollover();
  
  public abstract void setOffset(double value);
  
  public abstract double getOffset();
  
  public Object[] getObjectIdentifiers() {
    return null;
  }
  //////////////////////////////////////////////////////////////////////////////
  // Rollover from 360 degrees to 0 degrees for planetary longitudinal positions
  // or similar, or continuous and unlimited values:
  protected boolean rollover = false; // We need a rollover of 360 degrees being
                                      // equal to 0 degrees for longitudinal
                                      // position transits only.
  protected double rolloverVal = 360.; // if rollover, we roll over from 360 to 0
                                       // as default. Other values than 0.0 for the
                                       // minimum values are not supported for now.
  // These methods have to return the maxima of the first derivative of the
  // function, mathematically spoken...
  protected abstract double getMaxSpeed();
  protected abstract double getMinSpeed();
  // This method returns the precision in x-direction in an x-y-coordinate
  // system for the transit calculation routine.
  protected abstract double getDegreePrecision(double jdET);
  // This method returns the precision in y-direction in an x-y-coordinate
  // system from the x-direction precision.
  protected abstract double getTimePrecision(double degPrec);
  // This is the main routine, mathematically speaking: returning f(x):
  protected abstract double calc(double jdET);
}
class TransitValues {
  TransitCalculator tc = null;
  int tcIndex = 0; // Keep track of which tc is saved to jdET
  double transitVal = 0./0.;
  double jdStart = 0./0.;
  double jdEnd = 0./0.;
  double tvOffset = 0./0.;
  double zTmp = 0./0.;
  double z0 = 0./0.; // The final minimum value
  double zm = 0./0.;
  double zp = 0./0.;
  boolean varyingTransitPoints = false;  // e.g. -lon60+10 with -n, -N, -b -b, -b -B
  boolean duplicateTransitPoints = false; // e.g. -lon60+10 -N / -B only
  boolean outOfTimeRange = false;
  boolean back = false;
  boolean rollover = false;
}
class TransitOffsets {
  int idxOffset = 0;           // The index into the xx[] array in swe_calc*()
                               // 0 to 5: lon / lat / dist / speed in lon /
                               //         lat / dist
  Double[] values = null;      // The transit values, over which the
                               // the transits should be calculated
  double offset = 0.;          // An optional offset to be added to
                               // the transit values on each calculation
                               // iteration
}
class ObjFormatter {
  String postfix = "";
  Object[] arr = null;
  ObjFormatter(Object[] arr, String postfix) {
    this.arr = arr;
    this.postfix = postfix;
  }
  String format(int idx) {
    return arr[idx].toString() + postfix;
  }
}
class TransitArguments {
  // CH-Zuerich:
  double top_long = 8.55;
  double top_lat = 47.38;
  double top_elev = 400;
  // Default values for optional parameter:
  boolean withHeader = true;
  boolean back = false;
  boolean isUt = false; // Time of starting date
  boolean isUT = false; // Time of end date
  boolean calcSpeed = false;
  int sidmode=-1;                 // Means: tropical mode
  int whicheph = SweConst.SEFLG_SWIEPH;
  String ephepath = SweConst.SE_EPHE_PATH;
  String sBeginhour = "";
  double beginhour = 0;
  String pls2 = null;
  int pl2 = -2;                   // Means: not set
  double count = 1;
  // JPL:
  String fname=SweConst.SE_FNAME_DE406;
  String topoS = null;
  boolean convert = false;
  // Derived values:
  boolean countIsSet = false;
  // duplicateTransitPoints, e.g. -lat0+0.01 with -N / -B only
  boolean duplicateTransitPoints = false;   // multiple transit points
  // varyingTransitPoints, e.g. -lat0+0.01 with -N, -n / -b -B, -b -b
  boolean varyingTransitPoints = false;
  boolean yogaTransit = true;
  boolean helio = false;
  int iflag = 0;  // Flags to be used for transit calculations
  int cflag = 0;  // Flags to be used for pure calculations
  boolean outputFormatIsSet = false;
  String outputFormat = "dt";
  double zm = 0;
  double zp = 0;
  // A string containing the type and value of the transit point, e.g.:
  //    +lon0         for yoga transits over 0 degrees in longitude.
  //    -lat0+0.01    for transits over 0 degrees in latitude with 0.01 degree
  //                  increment.
  //    -lon30/45/60/90/120/180/270
  //                  for transits over any of these longitudinal degrees
  String transitValString="";
  // Required parameters:
  int pl1 = -2;
  String pls1 = null;
  String begindate = null;
  String enddate = null;
  String sEndhour = "";
  double endhour = 1./0.;         // Means: not set
  boolean endTimeIsSet = false;
  // Intermediate or other derived parameters:
  TransitOffsets to = null;
  boolean mp1 = false; // More than one planet
  boolean mp2 = false; // More than one planet on relative or yoga transits
  double tjde1 = 0.;
  double tjde2 = 0.;
  int[][] plNumbers = null;
  SweDate   sde1 = new SweDate();
  SweDate   sde2 = new SweDate();
  boolean rollover = false;
  TransitValues v = new TransitValues();
  int idxDuplicates = 0;
  boolean withDuplicates = true;
  double jdET2 = 0.;
}
class TransitResult {
  // The index in the array of all TransitCalculators returning the
  // nearest transit point:
  public int tcsNo = 0;
  // The nearest transit point found, Double.MAX_VALUE or Double.MIN_VALUE,
  // if no transit found:
  public double jdET = 0./0.;
  // The planet numbers:
  public int pl1 = 0;
  public int pl2 = 0;
  public double transitValue = 0./0.;
  public String toString() {
    return "tcs[" + tcsNo + "];pl:" + pl1 + "/" + pl2 + ";" + jdET;
  }
}
class Vedic {
    
    public String getReading(int day, int month, int year, double latitude, double longitude, double time, double greenwichOffset) {
	int SID_METHOD = SweConst.SE_SIDM_LAHIRI;
	String[] signNames = { "Aries","Taurus","Gemini","Cancer","Leo","Virgo",
			       "Libra","Scorpio","Sagittarius","Capricorn","Aquarius",
			       "Pisces"};
	
	double hour = time + (0. / 60.) + greenwichOffset; // IST				
	SwissEph sw = new SwissEph();
	SweDate sd = new SweDate(year, month, day, hour);
	sw.swe_set_sid_mode(SID_METHOD, 0, 0);
	double[] cusps = new double[13];
	double[] acsc = new double[10];
	double[] xp = new double[6];
	StringBuffer serr = new StringBuffer();
	double ayanamsa = sw.swe_get_ayanamsa_ut(sd.getJulDay());
	int flags = SweConst.SEFLG_SIDEREAL;
	int result = sw.swe_houses(sd.getJulDay(), flags, latitude, longitude, 'P', cusps, acsc);
	int ascSign = (int) (acsc[0] / 30) + 1;
	String ascOut = signNames[ascSign-1];
	
	flags = SweConst.SEFLG_SWIEPH | 
	    SweConst.SEFLG_SIDEREAL | 
	    SweConst.SEFLG_NONUT | 
	    SweConst.SEFLG_SPEED;
	int sign;
	int house;
	boolean retrograde = false;
	String output = "{";
	output += "'Ascending': ['" + ascOut + "'],";
	
	int[] planets = { SweConst.SE_SUN, SweConst.SE_MOON, SweConst.SE_MARS, SweConst.SE_MERCURY, SweConst.SE_JUPITER,
			  SweConst.SE_VENUS, SweConst.SE_SATURN, SweConst.SE_TRUE_NODE }; // Some
	for (int p = 0; p < planets.length; p++) {
	    int planet = planets[p];
	    String planetName = sw.swe_get_planet_name(planet);
	    int ret = sw.swe_calc_ut(sd.getJulDay(), planet, flags, xp, serr);
	    sign = (int) (xp[0] / 30) + 1;
	    house = (sign + 12 - ascSign) % 12 + 1;
	    retrograde = (xp[3] < 0);
	    output += String.format("'%s': ['%s',%d],", planetName,signNames[sign-1],house);
	}
	xp[0] = (xp[0] + 180.0) % 360;
	String planetName = "Ketu (true)";
	sign = (int) (xp[0] / 30) + 1;
	house = (sign + 12 - ascSign) % 12 + 1;
	output += String.format("'%s': ['%s',%d]", planetName,signNames[sign-1],house);
	output += "}";	
	return output;
    }
    public void test() {
	int year = 1973;
	int month = 4;
	int day = 24;
	double longitude = 32.85646943314241;
	double latitude = 39.941139297390365;
	double time = 10;
	double greenwichOffset = -3;
	String res = getReading(day, month, year, latitude, longitude, time, greenwichOffset);
	System.out.println(res);		
    }
    public String getReading(String[] args) {
	int day = Integer.valueOf(args[0]);
	int mon = Integer.valueOf(args[1]);
	int year = Integer.valueOf(args[2]);
	double time = Double.valueOf(args[3]);
	double latitude = Double.valueOf(args[4]);
	double longitude = Double.valueOf(args[5]);
	double greenwichOffset = -1 * Double.valueOf(args[6]);
	//System.out.printf("Java received %d %d %d %f %f %f %f", day,mon,year,time,latitude,longitude,offset);
	String res = getReading(day, mon, year, latitude, longitude, time, greenwichOffset);
	//System.out.println(res);		
	return res;
    }
    
    public static void main(String[] args) {
	Vedic v = new Vedic();
	//v.test();
	String res = v.getReading(args);
	System.out.println(res); 
    }
}
class VedicTest {
    
    private static final int SID_METHOD = SweConst.SE_SIDM_LAHIRI;
    private static final String[] signNames = { "Aries","Taurus","Gemini","Cancer","Leo","Virgo",
						"Libra","Scorpio","Sagittarius","Capricorn","Aquarius","Pisces"};
    
    public static void main(String[] args) {
	System.out.println((int)'P');
				
	int year = 1973;
	int month = 4;
	int day = 24;
	double longitude = 32.85646943314241;
	double latitude = 39.941139297390365;
	double hour = 10 + (0. / 60.) - 3; // IST
				
	SwissEph sw = new SwissEph();
	SweDate sd = new SweDate(year, month, day, hour);
	System.out.println(sd.getDate(0).toString());
	// Set sidereal mode:
	sw.swe_set_sid_mode(SID_METHOD, 0, 0);
	// Some required variables:
	double[] cusps = new double[13];
	double[] acsc = new double[10];
	double[] xp = new double[6];
	StringBuffer serr = new StringBuffer();
	// Print input details:
	System.out.println("Date (YYYY/MM/DD): " + sd.getYear() + "/" + sd.getMonth() + "/" + sd.getDay() + ", "
			   + toHMS(sd.getHour()));
	System.out.println("Jul. day:  " + sd.getJulDay());
	System.out.println("DeltaT:    " + sd.getDeltaT() * 24 * 3600 + " sec.");
	System.out.println("Location:  " + toDMS(Math.abs(longitude)) + (longitude > 0 ? "E" : "W") + " / "
			   + toDMS(Math.abs(latitude)) + (latitude > 0 ? "N" : "S"));
	// Get and print ayanamsa value for info:
	double ayanamsa = sw.swe_get_ayanamsa_ut(sd.getJulDay());
	System.out.println("Ayanamsa:  " + toDMS(ayanamsa) + " (" + sw.swe_get_ayanamsa_name(SID_METHOD) + ")");
	// Get and print lagna:
	int flags = SweConst.SEFLG_SIDEREAL;
	int result = sw.swe_houses(sd.getJulDay(), flags, latitude, longitude, 'P', cusps, acsc);
	System.out.println("Ascendant: " + toDMS(acsc[0]) + "\n");
	int ascSign = (int) (acsc[0] / 30) + 1;
	System.out.println("Ascendant Sign: " + signNames[ascSign-1] + "\n");
	// Calculate all planets:
	int[] planets = { SweConst.SE_SUN, SweConst.SE_MOON, SweConst.SE_MARS, SweConst.SE_MERCURY, SweConst.SE_JUPITER,
			  SweConst.SE_VENUS, SweConst.SE_SATURN, SweConst.SE_TRUE_NODE }; // Some
	// systems
	// prefer
	// SE_MEAN_NODE
	flags = SweConst.SEFLG_SWIEPH | // fastest method, requires data files
	    SweConst.SEFLG_SIDEREAL | // sidereal zodiac
	    SweConst.SEFLG_NONUT | // will be set automatically for sidereal
	    // calculations, if not set here
	    SweConst.SEFLG_SPEED; // to determine retrograde vs. direct
	// motion
	int sign;
	int house;
	boolean retrograde = false;
	for (int p = 0; p < planets.length; p++) {
	    int planet = planets[p];
	    String planetName = sw.swe_get_planet_name(planet);
	    int ret = sw.swe_calc_ut(sd.getJulDay(), planet, flags, xp, serr);
	    if (ret != flags) {
		if (serr.length() > 0) {
		    System.err.println("Warning: " + serr);
		} else {
		    System.err.println(String.format("Warning, different flags used (0x%x)", ret));
		}
	    }
	    sign = (int) (xp[0] / 30) + 1;
	    System.out.println(planetName);
	    System.out.println(signNames[sign-1]);
	    house = (sign + 12 - ascSign) % 12 + 1;
	    retrograde = (xp[3] < 0);
	    System.out.printf("%-12s: %s %c; sign: %2d; %s in house %2d\n", planetName, toDMS(xp[0]),
			      (retrograde ? 'R' : 'D'), sign, toDMS(xp[0] % 30), house);
	}
	// KETU
	xp[0] = (xp[0] + 180.0) % 360;
	String planetName = "Ketu (true)";
	sign = (int) (xp[0] / 30) + 1;
	house = (sign + 12 - ascSign) % 12 + 1;
	System.out.printf("%-12s: %s %c; sign: %2d; %s in house %2d\n", planetName, toDMS(xp[0]),
			  (retrograde ? 'R' : 'D'), sign, toDMS(xp[0] % 30), house);
    }
    static String toHMS(double d) {
	d += 0.5 / 3600.; // round to one second
	int h = (int) d;
	d = (d - h) * 60;
	int min = (int) d;
	int sec = (int) ((d - min) * 60);
		
	return String.format("%2d:%02d:%02d", h, min, sec);
    }
    static String toDMS(double d) {
	d += 0.5 / 3600. / 10000.; // round to 1/1000 of a second
	int deg = (int) d;
	d = (d - deg) * 60;
	int min = (int) d;
	d = (d - min) * 60;
	double sec = d;
	return String.format("%3d%02d'%07.4f\"", deg, min, sec);
    }
	
}

class Swetest {

    public String globalResult = ""; 
    
    SwissData swed = new SwissData();
    SwissLib  sl   = new SwissLib();
    SwissEph  sw   = new SwissEph();
    SweDate   sd   = null;
    CFmt      f    = new CFmt();

    static final double J2000=2451545.0;  /* 2000 January 1.5 */
    public double square_sum(double x[]) { return x[0]*x[0]+x[1]*x[1]+x[2]*x[2]; }
    public static final int SEFLG_EPHMASK=SweConst.SEFLG_JPLEPH|
        SweConst.SEFLG_SWIEPH|
        SweConst.SEFLG_MOSEPH;

    static final int BIT_ROUND_SEC=1;
    static final int BIT_ROUND_MIN=2;
    static final int BIT_ZODIAC=4;
    static final String PLSEL_D="0123456789mtA";
    static final String PLSEL_P="0123456789mtA"+
        "BCcg"+
        "DEFGHI";
    static final String PLSEL_H="JKLMNOPQRSTUVWXYZw";
    static final String PLSEL_A="0123456789mtABCcgDEFGHIJKLMNOPQRSTUVWXYZw";

    static final char DIFF_DIFF='d';
    static final char DIFF_MIDP='D';
    static final int MODE_HOUSE=1;
    static final int MODE_LABEL=2;

    String se_pname;
    public static final String[] zod_nam = new String[]
        {"ar", "ta", "ge", "cn", "le", "vi",
         "li", "sc", "sa", "cp", "aq", "pi"};

    String star = "algol", star2;
    String sastno = "433";
    String shyp = "1";

    /* globals shared between main() and print_line() */
    String fmt = "PLBRS";
    String gap = " ";
    double t, te, tut, jut = 0;
    int jmon, jday, jyear;
    int ipl = SweConst.SE_SUN, ipldiff = SweConst.SE_SUN, nhouses = 12;
    String spnam, spnam2="";
    StringBuffer serr=new StringBuffer(swed.AS_MAXCH);
    StringBuffer serr_save=new StringBuffer(swed.AS_MAXCH);
    StringBuffer serr_warn=new StringBuffer(swed.AS_MAXCH);
    boolean gregflag = SweDate.SE_GREG_CAL;
    int diff_mode = 0;
    boolean universal_time = false;
    int round_flag = 0;
    double x[]=new double[6], x2[]=new double[6], xequ[]=new double[6],
        xcart[]=new double[6], xcartq[]=new double[6],
        xobl[]=new double[6], xaz[]=new double[6], xt[]=new double[6],
        geopos[]=new double[3], hpos, hpos2, armc, xsv[]=new double[6];
    DblObj hposj=new DblObj();
    int hpos_meth = 0;
    double attr[]=new double[20], tret[]=new double[20];
    int iflag = 0, iflag2;              /* external flag: helio, geo... */
    static final String hs_nam[] = {"undef",
                                    "Ascendant", "MC", "ARMC", "Vertex"};
    int smod = 0;
    int direction = 1;
    boolean direction_flag = false;
    double tjd = 2415020.5;
    int nstep = 1, istep;
    int search_flag = 0;
    String sout;
    int whicheph = SweConst.SEFLG_SWIEPH;
    String psp;
    int p=0; // Index for psp
    boolean norefrac = false;
    boolean disccenter = false;

    static final int SMOD_LUNAR    =1;
    static final int SMOD_HOW      =2;       /* an option for Lunar */
    static final int SMOD_SOLAR    =4;
    static final int SMOD_LOCAL    =8;       /* an option for Solar */
    static final int SMOD_TOTAL    =16;
    static final int SMOD_ANNULAR  =32;      /* count as penumbral for Lunar */
    static final int SMOD_ANNTOT   =64;
    static final int SMOD_PARTIAL  =128;
    static final int SMOD_PENUMBRAL=256;
    static final int SMOD_ALL      =(SMOD_TOTAL| SMOD_ANNULAR|SMOD_PARTIAL|SMOD_ANNTOT);
    static final int SMOD_OCCULT   =512;
    static final int SMOD_RISE     =1024;
    static final int SMOD_METR     =2048;
    static final int SMOD_HOCAL    =4096;


    static final int ECL_LUN_PENUMBRAL     =1;       /* eclipse types for hocal list */
    static final int ECL_LUN_PARTIAL       =2;
    static final int ECL_LUN_TOTAL         =3;
    static final int ECL_SOL_PARTIAL       =4;
    static final int ECL_SOL_ANNULAR       =5;
    static final int ECL_SOL_TOTAL         =6;

    String SE_EPHE_PATH="";

    /**
     * This class is not to be instantiated, it is to be run via the main method.
     */
    public Swetest() { }

    /**
     * Use the parameter -h to get infos about the available options.
     */
    public static void main(String argv[]) {
        Swetest swt=new Swetest();
        System.exit(swt.main_start(argv));
    }

    public int main_start(String[] argv) {
        String saves="";
        String s1, s2;
        String sp, spsave, sp2;
        String spno;
        String plsel = PLSEL_D;
        int i, j, n, iflag_f = -1, iflgt;
        int line_count, line_limit = 3200000;
        double daya;
        double top_long = 0; /* Greenwich, UK */
        double top_lat = 51.5;
        double top_elev = 0;
        boolean have_geopos = false;
        int ihsy = (int)'p';
        boolean do_houses = false;
        String ephepath;
        String fname;
        String sdate;
        String begindate = null;
        long iflgret;
        boolean with_header = true;
        boolean with_header_always = false;
        boolean do_ayanamsa = false;
        int sid_mode = SweConst.SE_SIDM_FAGAN_BRADLEY;
        double t2, tstep = 1, thour = 0;
        double delt;
        serr.setLength(0); serr_save.setLength(0); serr_warn.setLength(0);
        saves = "";

        sd=new SweDate(tjd,gregflag);

        ephepath="";
        fname=SweConst.SE_FNAME_DE406;
        for (i = 0; i < argv.length; i++) {
            if (argv[i].startsWith("-DSE_EPHE_PATH")) {
                if (++i<argv.length) {
                    SE_EPHE_PATH=argv[i];
                }
            } else if (argv[i].startsWith("-ut")) {
                universal_time = true;
                if (argv[i].length() > 3) {
                    s1=argv[i].substring(3);
                    if (s1.indexOf(':')>=0) {
                        s1=s1.substring(0,s1.indexOf(':'))+"."+s1.substring(s1.indexOf(':')+1);
                        if (s1.indexOf(':')>=0) {
                            s1=s1.substring(0,s1.indexOf(':'))+s1.substring(s1.indexOf(':')+1);
                        }
                    }
                    thour = Double.valueOf(s1).doubleValue();
                    /* h.mmss -> decimal */
                    // Allowing for negative times: this is different from the C code!
                    t = (thour%1.0) * 100 + (thour<0?-1e-10:1e-10);
                    j = (int) t;
                    t = (t%1.0) * 100 + 1e-10;
                    thour = (int) thour + j / 60.0 + t / 3600.0;
                }
            } else if (argv[i].startsWith("-head")) {
                with_header = false;
            } else if (argv[i].startsWith("+head")) {
                with_header_always = true;
            } else if (argv[i].equals("-j2000")) {
                iflag |= SweConst.SEFLG_J2000;
            } else if (argv[i].equals("-icrs")) {
                iflag |= SweConst.SEFLG_ICRS;
            } else if (argv[i].startsWith("-ay")) {
                do_ayanamsa = true;
                sid_mode=0;
                if (argv[i].length()>3) {
                    sid_mode=Integer.parseInt(argv[i].substring(3));
                }
                sw.swe_set_sid_mode(sid_mode, 0, 0);
            } else if (argv[i].startsWith("-sidt0")) {
                iflag |= SweConst.SEFLG_SIDEREAL;
                //      sid_mode = atol(argv[i]+6);
                sid_mode=0;
                if (argv[i].length()>6) {
                    sid_mode=Integer.parseInt(argv[i].substring(6));
                }
                if (sid_mode == 0)
                    sid_mode = SweConst.SE_SIDM_FAGAN_BRADLEY;
                sid_mode |= SweConst.SE_SIDBIT_ECL_T0;
                sw.swe_set_sid_mode(sid_mode, 0, 0);
            } else if (argv[i].startsWith("-sidsp")) {
                iflag |= SweConst.SEFLG_SIDEREAL;
                //      sid_mode = atol(argv[i]+6);
                sid_mode=0;
                if (argv[i].length()>6) {
                    sid_mode=Integer.parseInt(argv[i].substring(6));
                }
                if (sid_mode == 0)
                    sid_mode = SweConst.SE_SIDM_FAGAN_BRADLEY;
                sid_mode |= SweConst.SE_SIDBIT_SSY_PLANE;
                sw.swe_set_sid_mode(sid_mode, 0, 0);
            } else if (argv[i].startsWith("-sid")) {
                iflag |= SweConst.SEFLG_SIDEREAL;
                //      sid_mode = atol(argv[i]+4);
                sid_mode=0;
                if (argv[i].length()>4) {
                    try {
                        sid_mode=Integer.parseInt(argv[i].substring(4));
                    } catch (NumberFormatException nf) {
                        // Anything not being a number will be considered '0'
                    }
                }
                if (sid_mode > 0)
                    sw.swe_set_sid_mode(sid_mode, 0, 0);
            } else if (argv[i].startsWith("-j")) {
                begindate = argv[i].substring(1);
            } else if (argv[i].startsWith("-ejpl")) {
                whicheph = SweConst.SEFLG_JPLEPH;
                if (argv[i].length()>5)
                    fname=argv[i].substring(5);
            } else if (argv[i].startsWith("-edir")) {
                if (argv[i].length() > 5)
                    ephepath=argv[i].substring(5);
            } else if (argv[i].startsWith("-eswe")) {
                whicheph = SweConst.SEFLG_SWIEPH;
            } else if (argv[i].startsWith("-emos")) {
                whicheph = SweConst.SEFLG_MOSEPH;
            } else if (argv[i].equals("-hel")) {
                iflag |= SweConst.SEFLG_HELCTR;
            } else if (argv[i].equals("-bary")) {
                iflag |= SweConst.SEFLG_BARYCTR;
            } else if (argv[i].startsWith("-house")) {
                sout="";
                boolean hLonIsSet=false;
                boolean hLatIsSet=false;
                // sscanf(argv[i] + 6, "%lf,%lf,%s", &top_long, &top_lat, sout);
                try {
                    String h=argv[i].substring(6);
                    int idx=h.indexOf(',');
                    String hf=h.substring(0,idx);
                    top_long=Double.valueOf(hf).doubleValue();
                    hLonIsSet=true;
                    h=h.substring(idx+1);
                    idx=h.indexOf(',');
                    if (idx<0) { idx=h.length(); }
                    hf=h.substring(0,idx);
                    top_lat=Double.valueOf(hf).doubleValue();
                    hLatIsSet=true;
                    sout=h.substring(idx+1);
                } catch (NumberFormatException nfe) {
                    if (!hLonIsSet) { top_long=0; } else { top_lat=0; }
                } catch (StringIndexOutOfBoundsException aie) {
                    if (!hLonIsSet) { top_long=0; } else if (!hLatIsSet) { top_lat=0; }
                }
                top_elev = 0;
                if (sout.length()>0) { ihsy = sout.charAt(0); }
                do_houses = true;
                have_geopos = true;
            } else if (argv[i].startsWith("-hsy")) {
                if (argv[i].length()<5) {
                    ihsy = 'p';
                } else {
                    ihsy = argv[i].charAt(4);
                }
                if (argv[i].length()>5) {
                    hpos_meth = Integer.parseInt(argv[i].substring(5));
                }
                have_geopos = true;
            } else if (argv[i].startsWith("-topo") ||
                       argv[i].startsWith("-geopos")) {
                int plen=(argv[i].startsWith("-topo")?5:7);
                if (plen==5) { iflag |= SweConst.SEFLG_TOPOCTR; }
                //      sscanf(argv[i] + 5, "%lf,%lf,%lf", &top_long, &top_lat, &top_elev);
                if (argv[i].length()>plen) {
                    String fl=argv[i].substring(plen);
                    top_long=new Double(fl.substring(0,fl.indexOf(','))).doubleValue();
                    fl=fl.substring(fl.indexOf(',')+1);
                    top_lat=new Double(fl.substring(0,fl.indexOf(','))).doubleValue();
                    fl=fl.substring(fl.indexOf(',')+1);
                    top_elev=new Double(fl).doubleValue();
                }
                have_geopos = true;
            } else if (argv[i].equals("-true")) {
                iflag |= SweConst.SEFLG_TRUEPOS;
            } else if (argv[i].equals("-noaberr")) {
                iflag |= SweConst.SEFLG_NOABERR;
            } else if (argv[i].equals("-nodefl")) {
                iflag |= SweConst.SEFLG_NOGDEFL;
            } else if (argv[i].equals("-nonut")) {
                iflag |= SweConst.SEFLG_NONUT;
            } else if (argv[i].equals("-speed3")) {
                iflag |= SweConst.SEFLG_SPEED3;
            } else if (argv[i].equals("-speed")) {
                iflag |= SweConst.SEFLG_SPEED;
            } else if (argv[i].startsWith("-testaa")) {
                whicheph = SweConst.SEFLG_JPLEPH;
                fname=SweConst.SE_FNAME_DE200;
                if (argv[i].substring(7).equals("95"))
                    begindate = "j2449975.5";
                if (argv[i].substring(7).equals("96"))
                    begindate = "j2450442.5";
                if (argv[i].substring(7).equals("97"))
                    begindate = "j2450482.5";
                fmt = "PADRu";
                universal_time = false;
                plsel="3";
            } else if (argv[i].equals("-lunecl")) {
                smod |= SMOD_LUNAR;
                smod &= ~SMOD_SOLAR;
            } else if (argv[i].equals("-solecl")) {
                smod |= SMOD_SOLAR;
                search_flag |= SweConst.SE_ECL_CENTRAL;
                search_flag |= SweConst.SE_ECL_NONCENTRAL;
                have_geopos = true;
            } else if (argv[i].equals("-occult")) {
                smod |= SMOD_OCCULT;
                smod &= ~SMOD_SOLAR;
                smod &= ~SMOD_LUNAR;
                search_flag |= SweConst.SE_ECL_CENTRAL;
                search_flag |= SweConst.SE_ECL_NONCENTRAL;
                have_geopos = true;
            } else if (argv[i].equals("-hocal")) {
                /* used to create a listing for inclusion in hocal.c source code */
                smod |= SMOD_HOCAL;
            } else if (argv[i].equals("-how")) {
                smod |= SMOD_HOW;
            } else if (argv[i].equals("-total")) {
                smod |= SMOD_TOTAL;
            } else if (argv[i].equals("-annular")) {
                smod |= SMOD_ANNULAR;
            } else if (argv[i].equals("-anntot")) {
                smod |= SMOD_ANNTOT;
            } else if (argv[i].equals("-partial")) {
                smod |= SMOD_PARTIAL;
            } else if (argv[i].equals("-penumbral")) {
                smod |= SMOD_PENUMBRAL;
            } else if (argv[i].equals("-noncentral")) {
                search_flag &= ~SweConst.SE_ECL_CENTRAL;
                search_flag |= SweConst.SE_ECL_NONCENTRAL;
            } else if (argv[i].equals("-central")) {
                search_flag &= ~SweConst.SE_ECL_NONCENTRAL;
                search_flag |= SweConst.SE_ECL_CENTRAL;
            } else if (argv[i].equals("-local")) {
                smod |= SMOD_LOCAL;
            } else if (argv[i].equals("-rise")) {
                smod |= SMOD_RISE;
                smod &= ~SMOD_SOLAR;
                have_geopos = true;
            } else if (argv[i].equals("-norefrac")) {
                norefrac = true;
            } else if (argv[i].equals("-disccenter")) {
                disccenter = true;
            } else if (argv[i].equals("-hindu")) {
                norefrac = true;
                disccenter = true;
            } else if (argv[i].equals("-metr")) {
                smod |= SMOD_METR;
                smod &= ~SMOD_SOLAR;
                have_geopos = true;
            } else if (argv[i].equals("-bwd")) {
                direction = -1;
                direction_flag = true;
            } else if (argv[i].startsWith("-p")) {
                spno="";
                if (argv[i].length()>2) {
                    spno = argv[i].substring(2);
                    switch ((int)spno.charAt(0)) {
                        case (int)'d':
                            /*
                              case (int)'\0':
                              case (int)' ':
                            */
                            plsel = PLSEL_D; break;
                        case (int)'p':  plsel = PLSEL_P; break;
                        case (int)'h':  plsel = PLSEL_H; break;
                        case (int)'a':  plsel = PLSEL_A; break;
                        default:   plsel = spno;
                    }
                } else {
                    // We need at least one char in Java, to be able to use existing code
                    plsel = " ";
                }
            } else if (argv[i].startsWith("-xs")) {
                /* number of asteroid */
                sastno="0";
                if (argv[i].length()>3) {
                    sastno=argv[i].substring(3);
                }
            } else if (argv[i].startsWith("-xf")) {
                /* name or number of fixed star */
                star="";
                if (argv[i].length()>3) {
                    star=argv[i].substring(3);
                }
            } else if (argv[i].startsWith("-xz")) {
                /* number of hypothetical body */
                if (argv[i].length()>3) {
                    shyp=argv[i].substring(3);
                }
            } else if (argv[i].startsWith("-x")) {
                /* name or number of fixed star */
                star="";
                if (argv[i].length()>2) {
                    star=argv[i].substring(2);
                }
            } else if (argv[i].startsWith("-n")) {
                nstep=0;
                if (argv[i].length()>2) {
                    nstep = Integer.parseInt(argv[i].substring(2));
                }
                if (nstep==0) {
                    nstep=20;
                }
            } else if (argv[i].startsWith("-i")) {
                if (iflag_f<0) iflag_f = 0;
                if (argv[i].length()>2) {
                    iflag_f = Integer.parseInt(argv[i].substring(2));
                }
                if ((iflag_f & SweConst.SEFLG_XYZ)!=0)
                    fmt = "PX";
            } else if (argv[i].startsWith("-s")) {
                tstep=0;
                if (argv[i].length()>2) {
                    tstep = new Double(argv[i].substring(2)).doubleValue();
                }
            } else if (argv[i].startsWith("-b")) {
                begindate="";
                if (argv[i].length()>2) {
                    begindate = argv[i].substring(2);
                }
            } else if (argv[i].startsWith("-f")) {
                fmt="";
                if (argv[i].length()>2) {
                    fmt = argv[i].substring(2);
                }
            } else if (argv[i].startsWith("-g")) {
                gap = "\t";
                if (argv[i].length()>2) {
                    gap = argv[i].substring(2);
                }
            } else if (argv[i].startsWith("-d")
                       || argv[i].startsWith("-D")) {
                diff_mode = (int)argv[i].charAt(1); /* 'd' or 'D' */
                ipldiff=-1;
                if (argv[i].length()>2) {
                    sp = argv[i].substring(2);
                    ipldiff = letter_to_ipl((int) sp.charAt(0));
                }
                if (ipldiff <0) ipldiff = SweConst.SE_SUN;
                spnam2=sw.swe_get_planet_name(ipldiff);
            } else if (argv[i].equals("-roundsec")) {
                round_flag |= BIT_ROUND_SEC;
            } else if (argv[i].equals("-roundmin")) {
                round_flag |= BIT_ROUND_MIN;
            } else if (argv[i].startsWith("-t")) {
                if (argv[i].length() > 2) {
                    s1=argv[i].substring(2);
                    if (s1.indexOf(':')>=0) {
                        s1=s1.substring(0,s1.indexOf(':'))+"."+s1.substring(s1.indexOf(':')+1);
                        if (s1.indexOf(':')>=0) {
                            s1=s1.substring(0,s1.indexOf(':'))+s1.substring(s1.indexOf(':')+1);
                        }
                    }
                    thour = Double.valueOf(s1).doubleValue();
                    /* h.mmss -> decimal */
                    // Allowing for negative times: this is different from the C code!
                    t = (thour%1.) * 100 + (thour<0?-1e-10:1e-10);
                    j = (int) t;
                    t = (t%1.) * 100 + 1e-10;
                    thour = (int) thour + j / 60.0 + t / 3600.0;
                }
            } else if (argv[i].startsWith("-h")
                       || argv[i].startsWith("-?")) {
                sp=" ";
                if (argv[i].length()>2) {
                    sp = argv[i].substring(2);
                }
                //      goto end_main;
                /* close open files and free allocated space */
                sw.swe_close();
                return SweConst.OK;
            } else {
                sout="illegal option "+argv[i]+"\n";
                DevNull.print(sout);
                System.exit(1);
            }
        }
        if ((smod & (SMOD_OCCULT | SMOD_RISE | SMOD_METR)) != 0) {
            ipl = letter_to_ipl((int)plsel.charAt(0));
            if (plsel.charAt(0) == 'f')
                ipl = SweConst.SE_FIXSTAR;
            else
                star = "";
            if ((smod & SMOD_OCCULT)!=0 && ipl == 1)
                ipl = 2; /* no occultation of moon by moon */
        }
        geopos[0] = top_long;
        geopos[1] = top_lat;
        geopos[2] = top_elev;
        sw.swe_set_topo(top_long, top_lat, top_elev);
        if (with_header) {
            DevNull.print("swetest ");
            for (i = 0; i < argv.length; i++) {
                DevNull.print(argv[i]);
                DevNull.print(" ");
            }
        }
        iflag = (iflag & ~SweConst.SEFLG_EPHMASK) | whicheph;
        if (fmt.indexOf("S")>=0 || fmt.indexOf("s")>=0 || fmt.indexOf("Q")>=0)
            iflag |= SweConst.SEFLG_SPEED;
        String argv0=System.getProperties().getProperty("user.dir");
        if (ephepath.length()>0)
            sw.swe_set_ephe_path(ephepath);
        else if (make_ephemeris_path(iflag, argv0) == SweConst.ERR) {
            iflag = (iflag & ~SweConst.SEFLG_EPHMASK) | SweConst.SEFLG_MOSEPH;
            whicheph = SweConst.SEFLG_MOSEPH;
        }
        if ((whicheph & SweConst.SEFLG_JPLEPH)!=0)
            sw.swe_set_jpl_file(fname);
        while (true) {
            serr.setLength(0); serr_save.setLength(0); serr_warn.setLength(0);
            if (begindate == null) {
                DevNull.print("\nDate ?");
                sdate = "";
                try {
                    InputStreamReader in=new InputStreamReader(System.in);
                    BufferedReader bin=new BufferedReader(in);
                    sdate=bin.readLine();
                } catch (IOException ie) {
                    DevNull.println(ie.getMessage());
                }
            } else {
                sdate=begindate;
                begindate = ".";  /* to exit afterwards */
            }
            if (sdate.equals("-bary")) {
                iflag = iflag & ~SweConst.SEFLG_HELCTR;
                iflag |= SweConst.SEFLG_BARYCTR;
                sdate = "";
            } else if (sdate.equals("-hel")) {
                iflag = iflag & ~SweConst.SEFLG_BARYCTR;
                iflag |= SweConst.SEFLG_HELCTR;
                sdate = "";
            } else if (sdate.equals("-geo")) {
                iflag = iflag & ~SweConst.SEFLG_BARYCTR;
                iflag = iflag & ~SweConst.SEFLG_HELCTR;
                sdate = "";
            } else if (sdate.equals("-ejpl")) {
                iflag &= ~SweConst.SEFLG_EPHMASK;
                iflag |= SweConst.SEFLG_JPLEPH;
                sdate = "";
            } else if (sdate.equals("-eswe")) {
                iflag &= ~SweConst.SEFLG_EPHMASK;
                iflag |= SweConst.SEFLG_SWIEPH;
                sdate = "";
            } else if (sdate.equals("-emos")) {
                iflag &= ~SweConst.SEFLG_EPHMASK;
                iflag |= SweConst.SEFLG_MOSEPH;
                sdate = "";
            } else if (sdate.startsWith("-xs")) {
                sastno=sdate.substring(3);
                sdate = "";
            }
            sp = sdate;
            spsave = sp;
            if (sp.length()>0 && sp.charAt(0) == '.') {
                sw.swe_close();
                return SweConst.OK;
            } else if (sp.length() == 0) {
                sdate=saves;
                sp=sdate;
            } else {
                saves=sdate;
            }
            if (sp.length()>0 && sp.charAt(0) == 'j') {   /* it's a day number */
                if (sp.indexOf(',') >= 0)
                    sp=sp.substring(0,sp.indexOf(','))+'.'+sp.substring(sp.indexOf(',')+1);
                tjd = new Double(sp.substring(1)).doubleValue();
                if (tjd < 2299160.5)
                    gregflag = SweDate.SE_JUL_CAL;
                else
                    gregflag = SweDate.SE_GREG_CAL;
                if (sp.indexOf("jul") >= 0)
                    gregflag = SweDate.SE_JUL_CAL;
                else if (sp.indexOf("greg") >= 0)
                    gregflag = SweDate.SE_GREG_CAL;
                sd.setJulDay(tjd);
                sd.setCalendarType(gregflag,SweDate.SE_KEEP_JD); // Keep JulDay!
                jyear=sd.getYear();
                jmon=sd.getMonth();
                jday=sd.getDay();
                jut=sd.getHour();
            } else if (sp.length()>0 && sp.charAt(0) == '+') {
                n=0;
                if (sp.length()>1) {
                    n = Integer.parseInt(sp.substring(1));
                }
                if (n == 0) n = 1;
                tjd += n;
                //      swe_revjul(tjd, gregflag, &jyear, &jmon, &jday, &jut);
                sd.setJulDay(tjd);
                jyear=sd.getYear();
                jmon=sd.getMonth();
                jday=sd.getDay();
                jut=sd.getHour();
            } else if (sp.length()>0 && sp.charAt(0) == '-') {
                n = Integer.parseInt(sp);
                if (n == 0) n = -1;
                tjd += n;
                //      swe_revjul(tjd, gregflag, &jyear, &jmon, &jday, &jut);
                sd.setJulDay(tjd);
                jyear=sd.getYear();
                jmon=sd.getMonth();
                jday=sd.getDay();
                jut=sd.getHour();
            } else {
                //      if (sscanf (sp, "%d%*c%d%*c%d", &jday,&jmon,&jyear) < 1) exit(1);
                jday=jmon=jyear=0;
                boolean neg=false;
                i=0;
                try {
                    neg=sp.charAt(0)=='-';
                    if (neg) { i++; }
                    while (Character.isDigit(sp.charAt(i))) {
                        jday=jday*10+Character.digit(sp.charAt(i++),10);
                    }
                    if (neg) { jday=-jday; neg=false; }

                    while (i<sp.length() &&
                           !Character.isDigit(sp.charAt(i)) && sp.charAt(i)!='-') { i++; }
                    neg=sp.charAt(i)=='-';
                    if (neg) { i++; }
                    while (i<sp.length() && Character.isDigit(sp.charAt(i))) {
                        jmon=jmon*10+Character.digit(sp.charAt(i++),10);
                    }
                    if (neg) { jmon=-jmon; neg=false; }

                    while (i<sp.length() &&
                           !Character.isDigit(sp.charAt(i)) && sp.charAt(i)!='-') { i++; }
                    neg=sp.charAt(i)=='-';
                    if (neg) { i++; }
                    while (i<sp.length() && Character.isDigit(sp.charAt(i))) {
                        jyear=jyear*10+Character.digit(sp.charAt(i++),10);
                    }
                    if (neg) { jyear=-jyear; }
                } catch (StringIndexOutOfBoundsException sob) {
                    System.exit(1);
                }
                if (jyear * 10000 + jmon * 100 + jday < 15821015)
                    gregflag = SweDate.SE_JUL_CAL;
                else
                    gregflag = SweDate.SE_GREG_CAL;
                if (sp.indexOf("jul") >= 0)
                    gregflag = SweDate.SE_JUL_CAL;
                else if (sp.indexOf("greg") >= 0)
                    gregflag = SweDate.SE_GREG_CAL;
                jut = 0;
                sd.setDate(jyear,jmon,jday,jut);
                sd.setCalendarType(gregflag,SweDate.SE_KEEP_DATE); // Keep Date!
                tjd = sd.getJulDay();
                tjd += thour / 24;
                sd.setJulDay(tjd);
            }
            line_count = 0;
            if (smod > 0) {
                do_eclipse_etc();
                sw.swe_close();
                return SweConst.OK;
            }
            for (t = tjd, istep = 1; istep <= nstep; t += tstep, istep++) {
                if (t < 2299160.5)
                    gregflag = SweDate.SE_JUL_CAL;
                else
                    gregflag = SweDate.SE_GREG_CAL;
                if (sp.indexOf("jul") >= 0)
                    gregflag = SweDate.SE_JUL_CAL;
                else if (spsave.indexOf("greg") >= 0)
                    gregflag = SweDate.SE_GREG_CAL;
                //      swe_revjul(t, gregflag, &jyear, &jmon, &jday, &jut);
                sd.setJulDay(t);
                sd.setCalendarType(gregflag,SweDate.SE_KEEP_JD); // Keep JulDay!
                jyear=sd.getYear();
                jmon=sd.getMonth();
                jday=sd.getDay();
                jut=sd.getHour();
                if (with_header) {
                    sout="\ndate (dmy) "+jday+"."+jmon+"."+jyear;
                    DevNull.print(sout);
                    if (gregflag)
                        DevNull.print(" greg.");
                    else
                        DevNull.print(" jul.");
                    t2 = t + 0.5;
                    t2 += 0.5 / 86400; /* round to second */
                    t2 = (t2 - (int) t2) * 24;
                    sout="  "+f.fmt("% 2d",(int) t2)+":";
                    DevNull.print(sout);
                    t2 = (t2 - (int) t2) * 60;
                    sout=f.fmt("%02d",(int)t2)+":";
                    DevNull.print(sout);
                    t2 = (t2 - (int) t2) * 60;
                    sout=f.fmt("%02d",(int) t2);
                    DevNull.print(sout);
                    if (universal_time)
                        DevNull.print(" UT");
                    else
                        DevNull.print(" ET");
                }
                delt = sd.getDeltaT(t);
                if (universal_time) {
                    if (with_header) {
                        sout="\nUT: "+f.fmt("%f",t);
                        DevNull.print(sout);
                    }
                    if (with_header) {
                        sout="     delta t: "+f.fmt("%f",delt * 86400.0)+" sec";
                        DevNull.print(sout);
                    }
                    te = t + delt;
                    tut = t;
                } else {
                    te = t;
                    tut = t - delt;
                }
                iflgret = sw.swe_calc(te, SweConst.SE_ECL_NUT, iflag, xobl, serr);
                if (with_header) {
                    sout="\nET: "+f.fmt("%f",te);
                    DevNull.print(sout);
                    if ((iflag & SweConst.SEFLG_SIDEREAL)!=0) {
                        daya = sw.swe_get_ayanamsa(te);
                        sout="   ayanamsa = "+dms(daya, round_flag);
                        DevNull.print(sout);
                    }
                    if (have_geopos) {
                        DevNull.print("\ngeo. long "+f.fmt("%f",geopos[0])+
                                         ", lat "+f.fmt("%f",geopos[1])+
                                         ", alt "+f.fmt("%f",geopos[2]));
                    }
                    if (iflag_f >=0)
                        iflag = iflag_f;
                    if (plsel.indexOf('o') < 0) {
                        sout="\n"+f.fmt("%-15s","Epsilon (true)")+" "+dms(xobl[0],round_flag);
                        DevNull.print(sout);
                    }
                    if (plsel.indexOf('n') < 0) {
                        s1=dms(xobl[2], round_flag);
                        s2=dms(xobl[3], round_flag);
                        //            sout="\nNutation        "+s1+gap+s2;
                        sout="\n"+f.fmt("%-15s","Nutation")+" "+s1+gap+s2;
                        DevNull.print(sout);
                    }
                    DevNull.print("\n");

                    if (do_houses) {
                        if (!universal_time) {
                            do_houses = false;
                            DevNull.print("option -house requires option -ut for "+
                                             "Universal Time\n");
                        } else {
                            s1 = dms(top_long, round_flag);
                            s2 = dms(top_lat, round_flag);
                            sout = "Houses system "+(char)ihsy+" for long="+s1+
                                ", lat="+s2+"\n";
                            DevNull.print(sout);
                        }     
                    }         
                }
                if (with_header && !with_header_always)
                    with_header = false;
                if (do_ayanamsa) {
                    daya = sw.swe_get_ayanamsa(te);
                    DevNull.print("Ayanamsa"+gap+dms(daya, round_flag)+"\n");
                    continue;
                }
                if (plsel.indexOf('e')>=0) {
                    print_line(MODE_LABEL);
                }
                for (psp = plsel, p=0; p<plsel.length(); p++) {
                    if (psp.charAt(p) == 'e') { continue; }
                    ipl = letter_to_ipl((int) psp.charAt(p));
                    if (psp.charAt(p) == 'f') {
                        ipl = SweConst.SE_FIXSTAR;
                    } else if (psp.charAt(p) == 's') {
                        try {
                            // Well, no: sastno may be appended a letter like '10s'!!!
                            //              ipl = Integer.parseInt(sastno) + 10000;
                            ipl = sl.atoi(sastno) + 10000;
                        } catch (NumberFormatException ne) {
                            ipl = SweConst.ERR;
                        }
                    } else if (psp.charAt(p) == 'z') {
                        try {
                            ipl = Integer.parseInt(shyp) + SweConst.SE_FICT_OFFSET_1;
                        } catch (NumberFormatException ne) {
                            ipl = SweConst.ERR;
                        }
                    }
                    if (ipl == -2) {
                        DevNull.print("illegal parameter -p"+plsel+"\n");
                        System.exit(1);
                    }
                    if ((iflag & SweConst.SEFLG_HELCTR)!=0) {
                        if (ipl == SweConst.SE_SUN
                            || ipl == SweConst.SE_MEAN_NODE
                            || ipl == SweConst.SE_TRUE_NODE
                            || ipl == SweConst.SE_MEAN_APOG
                            || ipl == SweConst.SE_OSCU_APOG)
                            continue;
                    } else if ((iflag & SweConst.SEFLG_BARYCTR)!=0) {
                        if (ipl == SweConst.SE_MEAN_NODE || ipl == SweConst.SE_TRUE_NODE
                            || ipl == SweConst.SE_MEAN_APOG
                            || ipl == SweConst.SE_OSCU_APOG)
                            continue;
                    } else          /* geocentric */
                        if (ipl == SweConst.SE_EARTH)
                            continue;
                    /* ecliptic position */
                    if (iflag_f >=0)
                        iflag = iflag_f;
                    if (ipl == SweConst.SE_FIXSTAR) {
                        StringBuffer sstar=new StringBuffer(star);
                        iflgret = sw.swe_fixstar(sstar, te, iflag, x, serr);
                        star=sstar.toString();
                        se_pname=star;
                    } else {
                        iflgret = sw.swe_calc(te, ipl, iflag, x, serr);
                        /* phase, magnitude, etc. */
                        if (iflgret != SweConst.ERR && (fmt.indexOf("+")>=0 ||
                                                        fmt.indexOf("-")>=0 || fmt.indexOf("*")>=0 ||
                                                        fmt.indexOf("/")>=0 || fmt.indexOf("=")>=0)) {
                            iflgret = sw.swe_pheno(te, ipl, iflag, attr, serr);
                        }
                        se_pname=sw.swe_get_planet_name(ipl);
                    }
                    if (psp.charAt(p) == 'q') {/* delta t */
                        x[0] = sd.getDeltaT(te) * 86400;
                        x[1] = x[2] = x[3] = 0;
                        se_pname = "Delta T";
                    }
                    if (psp.charAt(p) == 'o') {/* ecliptic is wanted, remove nutation */
                        x[2] = x[3] = 0;
                        se_pname="Ecl. Obl.";
                    }
                    if (psp.charAt(p) == 'n') {/* nutation is wanted, remove ecliptic */
                        x[0] = x[2];
                        x[1] = x[3];
                        x[2] = x[3] = 0;
                        se_pname="Nutation";
                    }
                    if (iflgret < 0) {
                        if (!serr.toString().equals(serr_save.toString())
                            && (ipl == SweConst.SE_SUN || ipl == SweConst.SE_MOON
                                || ipl == SweConst.SE_MEAN_NODE
                                || ipl == SweConst.SE_TRUE_NODE || ipl == SweConst.SE_CHIRON
                                || ipl == SweConst.SE_PHOLUS || ipl == SweConst.SE_CUPIDO
                                || ipl >= SweConst.SE_AST_OFFSET
                                || ipl == SweConst.SE_FIXSTAR)) {
                            sout="error: "+serr.toString()+"\n";
                            DevNull.print(sout);
                        }
                        serr_save=new StringBuffer(serr.toString());
                    } else if (serr.length()>0 && serr_warn.length()==0) {
                        if (serr.toString().indexOf("'seorbel.txt' not found")<0) {
                            serr_warn=new StringBuffer(serr.toString());
                        }
                    }
                    if (diff_mode != 0) {
                        iflgret = sw.swe_calc(te, ipldiff, iflag, x2, serr);
                        if (iflgret < 0) {
                            sout="error: "+serr.toString()+"\n";
                            DevNull.print(sout);
                        }
                        if (diff_mode == DIFF_DIFF) {
                            for (i = 1; i < 6; i++)
                                x[i] -= x2[i];
                            if ((iflag & SweConst.SEFLG_RADIANS) == 0)
                                x[0] = sl.swe_difdeg2n(x[0], x2[0]);
                            else
                                x[0] = sl.swe_difrad2n(x[0], x2[0]);
                        } else {      /* DIFF_MIDP */
                            for (i = 1; i < 6; i++)
                                x[i] = (x[i] + x2[i]) / 2;
                            if ((iflag & SweConst.SEFLG_RADIANS) == 0)
                                x[0] = sl.swe_deg_midp(x[0], x2[0]);
                            else
                                x[0] = sl.swe_rad_midp(x[0], x2[0]);
                        }
                    }
                    /* equator position */
                    //        if (strpbrk(fmt, "aADdQ") != null) { ... }
                    if (fmt.indexOf("a")>=0 || fmt.indexOf("A")>=0 ||
                        fmt.indexOf("D")>=0 || fmt.indexOf("d")>=0 ||
                        fmt.indexOf("Q")>=0) {
                        iflag2 = iflag | SweConst.SEFLG_EQUATORIAL;
                        if (ipl == SweConst.SE_FIXSTAR) {
                            StringBuffer sstar=new StringBuffer(star);
                            iflgret = sw.swe_fixstar(sstar, te, iflag2, xequ, serr);
                            star=sstar.toString();
                        } else {
                            iflgret = sw.swe_calc(te, ipl, iflag2, xequ, serr);
                        }
                        if (diff_mode != 0) {
                            iflgret = sw.swe_calc(te, ipldiff, iflag2, x2, serr);
                            if (diff_mode == DIFF_DIFF) {
                                for (i = 1; i < 6; i++)
                                    xequ[i] -= x2[i];
                                if ((iflag & SweConst.SEFLG_RADIANS) == 0)
                                    xequ[0] = sl.swe_difdeg2n(xequ[0], x2[0]);
                                else
                                    xequ[0] = sl.swe_difrad2n(xequ[0], x2[0]);
                            } else {    /* DIFF_MIDP */
                                for (i = 1; i < 6; i++)
                                    xequ[i] = (xequ[i] + x2[i]) / 2;
                                if ((iflag & SweConst.SEFLG_RADIANS) == 0)
                                    xequ[0] = sl.swe_deg_midp(xequ[0], x2[0]);
                                else
                                    xequ[0] = sl.swe_rad_midp(xequ[0], x2[0]);
                            }
                        }
                    }
                    /* azimuth and height */
                    //        if (strpbrk(fmt, "IiHhKk") != NULL) { ... }
                    if (fmt.indexOf("I")>=0 || fmt.indexOf("i")>=0 ||
                        fmt.indexOf("H")>=0 || fmt.indexOf("h")>=0 ||
                        fmt.indexOf("K")>=0 || fmt.indexOf("k")>=0) {
                        /* first, get topocentric equatorial positions */
                        iflgt = whicheph | SweConst.SEFLG_EQUATORIAL | SweConst.SEFLG_TOPOCTR;
                        if (ipl == SweConst.SE_FIXSTAR) {
                            StringBuffer sstar=new StringBuffer(star);
                            iflgret = sw.swe_fixstar(sstar, te, iflgt, xt, serr);
                            star=sstar.toString();
                        } else {
                            iflgret = sw.swe_calc(te, ipl, iflgt, xt, serr);
                        }
                        /* to azimuth/height */
                        sw.swe_azalt(tut, SweConst.SE_EQU2HOR, geopos, 1013.25, 10, xt, xaz);
                        if (diff_mode!=0) {
                            iflgret = sw.swe_calc(te, ipldiff, iflgt, xt, serr);
                            sw.swe_azalt(tut, SweConst.SE_EQU2HOR, geopos, 1013.25, 10, xt, x2);
                            if (diff_mode == DIFF_DIFF) {
                                for (i = 1; i < 3; i++)
                                    xaz[i] -= x2[i];
                                if ((iflag & SweConst.SEFLG_RADIANS) == 0)
                                    xaz[0] = sl.swe_difdeg2n(xaz[0], x2[0]);
                                else
                                    xaz[0] = sl.swe_difrad2n(xaz[0], x2[0]);
                            } else {    /* DIFF_MIDP */
                                for (i = 1; i < 3; i++)
                                    xaz[i] = (xaz[i] + x2[i]) / 2;
                                if ((iflag & SweConst.SEFLG_RADIANS) == 0)
                                    xaz[0] = sl.swe_deg_midp(xaz[0], x2[0]);
                                else
                                    xaz[0] = sl.swe_rad_midp(xaz[0], x2[0]);
                            }
                        }
                    }
                    /* ecliptic cartesian position */
                    //        if (strpbrk(fmt, "XU") != null) { ... }
                    if (fmt.indexOf("X")>=0 || fmt.indexOf("U")>=0) {
                        iflag2 = iflag | SweConst.SEFLG_XYZ;
                        if (ipl == SweConst.SE_FIXSTAR) {
                            StringBuffer sstar=new StringBuffer(star);
                            iflgret = sw.swe_fixstar(sstar, te, iflag2, xcart, serr);
                            star=sstar.toString();
                        } else {
                            iflgret = sw.swe_calc(te, ipl, iflag2, xcart, serr);
                        }
                        if (diff_mode != 0) {
                            iflgret = sw.swe_calc(te, ipldiff, iflag2, x2, serr);
                            if (diff_mode == DIFF_DIFF) {
                                for (i = 0; i < 6; i++)
                                    xcart[i] -= x2[i];
                            } else {
                                xcart[i] = (xcart[i] + x2[i]) / 2;
                            }
                        }
                    }
                    /* equator cartesian position */
                    //        if (strpbrk(fmt, "xu") != null) { ... }
                    if (fmt.indexOf("x")>=0 || fmt.indexOf("u")>=0) {
                        iflag2 = iflag | SweConst.SEFLG_XYZ | SweConst.SEFLG_EQUATORIAL;
                        if (ipl == SweConst.SE_FIXSTAR) {
                            StringBuffer sstar=new StringBuffer(star);
                            iflgret = sw.swe_fixstar(sstar, te, iflag2, xcartq, serr);
                            star=sstar.toString();
                        } else {
                            iflgret = sw.swe_calc(te, ipl, iflag2, xcartq, serr);
                        }
                        if (diff_mode != 0) {
                            iflgret = sw.swe_calc(te, ipldiff, iflag2, x2, serr);
                            if (diff_mode == DIFF_DIFF) {
                                for (i = 0; i < 6; i++)
                                    xcartq[i] -= x2[i];
                            } else {
                                xcartq[i] = (xcart[i] + x2[i]) / 2;
                            }
                        }
                    }
                    /* house position */
                    //          if (strpbrk(fmt, "gGj") != NULL) { ... }
                    if (fmt.indexOf("g")>=0 || fmt.indexOf("G")>=0 || fmt.indexOf("j")>=0) {
                        armc = sl.swe_degnorm(sl.swe_sidtime(tut) * 15 + geopos[0]);
                        for (i = 0; i < 6; i++)
                            xsv[i] = x[i];
                        if (hpos_meth == 1)
                            xsv[1] = 0;
                        if (ipl == SweConst.SE_FIXSTAR)
                            star2=star;
                        else
                            star2 = "";
                        if (hpos_meth >= 2 && Character.toLowerCase((char)ihsy) == 'g') {
                            StringBuffer sstar2=new StringBuffer(star2);
                            sw.swe_gauquelin_sector(tut, ipl, sstar2, iflag, hpos_meth, geopos, 0, 0, hposj, serr);
                            star2=sstar2.toString();
                        } else {
                            hposj.val = sw.swe_house_pos(armc, geopos[1], xobl[0], ihsy, xsv, serr);
                        }
                        if (Character.toLowerCase((char)ihsy) == 'g')
                            hpos = (hposj.val - 1) * 10;
                        else
                            hpos = (hposj.val - 1) * 30;
                        if (diff_mode!=0) {
                            for (i = 0; i < 6; i++)
                                xsv[i] = x2[i];
                            if (hpos_meth == 1)
                                xsv[1] = 0;
                            hpos2 = sw.swe_house_pos(armc, geopos[1], xobl[0], ihsy, xsv, serr);
                            if (Character.toLowerCase((char)ihsy) == 'g')
                                hpos2 = (hpos2 - 1) * 10;
                            else
                                hpos2 = (hpos2 - 1) * 30;
                            if (diff_mode == DIFF_DIFF) {
                                if ((iflag & SweConst.SEFLG_RADIANS) == 0)
                                    hpos = sl.swe_difdeg2n(hpos, hpos2);
                                else
                                    hpos = sl.swe_difrad2n(hpos, hpos2);
                            } else {    /* DIFF_MIDP */
                                if ((iflag & SweConst.SEFLG_RADIANS) == 0)
                                    hpos = sl.swe_deg_midp(hpos, hpos2);
                                else
                                    hpos = sl.swe_rad_midp(hpos, hpos2);
                            }
                        }
                    }
                    spnam=se_pname;
                    print_line(0);
                    line_count++;
                    if (line_count >= line_limit) {
                        sout="****** line count "+line_limit+" was exceeded\n";
                        DevNull.print(sout);
                        break;
                    }
                }         /* for psp */
                if (do_houses) {
                    double cusp[]=new double[100];
                    int iofs;
                    if (Character.toLowerCase((char)ihsy) == 'g')
                        nhouses = 36;
                    iofs = nhouses + 1;
                    iflgret = sw.swe_houses(t,iflag, top_lat, top_long, ihsy, cusp, cusp, iofs);
                    if (iflgret < 0) {
                        if (!serr.toString().equals(serr_save.toString())) {
                            sout="error: "+serr.toString()+"\n";
                            DevNull.print(sout);
                        }
                        serr_save=new StringBuffer(serr.toString());
                    } else {
                        for (ipl = 1; ipl < iofs+4; ipl++) {
                            x[0] = cusp[ipl];
                            x[1] = 0;   /* latitude */
                            x[2] = 1.0; /* pseudo radius vector */
                            //              if (strpbrk(fmt, "aADdQ") != NULL)
                            if (fmt.indexOf('a')>=0 || fmt.indexOf('A')>=0 ||
                                fmt.indexOf('D')>=0 || fmt.indexOf('d')>=0 ||
                                fmt.indexOf('Q')>=0) {
                                sl.swe_cotrans(x, 0, xequ, 0, -xobl[0]);
                            }
                            print_line(MODE_HOUSE);
                            line_count++;
                        }
                    }
                }   
                if (line_count >= line_limit)
                    break;
            }           /* for tjd */
            if (serr_warn.length() != 0) {
                DevNull.print("\nwarning: ");
                DevNull.print(serr_warn.toString());
                DevNull.print("\n");
            }
        }             /* while 1 */
    }

    /*
     * The string fmt contains a sequence of format specifiers;
     * each character in fmt creates a column, the columns are
     * sparated by the gap string.
     */
    int print_line(int mode) {
        String sp, sp2, sout;
        double t2, ju2 = 0;
        double y_frac;
        double ar, sinp;
        boolean is_house = ((mode & MODE_HOUSE) != 0);
        boolean is_label = ((mode & MODE_LABEL) != 0);
        int iflgret;
        int c=0;
        for (sp = fmt; c<fmt.length(); c++) {
            if (is_house && "bBsSrRxXuUQnNfF+-*/=".indexOf(sp.charAt(c))>=0) {
                continue;
            }
            if (c != 0)
                DevNull.print(gap);
            switch((int)sp.charAt(c)) {
                case (int)'y':
                    if (is_label) { DevNull.println("year"); break; }
                    sout=""+jyear;
                    DevNull.print(sout);
                    break;
                case (int)'Y':
                    if (is_label) { DevNull.println("year"); break; }
                    t2 = sd.getJulDay(jyear,1,1,ju2,gregflag);
                    y_frac = (t - t2) / 365.0;
                    sout=f.fmt("%.2f",jyear + y_frac);
                    DevNull.print(sout);
                    break;
                case (int)'p':
                    if (is_label) { DevNull.println("obj.nr"); break; }
                    if (!is_house && diff_mode == DIFF_DIFF)
                        sout=""+ipl+"-"+ipldiff;
                    else if (!is_house && diff_mode == DIFF_MIDP)
                        sout=""+ipl+"/"+ipldiff;
                    else
                        sout=""+ipl;
                    DevNull.print(sout);
                    break;
                case (int)'P':
                    if (is_label) { DevNull.println("name           "); break; }
                    if (is_house) {
                        if (ipl <= nhouses)
                            sout="house "+f.fmt("%2d",ipl)+"       ";
                        else
                            sout=f.fmt("%-15s",hs_nam[ipl - nhouses]);
                    } else if (diff_mode == DIFF_DIFF)
                        sout=f.fmt("%.3s",spnam)+"-"+f.fmt("%.3s",spnam2);
                    else if (diff_mode == DIFF_MIDP)
                        sout=f.fmt("%.3s",spnam)+"/"+f.fmt("%.3s",spnam2);
                    else {
                        sout=f.fmt("%-15s",spnam);
                    }
                    DevNull.print(sout);
                    break;
                case (int)'J':
                    if (is_label) { DevNull.println("julday"); break; }
                    y_frac = (t - (int)(t)) * 100;
                    if ((int)(y_frac) != y_frac)
                        sout=f.fmt("%.5f", t);
                    else
                        sout=f.fmt("%.2f", t);
                    DevNull.print(sout);
                    break;
                case (int)'T':
                    if (is_label) { DevNull.println("date"); break; }
                    sout=f.fmt("%02d",jday)+"."+f.fmt("%02d",jmon)+"."+jyear;
                    if (jut != 0) {
                        int h, m, s;
                        s = (int) (jut * 3600 + 0.5);
                        h = (int) (s / 3600.0);
                        m = (int) ((s % 3600) / 60.0);
                        s %= 60;
                        sout+=" "+f.fmt("%d",h)+":"+f.fmt("%02d",m)+":"+
                            f.fmt("%02d",s);
                        if (universal_time)
                            sout+=" UT";
                        else
                            sout+=" ET";
                    }
                    DevNull.print(sout);
                    break;
                case (int)'t':
                    if (is_label) { DevNull.println("date"); break; }
                    sout=f.fmt("%02d",jyear % 100)+f.fmt("%02d",jmon)+
                        f.fmt("%02d",jday);
                    DevNull.print(sout);
                    break;
                case (int)'L':
                    if (is_label) { DevNull.println("long."); break; }
                    if (p >= psp.length() || (p < psp.length() && psp.charAt(p) != 'q')) { /* != delta t */
                        DevNull.print(dms(x[0], round_flag));
                        break;
                    }
                    // Fall through else...
                case (int)'l':
                    if (is_label && sp.charAt(c) != 'l') { DevNull.println("long"); break; }
                    sout=f.fmt("%# 11.7f", x[0]);
                    DevNull.print(sout);
                    break;
                case (int)'G':
                    if (is_label) { DevNull.println("housPos"); break; }
                    DevNull.print(dms(hpos, round_flag));
                    break;
                case (int)'g':
                    if (is_label) { DevNull.println("housPos"); break; }
                    sout=f.fmt("%# 11.7f", hpos);
                    DevNull.print(sout);
                    break;
                case (int)'j':
                    if (is_label) { DevNull.println("houseNr"); break; }
                    sout=f.fmt("%# 11.7f", hposj.val);
                    DevNull.print(sout);
                    break;
                case (int)'Z':
                    if (is_label) { DevNull.println("long"); break; }
                    DevNull.print(dms(x[0], round_flag|BIT_ZODIAC));
                    break;
                case (int)'S':
                case (int)'s':
                    if (fmt.indexOf("X")>=0 || fmt.indexOf("U")>=0 ||
                        fmt.indexOf("x")>=0 || fmt.indexOf("u")>=0 ||
                        (sp.length()>c+1 &&
                         (sp.charAt(c+1) == 'S' || sp.charAt(c+1) == 's'))) {
                        int c2=0;
                        for (sp2 = fmt; c2<fmt.length(); c2++) {
                            if (c2 != 0)
                                DevNull.print(gap);
                            switch((int)sp2.charAt(c2)) {
                                case (int)'L':   /* speed! */
                                case (int)'Z':   /* speed! */
                                    if (is_label) { DevNull.println("lon/day"); break; }
                                    DevNull.print(dms(x[3], round_flag));
                                    break;
                                case (int)'l':   /* speed! */
                                    if (is_label) { DevNull.println("lon/day"); break; }
                                    sout=f.fmt("%11.7f", x[3]);
                                    DevNull.print(sout);
                                    break;
                                case (int)'B':   /* speed! */
                                    if (is_label) { DevNull.println("lat/day"); break; }
                                    DevNull.print(dms(x[4], round_flag));
                                    break;
                                case (int)'b':   /* speed! */
                                    if (is_label) { DevNull.println("lat/day"); break; }
                                    sout=f.fmt("%11.7f", x[4]);
                                    DevNull.print(sout);
                                    break;
                                case (int)'A':   /* speed! */
                                    if (is_label) { DevNull.println("RA/day"); break; }
                                    DevNull.print(dms(xequ[3]/15,
                                                         round_flag|SweConst.SEFLG_EQUATORIAL));
                                    break;
                                case (int)'a':   /* speed! */
                                    if (is_label) { DevNull.println("RA/day"); break; }
                                    sout=f.fmt("%11.7f", xequ[3]);
                                    DevNull.print(sout);
                                    break;
                                case (int)'D':   /* speed! */
                                    if (is_label) { DevNull.println("dcl/day"); break; }
                                    DevNull.print(dms(xequ[4], round_flag));
                                    break;
                                case (int)'d':   /* speed! */
                                    if (is_label) { DevNull.println("dcl/day"); break; }
                                    sout=f.fmt("%11.7f", xequ[4]);
                                    DevNull.print(sout);
                                    break;
                                case (int)'R':   /* speed! */
                                case (int)'r':   /* speed! */
                                    if (is_label) { DevNull.println("AU/day"); break; }
                                    sout=f.fmt("%# 14.9f", x[5]);
                                    DevNull.print(sout);
                                    break;
                                case (int)'U':   /* speed! */
                                case (int)'X':   /* speed! */
                                    if (is_label) { DevNull.println("speed_0"+gap+"speed_1"+gap+"speed_2"); break; }
                                    if (sp.charAt(c) =='U')
                                        ar = Math.sqrt(square_sum(xcart));
                                    else
                                        ar = 1;
                                    sout=f.fmt("%# 14.9f", xcart[3]/ar)+gap;
                                    DevNull.print(sout);
                                    sout=f.fmt("%# 14.9f", xcart[4]/ar)+gap;
                                    DevNull.print(sout);
                                    sout=f.fmt("%# 14.9f", xcart[5]/ar);
                                    DevNull.print(sout);
                                    break;
                                case (int)'u':   /* speed! */
                                case (int)'x':   /* speed! */
                                    if (is_label) { DevNull.println("speed_0"+gap+"speed_1"+gap+"speed_2"); break; }
                                    if (sp.charAt(c) =='u')
                                        ar = Math.sqrt(square_sum(xcartq));
                                    else
                                        ar = 1;
                                    sout=f.fmt("%# 14.9f", xcartq[3]/ar)+gap;
                                    DevNull.print(sout);
                                    sout=f.fmt("%# 14.9f", xcartq[4]/ar)+gap;
                                    DevNull.print(sout);
                                    sout=f.fmt("%# 14.9f", xcartq[5]/ar);
                                    DevNull.print(sout);
                                    break;
                                default:
                                    break;
                            }
                        }
                        if (sp.charAt(c+1) == 'S' || sp.charAt(c+1) == 's')
                            c++;
                    } else if (sp.charAt(c) == 'S') {
                        if (is_label) { DevNull.println("deg/day"); break; }
                        DevNull.print(dms(x[3], round_flag));
                    } else {
                        if (is_label) { DevNull.println("deg/day"); break; }
                        DevNull.print(f.fmt("%# 11.7f", x[3]));
                    }
                    break;
                case (int)'B':
                    if (is_label) { DevNull.println("lat"); break; }
                    DevNull.print(dms(x[1], round_flag));
                    break;
                case (int)'b':
                    if (is_label) { DevNull.println("lat"); break; }
                    sout=f.fmt("%# 11.7f", x[1]);
                    DevNull.print(sout);
                    break;
                case (int)'A':     /* rectascensio */
                    if (is_label) { DevNull.println("RA"); break; }
                    DevNull.print(dms(xequ[0]/15,
                                         round_flag|SweConst.SEFLG_EQUATORIAL));
                    break;
                case (int)'a':     /* rectascensio */
                    if (is_label) { DevNull.println("RA"); break; }
                    sout=f.fmt("%# 11.7f", xequ[0]);
                    DevNull.print(sout);
                    break;
                case (int)'D':     /* declination */
                    if (is_label) { DevNull.println("decl"); break; }
                    DevNull.print(dms(xequ[1], round_flag));
                    break;
                case (int)'d':     /* declination */
                    if (is_label) { DevNull.println("decl"); break; }
                    sout=f.fmt("%# 11.7f", xequ[1]);
                    DevNull.print(sout);
                    break;
                case 'I':     /* azimuth */
                    if (is_label) { DevNull.println("azimuth"); break; }
                    DevNull.print(dms(xaz[0], round_flag));
                    break;
                case 'i':     /* azimuth */
                    if (is_label) { DevNull.println("azimuth"); break; }
                    sout=f.fmt("%# 11.7f", xaz[0]);
                    DevNull.print(sout);
                    break;
                case 'H':     /* height */
                    if (is_label) { DevNull.println("height"); break; }
                    DevNull.print(dms(xaz[1], round_flag));
                    break;
                case 'h':     /* height */
                    if (is_label) { DevNull.println("height"); break; }
                    sout=f.fmt("%# 11.7f", xaz[1]);
                    DevNull.print(sout);
                    break;
                case 'K':     /* height (apparent) */
                    if (is_label) { DevNull.println("hgtApp"); break; }
                    DevNull.print(dms(xaz[2], round_flag));
                    break;
                case 'k':     /* height (apparent) */
                    if (is_label) { DevNull.println("hgtApp"); break; }
                    sout=f.fmt("%# 11.7f", xaz[2]);
                    DevNull.print(sout);
                    break;
                case (int)'R':
                    if (is_label) { DevNull.println("distAU"); break; }
                    sout=f.fmt("%# 14.9f", x[2]);
                    DevNull.print(sout);
                    break;
                case (int)'r':
                    if (is_label) { DevNull.println("dist"); break; }
                    if ( ipl == SweConst.SE_MOON ) { /* for moon print parallax */
                        sinp = 8.794 / x[2];    /* in seconds of arc */
                        ar = sinp * (1 + sinp * sinp * 3.917402e-12);
                        /* the factor is 1 / (3600^2 * (180/pi)^2 * 6) */
                        sout=f.fmt("%# 13.5f",ar)+"\"";
                    } else {
                        sout=f.fmt("%# 14.9f", x[2]);
                    }
                    DevNull.print(sout);
                    break;
                case (int)'U':
                case (int)'X':
                    if (sp.charAt(c) =='U')
                        ar = Math.sqrt(square_sum(xcart));
                    else
                        ar = 1;
                    sout=f.fmt("%# 14.9f", xcart[0]/ar)+gap;
                    DevNull.print(sout);
                    sout=f.fmt("%# 14.9f", xcart[1]/ar)+gap;
                    DevNull.print(sout);
                    sout=f.fmt("%# 14.9f", xcart[2]/ar);
                    DevNull.print(sout);
                    break;
                case (int)'u':
                case (int)'x':
                    if (is_label) { DevNull.println("x0"+gap+"x1"+gap+"x2"); break; }
                    if (sp.charAt(c) =='u')
                        ar = Math.sqrt(square_sum(xcartq));
                    else
                        ar = 1;
                    sout=f.fmt("%# 14.9f", xcartq[0]/ar)+gap;
                    DevNull.print(sout);
                    sout=f.fmt("%# 14.9f", xcartq[1]/ar)+gap;
                    DevNull.print(sout);
                    sout=f.fmt("%# 14.9f", xcartq[2]/ar);
                    DevNull.print(sout);
                    break;
                case (int)'Q':
                    if (is_label) { DevNull.println("Q"); break; }
                    //                sout=f.fmt("%-15s", spnam);
                    sout=(spnam+"               ").substring(0,Math.max(15,spnam.length()));
                    DevNull.print(sout);
                    DevNull.print(dms(x[0], round_flag));
                    DevNull.print(dms(x[1], round_flag));
                    sout="  "+f.fmt("%# 14.9f", x[2]);
                    DevNull.print(sout);
                    DevNull.print(dms(x[3], round_flag));
                    DevNull.print(dms(x[4], round_flag));
                    sout="  "+f.fmt("%# 14.9f", x[5])+"\n";
                    DevNull.print(sout);
                    sout="               "+dms(xequ[0], round_flag);
                    DevNull.print(sout);
                    DevNull.print(dms(xequ[1], round_flag));
                    sout="                "+dms(xequ[3], round_flag);
                    DevNull.print(sout);
                    DevNull.print(dms(xequ[4], round_flag));
                    break;
                case 'N':
                case 'n': {
                    double xasc[]=new double[6], xdsc[]=new double[6];
                    int imeth = (Character.isLowerCase(sp.charAt(c)))?
                        SweConst.SE_NODBIT_MEAN:SweConst.SE_NODBIT_OSCU;
                    iflgret = sw.swe_nod_aps(te, ipl, iflag, imeth, xasc,
                                             xdsc, null, null, serr);
                    if (iflgret >= 0 &&
                        (ipl <= SweConst.SE_NEPTUNE || sp.charAt(c) == 'N') ) {
                        if (is_label) { DevNull.println("nodAsc"+gap+"nodDesc"); break; }
                        DevNull.print(f.fmt("%# 11.7f",xasc[0]));
                        DevNull.print(gap);
                        DevNull.print(f.fmt("%# 11.7f",xdsc[0]));
                    }
                };
                    break;
                case 'F':
                case 'f':
                    if (!is_house) {
                        double xfoc[]=new double[6], xaph[]=new double[6],
                            xper[]=new double[6];
                        int imeth = (Character.isLowerCase(sp.charAt(c)))?
                            SweConst.SE_NODBIT_MEAN:SweConst.SE_NODBIT_OSCU;
                        iflgret = sw.swe_nod_aps(te, ipl, iflag, imeth, null, null,
                                                 xper, xaph, serr);
                        if (iflgret >= 0 && (ipl <= SweConst.SE_NEPTUNE ||
                                             sp.charAt(c) == 'F') ) {
                            if (is_label) { DevNull.println("peri"+gap+"apo"); break; }
                            DevNull.print(f.fmt("%# 11.7f", xper[0]));
                            DevNull.print(gap);
                            DevNull.print(f.fmt("%# 11.7f", xaph[0]));
                        }
                        imeth |= SweConst.SE_NODBIT_FOPOINT;
                        iflgret = sw.swe_nod_aps(te, ipl, iflag, imeth, null, null,
                                                 xper, xfoc, serr);
                        if (iflgret >= 0 && (ipl <= SweConst.SE_NEPTUNE ||
                                             sp.charAt(c) == 'F') ) {
                            if (is_label) { DevNull.println(gap+"focus"); break; }
                            DevNull.print(gap);
                            DevNull.print(f.fmt("%# 11.7f", xfoc[0]));
                        }
                    };
                    break;
                case '+':
                    if (is_house) break;
                    if (is_label) { DevNull.println("phase"); break; }
                    DevNull.print(dms(attr[0], round_flag));
                    break;
                case '-':
                    if (is_label) { DevNull.println("phase"); break; }
                    if (is_house) break;
                    DevNull.print("  "+f.fmt("%# 14.9f", attr[1]));
                    break;
                case '*':
                    if (is_label) { DevNull.println("elong"); break; }
                    if (is_house) break;
                    DevNull.print(dms(attr[2], round_flag));
                    break;
                case '/':
                    if (is_label) { DevNull.println("diamet"); break; }
                    if (is_house) break;
                    DevNull.print(dms(attr[3], round_flag));
                    break;
                case '=':
                    if (is_label) { DevNull.println("magn"); break; }
                    if (is_house) break;
                    DevNull.print("  "+f.fmt("%# 6.1f", attr[4])+"m");
                    break;
            }     /* switch */
        }       /* for sp */
        DevNull.print("\n");
        return SweConst.OK;
    }

    private String dms(double xv, int iflag) {
        int izod;
        int k, kdeg, kmin, ksec;
        String c = swed.ODEGREE_CHAR;
        String s1;
        String s;
        int sgn;
        s = "";
        if ((iflag & SweConst.SEFLG_EQUATORIAL)!=0)
            c = "h";
        if (xv < 0) {
            xv = -xv;
            sgn = -1;
        } else
            sgn = 1;
        if ((iflag & BIT_ROUND_MIN)!=0)
            xv = sl.swe_degnorm(xv + 0.5/60);
        if ((iflag & BIT_ROUND_SEC)!=0)
            xv = sl.swe_degnorm(xv + 0.5/3600);
        if ((iflag & BIT_ZODIAC)!=0) {
            izod = (int) (xv / 30)%12;
            xv%=30.;
            kdeg = (int) xv;
            s=f.fmt("%2ld",kdeg)+" "+zod_nam[izod]+" ";
        } else {
            kdeg = (int) xv;
            s=" "+f.fmt("%3ld", kdeg)+c;
        }
        xv -= kdeg;
        xv *= 60;
        kmin = (int) xv;
        if ((iflag & BIT_ZODIAC)!=0 && (iflag & BIT_ROUND_MIN)!=0)
            s1=f.fmt("%2ld", kmin);
        else
            s1=f.fmt("%2ld", kmin)+"'";
        s+=s1;
        if ((iflag & BIT_ROUND_MIN)!=0)
            return return_dms(sgn,s);
        xv -= kmin;
        xv *= 60;
        ksec = (int) xv;
        if ((iflag & BIT_ROUND_SEC)!=0)
            s1=f.fmt("%2ld", ksec)+"\"";
        else
            s1=f.fmt("%2ld", ksec);
        s+=s1;
        if ((iflag & BIT_ROUND_SEC)!=0)
            return return_dms(sgn,s);
        xv -= ksec;
        k = (int) (xv * 10000);
        s1="."+f.fmt("%04ld", k);
        s+=s1;
        return return_dms(sgn,s);
    }

    private String return_dms(int sgn, String s) {
        if (sgn < 0) {
            for (int i=0; i<s.length();i++) {
                if (Character.isDigit(s.charAt(i))) {
                    s=s.substring(0,i-1)+"-"+s.substring(i);
                    break;
                }
            }
        }

        globalResult = s;
        
        return(s);
    }

    private int letter_to_ipl(int letter) {
        if (letter >= (int)'0' && letter <= (int)'9')
            return letter - (int)'0' + SweConst.SE_SUN;
        if (letter >= (int)'A' && letter <= (int)'I')
            return letter - (int)'A' + SweConst.SE_MEAN_APOG;
        if (letter >= (int)'J' && letter <= (int)'Z')
            return letter - (int)'J' + SweConst.SE_CUPIDO;
        switch (letter) {
            case (int)'m': return SweConst.SE_MEAN_NODE;
            case (int)'c': return SweConst.SE_INTP_APOG;
            case (int)'g': return SweConst.SE_INTP_PERG;
            case (int)'n':
            case (int)'o': return SweConst.SE_ECL_NUT;
            case (int)'t': return SweConst.SE_TRUE_NODE;
            case (int)'f': return SweConst.SE_FIXSTAR;
            case (int)'w': return SweConst.SE_WALDEMATH;
            case 'e': /* swetest: a line of labels */
            case 'q': /* swetest: delta t */
            case 's': /* swetest: an asteroid, with number given in -xs[number] */
            case 'z': /* swetest: a fictitious body, number given in -xz[number] */
            case 'd': /* swetest: default (main) factors 0123456789mtABC */
            case 'p': /* swetest: main factors ('d') plus main asteroids DEFGHI */
            case 'h': /* swetest: fictitious factors JKLMNOPQRSTUVWXYZw */
            case 'a': /* swetest: all factors, like 'p'+'h' */
                return -1;
        }
        return -2;
    }


    private int do_eclipse_etc() {
        DblObj dtmp=new DblObj();
        StringBuffer sstar;
        int ii, i;
        boolean has_found = false;
        double t_ut, dt;
        int ecl_type = 0, eclflag;
        String s1, s2;
        int rsmi = 0;
        if ((smod & (SMOD_LUNAR | SMOD_SOLAR | SMOD_OCCULT))!=0)  {
            if ((smod & SMOD_ALL) == 0) /* no selective eclipse type set, set all */
                smod |= SMOD_ALL;
            if ((smod & SMOD_TOTAL)!=0) search_flag |= SweConst.SE_ECL_TOTAL;
            if ((smod & SMOD_ANNULAR)!=0) search_flag |= SweConst.SE_ECL_ANNULAR | SweConst.SE_ECL_PENUMBRAL;
            if ((smod & SMOD_PARTIAL)!=0) search_flag |= SweConst.SE_ECL_PARTIAL;
            if ((smod & SMOD_ANNTOT)!=0) search_flag |= SweConst.SE_ECL_ANNULAR_TOTAL;
        }
        /* 
         * for local eclipses: set geographic position of observer 
         */
        if ((smod & (SMOD_LOCAL|SMOD_RISE|SMOD_METR))!=0)
            sw.swe_set_topo(geopos[0], geopos[1], geopos[2]); 
        t_ut = tjd;
        do_printf("\n");
        for (ii = 0; ii < nstep; ii++) {
            sout = "";
            if ((smod & SMOD_LUNAR)!=0 && (smod & SMOD_HOW)!=0) {
                if ((eclflag = sw.swe_lun_eclipse_how(t_ut, whicheph, geopos, attr, serr)) == SweConst.ERR) {
                    do_printf(serr);
                    System.exit(0);
                } else {
                    ecl_type = 0;
                    if ((eclflag & SweConst.SE_ECL_TOTAL)!=0) {
                        sout="total lunar eclipse: "+f.fmt("%f",attr[0])+" o/o\n";
                        ecl_type = ECL_LUN_TOTAL;
                    } else if ((eclflag & SweConst.SE_ECL_PARTIAL)!=0)  {
                        sout="partial lunar eclipse: "+f.fmt("%f",attr[0])+" o/o\n";
                        ecl_type = ECL_LUN_PARTIAL;
                    } else if ((eclflag & SweConst.SE_ECL_PENUMBRAL)!=0)  {
                        sout="penumbral lunar eclipse: "+f.fmt("%f",attr[0])+" o/o\n";
                        ecl_type = ECL_LUN_PENUMBRAL;
                    } else {
                        sout="no lunar eclipse\n";
                    }
                    do_printf(sout);
                }
            }
            if ((smod & SMOD_LUNAR)!=0 && (smod & SMOD_HOW)==0) {
                if ((eclflag = sw.swe_lun_eclipse_when(t_ut, whicheph, search_flag, 
                                                       tret, direction_flag?-1:0, serr)) == SweConst.ERR) {
                    do_printf(serr);
                    System.exit(0);
                } 
                t_ut = tret[0];
                if ((eclflag & SweConst.SE_ECL_TOTAL)!=0) {
                    sout="total   ";
                    ecl_type = ECL_LUN_TOTAL;
                }
                if ((eclflag & SweConst.SE_ECL_PENUMBRAL)!=0) {
                    sout="penumb. ";
                    ecl_type = ECL_LUN_PENUMBRAL;
                }
                if ((eclflag & SweConst.SE_ECL_PARTIAL)!=0) {
                    sout="partial ";
                    ecl_type = ECL_LUN_PARTIAL;
                }
                sout+="lunar eclipse ";
                //        swe_revjul(t_ut, gregflag, &jyear, &jmon, &jday, &jut);
                sd.setJulDay(t_ut);
                sd.setCalendarType(gregflag,SweDate.SE_KEEP_JD); // Keep JulDay!
                jyear=sd.getYear();
                jmon=sd.getMonth();
                jday=sd.getDay();
                jut=sd.getHour();
                if ((eclflag = sw.swe_lun_eclipse_how(t_ut, whicheph, geopos, attr, serr)) == SweConst.ERR) {
                    do_printf(serr);
                    System.exit(0);
                }
                /* eclipse times, penumbral, partial, total begin and end */
                sout += f.fmt("%2d",jday)+"."+f.fmt("%2d",jmon)+"."+
                    f.fmt("%4d",jyear)+"\t"+hms(jut,0)+"\t"+f.fmt("%f",attr[0])+
                    " o/o\n";
                sout += "  "+hms_from_tjd(tret[6])+" "; 
                if (tret[2] != 0)
                    sout += hms_from_tjd(tret[2])+" "; 
                else
                    sout+="   -         ";
                if (tret[4] != 0)
                    sout += hms_from_tjd(tret[4])+" "; 
                else
                    sout+="   -         ";
                if (tret[5] != 0)
                    sout += hms_from_tjd(tret[5]) + " "; 
                else
                    sout+="   -         ";
                if (tret[3] != 0)
                    sout += hms_from_tjd(tret[3]) + " "; 
                else
                    sout+="   -         ";
                sout += hms_from_tjd(tret[7]) + "\n"; 
                if ((smod & SMOD_HOCAL)!=0) {
                    IntObj ihou=new IntObj(), imin=new IntObj(), isec=new IntObj(), isgn=new IntObj();
                    DblObj dfrc=new DblObj();
                    sl.swe_split_deg(jut, SweConst.SE_SPLIT_DEG_ROUND_MIN, ihou, imin, isec, dfrc, isgn);
                    sout="\""+f.fmt("%04d",jyear)+" "+f.fmt("%02d",jmon)+" "+f.fmt("%02d",jday)+" "+f.fmt("%02d",ihou.val)+"."+f.fmt("%02d",imin.val)+" "+f.fmt("%d",ecl_type)+"\",\n";
                } 
                do_printf(sout);
            }
            if ((smod & SMOD_SOLAR)!=0 && (smod & SMOD_LOCAL)!=0) {
                if ((eclflag = sw.swe_sol_eclipse_when_loc(t_ut, whicheph, geopos, tret, attr, direction_flag?-1:0, serr)) == SweConst.ERR) {
                    do_printf(serr);
                    System.exit(0);
                } else { 
                    has_found = false;
                    t_ut = tret[0];
                    if ((smod & SMOD_TOTAL)!=0 && (eclflag & SweConst.SE_ECL_TOTAL)!=0) {
                        sout="total   ";
                        has_found = true;
                        ecl_type = ECL_SOL_TOTAL;
                    }
                    if ((smod & SMOD_ANNULAR)!=0 && (eclflag & SweConst.SE_ECL_ANNULAR)!=0) {
                        sout="annular ";
                        has_found = true;
                        ecl_type = ECL_SOL_ANNULAR;
                    }
                    if ((smod & SMOD_PARTIAL)!=0 && (eclflag & SweConst.SE_ECL_PARTIAL)!=0) {
                        sout="partial ";
                        has_found = true;
                        ecl_type = ECL_SOL_PARTIAL;
                    }
                    if (!has_found) {
                        ii--;
                    } else {
                        i = sw.swe_calc(t_ut + sd.getDeltaT(t_ut), SweConst.SE_ECL_NUT, 0, x, serr);
                        sd.setJulDay(t_ut);
                        sd.setCalendarType(gregflag,SweDate.SE_KEEP_JD); // Keep JulDay!
                        jyear=sd.getYear();
                        jmon=sd.getMonth();
                        jday=sd.getDay();
                        jut=sd.getHour();
                        sout += f.fmt("%2d",jday)+"."+f.fmt("%2d",jmon)+"."+f.fmt("%4d",jyear)+"\t"+hms(jut,0)+"\t"+f.fmt("%f",attr[0])+"o/o\n";
                        dt = (tret[3] - tret[2]) * 24 * 60;
                        sout += "\t"+(int)dt+" min "+f.fmt("%4.2f",(dt%1.) * 60)+" sec\t";
                        if ((eclflag & SweConst.SE_ECL_1ST_VISIBLE)!=0)
                            sout += hms_from_tjd(tret[1]) + " "; 
                        else
                            sout+="   -         ";
                        if ((eclflag & SweConst.SE_ECL_2ND_VISIBLE)!=0)
                            sout += hms_from_tjd(tret[2]) + " "; 
                        else
                            sout+="   -         ";
                        if ((eclflag & SweConst.SE_ECL_3RD_VISIBLE)!=0)
                            sout += hms_from_tjd(tret[3]) + " "; 
                        else
                            sout+="   -         ";
                        if ((eclflag & SweConst.SE_ECL_4TH_VISIBLE)!=0)
                            sout += hms_from_tjd(tret[4]) + " "; 
                        else
                            sout+="   -         ";
                        sout+="\n";
                        do_printf(sout);
                    }
                }
            }   /* endif search_local */
            if ((smod & SMOD_OCCULT)!=0 && (smod & SMOD_LOCAL)!=0) {
                sstar=new StringBuffer(star);
                if ((eclflag = sw.swe_lun_occult_when_loc(t_ut, ipl, sstar, whicheph, geopos, tret, attr, direction_flag?-1:0, serr)) == SweConst.ERR) {
                    do_printf(serr);
                    System.exit(0);
                } else {
                    star=sstar.toString();
                    has_found = false;
                    t_ut = tret[0];
                    if ((smod & SMOD_TOTAL)!=0 && (eclflag & SweConst.SE_ECL_TOTAL)!=0) {
                        sout="total   ";
                        has_found = true;
                        ecl_type = ECL_SOL_TOTAL;
                    }
                    if ((smod & SMOD_ANNULAR)!=0 && (eclflag & SweConst.SE_ECL_ANNULAR)!=0) {
                        sout="annular ";
                        has_found = true;
                        ecl_type = ECL_SOL_ANNULAR;
                    }
                    if ((smod & SMOD_PARTIAL)!=0 && (eclflag & SweConst.SE_ECL_PARTIAL)!=0) {
                        sout="partial ";
                        has_found = true;
                        ecl_type = ECL_SOL_PARTIAL;
                    }
                    if (!has_found) {
                        ii--;
                    } else {
                        i = sw.swe_calc(t_ut + sd.getDeltaT(t_ut), SweConst.SE_ECL_NUT, 0, x, serr);
                        sd.setJulDay(t_ut);
                        sd.setCalendarType(gregflag,SweDate.SE_KEEP_JD); // Keep JulDay!
                        jyear=sd.getYear();
                        jmon=sd.getMonth();
                        jday=sd.getDay();
                        jut=sd.getHour();
                        sout += f.fmt("%2d",jday)+"."+f.fmt("%2d",jmon)+"."+f.fmt("%4d",jyear)+"\t"+hms(jut,0)+"\t"+f.fmt("%f",attr[0])+"o/o\n";
                        dt = (tret[3] - tret[2]) * 24 * 60;
                        sout += "\t"+f.fmt("%d",(int) dt)+" min "+f.fmt("%4.2f",(dt%1.)*60)+" sec\t";
                        if ((eclflag & SweConst.SE_ECL_1ST_VISIBLE)!=0)
                            sout += hms_from_tjd(tret[1]) + " "; 
                        else
                            sout+="   -         ";
                        if ((eclflag & SweConst.SE_ECL_2ND_VISIBLE)!=0)
                            sout += hms_from_tjd(tret[2]) + " "; 
                        else
                            sout+="   -         ";
                        if ((eclflag & SweConst.SE_ECL_3RD_VISIBLE)!=0)
                            sout += hms_from_tjd(tret[3]) + " "; 
                        else
                            sout+="   -         ";
                        if ((eclflag & SweConst.SE_ECL_4TH_VISIBLE)!=0)
                            sout += hms_from_tjd(tret[4]) + " "; 
                        else
                            sout+="   -         ";
                        sout+="\n";
                        do_printf(sout);
                    }
                }
            }   /* endif search_local */
            if ((smod & SMOD_SOLAR)!=0 && (smod & SMOD_LOCAL)==0) {
                if ((eclflag = sw.swe_sol_eclipse_when_glob(t_ut, whicheph, search_flag,
                                                            tret, direction_flag?-1:0, serr)) == SweConst.ERR) {
                    do_printf(serr);
                    System.exit(0);
                } 
                t_ut = tret[0];
                if ((eclflag & SweConst.SE_ECL_TOTAL)!=0) {
                    sout="total   ";
                    ecl_type = ECL_SOL_TOTAL;
                }
                if ((eclflag & SweConst.SE_ECL_ANNULAR)!=0) {
                    sout="annular ";
                    ecl_type = ECL_SOL_ANNULAR;
                }
                if ((eclflag & SweConst.SE_ECL_ANNULAR_TOTAL)!=0) {
                    sout="ann-tot ";
                    ecl_type = ECL_SOL_ANNULAR;        /* by Alois: what is this ? */
                }
                if ((eclflag & SweConst.SE_ECL_PARTIAL)!=0) {
                    sout="partial ";
                    ecl_type = ECL_SOL_PARTIAL;
                }
                if ((eclflag & SweConst.SE_ECL_NONCENTRAL)!=0 && (eclflag & SweConst.SE_ECL_PARTIAL)==0)
                    sout+="non-central ";
                sw.swe_sol_eclipse_where(t_ut, whicheph, geopos, attr, serr);
                //      swe_revjul(t_ut, gregflag, &jyear, &jmon, &jday, &jut);
                sd.setJulDay(t_ut);
                sd.setCalendarType(gregflag,SweDate.SE_KEEP_JD); // Keep JulDay!
                jyear=sd.getYear();
                jmon=sd.getMonth();
                jday=sd.getDay();
                jut=sd.getHour();
                sout += f.fmt("%2d",jday)+"."+f.fmt("%2d",jmon)+"."+f.fmt("%4d",jyear)+"\t"+hms(jut,0)+"\t"+f.fmt("%f",attr[3])+" km\t"+f.fmt("%f",attr[0])+" o/o\n";
                sout += "\t" + hms_from_tjd(tret[2]) + " "; 
                if (tret[4] != 0)
                    sout += hms_from_tjd(tret[4]) + " "; 
                else
                    sout+="   -         ";
                if (tret[5] != 0)
                    sout += hms_from_tjd(tret[5]) + " "; 
                else
                    sout+="   -         ";
                sout += hms_from_tjd(tret[3]) + "\n"; 
                s1=dms(geopos[0], BIT_ROUND_MIN);
                s2=dms(geopos[1], BIT_ROUND_MIN);
                sout += "\t"+s1+"\t"+s2;
                if ((eclflag & SweConst.SE_ECL_PARTIAL)==0 && (eclflag & SweConst.SE_ECL_NONCENTRAL)==0) {
                    if ((eclflag = sw.swe_sol_eclipse_when_loc(t_ut - 10, whicheph, geopos, tret, attr, 0, serr)) == SweConst.ERR) {
                        do_printf(serr);
                        System.exit(0);
                    }
                    if (Math.abs(tret[0] - t_ut) > 1) 
                        do_printf("when_loc returns wrong date\n");
                    dt = (tret[3] - tret[2]) * 24 * 60;
                    sout += "\t"+(int)dt+" min "+f.fmt("%4.2f",(dt%1.) * 60.)+" sec\t";
                }
                sout+="\n";
                if ((smod & SMOD_HOCAL)!=0) {
                    IntObj ihou=new IntObj(), imin=new IntObj(), isec=new IntObj(), isgn=new IntObj();
                    DblObj dfrc=new DblObj();
                    sl.swe_split_deg(jut, SweConst.SE_SPLIT_DEG_ROUND_MIN, ihou, imin, isec, dfrc, isgn);
                    sout="\""+f.fmt("%04d",jyear)+" "+f.fmt("%02d",jmon)+" "+f.fmt("%02d",jday)+" "+f.fmt("%02d",ihou.val)+"."+f.fmt("%02d",imin.val)+" "+f.fmt("%d",ecl_type)+"\",\n";
                } 
                do_printf(sout);
            }
            if ((smod & SMOD_OCCULT)!=0 && (smod & SMOD_LOCAL)==0) {
                /* * global search for eclipses */
                sstar=new StringBuffer(star);
                if ((eclflag = sw.swe_lun_occult_when_glob(t_ut, ipl, sstar, whicheph, search_flag, tret, direction_flag?-1:0, serr)) == SweConst.ERR) {
                    do_printf(serr);
                    System.exit(0);
                } 
                star=sstar.toString();
                t_ut = tret[0];
                if ((eclflag & SweConst.SE_ECL_TOTAL)!=0) {
                    sout="total   ";
                    ecl_type = ECL_SOL_TOTAL;
                }
                if ((eclflag & SweConst.SE_ECL_ANNULAR)!=0) {
                    sout="annular ";
                    ecl_type = ECL_SOL_ANNULAR;
                }
                if ((eclflag & SweConst.SE_ECL_ANNULAR_TOTAL)!=0) {
                    sout="ann-tot ";
                    ecl_type = ECL_SOL_ANNULAR;        /* by Alois: what is this ? */
                }
                if ((eclflag & SweConst.SE_ECL_PARTIAL)!=0) {
                    sout="partial ";
                    ecl_type = ECL_SOL_PARTIAL;
                }
                if ((eclflag & SweConst.SE_ECL_NONCENTRAL)!=0 && (eclflag & SweConst.SE_ECL_PARTIAL)==0)
                    sout+="non-central ";
                sstar=new StringBuffer(star);
                sw.swe_lun_occult_where(t_ut, ipl, sstar, whicheph, geopos, attr, serr);
                star=sstar.toString();
                sd.setJulDay(t_ut);
                sd.setCalendarType(gregflag,SweDate.SE_KEEP_JD); // Keep JulDay!
                jyear=sd.getYear();
                jmon=sd.getMonth();
                jday=sd.getDay();
                jut=sd.getHour();
                sout += f.fmt("%2d",jday)+"."+f.fmt("%2d",jmon)+"."+f.fmt("%4d",jyear)+"\t"+hms(jut,0)+"\t"+f.fmt("%f",attr[3])+" km\t"+f.fmt("%f",attr[0])+" o/o\n";
                sout += "\t" + hms_from_tjd(tret[2]) + " "; 
                if (tret[4] != 0)
                    sout += hms_from_tjd(tret[4]) + " "; 
                else
                    sout+="   -         ";
                if (tret[5] != 0)
                    sout += hms_from_tjd(tret[5]) + " "; 
                else
                    sout+="   -         ";
                sout += hms_from_tjd(tret[3]) + "\n"; 
                s1=dms(geopos[0], BIT_ROUND_MIN);
                s2=dms(geopos[1], BIT_ROUND_MIN);
                sout += "\t"+s1+"\t"+s2;
                if ((eclflag & SweConst.SE_ECL_PARTIAL)==0 && (eclflag & SweConst.SE_ECL_NONCENTRAL)==0) {
                    sstar=new StringBuffer(star);
                    if ((eclflag = sw.swe_lun_occult_when_loc(t_ut - 10, ipl, sstar, whicheph, geopos, tret, attr, 0, serr)) == SweConst.ERR) {
                        do_printf(serr);
                        System.exit(0);
                    }
                    star=sstar.toString();
                    if (Math.abs(tret[0] - t_ut) > 1) 
                        do_printf("when_loc returns wrong date\n");
                    dt = (tret[3] - tret[2]) * 24 * 60;
                    sout += "\t"+(int)dt+" min "+f.fmt("%4.2f",(dt%1.)*60)+" sec\t";
                } 
                sout+="\n";
                if ((smod & SMOD_HOCAL)!=0) {
                    IntObj ihou=new IntObj(), imin=new IntObj(), isec=new IntObj(), isgn=new IntObj();
                    DblObj dfrc=new DblObj();
                    sl.swe_split_deg(jut, SweConst.SE_SPLIT_DEG_ROUND_MIN, ihou, imin, isec, dfrc, isgn);
                    sout="\""+f.fmt("%04d",jyear)+" "+f.fmt("%02d",jmon)+" "+f.fmt("%02d",jday)+" "+f.fmt("%02d",ihou.val)+"."+f.fmt("%02d",imin.val)+" "+f.fmt("%d",ecl_type)+"\",\n";
                } 
                do_printf(sout);
            }
            if ((smod & SMOD_RISE)!=0) {
                dtmp.val=tret[0];
                sstar=new StringBuffer(star);
                rsmi = SweConst.SE_CALC_RISE;
                if (norefrac) rsmi |= SweConst.SE_BIT_NO_REFRACTION;
                if (disccenter) rsmi |= SweConst.SE_BIT_DISC_CENTER;
                if (sw.swe_rise_trans(t_ut, ipl, sstar, whicheph, rsmi, geopos, 1013.25, 10, dtmp, serr) !=
                    SweConst.OK) {
                    do_printf(serr);
                    System.exit(0);
                } 
                star=sstar.toString();
                tret[0]=dtmp.val;
                dtmp.val=tret[1];
                sstar=new StringBuffer(star);
                rsmi = SweConst.SE_CALC_SET;
                if (norefrac) rsmi |= SweConst.SE_BIT_NO_REFRACTION;
                if (disccenter) rsmi |= SweConst.SE_BIT_DISC_CENTER;
                if (sw.swe_rise_trans(t_ut, ipl, sstar, whicheph, rsmi, geopos, 1013.25, 10, dtmp, serr) !=
                    SweConst.OK) {
                    do_printf(serr);
                    System.exit(0);
                } 
                star=sstar.toString();
                tret[1]=dtmp.val;
                sout="rise     ";
                if (tret[0] == 0 || tret[0] > tret[1]) {
                    sout+="         -                     ";
                } else {
                    sd.setJulDay(tret[0]);
                    sd.setCalendarType(gregflag,SweDate.SE_KEEP_JD); // Keep JulDay!
                    jyear=sd.getYear();
                    jmon=sd.getMonth();
                    jday=sd.getDay();
                    jut=sd.getHour();
                    sout += f.fmt("%2d",jday)+"."+f.fmt("%2d",jmon)+"."+f.fmt("%4d",jyear)+"\t"+hms(jut,0)+"    ";
                }
                sout+="set      ";
                if (tret[1] == 0) {
                    sout+="         -                     \n";
                } else {
                    sd.setJulDay(tret[1]);
                    sd.setCalendarType(gregflag,SweDate.SE_KEEP_JD); // Keep JulDay!
                    jyear=sd.getYear();
                    jmon=sd.getMonth();
                    jday=sd.getDay();
                    jut=sd.getHour();
                    sout += f.fmt("%2d",jday)+"."+f.fmt("%2d",jmon)+"."+f.fmt("%4d",jyear)+"\t"+hms(jut,0)+"\n"; 
                }
                do_printf(sout);
            }
            if ((smod & SMOD_METR)!=0) {
                dtmp.val=tret[0];
                sstar=new StringBuffer(star);
                if (sw.swe_rise_trans(t_ut, ipl, sstar, whicheph, SweConst.SE_CALC_MTRANSIT, geopos, 1013.25, 10, dtmp, serr) != SweConst.OK) {
                    do_printf(serr);
                    System.exit(0);
                } 
                star=sstar.toString();
                tret[0]=dtmp.val;
                dtmp.val=tret[1];
                sstar=new StringBuffer(star);
                if (sw.swe_rise_trans(t_ut, ipl, sstar, whicheph, SweConst.SE_CALC_ITRANSIT, geopos, 1013.25, 10, dtmp, serr) != SweConst.OK) {
                    do_printf(serr);
                    System.exit(0);
                }
                star=sstar.toString();
                tret[1]=dtmp.val;
                sout="mtransit ";
                if (tret[0] == 0) {
                    sout+="         -                     ";
                } else {
                    sd.setJulDay(tret[0]);
                    sd.setCalendarType(gregflag,SweDate.SE_KEEP_JD); // Keep JulDay!
                    jyear=sd.getYear();
                    jmon=sd.getMonth();
                    jday=sd.getDay();
                    jut=sd.getHour();
                    sout += f.fmt("%2d",jday)+"."+f.fmt("%2d",jmon)+"."+f.fmt("%4d",jyear)+"\t"+hms(jut,0)+"    "; 
                }
                sout+="itransit ";
                if (tret[1] == 0) {
                    sout+="         -                     \n";
                } else {
                    sd.setJulDay(tret[1]);
                    sd.setCalendarType(gregflag,SweDate.SE_KEEP_JD); // Keep JulDay!
                    jyear=sd.getYear();
                    jmon=sd.getMonth();
                    jday=sd.getDay();
                    jut=sd.getHour();
                    sout += f.fmt("%2d",jday)+"."+f.fmt("%2d",jmon)+"."+f.fmt("%4d",jyear)+"\t"+hms(jut,0)+"\n"; 
                }
                do_printf(sout);
            }
            if ((smod & (SMOD_RISE | SMOD_METR))!=0 && tret[1] > 0)
                t_ut = tret[1] + 0.1;
            else
                t_ut += direction;
        }
        if (serr_warn.length() > 0) {
            do_printf("\nwarning: ");
            do_printf(serr_warn);
            do_printf("\n");
        }
        return SweConst.OK;
    }
  
    private String hms_from_tjd(double x) {
        String s;
        s=hms(((x + 1000000.5)%1.) * 24, 0)+" ";
        return s;
    }
  
    private String hms(double x, int iflag) {
        String s;
        int sp;
        String c = swed.ODEGREE_CHAR;
        x += 0.5 / 36000.0; /* round to 0.1 sec */
        s=dms(x, iflag);
        sp = s.indexOf(c);
        if (sp >= 0) {
            s = s.substring(0,sp) + ":" + s.substring(sp+c.length());
            s = s.replace('\'',':');
            s = s.substring(0,s.lastIndexOf(':')+5);
        }
        return s;
    }
  
    static void do_printf(StringBuffer info) {
        DevNull.print(info.toString());
    }
    static void do_printf(String info) {
        DevNull.print(info);
    }

    /* make_ephemeris_path().
     * ephemeris path includes
     *   current working directory
     *   + program directory
     *   + default path from swephexp.h on current drive
     *   +                              on program drive
     *   +                              on drive C:
     */
    private int make_ephemeris_path(int iflg, String argv0) {
        String path="", s="";
        int sp;
        String dirglue = swed.DIR_GLUE;
        int pathlen = 0;
        /* moshier needs no ephemeris path */
        if ((iflg & SweConst.SEFLG_MOSEPH)!=0)
            return SweConst.OK;
        /* current working directory */
        path="."+swed.PATH_SEPARATOR.charAt(0);
        /* program directory */
        sp = argv0.lastIndexOf(dirglue);
        if (sp >= 0) {
            pathlen = sp;
            if (path.length() + pathlen < swed.AS_MAXCH-1) {
                s=argv0.substring(0,pathlen);
                path=path+s+swed.PATH_SEPARATOR.charAt(0);
            }
        }
        if (path.length() + pathlen < swed.AS_MAXCH-1)
            path+=SweConst.SE_EPHE_PATH;
        return SweConst.OK;
    }


}

class Zodiac  {
       
  Swetest alg = new Swetest();

  public int sign(int planetNumber, String date) {

    String i1 = "-p" + planetNumber;
    String i2 = "-b" + date;
    String i3 = "-fZ";
    String i4 = "-head";
    String i5 = "-roundmin";

    String[] args = new String[]{i1, i2, i3, i4, i5};

    alg.main_start(args);

    String result = alg.globalResult;

    Pattern p = Pattern.compile("([a-z][a-z])");
    Matcher m = p.matcher(result);
    String sign = "";
    if (m.find()) {
      sign = m.group(1);
    }

    int signNo = 0;
    for (String z:Swetest.zod_nam) {
      if (sign.equals(z)) break;
      signNo++;
    }
                       
    return signNo;
  }

  public int decanWithinSign(int planetNumber, String date) {
        
    String i1 = "-p" + planetNumber;
    String i2 = "-b" + date;
    String i3 = "-fZ";
    String i4 = "-head";
    String i5 = "-roundmin";

    String[] args = new String[]{i1, i2, i3, i4, i5};

    alg.main_start(args);

    String result = alg.globalResult;

    String res[] = result.split(" ");

    String token = "**********"
    if (res[0].equals("")) {
      token = "**********"
    } else {
      token = "**********"
    }

    int decan = "**********"
        
    return decan+1;
  }

  public int decan(int planetNumber, String date) {
    int sign = sign(planetNumber, date);
    int decan = decanWithinSign(planetNumber, date);
    return (sign * 3) + decan;
  }

  public int[] decans(String date) {
    int d[] = new int[10];
    for (int i=0;i<10;i++) {
      d[i] = decan(i, date);
    }
    return d;        
  }
    
}

class DecanTest {

    public void testDecan() {
	Zodiac l = new Zodiac();
	int i[] = l.decans("10.9.1930");
	for (Object ii : i) {
	    System.out.println("ii=" + ii);
	}
	System.out.println("--------------");
    }

    public void testLewi() {
	Zodiac l = new Zodiac();
	int i;

	// [4, 29, 1, 4, 32, 32, 8, 21, 25, 19]
	for (int j=0;j<10;j++){
	    i = l.decan(j, "24.4.1973");
	    System.out.println("i=" + i);
	}	    	
    }

    public static void main(String[] args) {
	DecanTest v = new DecanTest();
	v.testDecan();
	v.testLewi();
    }    
    
}

class DecanLewi {

    private static final List<String> PLANETS = Collections.unmodifiableList(Arrays.asList(
            "sun", "mo", "mer", "ven", "mar", "ju", "sa", "ur", "ne", "pl"
    ));

    private static final int[][] SUN_MOON_TABLE = new int[12][12];

    static {
        for (int i = 0; i < 12; i++) {
            for (int j = 0; j < 12; j++) {
                SUN_MOON_TABLE[i][j] = (i * 12) + j + 1;
            }
        }
    }

    public static Map<String, Map<String, Map<String, Integer>>> lewimapInit() {
        Map<String, Map<String, Map<String, Integer>>> mapping = new HashMap<>();

        BiConsumer<String, String, Map<String, Integer>> addMapping = (planet, aspect, values) ->
            mapping.computeIfAbsent(planet, k -> new HashMap<>()).put(aspect, values);

        // --- MO ---
        addMapping.accept("mo", "tick", Map.of("sun",245,"mer",145,"ven",146,"mar",147,"ju",148,"sa",149,"ur",150,"ne",151,"pl",254));
        Map<String, Integer> moTriStarMap = Map.of("sun",246,"mer",152,"ven",153,"mar",154,"ju",155,"sa",156,"ur",157,"ne",158,"pl",255);
        addMapping.accept("mo", "tri", moTriStarMap);
        addMapping.accept("mo", "*", moTriStarMap); // Same as tri
        Map<String, Integer> moSqOppMap = Map.of("sun",247,"mer",159,"ven",160,"mar",161,"ju",162,"sa",163,"ur",164,"ne",165,"pl",256);
        addMapping.accept("mo", "sq", moSqOppMap);
        addMapping.accept("mo", "opp", moSqOppMap); // Same as sq

        // --- UR ---
        addMapping.accept("ur", "tick", Map.of("ne",242,"pl",272));
        Map<String, Integer> urTriStarMap = Map.of("ne",243,"pl",273);
        addMapping.accept("ur", "tri", urTriStarMap);
        addMapping.accept("ur", "*", urTriStarMap); // Same as tri
        Map<String, Integer> urSqOppMap = Map.of("ne",244,"pl",274);
        addMapping.accept("ur", "sq", urSqOppMap);
        addMapping.accept("ur", "opp", urSqOppMap); // Same as sq

        // --- SUN ---
        addMapping.accept("sun", "tick", Map.of("mer",166,"ven",167,"mar",168,"ju",169,"sa",170,"ur",171,"ne",172,"pl",251));
        Map<String, Integer> sunTriStarMap = Map.of("ven",248,"mar",173,"ju",174,"sa",175,"ur",176,"ne",177,"pl",252);
        addMapping.accept("sun", "tri", sunTriStarMap);
        addMapping.accept("sun", "*", sunTriStarMap); // Same as tri
        Map<String, Integer> sunSqOppMap = Map.of("mar",178,"ju",179,"sa",180,"ur",181,"ne",182,"pl",253);
        addMapping.accept("sun", "sq", sunSqOppMap);
        addMapping.accept("sun", "opp", sunSqOppMap); // Same as sq

        // --- SA ---
        addMapping.accept("sa", "tick", Map.of("ur",236,"ne",237,"pl",269));
        Map<String, Integer> saTriStarMap = Map.of("ur",238,"ne",239,"pl",270);
        addMapping.accept("sa", "tri", saTriStarMap);
        addMapping.accept("sa", "*", saTriStarMap); // Same as tri
        Map<String, Integer> saSqOppMap = Map.of("ur",240,"ne",241,"pl",271);
        addMapping.accept("sa", "sq", saSqOppMap);
        addMapping.accept("sa", "opp", saSqOppMap); // Same as sq

        // --- MER ---
        addMapping.accept("mer", "tick", Map.of("ven",183,"mar",184,"ju",185,"sa",186,"ur",187,"ne",188,"pl",257));
        Map<String, Integer> merTriStarMap = Map.of("ven",189,"mar",190,"ju",191,"sa",192,"ur",193,"ne",194,"pl",258);
        addMapping.accept("mer", "tri", merTriStarMap);
        addMapping.accept("mer", "*", merTriStarMap); // Same as tri
        Map<String, Integer> merSqOppMap = Map.of("mar",195,"ju",196,"sa",197,"ur",198,"ne",199,"pl",259);
        addMapping.accept("mer", "sq", merSqOppMap);
        addMapping.accept("mer", "opp", merSqOppMap); // Same as sq

        // --- JU ---
        addMapping.accept("ju", "tick", Map.of("sa",227,"ur",228,"ne",229,"pl",266));
        Map<String, Integer> juTriStarMap = Map.of("sa",230,"ur",231,"ne",232,"pl",267);
        addMapping.accept("ju", "tri", juTriStarMap);
        addMapping.accept("ju", "*", juTriStarMap); // Same as tri
        Map<String, Integer> juSqOppMap = Map.of("sa",233,"ur",234,"ne",235,"pl",268);
        addMapping.accept("ju", "sq", juSqOppMap);
        addMapping.accept("ju", "opp", juSqOppMap); // Same as sq

        // --- VEN ---
        addMapping.accept("ven", "tick", Map.of("mar",200,"ju",201,"sa",202,"ur",203,"ne",204,"pl",260));
        Map<String, Integer> venTriStarMap = Map.of("mar",205,"ju",206,"sa",207,"ur",208,"ne",209,"pl",261);
        addMapping.accept("ven", "tri", venTriStarMap);
        addMapping.accept("ven", "*", venTriStarMap); // Same as tri
        Map<String, Integer> venSqOppMap = Map.of("mar",210,"ju",211,"sa",212,"ur",213,"ne",214,"pl",262);
        addMapping.accept("ven", "sq", venSqOppMap);
        addMapping.accept("ven", "opp", venSqOppMap); // Same as sq

        // --- MAR ---
        addMapping.accept("mar", "tick", Map.of("ju",215,"sa",216,"ur",217,"ne",218,"pl",263));
        Map<String, Integer> marTriStarMap = Map.of("ju",219,"sa",220,"ur",221,"ne",222,"pl",264);
        addMapping.accept("mar", "tri", marTriStarMap);
        addMapping.accept("mar", "*", marTriStarMap); // Same as tri
        Map<String, Integer> marSqOppMap = Map.of("ju",223,"sa",224,"ur",225,"ne",226,"pl",265);
        addMapping.accept("mar", "sq", marSqOppMap);
        addMapping.accept("mar", "opp", marSqOppMap); // Same as sq

        // --- NE ---
        addMapping.accept("ne", "tick", Map.of("pl",275));
        Map<String, Integer> neTriStarMap = Map.of("pl",276);
        addMapping.accept("ne", "tri", neTriStarMap);
        addMapping.accept("ne", "*", neTriStarMap); // Same as tri
        Map<String, Integer> neSqOppMap = Map.of("pl",277);
        addMapping.accept("ne", "sq", neSqOppMap);
        addMapping.accept("ne", "opp", neSqOppMap); // Same as sq

        return mapping;
    }

    /**
     * Calculates Lewi results based on decan values.
     * Equivalent to calculate_lewi_decans in Python.
     * @param decans A List of 10 integers representing decan values for planets in PLANETS order.
     * @return A sorted List of integers representing the results.
     */
    public static List<Integer> calculateLewiDecans(List<Integer> decans) {
        if (decans == null || decans.size() != PLANETS.size()) {
            throw new IllegalArgumentException("Decans list must contain " + PLANETS.size() + " elements.");
        }

        Map<String, Map<String, Map<String, Integer>>> smap = lewimapInit();
        List<Integer> res = new ArrayList<>();

        // Sun/Moon table calculation
        // Find indices of sun and moon in the PLANETS list
        int sunListIndex = PLANETS.indexOf("sun");
        int moonListIndex = PLANETS.indexOf("mo");
        if (sunListIndex == -1 || moonListIndex == -1) {
            throw new IllegalStateException("Sun or Moon not found in PLANETS list definition.");
        }

        // Ensure floating point division by using 3.0
        double sunDecan = decans.get(sunListIndex);
        double moonDecan = decans.get(moonListIndex);

        // Calculate 0-based index for SUN_MOON_TABLE
        int sunTableIndex = (int) Math.ceil(sunDecan / 3.0) - 1;
        int moonTableIndex = (int) Math.ceil(moonDecan / 3.0) - 1;

        // Add boundary checks for safety
        if (sunTableIndex >= 0 && sunTableIndex < 12 && moonTableIndex >= 0 && moonTableIndex < 12) {
             res.add(SUN_MOON_TABLE[sunTableIndex][moonTableIndex]);
        } else {
             System.err.println("Warning: Calculated Sun/Moon index out of bounds (" + sunTableIndex + ", " + moonTableIndex + ").");
        }


        // Calculate angles
        List<String> stepSigns = Arrays.asList("*", "sq", "tri", "opp", "tri", "sq", "*");
        int[] steps = {6, 9, 12, 18, 24, 27, 30}; // Use primitive array

        for (int i = 0; i < PLANETS.size(); i++) {
            String planet = PLANETS.get(i);
            int decan = decans.get(i);

            // Calculate relative positions (relpos)
            List<Integer> relpos = new ArrayList<>();
            for (int step : steps) {
                relpos.add((step + decan) % 36); // Modulo 36 for wrapping
            }

            // Iterate through relative positions and step signs
            for (int j = 0; j < relpos.size(); j++) {
                int pos = relpos.get(j);
                String stepSign = stepSigns.get(j);

                // Find planets matching the current position 'pos'
                List<String> matchingPlanets = new ArrayList<>();
                // List<Integer> matchingIndices = new ArrayList<>(); // Keep track of indices if needed
                for (int k = 0; k < decans.size(); k++) {
                    // Ensure comparison is between Integers (objects)
                    if (decans.get(k).equals(pos)) {
                        // matchingIndices.add(k);
                        matchingPlanets.add(PLANETS.get(k));
                    }
                }

                if (!matchingPlanets.isEmpty()) {
                    for (String p : matchingPlanets) {
                        // Check mapping validity (equivalent to 'not pd.isnull' and 'in')
                        // Navigate nested maps safely
                        Map<String, Map<String, Integer>> planetMap = smap.get(planet);
                        if (planetMap != null) {
                             Map<String, Integer> aspectMap = planetMap.get(stepSign);
                             if (aspectMap != null && aspectMap.containsKey(p)) {
                                 res.add(aspectMap.get(p));
                             }
                        }
                    }
                }
            }
        }

        // Calculate alignments (same decans)
        for (int i = 0; i < decans.size(); i++) {
            int dec = decans.get(i);
            List<Integer> matchingIndices = new ArrayList<>();
            for (int k = 0; k < decans.size(); k++) {
                 if (decans.get(k).equals(dec)) {
                    matchingIndices.add(k);
                }
            }

            if (matchingIndices.size() > 1) { // More than one planet at this decan
                String planetI = PLANETS.get(i);
                for (int x : matchingIndices) {
                    // Avoid self-comparison and double counting (i < x ensures each pair is checked once)
                    if (i < x) {
                         String planetX = PLANETS.get(x);
                         // Check mapping validity for 'tick' aspect
                         // Navigate nested maps safely
                         Map<String, Map<String, Integer>> planetIMap = smap.get(planetI);
                         if (planetIMap != null) {
                             Map<String, Integer> tickMap = planetIMap.get("tick");
                             if (tickMap != null && tickMap.containsKey(planetX)) {
                                 res.add(tickMap.get(planetX));
                             }
                         }
                    }
                }
            }
        }

        // Sort the results
        Collections.sort(res);
        // Optional: Remove duplicates if the Python version implicitly did so via sets somewhere not shown
        // return res.stream().distinct().sorted().collect(Collectors.toList());

        return res; // Keep duplicates as per direct translation of the provided code
    }

    // Main method mirroring the Python 'if __name__ == "__main__":' block
    public static void main(String[] args) {
        // Test data from the Python script
        List<Integer> testDecans = Arrays.asList(4, 29, 1, 4, 32, 32, 8, 21, 25, 19);

        // Ensure testDecans has the correct size
        if (testDecans.size() != PLANETS.size()) {
             System.err.println("Error: testDecans size (" + testDecans.size() + ") does not match PLANETS size (" + PLANETS.size() + ").");
             return;
        }

        List<Integer> res = calculateLewiDecans(testDecans);

        System.out.println("Calculated Lewi Decans: " + res);

        // Values to check for presence
        List<Integer> checkValues = Arrays.asList(22, 167, 194, 215, 220, 230, 259, 276);

        boolean allPresent = true;
        for (int val : checkValues) {
            if (!res.contains(val)) {
                allPresent = false;
                System.out.println("Value not found: " + val); // Added for detail
            }
        }
        System.out.println("All check values present in result? " + allPresent); // Should print true based on Python output expectation
    }

    // Needed for lewimapInit helper lambda (part of Java standard library since Java 8)
    @FunctionalInterface
    interface BiConsumer<T, U, V> {
        void accept(T t, U u, V v);
    }
}
ndard library since Java 8)
    @FunctionalInterface
    interface BiConsumer<T, U, V> {
        void accept(T t, U u, V v);
    }
}
